<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>日常学习</title>
  <id>http://geniousbar.github.io</id>
  <link href="http://geniousbar.github.io"/>
  <link href="http://geniousbar.github.io/feed.xml" rel="self"/>
  <updated>2021-05-24T00:00:00+00:00</updated>
  <author>
    <name>geniousbar</name>
  </author>
  <entry>
    <title></title>
    <link rel="alternate" href="http://geniousbar.github.io/2021/05/24/current-os/"/>
    <id>http://geniousbar.github.io/2021/05/24/current-os/</id>
    <published>2021-05-24T00:00:00+00:00</published>
    <updated>2021-06-11T13:47:26+00:00</updated>
    <summary type="html">
&lt;hr&gt;
&lt;p&gt;title: Modern current os&lt;br&gt;
date: 2021-05-24&lt;br&gt;
tags: os, linux&lt;br&gt;
—&lt;/p&gt;

&lt;h3 id="现代操作系统"&gt;现代操作系统：&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;抽象是管理复杂性的关键， 好的抽象可以把一个 不可能管理的任务 分为 两个可管理的部件。 抽象的定义和实现 + 用这些抽象解决的问题。&lt;br&gt;
操作系统的任务 就是 创建好的抽象 并实现和管理它所创建的抽象对象。抽象内容是理解操作系统的关键。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id="作为资源管理者的操作系统"&gt;作为资源管理者的操作系统：&lt;/h4&gt;

&lt;h5 id="资源管理包括-以下两种不同方式实现-多路复用共享资源时间上-复用--空间上复用-"&gt;资源管理包括 以下两种不同方式实现 多路复用（共享）资源：时间上 复用 + ...&lt;/h5&gt;</summary>
    <content type="html">
&lt;hr /&gt;
&lt;p&gt;title: Modern current os&lt;br /&gt;
date: 2021-05-24&lt;br /&gt;
tags: os, linux&lt;br /&gt;
—&lt;/p&gt;

&lt;h3 id="现代操作系统"&gt;现代操作系统：&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;抽象是管理复杂性的关键， 好的抽象可以把一个 不可能管理的任务 分为 两个可管理的部件。 抽象的定义和实现 + 用这些抽象解决的问题。&lt;br /&gt;
操作系统的任务 就是 创建好的抽象 并实现和管理它所创建的抽象对象。抽象内容是理解操作系统的关键。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id="作为资源管理者的操作系统"&gt;作为资源管理者的操作系统：&lt;/h4&gt;

&lt;h5 id="资源管理包括-以下两种不同方式实现-多路复用共享资源时间上-复用--空间上复用-"&gt;资源管理包括 以下两种不同方式实现 多路复用（共享）资源：时间上 复用 + 空间上复用 。&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;时间复用 例子 比如 打印机， 问题： 如何决定下一个执行哪个任务？ 以及 任务运行的时间&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;空间复用 比如硬盘、内存。 问题： 任务之间的公平， 保护问题。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;网络操作系统 与 分布式 操作系统： 网络操作系统 与 单处理器的操作系统没有本质区别。 分布式操作系统 则 与 集中式系统 有本质的区别，用户根本不知道自己的文件存储在什么地方，任务在那个机器上运行，网络中的通信延迟导致 分布式算法必须能够适应信息不完备、信息过时、信息错误的情况。这与 单机形成对比， 单机系统中操作系统掌握着完全的信息。因此 需要更复杂的处理器调度算法  来获得 更大的并行度。&lt;/p&gt;

&lt;h4 id="处理器"&gt;处理器：&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;访问内存 以得到指令或数据 的时间  要比执行指令花费的时间 长得多。所以 CPU内部都保存 一些用来 保存关键变量+临时数据的寄存器。
    &lt;h5 id="cpu包含"&gt;cpu包含：&lt;/h5&gt;
  &lt;/li&gt;
  &lt;li&gt;程序计数器： 下一条指令的内存地址&lt;/li&gt;
  &lt;li&gt;堆栈指针： 内存中当前栈的顶端，用于 函数调用中的 参数传递&lt;/li&gt;
  &lt;li&gt;程序状态字 PSW program status word： 包含  条件码 + cpu优先级 + 用户态内核态 + 控制位 （在系统调用中、IO 中 PSW 作用非常重要）&lt;/li&gt;
  &lt;li&gt;指令流水线： 将指令分解为 取指 + 解码 + 执行 多个单元 并行执行的结构。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;超标量CPU： 此设计中， 存在多个执行单元比如： 1个CPU 用于整数计算 + 1个cpu用于浮点数计算。 该设计 可能导致  程序中的指令 经常不按照 顺序执行。在多数情况下， 硬件负责  保证这种运算结果与顺序执行指令的结果相同，但是，应有部分 复杂情形 需要操作系统 来处理。&lt;/p&gt;

&lt;h5 id="内核态--用户态-psw-中存在-二进制-位-控制该模式内核态-cpu-可执行-指令集中的任何一条命令-用户态-则-只能执行指令集的一个子集比如io-操作-为了从操作系统获得服务-用户必须-使用-系统调用--以陷入内核-调用-操作系统trap-指令-从用户态切换到内核态"&gt;内核态 + 用户态： PSW 中存在 二进制 位 控制该模式，内核态： cpu 可执行 指令集中的任何一条命令， 用户态： 则 只能执行指令集的一个子集。（比如IO 操作） 为了从操作系统获得服务， 用户必须 使用 系统调用  以陷入内核 调用 操作系统。TRAP 指令 从用户态切换到内核态。&lt;/h5&gt;

&lt;blockquote&gt;
  &lt;p&gt;计算机使用陷阱 而非 一条指令来执行 系统调用， 而其他的多数陷阱 是由硬件引起的，用于 异常的发生，比如 除以 0。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;多线程 和 超线程：  多线程允许 cpu 保持两个不同的线程状态， 然后在纳秒级别内进行切换，多线程并非真正的并行处理， 在同一时刻 只有一个进程运行，但是线程的切换时间 为纳秒级别&lt;/strong&gt;&lt;/p&gt;

&lt;h5 id="多核cpu"&gt;多核CPU&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;GPU：  Graphics Processing Unit 上万个微核组成的处理器， 擅长大量的并行简单运算，很难编程， 虽然GPU对于操作系统 非常有用（比如加密 ，图像处理 etc） 但是 操作系统本身 不太可能 运行在GPU上。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="存储器系统--寄存器--高速缓存--主存--磁盘"&gt;存储器系统：  寄存器  高速缓存  主存  磁盘&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;任何缓存系统 都需要考虑的问题：
    &lt;ol&gt;
      &lt;li&gt;何时把一个新的内容放到缓存&lt;/li&gt;
      &lt;li&gt;把新的内容 放在缓存的哪一行上&lt;/li&gt;
      &lt;li&gt;在需要时， 应该把那个内容村缓存移走&lt;/li&gt;
      &lt;li&gt;应该把新移走的内容放在某个较大存储器的何处&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;通常通过 所引用内存地址的 高位地址 计算应该使用的缓存行。比如 对于64字节的 4096个缓存行 以及32位地址， 其中 6-17位 用来定位缓存行，而 0-5 则用来确定缓存行中的字节&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;缓存层级设计:
    &lt;ol&gt;
      &lt;li&gt;缓存是好方法： 现代cpu有两个L1缓存，第一个 L1 总是在 CPU中， 用来将 已解码 的指令调入CPU的执行引擎。 第二个L1 则存放 频繁使用的数据字节。&lt;/li&gt;
      &lt;li&gt;二级缓存L2 用来存放最近使用的若干兆内存字节，L2 延迟 1-2个时钟， L1 则没有延迟&lt;/li&gt;
      &lt;li&gt;在多核芯片中， 设计师 需要确定缓存的位置， Intel 中多核 CPU 共享L2缓存， AMD 则 每个核 都有自己的 L2缓存。Intel 需要设计 更复杂的缓存同步问题， AMD 则需要在 缓存一致上 存在困哪。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;存储设备类型：
    &lt;ol&gt;
      &lt;li&gt;内存： RAM random access Memory：&lt;/li&gt;
      &lt;li&gt;ROM: read only memory&lt;/li&gt;
      &lt;li&gt;Flash Memory:介于  RAM 与 磁盘之间， 与磁盘存储器不同， 如果 flash 擦除次数过多， 就会被磨损。&lt;/li&gt;
      &lt;li&gt;CMOS: 用于保存时间 和日期，还可以用来保存 配置参数 等，比如 那个是启动磁盘。&lt;/li&gt;
      &lt;li&gt;磁盘：&lt;/li&gt;
      &lt;li&gt;固态硬盘： 数据存储在Flash memory (闪存)中, 应该是一份 大的 Flash。&lt;/li&gt;
      &lt;li&gt;虚拟内存：  将程序放在磁盘上，而将主内存作为一种缓存， 用来保存频繁访问的区域。能够提供大于内存 的 ”内存地址“ MMU 是其实现中的重要一环。&lt;br /&gt;
&lt;strong&gt;缓存 + MMU 对于系统的性能 具有重要的影响，程序间上下文切换， 需要修改MMU的配置，将 需要同步的数据 从内存写回到 磁盘中。&lt;/strong&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id="io-设备包括-设备控制器----设备本身-控制器-从操作系统接受指令完成数据的处理-控制器的任务是为操作系统提供一个简单的接口-来处理-设备提供的数据"&gt;IO 设备包括： 设备控制器  +  设备本身， 控制器 从操作系统接受指令，完成数据的处理。 控制器的任务是为操作系统提供一个简单的接口， 来处理 设备提供的数据。&lt;/h5&gt;

&lt;h6 id="驱动程序"&gt;驱动程序&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;设备控制器的不同，导致需要不同的 设备驱动程序。 并为不同的操作系统提供相应的驱动程序。(即驱动程序 为 设备控制器 与 操作系统的桥梁。 设备控制器为  为了简化驱动程序 对操作系统的接口 而设计的，用来隐藏 设备的复杂性的控制设备)&lt;/li&gt;
  &lt;li&gt;大部分的驱动程序都需要装入操作系统中，这样他可以在 内核态 运行， 但是其也可以在 内核外运行。 现代的Linux与Windows也的确对该种方式提供了一定的支持，但绝大部分 驱动程序 依然需要在内核态运行， 非常少的 现代系统 能够在内核外运行全部驱动程序。&lt;/li&gt;
  &lt;li&gt;在用户态运行的驱动程序 必须能够 以某种受控的 方式访问设备，然后这并不容易。&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id="将设备驱动程序-装载到-操作系统有三个方法"&gt;将设备驱动程序 装载到 操作系统有三个方法：&lt;/h6&gt;
&lt;ol&gt;
  &lt;li&gt;将内核与驱动程序重新链接， 然后重启操作系统&lt;/li&gt;
  &lt;li&gt;在操作系统文件中设定一个入口，并通知该文件需要一个设备驱动程序， 然后重启系统， 在启动中， 操作系统 去寻找所需的设备驱动程序 并将其装载 （Windows 工作方式）&lt;/li&gt;
  &lt;li&gt;操作系统在运行时 接受新的设备驱动程序 并立即 将其安装好， 无需重启， 即是热插拔， USG IEEE 1394设备。&lt;/li&gt;
&lt;/ol&gt;

&lt;h6 id="输入输出的三种方式"&gt;输入+输出的三种方式：&lt;/h6&gt;
&lt;ol&gt;
  &lt;li&gt;忙等待： 用户程序发出一个系统调用，内核将其翻译成对应的 设备驱动程序 调用， 然后设备驱动程序 在一个连续不断的循环中检查设备，查看该设备是否万和城呢够了工作， 当IO 接手后， 设备驱动程序 将数据送到指定的地方， 并返回，然后操作系统将控制返回给 调用者，确定为 占据CPU， CPU 会一直轮训 设备知道对应的IO操作完成。&lt;/li&gt;
  &lt;li&gt;设备驱动程序 启动设备并且让该设备在操作完成时 发出一个中断， 设备驱动程序在这个时候 返回， 操作系统 阻塞调用者，并进行其他工作， 当设备驱动程序 检测到该设备完成时候，将发出一个中断通知操作完成。其中中断是一个非常重要的概念，IO 分为三步， 1） 设备驱动程序 通过写设备寄存器通知设备控制器做什么，然后 设备控制器 启动该设备， 当设备控制器完成操作 2） 使用特定的总线发送信号给中断控制器芯片&lt;/li&gt;
  &lt;li&gt;中断控制芯片 接受中断，他会在CPU芯片的一个管脚上声明，&lt;/li&gt;
  &lt;li&gt;中断控制器将该设备的编号 放到总线上，这样 CPU可以读取总线，并指导那个设备完成了操作。 中断 处理程序：  …  d第三种） 使用特殊的直接存储器访问 (Direct Memory Access, DMA) 芯片， 它可以 控制内存和某些控制前 之间的位流， 而无需 持续的CPU 干涉，cpu 对dma芯片 进行设置， 说明 需要传送的字节数、有关设备、和内存地址 以及操作方向， 接着启动DMA 当DMA芯片完成时，它会 引发一个中断，。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;中断&lt;/strong&gt;： 中断会发生在非常不合适的时刻， 比如另外一个中断程序正在运行时发生，如果此时接受中断 可能导致 中断程序的递归处理。所以cpu 会关闭中断并在稍后在开启中断，中断关闭时： 任何已经发出中断的设备，可以继续保持其中断信号，但是cpu不会被中断，直到中断再次启用为止， 如果多个设备发生了中断，则 中断控制器 将决定先处理那个中断， 通常这取决于 事先赋予每个设备的静态优先级，最高优先级的设备得到优先处理，其他的设备则等待。&lt;/p&gt;

&lt;h6 id="总线以及其演变"&gt;总线以及其演变&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;总线：单总线（IBM PC） 因为 处理器以 传输 需求的提升被废弃。&lt;/li&gt;
  &lt;li&gt;PCIe： 其之前的总线 都是并行 且共享的。即： 共享总线架构， 多个设备使用一些相同的导线传递数据，因为多个设备同时需要发送数据时，需要进行仲裁来决定哪一个设备优先使用。其传输方式 是”并行的“ 即 通过多条导线发送数据的每一个字，例如 一个32位 数据通过 32条并行的导线进行发送。 PCIe 则使用分离的端到端的链路，进行串行总线架构，通过一套 被称为 数据通路的链路传递集合了所有位 的一条消息，类似网络包。 即： 同时可以多个设备共享使用总线。&lt;/li&gt;
  &lt;li&gt;USB (universal serial bus) 是用来将所有的慢速设备 与计算机进行连接的。USB 是一种集中式总线， 其根设备 每1ms 轮训一次IO 设备，看是否有消息收发， usb 1.0 处理  12Mb/s, 2.0 提高到 480Mb/s 3.0 则可以达到 不小语言  5Gb/s 的速率。&lt;/li&gt;
  &lt;li&gt;在即插即用的IO设备之前， 每个IO卡 都有一个固定的 中断请求级别 和 用于 其IO寄存器的固定地址， 比如 键盘 中断级别为1， 并使用0x60-0x64 的IO地址， 即插即用 所做的操作 即是： 系统 自动的收集有关IO设备的信息，集中赋予 中断级别和 IO地址，然后通知设备控制器其所使用的数值， 这项工作 与 计算机的启动密切相关。&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id="操作系统分类"&gt;操作系统分类：&lt;/h6&gt;
&lt;ol&gt;
  &lt;li&gt;大型机操作系统  主要面向多作业的同时处理， 多数这样的作业 需要大量的IO能力， 系统主要提供三类服务： 批处理、事务处理、分时。事务处理系统负责大量小的任务， 比如航班预订任务， 每个业务量很小，但是 系统需要每秒处理上千个业务。在部分领域 大型机系统 正在被 Linux 取代&lt;/li&gt;
  &lt;li&gt;服务器操作系统： 服务器可以是 大型的个人计算、工作站、甚至是大型机， 他们通过网络为若干个用户服务，。&lt;/li&gt;
  &lt;li&gt;多处理器操作系统： 将大量CPU链接成单个系统。 根据连接和共享方式的不同，这些系统称为 并行计算机 、多计算机、多处理器。个人计算机也开始普及 多核芯片。&lt;/li&gt;
  &lt;li&gt;个人计算机操作系统&lt;/li&gt;
  &lt;li&gt;掌上计算机操作系统：&lt;/li&gt;
  &lt;li&gt;嵌入式操作系统&lt;/li&gt;
  &lt;li&gt;传感器节点操作系统：  许多用途需要微小传感器的节点网络。比如森林火灾探测，气象探测器。 此类传感器 能源资源有限。 每个节点上运行一个小型但是真实的操作系统，通常操作系统是事件驱动的，可以相应外部事件 或者基于内部的时钟进行周期性检测，该系统必须小而简单，InyOS 是一个知名的该类操作系统&lt;/li&gt;
  &lt;li&gt;实时操作系统： 系统的特征是将时间作为关键参数，比如工业过程控制系统，焊接机器人 焊接的太早 或者太晚 都有可能造成物品 损坏，所以需要在规定的时间内进行操作， 这就是硬实时系统。另一个则是软实时系统， 即： 偶尔的超时是可以接受的。&lt;/li&gt;
  &lt;li&gt;智能卡系统： 比如包含一块cpu芯片的信用卡&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id="操作系统周边概念"&gt;操作系统周边概念:&lt;/h5&gt;
&lt;ol&gt;
  &lt;li&gt;进程： 正在执行的程序，容纳一个程序所需要的所有信息的容器。包括相关的地址空间（存放 可执行程序， 程序数据，以及堆栈 ） + 进程相关的资源集  + 寄存器 + 打开的文件清单 + 信号  等 以及 运行进程需要的其他的信息。&lt;/li&gt;
  &lt;li&gt;进程表： 操作系统中存储 每一个进程有关的所有信息 放在一张表中：进程表。&lt;/li&gt;
  &lt;li&gt;系统调用： 创建进程 、 申请内存、等待进程结束 etc&lt;/li&gt;
  &lt;li&gt;信号： 无论进程在做什么，进程将被暂时挂起， 然后运行进程信号处理器， 这些信号 是软件模拟的硬件中断。&lt;/li&gt;
  &lt;li&gt;系统管理授权； 启动进程的用户UID， GID group id
    &lt;h6 id="地址空间-虚拟内存技术--本质上-操作系统创建了一个地址空间的抽象作为进程可以引用地址的集合-改地址空间与物理内存解耦可能大于也可能小于-物理空间-对地址空间和物理空间的管理组成了操作系统功能的一个重要部分"&gt;地址空间： 虚拟内存技术，  本质上 操作系统创建了一个地址空间的抽象，作为进程可以引用地址的集合， 改地址空间与物理内存解耦，可能大于也可能小于 物理空间。 对地址空间和物理空间的管理组成了操作系统功能的一个重要部分。&lt;/h6&gt;
    &lt;h6 id="文件系统"&gt;文件系统：&lt;/h6&gt;
    &lt;ul&gt;
      &lt;li&gt;文件： 支持操作系统的另一个关几年概念。 一项重要功能 即是：隐藏磁盘和其他IO设备的细节特性， 提供一个良好的清晰的独立与设备的抽象文件模型。&lt;/li&gt;
      &lt;li&gt;目录： 将文件分类成组。  目录中的目录项可以使文件或者目录， 从而产生了一个层次结构—-文件系统。&lt;/li&gt;
      &lt;li&gt;进程和文件层次都可以组成为树状结构，但是： 一般进程的树状结构 不会超过三层， 而文件结构 则 不受控制， 进程树 是暂时的，而目录层次则是 永久的。&lt;/li&gt;
      &lt;li&gt;每个进程 有一个 工作目录， 对于 非绝对路径 都将 从该工作目录下 开始寻找，&lt;/li&gt;
      &lt;li&gt;安装文件系统： 如果安装一个 DVD光盘 时候，我们需要mount 系统调用 来讲Cd-rom上的我呢间系统连接到程序所希望的根文件系统上。&lt;/li&gt;
      &lt;li&gt;特殊文件： 提供特殊文件是为了是IO设备看起来 想文件一般。 这样就可以使用系统调用 来读写文件， IO 设备也可以通过同样的系统调用 来进行读写，包含： 块特殊文件， 字符特殊文件。 可以随机存储区的块组成的设备，比如磁盘。  字符特殊文件 用于打印机， 调制解调器，输出为字符流的设备。 按照惯例，特殊文件 放在/dev 目录下。&lt;/li&gt;
      &lt;li&gt;管道： 虚拟文件， 可以连接两个进程，通过在管道上写读 来进行进程间通讯。&lt;/li&gt;
      &lt;li&gt;保护： 管理系统的安全依靠 操作系统。 例如文件只能授权用户使用。 在文件系统中，对每个文件 富裕一个 9位 的 二进制保护码&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id="操作系统体系结构"&gt;操作系统体系结构：&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;单体系统： 整个操作系统 在内核态 以单一程序的方式运行， 整个操作系统 以过程集合的方式编写， 链接成一个大型的可执行文件 的二进制程序。&lt;/li&gt;
  &lt;li&gt;层次式 系统： 其上层软件都是在下层软件的基础上进行构建的。Dijkstra 领导开发 的THE 系统 是此模式的第一个系统， 该系统分为六层。MuLTICS 系统 采用了更进一步的通用层次化概念。 采用同心环 构成， 内环比外环 有更高的级别，外环的过程调用内环过程时候，他必须执行一条等价于系统调用的trap指令， 内环对调用进行详细的参数检查校验，执行，然后返回给内环结果。&lt;/li&gt;
  &lt;li&gt;微内核： 背后的思想是： 为了实现高可靠性，将操作系统划分为小的、良好定义的模块，只有其中的一个模块 —微内核 运行在内核态， 其余的模块 由于功能相对较弱，则作为普通用户进程运行，特别的，由于把每个设备驱动程序 作为普通用户进程，这些模块的崩溃，并不会导致系统的死机。相对应的 单体系统中  因为所有的驱动程序都在内核中， 一个驱动程序的故障 很有可能导致系统的崩溃。&lt;/li&gt;
  &lt;li&gt;客户端-服务器模式：一个微内核思想的变体是将进程分为两类： 服务器 + 客户端， 每个服务器提供某种服务，客户单使用这些服务。 通常 在系统最底层是微内核。泛化的现象为： 服务器与客户端运行在不同的计算机上。他们通过网络连接， 成为 web服务。&lt;/li&gt;
  &lt;li&gt;虚拟机：&lt;/li&gt;
  &lt;li&gt;外核：&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="虚拟机-todo"&gt;虚拟机： todo&lt;/h4&gt;

&lt;h5 id="进程--线程"&gt;进程 + 线程：&lt;/h5&gt;
&lt;h6 id="相关概念"&gt;相关概念&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;伪并行： 并行的错觉，瞬间仍然是一个进程执行，只是在1s内能够运行多个进程。 区分于 多处理器系统。&lt;/li&gt;
  &lt;li&gt;前台进程: 与用户交互的进程。&lt;/li&gt;
  &lt;li&gt;守护进程：与用户交互 无关的，后台进程。（简单的定义，在Linux programming interface 中存在更准确的定义）
    &lt;h6 id="进程"&gt;进程：&lt;/h6&gt;
  &lt;/li&gt;
  &lt;li&gt;进程终止： 1） 正常退出 2） 出错 或 严重错误 3）被杀死
    &lt;ol&gt;
      &lt;li&gt;编译器在 main中添加 exit系统调用&lt;/li&gt;
      &lt;li&gt;除以0，非法操作 等错误，Linux 中能否定义 此类错误处理器？&lt;/li&gt;
      &lt;li&gt;kill 系统调用&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;层次结构：
    &lt;ol&gt;
      &lt;li&gt;windows 中 不存在进程间的层次结构。&lt;/li&gt;
      &lt;li&gt;linux 中 init 启动之后， 会为每个终端创建一个新进程，这些进程等待用户登录，如果登录成功，该进程执行一个shell终端 来接受命令，所接受的命令会创建更多的 进程， 所以整个系统会成为一个以init 为根的进程树。&lt;/li&gt;
      &lt;li&gt;进程组： 进程 + 后代进程&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;进程状态以及其之间的转换：todo&lt;/li&gt;
  &lt;li&gt;理论来说：调度程序( 包含 中断处理， 启动、停止进程等 功能) 是 进程的根基。&lt;/li&gt;
  &lt;li&gt;假设： 程序的IO操作 / 停留在内存的时间（运行态） = P 则 n个进程的cpu利用率为 1 - P ** n。 该模型 可以简单的抽象 估计 进程数目 对于cpu利用率的提升。&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id="线程"&gt;线程：&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;特点：
    &lt;ol&gt;
      &lt;li&gt;并行实体， 共享同一个 地址空间、数据（即：全局变量 打开文件描述符，定时器， 信号处理器 etc）&lt;/li&gt;
      &lt;li&gt;比进程轻量，创建速度是进程的10-100 倍&lt;/li&gt;
      &lt;li&gt;在多核CPU中可以真正的并行&lt;/li&gt;
      &lt;li&gt;多线程 可以调用 阻塞系统调用，但是依然能够 实现并行。 否则需要 单进程 状态机来 执行非阻塞的调用 并在 各个状态机之间不断切换。即： 多线程 具有 不用更改代码 很容易的实现调用 阻塞系统调用，简单的实现 并行。&lt;/li&gt;
      &lt;li&gt;源于独立的两个概念： 资源分组 与 执行。 将两个概念分离开来 则形成了： 进程为系统的资源管理单位， 线程 为执行的单位。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;相关调用 :  thread_create, thread_exit, thread_join, threa_yield&lt;/li&gt;
  &lt;li&gt;线程可以存在层次关系，但是多数时候，并不需要，即： 线程之间是平等的。&lt;/li&gt;
  &lt;li&gt;实现方式： 1） 用户空间实现 2）内核实现  3） 混合实现
    &lt;ol&gt;
      &lt;li&gt;用户空间实现： 内核对用户中的多线程一无所知，即 内核视角中： 单进程
        &lt;ul&gt;
          &lt;li&gt;优点： 线程间的切换 无需 系统调用，不需要在用户空间 与 内核空间 中进行切换。所以 速度 比 内核快一个数量级。&lt;/li&gt;
          &lt;li&gt;方便的实现自己的调度算法&lt;/li&gt;
          &lt;li&gt;问题： 如何实现阻塞的系统调用&lt;/li&gt;
          &lt;li&gt;缺页中断问题：缺页中断 会阻塞整个进程导致进程中的所有线程阻塞&lt;/li&gt;
          &lt;li&gt;无时钟中断：即一个线程不自己yield，导致其一直占用cpu，导致其他thread饥饿&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id="进程间通讯"&gt;进程间通讯：&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;3个问题： 三个问题中，出第一个问题外， 2，3 问题对于 进程、线程来说同样适用。第一个问题对于线程来说 比较简单，因为他们共享同样的地址空间。
    &lt;ol&gt;
      &lt;li&gt;一个进程如何传递消息给另一个进程&lt;/li&gt;
      &lt;li&gt;确保两个或者更多的进程在关键活动中不会出现交叉&lt;/li&gt;
      &lt;li&gt;进程间正确的执行顺序，比如A进程产生数据而B进程进行打印，那么 B在打印之前 必须进行等待，知道A已经产生数据&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;简单概念：
    &lt;ul&gt;
      &lt;li&gt;竞争条件： 多核的普及，使条件竞争越来越普通。&lt;/li&gt;
      &lt;li&gt;临界区：对共享内存进行访问的程序片段 被称为 临界区。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;互斥进入临界区 mutual exclusion 的几种方法：
    &lt;ol&gt;
      &lt;li&gt;屏蔽中断： 屏蔽所有中断，在离开时 再开打开中断。屏蔽中断后，时钟中断也被屏蔽。cpu只有发生时钟中断或其他中断时才会进行进程切换。这样屏蔽中断之后，cpu就不会切换到其他进程，所以进程能够安全的更改内存，而不必担心其他家吃的介入。 适合os使用（比如在更进程队列等数据时），并且只对单个cpu起作用。&lt;/li&gt;
      &lt;li&gt;设定锁变量： 普通的锁变量 对于 进程调度 产生的竞争条件 不起作用&lt;/li&gt;
      &lt;li&gt;严格轮换法： 两个进程相互等待对方的吧变量标志，严格的进行 进程A,B交替执行。&lt;/li&gt;
      &lt;li&gt;Peterson 算法：&lt;/li&gt;
      &lt;li&gt;TSL指令：（测试并加锁 test and set lock） 该指令将锁住 内存总线，已禁止其他CPU在被指令结束之前 访问内存。执行如下原子操作： 将内存字节lock读到寄存器RX中，然后在该内存地址上存储一个非零值。 一个可以代替该命令的命令为XCHG，该指令原子性的交换两个位置的内容。本质上同TSL指令一样&lt;br /&gt;
&lt;strong&gt;以上的锁都称为spin lock 自旋锁，即在没有获得锁的时候 进行 cpu的忙等待 busy waiting，因为此种方式 非常浪费cpu时间，所以同行应该尽量避免， 只有有理由认为 忙等待时间是非常短的时候 才使用忙等待&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;自旋锁可能存在的问题： 1）优先级反转问题： 即两个进程 高优先级H与低优先级L，调度规则为 只要H处于就绪状态 即可运行。 在某一时刻 L处于临界区中，H处于就绪态，准备进入临界区，此时H开始忙等待，由于H就绪就不会调度L运行，导致L无法完成工作，离开临界区。所以H将无限的等待下去&lt;/strong&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;互斥进入临界区的 睡眠与唤醒 解法： 假设存在连个系统调用 sleep与wakeup，sleep引起系统阻塞，即被挂起。直到另外一个进程将其唤醒。wakeup 调用一个参数，即被唤醒的进程。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;生产者消费者问题：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight c"&gt;&lt;code&gt;&lt;span class="cp"&gt;#define N 100
&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;producer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;item&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;produce_item&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; 
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="err"&gt;（&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="err"&gt;）&lt;/span&gt; &lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// 缓冲区满 则 休眠&lt;/span&gt;
        &lt;span class="n"&gt;insert_item&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;wakeup&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;consumer&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 缓冲区&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;consumer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// 缓冲区空，则进入休眠状态&lt;/span&gt;
        &lt;span class="n"&gt;item&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;remove_item&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; 
        &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;wakeup&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;producer&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 缓冲区满，则 唤醒 生产者&lt;/span&gt;
        &lt;span class="n"&gt;consume_item&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;此代码结构中存在两个问题&lt;/strong&gt;：1） 共同修改的count变量 未进行访问保护  2） 消费者 在逻辑上 未进行睡眠时，生产者的wakeup 信号丢失了。情况如下： 在 count 为0时，消费者 进行消费，读取了count 为0。此时调度器 决定执行 生产者，生产者 生产完毕，并执行 wakeup。因为消费者没有sleep所以生产者的wakeup信号丢失了，之后 消费者执行，count == 0 sleep操作。消费者将阻塞。而生产者 则一直生产 直到缓冲区已满 也阻塞起来。&lt;/p&gt;

&lt;h6 id="信号量dijkstra-提出来的算法-使用整型变量累计唤醒次数供以后使用"&gt;信号量：Dijkstra 提出来的算法， 使用整型变量累计唤醒次数，供以后使用&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;其存在两种操作；down， up（类似于 sleep 与 wakeup）&lt;/li&gt;
  &lt;li&gt;down操作； 检查信号量 数值是否大于 0，大于0  则将其数值减一。并继续，若该值为0  则进程将睡眠。操作为原子操作，  保证一个一个信号的操作完成，则 在改造做完成或阻塞之前，其他进程 均不允许访问该信号量。&lt;/li&gt;
  &lt;li&gt;原子性 对于解决 同步问题和避免竞争问题 是必不可少的。&lt;br /&gt;
up操作； 对信号数值+1， 如果一个或者多个进程在该信号量上 睡眠（即因为之前的down操作无法完成） 则由系统 选择其中的一个 进程，并允许该进程完成它的down操作。否则，将信号量数值+1。 则 对一个有进程在其上睡眠的信号量执行一个up操作之后，该信号量的值依然是0，但是其上的睡眠进程少了一个。区别于down操作，不会有进程在up操作上阻塞。&lt;/li&gt;
  &lt;li&gt;因为其中 依然需要保证原子操作，即： 依然需要使用 TSL或者XCHG 指令 来保证同一个时刻，只有一个cpu在对 信号量进行操作。但是需要注意 区别于 使用 TSL spin lock 自旋锁来 使生产者 等待 消费者 消费 是完全不同的。即：up down操作 中使用TSL 只是为了更新 信号量，然后睡眠或者唤醒进程，而自旋锁 则 对 消费者或者生产者 在临界区中的执行操作 一直进行等待&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id="互斥锁-不需要-信号量的计数功能-将信号量的初始数值设定为1-即-保证只有一个进程能够进入-临界区称为-二元信号量即为互斥锁又称为互斥量"&gt;互斥锁: 不需要 信号量的计数功能, 将信号量的初始数值设定为1， 即 保证只有一个进程能够进入 临界区，称为 二元信号量,即为互斥锁。又称为互斥量。&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;使用信号量 来实现 生产者消费者问题：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight c"&gt;&lt;code&gt;
&lt;span class="cp"&gt;#define N 100
&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;semaphore&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;semaphore&lt;/span&gt; &lt;span class="n"&gt;mutex&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 将 信号量的数值设置为1，即为 二元信号量，互斥锁.&lt;/span&gt;
&lt;span class="n"&gt;semaphore&lt;/span&gt; &lt;span class="n"&gt;full&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;semaphore&lt;/span&gt; &lt;span class="n"&gt;empty&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;


&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;producer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;item&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;produce_item&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;down&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 将 空槽位 数量 - 1&lt;/span&gt;
        &lt;span class="n"&gt;down&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 获取互斥锁&lt;/span&gt;
        &lt;span class="n"&gt;insert_item&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;up&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 释放互斥锁&lt;/span&gt;
        &lt;span class="n"&gt;up&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;full&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;// 将 满槽数 + 1&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;consumer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;down&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;full&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//将 满槽数 - 1&lt;/span&gt;
        &lt;span class="n"&gt;down&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 获取互斥锁&lt;/span&gt;
        &lt;span class="n"&gt;item&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;remove_item&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;up&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 释放互斥锁&lt;/span&gt;
        &lt;span class="n"&gt;up&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 将 空槽位 数量 + 1&lt;/span&gt;
        &lt;span class="n"&gt;consume_item&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;解释&lt;/strong&gt;: 其中信号量 full以及 empty 作为 同步使用，即保证 消费者 与 生产者 按照 正确的顺序发生。而mutex 则 互斥进入临界区。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;进程实现的一些方法:
    &lt;ul&gt;
      &lt;li&gt;线程能够 共享内存空间，所以很方便的使用上述技术。但是进程是否可以呢？ 答案是可以： 1） 使用 共享数据结构，比如信号量，可以放在内核中，并只能通过系统调用来访问。 2） Linux提供系统调用方法 来使多个进程共享 部分地址空间。 3）可以使用共享文件。&lt;/li&gt;
      &lt;li&gt;如果两个进程共享全部或者部分内存的话，进程和线程之间的差别就变得模糊起来。但无论怎样差别还是有的， 共享地址空间的进程依然依然持有各自打开的文件，定时器 以及其他的一些进程特性，多线程中 则共享全部进程特性。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id="快速用户互斥量-futex-结合了-自旋锁--与-信号量的-优点"&gt;快速用户互斥量 futex： 结合了 自旋锁  与 信号量的 优点。&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;短时间的自旋锁 会很快，但是 如果等待时间长，则会浪费cpu周期，如果有很多竞争，那么阻塞进程 并且当锁被释放时候 让内核接触阻塞会更加有效。&lt;/li&gt;
  &lt;li&gt;futex 分为两部分： 内核服务 + 用户库。内和服务提供了一个队列，允许多个进程在一个锁上进行等待， 他们不会运行，除非显示的解除阻塞。将一个进程阻塞 放到等待队列中。&lt;/li&gt;
  &lt;li&gt;在没有竞争的情况下，futex 运行在用户空间中，线程通过原子操作TSL 来争夺锁。如果发生竞争， 即该锁被其他线程持有，那么线程必须等待，这种情况下 futex锁不自旋，而是使用系统调用将自己放到内核的等待队列上，当一个线程使用完该锁时，通过原子性操作释放锁之后，并检查内核的等待队列上是否有线程阻塞，如果有 则对一个或者多个线程解除阻塞。&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id="条件变量"&gt;条件变量:&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;pthread： 中的互斥量。pthrea提供了许多的同步线程函数，其基本机制即是 使用一个可以被锁定和释放的互斥量 保护每个临界区。&lt;/li&gt;
  &lt;li&gt;除了互斥量外：还提供了另外一种同步机制 条件变量。条件变量 允许线程由于一些未达到的条件而阻塞。 大部分情况下 互斥量与条件变量是一起使用的。&lt;/li&gt;
  &lt;li&gt;pthread 互斥量相关: todo 表格&lt;/li&gt;
  &lt;li&gt;pthread与条件变量相关：todo表格&lt;/li&gt;
  &lt;li&gt;条件变量与互斥量经常一起使用，这种模式： 让一个线程锁住一个互斥量，进入临界区 当不能获得期望的结果时 等待一个条件变量。最后另一个线程向他发送信号，使它可以继续执行。pthread_cond_wait 原子性的调用并解锁他持有的互斥量，所以互斥量也是其参数之一。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;值得指出的是：条件变量并不在内存中，如果将一个信号传递给一个没有线程等待的条件变量，那么这个信号将消失，编码时应该小心的避免信号丢失情况的发生。条件变量 并不能像信量那样积累信号以便 以后使用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;下面是生产者消费者的 互斥量 + 条件变量 使用方法：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight c"&gt;&lt;code&gt;
&lt;span class="cp"&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;pthread.h&amp;gt;
#define MAX 1000000
&lt;/span&gt;
&lt;span class="n"&gt;pthread_mutex_t&lt;/span&gt; &lt;span class="n"&gt;the_mutex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;pthread_cond_t&lt;/span&gt; &lt;span class="n"&gt;condc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;condp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;buff&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;


&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;producer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;MAX&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;pthread_mutex_lock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;the_mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buff&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;pthread_cond_wait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;condp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;the_mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;buff&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;pthread_cond_signal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;condc&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;pthread_mutex_unlock&lt;/span&gt;&lt;span class="err"&gt;（&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;the_mutex&lt;/span&gt;&lt;span class="err"&gt;）&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;pthread_exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;consumer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;MAX&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;pthread_mutex_lock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;the_mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buff&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;pthread_cond_wait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;condc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;the_mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;buff&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;pthread_cond_signal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;condp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;pthread_mutex_unlock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;the_mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;pthread_exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;pthread_t&lt;/span&gt; &lt;span class="n"&gt;pro&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;con&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;pthread_mutex_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;the_mutex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;pthread_cond_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;condc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;pthread_cond_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;condp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;pthread_create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;con&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;consumer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;pthread_create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;pro&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;producer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;pthread_join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pro&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;pthread_join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;con&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;pthread_cond_destroy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;condc&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;pthread_cond_destroy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;condp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;pthread_mutex_destroy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;the_mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;以上是使用  互斥量 + 条件变量 的典型实例。 注意其中 的pthread_cond_wait的使用 以及其前缀条件。 应该总是使用 while循环 来检查 线程被唤醒后，条件是否满足。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="管程-高级同步原语-其重要的特性为-任一时刻--管程-中-只能有一个活跃的线程-这一特性使管程能够有效的完成互斥管程是编程语言的基本组成部分编译知道如何-处理对管程的调用-进入管程的互斥-通常由编译器负责其通常的的做法为使用一个-互斥量但是-依然存在问题-在上面的例子中我们使用-条件变量来使线程从-阻塞状态中恢复所以-我们--也需要同样的-同步机制-即-我们在管程中引入了-条件变量"&gt;管程: 高级同步原语 其重要的特性为： 任一时刻  管程 中 只能有一个活跃的线程。 这一特性使管程能够有效的完成互斥。管程是编程语言的基本组成部分，编译知道如何 处理对管程的调用。 进入管程的互斥 通常由编译器负责。其通常的的做法为使用一个 互斥量。但是 依然存在问题， 在上面的例子中，我们使用 条件变量来使线程从 阻塞状态中恢复。所以 我们  也需要同样的 同步机制 。即 我们在管程中引入了 条件变量。&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;当一个管程过程发现自己 不能够继续进行下去的时候， 它将会在某个条件变量上进行wait操作，该操作将导致线程阻塞，并释放临界区的锁，导致其他的管程进入临界区域，并等待其他线程在条件变量上的唤醒操作。&lt;/li&gt;
  &lt;li&gt;当一个线程对阻塞在条件变量进行唤醒操作时， 即发送signal时，为了避免管程中同时存在两个活跃线程，我们需要一条规则来确定 唤醒操作 之后 应该怎么办：&lt;/li&gt;
  &lt;li&gt;两个方法： 1）让新唤醒的线程运行，而挂起另外一个。2）执行signal的线程立即退出管程，即signal应该为函数的最后一条语句。&lt;/li&gt;
  &lt;li&gt;Java中的管程实现： 使用sychronized 标记管程函数，也不使用显示的条件变量，而是提供了对应的函数wait,notify。&lt;/li&gt;
&lt;/ol&gt;

&lt;h6 id="总结信号量的提供已经很好地解决了线程之间的临界区同步以及发生顺序问题确-为什么依然-要提供--互斥量--条件变量的组合呢"&gt;总结：信号量的提供已经很好地解决了，线程之间的临界区同步，以及发生顺序问题，确 为什么依然 要提供  互斥量 + 条件变量的组合呢？&lt;/h6&gt;
&lt;ol&gt;
  &lt;li&gt;现实的情况比较复杂，. 信号量是一个比较高级的操作原语，其可以使用互斥量 + 条件变量 + counter来实现。对程序暴露出更低级的操作  是非常有必要的。&lt;/li&gt;
  &lt;li&gt;互斥量 可以简单地 实现 1个互斥量 +  n个条件变量 的 组合实现。即 在临界区中 可以实现多种情况的 wait 与 signal&lt;/li&gt;
  &lt;li&gt;互斥量 + 条件变量 与  信号量 的使用 规则形式不同。信号量 需要先 down(full) 然后才 down(mutex) 进入临界区。而 互斥量 +条件变量的使用 ，则 是 先 lock(&amp;amp;mutex) 然后 根据条件 进行条件变量 的wait。&lt;/li&gt;
  &lt;li&gt;管程模式 导致 管程 中确实需要 条件变量。 因为管程 优先锁定互斥量进入临界区。&lt;/li&gt;
&lt;/ol&gt;

&lt;h6 id="消息传递-message-passing-使用两条-通信原语send-receive他们是-信号量而不像管程是系统调用-而不是语言成分"&gt;消息传递： message passing, 使用两条 通信原语：send receive，他们是 信号量而不像管程，是系统调用 而不是语言成分。&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;send(destination, &amp;amp;message)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;receive(source, &amp;amp;message)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;设计要点：  系统面临着  许多信号量 与管程 所未涉及的问题和设计难点。 特别是 通过网络在不同机器之间进行通讯的情况。 可能会发生 网络问题，导致消息丢失等情况的发生。 为了防止消息丢失，需要接收方，向发送方回复 确认消息，防止发送方 未收到确认消息超时重发。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;使用 消息传递解决 生产者-消费者问题：即：消费者 receive消息，而发送者 send消息。&lt;/li&gt;
  &lt;li&gt;消息传递方式 可以有多种形式： 一种方法则是 引入信箱（mail box ）用来对一定数量的消息进行缓冲的地方。 一个进程向一个满的信箱发送消息时，进程将被挂起。直到信箱中有消息被取走。&lt;/li&gt;
  &lt;li&gt;通常 在并行程序设计系统中 使用消息传递。例如著名的消息传递接口(Message-Passing Interface MPI )&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id="屏障-用于同步进程组一些应用中划分了若干阶段并且规定除非所有的进程-都准备就绪否则任何进程都不能进入下一个阶段-可以通过在每一个阶段的结尾安置--屏障-来实现此类型行为--当一个进程到达屏障时他就被阻拦直到所有进程都到达-该屏障为止屏障用于一组进程的同步"&gt;屏障： 用于同步进程组，一些应用中划分了若干阶段，并且规定，除非所有的进程 都准备就绪，否则任何进程都不能进入下一个阶段。 可以通过在每一个阶段的结尾安置  屏障 来实现此类型行为。  当一个进程到达屏障时，他就被阻拦，直到所有进程都到达 该屏障为止。屏障用于一组进程的同步，&lt;/h6&gt;

&lt;h4 id="调度-当计算机同时存在多个进程或者线程同时竞争cpu只要有两个或更多的进程处于就绪状态如果只有一个cpu发生那么就必须选择下一个要运行的进程在操作系统中完成选择工作的这一部分称为-调度程序该程序使用的算法称为-调度算法"&gt;调度： 当计算机同时存在多个进程或者线程同时竞争cpu，只要有两个或更多的进程处于就绪状态，如果只有一个cpu发生，那么就必须选择下一个要运行的进程，在操作系统中完成选择工作的这一部分称为 调度程序。该程序使用的算法称为 调度算法。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;周边概念：
    &lt;ul&gt;
      &lt;li&gt;进程调度 与线程调度 没有本质区别，但是线程调度 依然会存在 一些独特的问题。&lt;/li&gt;
      &lt;li&gt;进程的切换 代价 是比较高的。  首先 用户态 必须 切换到内核态，然后保存当前进程的状态，包括在进程表 中存储寄存器的数值、内存映像等 以便进程的 重新装载，同时 进程切换 还要使整个内存高速缓存失效，强迫 从换内存中 动态重新装入两次（进入内核一次，离开内核一次）。即：进程切换会耗费cpu时间，&lt;/li&gt;
      &lt;li&gt;进程 行为： 几乎所有的进程的IO请求与计算都是 交替发生的。即：cpu 运行一段时间之后，然后发起一个系统调用 以 读写文件，在完成系统调用之后，cpu开始计算，直到他需要读取更多的 数据 为止。  请注意某些IO活动 可以看做计算 。 当一个进程 等待外部设备 完成工作 而被阻塞时，才是IO活动。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;根据检查花费在 cpu计算与 IO上的时间 可以将进程划分为 两类：
    &lt;ul&gt;
      &lt;li&gt;计算密集型：较长时间的cpu集中使用 + 较小频繁的IO等待&lt;/li&gt;
      &lt;li&gt;IO密集型： 较短时间的cpu集中使用 + 频繁的IO等待&lt;br /&gt;
&lt;strong&gt;随着cpu变得越来越快&lt;/strong&gt;，更多的进程倾向为 IO 密集型。因为cpu的改进比磁盘的改进快得多。结果是， 未来对于 IO密集型进程的调度处理 更加重要。两个结论：1）IO密集型进程应该尽快得到调度，而使磁盘得到充分的发挥， 2） 如果进程是IO密集型，则可以 多运行一些这类进程 以便 保持cpu利用率。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;何时调度： 调度时机
    &lt;ol&gt;
      &lt;li&gt;在创建一个新的进程后&lt;/li&gt;
      &lt;li&gt;在一个进程退出时&lt;/li&gt;
      &lt;li&gt;在一个进程阻塞在IO和信号量上 或由于其他原因阻塞时&lt;/li&gt;
      &lt;li&gt;在一个IO中断发生后&lt;/li&gt;
      &lt;li&gt;硬件时钟中断： 可以在 每个时钟中断 或者每k个时钟中断 时，做出决策。 感觉如何处理时钟中断可将调度算法 分为两类：
        &lt;ul&gt;
          &lt;li&gt;非抢占式 调度算法 挑选一个进程 然后让该进程运行直到被阻塞 或者 进程主动释放cpu，即是该进程运行数个小时，依然不会被挂起。这样的结果是，在时钟中断 发生时不会进行调度，在处理完 时钟中断后，如果没有更高优先级的进程 等待到时，则中断的进程会继续进行。&lt;/li&gt;
          &lt;li&gt;抢占式调度算法： 挑选一个进程并让该进程运行某个固定时段的最大值。如果该时间段结束，该进程依然在运行，将被挂起，调度程序将挑选另一个进程运行。抢占式调度算法。需要在时间末端发生时钟中断。以便把cpu控制返回给调度程序，如果没有可用的时钟，那么不能够实现 抢占式调度算法。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;调度算法分类：不同的环境 需要不同的调度算法，以为需要不同的目标。分为三类环境：批处理、交互式、实时
    &lt;ol&gt;
      &lt;li&gt;批处理环境中： 可以运行非抢占式算法，&lt;/li&gt;
      &lt;li&gt;交互式环境中：抢占式必须要的，&lt;/li&gt;
      &lt;li&gt;实时系统中： 抢占有时是不需要的。以为进程知道他们可能会长时间得不到运行，而尽快完成任务。与交互环境的区别，在于：实时系统只运行那些用来推进现有应用的程序，而交互是系统是通用的。  他可以运行任意的非写作甚至是恶意的程序。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;调度算法的目标：取决于环境目标 + 通用目标：
    &lt;ul&gt;
      &lt;li&gt;通用目标：
        &lt;ul&gt;
          &lt;li&gt;1）公平， 相似的进程得到的cpu时间是相似的，不同类型的进程 得到的计算 可以采用不同的方式，或者有差异。&lt;/li&gt;
          &lt;li&gt;2） 保持系统中的所有部分尽可能忙碌，例如cpu、磁盘。 在批处理系统中，调度程序控制那些任务的调入内存。 内存中既有 cpu密集型 与IO密集型 作业 要优于 先运算完  cpu密集型任务，然后再运算 IO密集型任务。 因为 在集中计算 所有的cpu密集型任务时，cpu 保持忙碌，任务保持对cpu的争抢，而磁盘保持闲置状态。显然 可以通过仔细的安排任务，能够 使整个系统运行的更好一些。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;场景目标：  &lt;br /&gt;
批处理系统： 吞吐量- 每小时做大作业量， 周转时间- 从提交到终止间的最小时间， CPU利用率- 保持cpu始终忙碌。&lt;br /&gt;
交互式系统： 响应时间–快速响应请求，均衡性– 满足用户的期望。&lt;br /&gt;
实时系统–满足截止时间： 避免丢失数据，可预测性- 在多媒体系统中避免低品质。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;批处理作业中的 三个衡量指标:  吞吐量，周转时间，cpu利用率。&lt;/li&gt;
  &lt;li&gt;吞吐量（throught）: 系统每个小时完成的工作量。每小时完成50个作业好于 完成40个作业。&lt;/li&gt;
  &lt;li&gt;周转时间(turnaround time): 从一个作业提交时刻开始直到 作业完成时刻为止 的统计平均时间。度量了 用户要得到输出所需要的平均时间，越小越好。&lt;/li&gt;
  &lt;li&gt;cpu利用率： cpu利用比率。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;吞吐量与 周转时间之间的冲突： 例如 对于确定的短作业 与长作业 的一个组合。 总是运行短作业而不是长作业，会获得出色的吞吐性能。但是其代价为 长的作业周转时间较差。即得到了较高的吞吐量 ，但是 平均周转较差。&lt;/p&gt;

&lt;p&gt;交互式系统的不同指标： 最小响应时间： 从命令到得到响应之间的时间。均衡性： 用户对于一件事情完成需要多少时间 总是一个固定的期望。&lt;/p&gt;

&lt;p&gt;实时系统： 特点是 必须满足截止时间要求。&lt;/p&gt;

&lt;p&gt;批处理中的调度算法：&lt;/p&gt;

&lt;p&gt;先来先服务：first-come first-serverd 算法。该算法 按照 进程请求cpu的顺序 使用cpu， 可以想象有一个 就绪进程的队列， 产生新作业时，新进程排在就绪队列 尾部。 当正在运行的进程由 就绪变为阻塞时，就绪队列中的第一个进程运行，当被阻塞的进程变为就绪状态时，就像一个新来的作业进程一样，排到就绪队列的末尾。 该类算法 实现起来比较简单。但是存在一个明显的缺点，即： 对于IO密集型进程不太友好，没有很好的考量 是系统中的 设备是否充分利用。  考虑 两个进程，一个cpu密集型进程 每次运行1s的cpu计算 和一个 IO密集型进程，很少利用cpu，但是需要都要运行1000次的磁盘读写操作才能完成任务。 如果 按照该类调度算法 的话，则IO密集型进程需要运行1000s才能够运行完成，但是如果 使用抢占式 调度算法的话，则可以 没10ms进行一次抢占调度，则 IO密集型进程将在10s内完成，而对于 cpu密集型进程 则没有太大影响。&lt;/p&gt;

&lt;p&gt;最短作业优先： 适用于一种运行时间预知的非抢占式调度算法。 即：作业按照 完成时间 从小到大排列，即 shortest job first.&lt;br /&gt;
考虑有4各作业。其运行时间 分别为 a ,b,c,d  其平均周转时间为 (4a + 3b + 2c + d)/4，可见第一个作业a的完成时间，对于 平均周转 影响最大，而 吞吐量 同样为最大。  又必须要指出， 只有在所有的作业都可同时运行的情况下，最短作业优先算法才是最优的。反例： 5各作业，A-E,运行时间分别为：2,4,1,1,1 他们到达系统的时间分别为 0,0,3,3,3， 系统在开始时 只能选择A与B， 按照 该调度算法的排序 为A,B,C,D,E 其平均周转时间为4.6，但是按照 B,C,D,E,A的调度安排，时间为4.4，优于  最短作业优先。&lt;/p&gt;

&lt;p&gt;最短剩余时间优先： 最短作业优先的抢占式调度版本。 调度程序总是选择 剩余运行时间 最短的那个进程 进行运行。当新加入的进程的剩余时间最短时，则当前进程就被挂起，运行新的进程。&lt;/p&gt;

&lt;p&gt;交互式系统中的调度：&lt;/p&gt;

&lt;p&gt;轮转调度（round robin）： 简单公平的调度算法， 每个进程被分配一个时间段，称为时间片。 （quantum）&lt;/p&gt;

&lt;p&gt;即允许 进程在该时间段内运行，如果在时间片结束时候该进程还在运行 则剥夺cpu并分配给另一个进程。如果该进程在时间片内 阻塞或者结束 则 cpu将立即切换。&lt;/p&gt;

&lt;p&gt;轮转调度算法 实现非常简单，即维护一个 可以运行的进程列表。不断的从列表头上取出进程运行，时间片用完后，将进程放到列表队尾。&lt;/p&gt;

&lt;p&gt;关于时间片的长度设定： 从一个进程切换到另一个进程 即 进程切换 也称为 上下文切换。 其中需要 保存和装入寄存器数值，更新各种列表，清除和重新调入内存 高速缓存等 操作。&lt;/p&gt;

&lt;p&gt;如果时间片设定为4ms 而进程切换需要 1ms，则 cpu时间将花费 20% 的时间在进程的切换上。&lt;br /&gt;
如果将时间片设定为100ms，则cpu时间将花费1%在进程间的切换上。但是 可以想见的是，排在队尾的进程将在很久之后才能得到cpu的时间，对于交互式系统用户而言，将是缓慢的。&lt;br /&gt;
如果将时间片设置为长于平均的cpu突发时间，那么将不会经常发生抢占，相反 多数进程将在时间片内发生 阻塞操作，从而引起进程切换，抢占的消失改善了性能，因为进程只有在逻辑上需要的时候发生了切换，即：进程确实不能够在继续进行下去。&lt;/p&gt;

&lt;p&gt;总结：时间片设定的太短，导致cpu利用率的降低，时间片设定的太长，导致交互请求的响应变长，普遍间时间片设定为 20-50ms范围内 。&lt;/p&gt;

&lt;p&gt;优先级调度：&lt;/p&gt;

&lt;p&gt;在轮转调度中 存在一个隐藏的假设，即： 所有的进程是同样重要的。实际上 进程的优先级是可以调整的。即进程之间存在重要性的差异。比如 在屏幕上显示视频的进程 比 后台发送邮件的进程具有较高的优先级。&lt;/p&gt;

&lt;p&gt;从此可以看到 时钟滴答 与 时间片 是不同的概念。这里面的时钟中断 应该是 linux中 可以控制的时钟周期，即cpu频率保持不变，但是在 配置的滴答个数 可以 进行时钟中断，而 时间片的概念呢？是建立在 时钟中断上的吧？&lt;/p&gt;

&lt;p&gt;两种方法：&lt;br /&gt;
为了防止 高优先级的进程一直无休止的运行下去，调度程序可能在每个时钟滴答（时钟中断）降低当前进程的优先级，如果这一行为导致该进程的优先级低于此高级优先级的进程，则进行进程切换。&lt;br /&gt;
给每个进程赋予一个允许运行的最大时间片。 当用完这个时间片  则 此高优先级的进程 便能获得运行机会，即进行进程切换。&lt;/p&gt;

&lt;p&gt;优先级 可静态确定 或 动态确定。 比如 按照行政等级 确定 等级高的人 的任务具有更高的优先级。&lt;/p&gt;

&lt;p&gt;动态确定： 的比如，将IO密集型进程设定更高的优先级，算法 1/f，f为进程在上次的时间片上用的时间片。IO密集型进程 其多数时间 用来等待 IO结束，当这样的进程需要CPU时候，应该立即分配给他，以便让其 启动下一个 IO请求，以充分利用cpu与IO设备。一个在50ms时间片中花费 1ms 时间的 进程 将获得 50的优先级，一个进行  2mscpu运算的进程将获得25的优先级。&lt;/p&gt;

&lt;p&gt;多级队列： 优先级调度 中优先级之间 改变优先级 的另外一种方法： 设立优先级类，将最高优先级类的 进程运行一个时间片，此高级优先级的进程 运行 2个时间片， 下一个优先级的进程类运行 4个时间片。 以此类推，当一个进程用完分配的时间片之后，将被移到下一个优先级类。 这样的规则将导致 cpu密集型进程将获得更低的优先级，更大的时间片进行运行。 这里面的存在的缺陷在于，没有将 优先级提升的方法，如果 交互式进程因为 偶尔的 用完时间片的行为  将导致 不断的惩罚，将导致 降低为 低优先级。&lt;/p&gt;

&lt;p&gt;最短进程优化：&lt;/p&gt;

&lt;p&gt;再批处理系统中 使用 最暖进程优先算法是非常好的。 然而如何将其 应用在交互式系统中 则成为问题，因为 如何从当前进程中找到运行时间 最短的那个进程。 交互式 进程通常的模式 为：  等待命令、执行命令、等待命令、执行命令 如此往复。&lt;br /&gt;
一种办法为： 根据进程过去的行为进行推测。使用时间老化算法来估算 进程运行时间。 假设进程 之前进程运行的时间  为  T0，当前估计时间 T1，本次 实际时间 为 T0/2 + T1/2 则  aT0 + (1 - a) T1 通过选择 a，可以决定 尽快忘掉老的运行时间。当 a = 1/2时，我们可以得到如下的队列：&lt;/p&gt;

&lt;p&gt;T0， T0/2 + T1/2， T0/4 + T1/4 + T2/2， T0/8 + T/8 + T2/4 + T3/2 在 3此过后 T0的权重 降低为 1/8&lt;/p&gt;

&lt;p&gt;我们把 这种通过当前预测值 + 先前估计值  加权平均 而得到 一个 估计值 的技术 成为 老化技术。&lt;/p&gt;

&lt;p&gt;保证调度： 向用户做出明确的性能保障，然后去实现它。一个简单的保证为： 如有n各用户登录，则保证用户将获得 1/n 的计算能力。 即系统 需要追踪 系统的运行参数， 诸如 用户进程 实际占用的cpu运行时间，以及 应该占用的cpu时间。其数值比率 大 则说明 获得时间多，而数值小 则说明 获得cpu时间少。  该算法 将优先调度 数值小的 进程 ，已实现 性能保证要求。&lt;/p&gt;

&lt;p&gt;彩票调度： 保证调度 很难实现，一种近似实现 为 彩票调度（lottery scheduling） 基本思想为 为进程提供 各种系统资源 的彩票。 需要做出调度决策时，就随机抽取一张彩票，拥有该彩票的进程获得调度。&lt;br /&gt;
如果cpu出售了1000张彩票 ，某个进程 持有 20张，则每一次抽奖 该进程就有20%的几率 获得cpu， 在较长的运行时间中，该进程将获得20%的cpu。与  优先级调度 相比较，很难解释进程的优先级为 20 是什么意思，也更难预测 进程将获得与 优先级相关的多少cpu时间。而彩票调度  则 非常明确，拥有 f分彩票 进程 大约得到 系统资源的f份额。&lt;/p&gt;

&lt;p&gt;彩票调度 可以用来解决一些 难题，比如 视频流服务器， 服务器上若干进程 为用户提供 帧速率 为10，20，25 的视频流，  只需要 分配 进程 对应的 彩票份额，10， 20，25 即可。&lt;/p&gt;

&lt;p&gt;公平分享调度： 需要具体考虑 公平 的定义，用户公平的调度 则需要考虑 在 进程调度 期间 用户的进程 分配 cpu占用问题。&lt;/p&gt;

&lt;p&gt;策略和机制： 调度机制 与 调度策略 分离开来。调度机制位于内核，而调度策略 则由用户进程 决定。&lt;/p&gt;

&lt;p&gt;线程调度： 若干进程 由多个线程 时候，系统中就存在两个层次的并行： 进程和线程， 在这样的系统中 调度 处理 有本质上的差别。当然这取决于线程 的实现： 即 用户级线程 还是内核级线程。&lt;/p&gt;

&lt;p&gt;在 用户级别线程下： 由于内核并不知道线程的存在 ，所以 内核 依然 按照 进程调度，即 用户线程调度 决定 选择那个一个线程。 调度算法 选取中 可以选用上面的任何一种，但 轮转调度 和优先级 调度更为常用。 缺陷则是缺乏 一个时钟中断中断运行时间 过长的线程，但是因为线程之间 为合作关系，所以通常并不是问题。&lt;br /&gt;
内核级线程： 对于内核  可以考虑优先调度同属于一个进程的线程，以为同进程间的线程调度 代价要小于 进程之间的调度。其他方面 则与 进程间调度没有什么不同。Linux中 线程与进程同为 调度实体。&lt;/p&gt;

&lt;p&gt;用户级线程 与 内核级线程 之间的差别在于 性能： 用户级线程的线程切换 需要较少的机器指令，而内核级线程 切换  则需要 完整的上下文切换、修改内存映像、高速缓存失效（而同样归于同进程的线程 则是不需要） 等操作，这导致了数量级别的延迟。&lt;/p&gt;

&lt;p&gt;用户级线程 可以使用 特定优化的调度算法，以为 应用程序 知道自己的应用场景，而 内核级线程 内核从来不了解 每个线程的作用。一般而言，应用定制的线程调度算法 能够比内核 更好的满足 应用的需要。&lt;/p&gt;

&lt;p&gt;经典的IPC问题：  哲学家就餐问题， 读者-写者问题&lt;/p&gt;

&lt;p&gt;哲学家就餐问题：&lt;/p&gt;

&lt;p&gt;直观的解法： 显然是错误的，如果 五位哲学家 同时执行（拿起 左边的筷子 、拿起右边的筷子） 将会导致 没有人能够拿起 右边的筷子， 从而导致死锁。  一个简单的解决方法为：  在哲学家拿起 左边的筷子时候，查看右边的筷子 是否可用，如果不可用，则先放下左边的筷子 ， 等一段时间，再重复这个过程。  但这个解法同样存在问题。 尽管原因不同，同一时间 所有的哲学家 都开始进行 该算法，同时 拿起左边的筷子，同时 查看右边筷子是否可用，放下，等待。 如此运行下去 所有的进程都在运行，但是却无法取得进展，该现象 我们称之为饥饿。&lt;br /&gt;
我们简单的将 上述 中的等待时间 设定为一个 动态的随机时间，而不是等待一个固定的时间 。这样发生饥饿的可能性就非常小了， 几乎在所有的程序中，稍后再试的办法并不会演化成为一个问题。例如 ： 在流行的以太网上，  如果两台计算机同时发送包 ，那么每台计算机会稍等一哥随机时间之后 再次尝试，在实践中  该方案工作良好。 少数的程序中， 人们希望一种总是能够工作的方案，他不会因为一串 随机数字而失败。&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight c"&gt;&lt;code&gt;&lt;span class="cp"&gt;#define N 5
&lt;/span&gt;

&lt;span class="n"&gt;vodi&lt;/span&gt; &lt;span class="nf"&gt;philosopher&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;think&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
  &lt;span class="n"&gt;take_fork&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;take_fork&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;eat&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
  &lt;span class="n"&gt;put_fork&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
  &lt;span class="n"&gt;put_fork&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最优的解法： 这里应该搜索，没有理解其代码意思。&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight c"&gt;&lt;code&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;philosopher&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;take_forks&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;down&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;hungry&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;up&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;down&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;put_forks&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;down&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;thinking&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LEFT&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;RIGHT&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;up&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;test&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;hungry&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;LEFT&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;EATING&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;RIGHT&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;EATING&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;EATING&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;up&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;读者-写者问题：一个数据库访问模型：  多个进程可以同时读取数据库，但是如果一个进程 正在更新 写数据库，则所有的其他进程 都不能够访问数据库。&lt;/p&gt;

&lt;p&gt;下面是一个读者优先访问示例代码：&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight c"&gt;&lt;code&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;semaphore&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;semaphore&lt;/span&gt; &lt;span class="n"&gt;mutex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;semaphore&lt;/span&gt; &lt;span class="n"&gt;db&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;rc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;reader&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;down&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mutext&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;rc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;rc&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rc&lt;/span&gt; &lt;span class="o"&gt;===&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;down&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;up&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;read_data_base&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;down&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;rc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;rc&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rc&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;up&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;up&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;use_data_read&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="n"&gt;think_up_data&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  &lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="n"&gt;down&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
   &lt;span class="n"&gt;write_data_base&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
   &lt;span class="n"&gt;up&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该解法中 隐含着一种情况：即 数据库当前存在一个读者 时候，另一个读者来了 以及 更多的读者来了，同样允许。这时 一个写者到来  由于写者是拍他的，不允许进入数据库，导致被挂起。需要等待所有的读者处理完成之后 才能开始进行处理写操作。即 读者比 写者拥有更多高的优先级， 写总是排在读后面，如果读者多的情况下 将导致 写 迟迟不能完成操作。&lt;/p&gt;

&lt;p&gt;写优先的解法 需要查找 courtois等人的相关资料。&lt;/p&gt;

&lt;p&gt;总结：&lt;br /&gt;
进程问题已经有了成熟的解决方案，几乎所有的系统都将进程视为一个容器， 用以管理相关的资源，比如地址空间、线程、打开的文件描述符等。 不同的系统管理进程资源的基本想法大致相同。 只是在工程处理上略有差异。&lt;br /&gt;
线程是比进程新的概念，但是也经过了深入了的研究。&lt;br /&gt;
进行执行过程的 记录和重放  也是一个非常活跃的研究领域。 重放技术 可以帮助开发者 追踪一些难以发现的程序漏洞。&lt;br /&gt;
调度问题  也是研究者感兴趣的问题。 一些研究主题包括移动设备上的低能耗调度， 超线程级调度 和偏执意识调度 。 智能手机的计算量 增加 因为电池容量有限。 一些研究者提出 可能的时候将进程迁移到云上某个更强大的服务器上执行。但实际系统的设计者  很少会因为没有合适的线程调度算法 而苦恼。所以这是一个由 研究者推送而不是 需求推动的研究类型。总而言之， 进程，线程 与调度已经不再是研究热点了，功耗管理 、虚拟化、云计算 、与安全问题 成为了热点主题。&lt;/p&gt;

&lt;p&gt;习题答案 ：（部分重要）&lt;/p&gt;

&lt;p&gt;当代计算机中，为什么中断处理程序中 至少部分是由汇编程序来编的？&lt;br /&gt;
答： 高级语言不允许访问 必要的cpu资源，比如 一个中断处理程序中 可能需要开启、禁止 中断。 此外 中断处理程序 需要尽可能的快。&lt;/p&gt;

&lt;p&gt;中断 或 系统调用 将控制权 转移到 操作系统时，为什么 通常会 用到与 被中断进程 的栈分离的 内核栈？&lt;br /&gt;
答： 为内核使用单独的堆栈有几个原因。 其中两个如下。 首先，您不希望操作系统崩溃，因为编写得不好的用户程序不允许有足够的堆栈空间。 其次，如果内核在从系统调用返回时将堆栈数据留在用户程序的内存空间中，恶意用户可能能够使用这些数据来查找有关其他进程的信息。&lt;/p&gt;

&lt;h3 id="内存管理-"&gt;内存管理 ：&lt;/h3&gt;

&lt;p&gt;不管存储器多大，程序都可以将其填满。&lt;/p&gt;

&lt;p&gt;分层存储器体系： 在这个体系中，存在 MB 的快速、昂贵、易失性的高速缓存，GB的速度价格适中的同样易失的内存 ，以及 TB的低速、廉价、非易失的磁盘存储。&lt;/p&gt;

&lt;p&gt;操作系统的工作之一 就是 将层次存储系统体系 抽象成为一个 有用的模型 并管理这个抽象。&lt;/p&gt;

&lt;p&gt;分层存储器系统称为 存储管理系统：  他的任务是 有效的管理内存，即记录哪些 内存是正在使用的，哪些 是空闲的， 在进程需要时候为其分配内存 ，不需要时释放内存。&lt;/p&gt;

&lt;p&gt;探索 内存抽象方案 的步骤：&lt;/p&gt;

&lt;p&gt;无存储器抽象：  最简单的存储器抽象 即 没有抽象。  早期的大型机  小型计算机 都没有存储抽象。 每一个程序 都直接访问物理内存。&lt;br /&gt;
因此  那时候呈现给编程人员的存储器 即是：  从0到某个上限的地址集合，每个地址 对应一个 可容纳 一定数目的二进制数据，通常是 8位。&lt;br /&gt;
指令 MOve Register1， 100  即：将  100的物理内存的内容，转移到 register1中。&lt;/p&gt;

&lt;p&gt;改种方案下， 系统中同时运行两个程序 是不可能的。如果进程 A在 地址 100位置写入数据，进程 2  在稍后的时间中 对地址 100进行了改写，可能导致 进程A的崩溃。&lt;/p&gt;

&lt;p&gt;在该模式 内存的布局方式有以下三种：&lt;/p&gt;

&lt;p&gt;操作系统位于 RAM 的底部&lt;br /&gt;
操作系统位于内存顶端 的ROM（只读存储器） 中&lt;br /&gt;
设备驱动程序位于顶端的ROM中，操作系统位于底端的RAM中&lt;/p&gt;

&lt;p&gt;第二种方案 经常用在 一些掌上电脑，和嵌入式系统中。&lt;br /&gt;
第三种方案 用于早期的个人计算机中， ROM中的系统部分 为 BIOS（basic  input output system）&lt;/p&gt;

&lt;p&gt;在没有存储器抽象的情况下 同时运行多个程序。&lt;/p&gt;

&lt;p&gt;操作系统 只需要 把当前的内存中的内容 保存到磁盘上 ，然后将下一个程序 读入到内存中 再次运行即可。 只要在同一时刻 内存中只有一个程序 即可。&lt;/p&gt;

&lt;p&gt;IBM 360 的做法：&lt;br /&gt;
内存被划分为 大小2KB的块。 每个块 分配一个 4位的保护键， 保护键存储在cpu的特殊寄存器中， PSW中存在一个 4位码， 一个运行中的进程如果访问保护码 与 PSW中的不同的内存，硬件将会捕获该事件。  因为只有系统可以修改保护键，这样就可以放置用户进程 之间、用户和操作系统之间的相互干扰。&lt;/p&gt;

&lt;p&gt;静态重定位技术： 即便 存在保护键，依然无法解决 两个进程 使用重复的绝对地址的问题，我们希望每个进程使用一套自己私有的内存地址来进行内存访问。IBM  360 采用的方法 即：在第二个 程序 装载到内存 100地址时， 常数100将被 加到 每一个 程序地址上。&lt;/p&gt;

&lt;p&gt;缺少存储器抽象在嵌入式系统中 依然非常常见， 比如 洗衣机 微波炉 此类 设备 都已经完全被ROM形式的软件控制。 这种情况下，软件都采用 绝对地址寻址的方式，以为 所有的运行的程序 都可以被事先确定，  用户不需要运行自己的软件。&lt;/p&gt;

&lt;p&gt;存储器抽象：地址空间&lt;/p&gt;

&lt;p&gt;直接暴露物理地址的问题： 1） 用户程序可以简单的寻址内存地址，很容易地破坏 操作系统。 2） 同时运行多个程序将非常困难。&lt;/p&gt;

&lt;p&gt;地址空间的概念：&lt;/p&gt;

&lt;p&gt;要多个应用程序 同时处于内存 而不互相影响 需要解决两个问题： 1）保护 2）重定位 。&lt;/p&gt;

&lt;p&gt;IBM 360的办法 实际效果并不好，因为 其 静态重定位 技术，不仅缓慢，还需要 额外的标记 来确定 那些地址 需要被加。&lt;/p&gt;

&lt;p&gt;就像 进程的概念 创造了 cpu的抽象 为 进程使用 一样。&lt;/p&gt;

&lt;p&gt;地址空间 为程序 创造了 一种抽象 的内存，地址空间 是一个进程可以用于寻址内存的地址集合。每个进程 都有自己的 地址空间，独立于 其他的 进程 地址空间。&lt;/p&gt;

&lt;p&gt;地址空间的概念非常常见：  比如 电话号码、url等。&lt;br /&gt;
简单实现：动态重定位：  给cpu配置两个寄存器： 基址寄存器 、界限寄存器。 使程序 装载期间 无需 重定位。当一个进程运行时 程序的起始地址 装载到 基址寄存器中，程序的长度 装载到 界限寄存器中。每次 进程访问内存，取一条指令、读写一个内存地址时， cpu硬件会将 地址发送到内存总线前， 自动把基址寄存器的数值 +  进程发出的地址上。 同时检查 结果是否在 界限寄存器 范围内。 超过了 界限 则捕获错误。&lt;/p&gt;

&lt;p&gt;基址寄存器 16384， 界限寄存器： 17000  指令 jmp 28 被翻译成 jmp  16412&lt;/p&gt;

&lt;p&gt;此方法可以简单实现存储器抽象。&lt;/p&gt;

&lt;p&gt;内存管理技术：&lt;/p&gt;

&lt;p&gt;1）交换技术：  两种处理内存超载的方法： 最简单的策略 是 交换技术， 即 将把进程完整的调入内存中，使该进程运行一段时间，然后把他 存回磁盘。 虚拟内存： 使程序只有一部分被调入内存的情况下 运行。&lt;/p&gt;

&lt;p&gt;空闲内存管理：&lt;/p&gt;

&lt;p&gt;动态分配内存时， 操作系统 必须 对其进行管理 ，一般有两种办法： 1） 位图 2） 空闲去链表，&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用位图的存储管理： 内存可能被划分为 几个字 或 几千字的分配单位，每个分配单位 对应于图中的一位。0表示空闲，1表示占用。分配单元的大小是一个重要的设计元素， 分配单元小 则位图大，位图占用的内存空间的比例就会提升。分配单元大 ，则位图小。但进程分配的存在更多的浪费。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;位图主要的问题是：  再决定分配一个 大小 为k个分配单元的进程调入内存时，存储管理器 必须搜索位图 已找到 k个连续的0串，因为 位图中该串可能跨越字的边界。 查找位图中 制定长度的连续0串是一个耗时操作。&lt;/p&gt;

&lt;p&gt;使用链表的存储管理：&lt;/p&gt;

&lt;p&gt;维护一个记录已分配内存段和空闲内存段的链表。&lt;/p&gt;

&lt;p&gt;有几种方法  为 新创建的进程 分配内存：&lt;br /&gt;
1） 首次匹配算法：  沿着链表进行搜索， 直到找到一个足够大的空闲区间。 除非空闲空间与 需要分配的空间大小一样，否则将该空闲区分为两部分，一部分供进程使用，一部分 成为新的空闲区。 速度非常快的算法，因为它可以尽可能少的搜索节点。&lt;/p&gt;

&lt;p&gt;2） 最佳适配算法：搜索整个链表， 找到能够容纳新进程的最小空闲区间。该算法试图找到最接近实际需要的空闲区。&lt;br /&gt;
其他算法： 快速适配法&lt;/p&gt;

&lt;p&gt;虚拟内存： 虽然 基址寄存器 + 界限寄存器 能够很好的 应对 内存抽象管理要求，但是  随着软件的膨胀 需要运行的程序往往大到内存 无法容纳， 而系统必须能够支撑起多个程序的同时运行， 即使内存仅仅 可以满足其中一个的程序需要。&lt;/p&gt;

&lt;p&gt;总体来看 程序对内存的需求 超过了实际内存大小。  交换技术 并不是一个很好的方案，因为 一个典型的SATA磁盘的峰值传输效率 只有几百兆每秒，这意味着需要好几秒 才能换入 一个1GB的程序。&lt;/p&gt;

&lt;p&gt;该类问题 很早就出现了，初始的简单解决办法 成为 ：覆盖 （overlay） 把程序分割成为许多片段， 程序开始，将覆盖管理模块转入内存，该管理模块立即 装并运行程序的片段0，在系统需要时 将由 管理模块 程序片段1装载到内存中，覆盖管理模块允许多个 片段  同时在内存中，部分在磁盘上，在需要时候动态的换入换出。&lt;/p&gt;

&lt;p&gt;虽然 有管理模块来负责 换入换出操作，但是 依然需要程序员将程序 分割成多个片段，最后人们将这种费事重复性的操作 交给了计算机去做。&lt;/p&gt;

&lt;p&gt;采用的这个方法 称为虚拟内存。 基本思想为： 每个程序拥有自己的地址空间，这个空间被分割成为多个块，每一块称作一页或页面（page）， 每一页 都有连续的地址范围，这些页面被影射到 物理内存， 但并不需要所有页面都在内存中才能够运行程序， 当程序引用到一部分在物理内存中的地址空间时，  由硬件执行必要的映射， 当程序引用到 一部分不在物理内存中的地址空间时， 由 操作系统负责将缺失的部分程序装入到 物理内存并重新执行失败的指令。&lt;/p&gt;

&lt;p&gt;分页： 大部分 虚拟内存使用的技术。&lt;/p&gt;

&lt;p&gt;Mov reg, 1000  将内存地址 1000 的内存复制到 reg中，其中的1000地址 可以由 索引、基址寄存器、段寄存器 或其他方式产生。&lt;/p&gt;

&lt;p&gt;由程序产生的地址称为虚拟地址（virtual address） 它们构成了一个虚拟地址空间。 没有虚拟内存的计算机上，虚拟地址 就是 内存物理地址， 使用虚拟内存的情况下， 虚拟地址 并不直接传送到内存总线上，而是 先传到  内存管理单元（memory  management unit MMU） mmu将虚拟地址映射称为 物理内存地址 ，在传送到物理内存地址总线上。&lt;/p&gt;

&lt;p&gt;虚拟地址 按照固定大小划分为称为 页面 （page）的单元， 物理内存中对应的为 页框（page frame）  RAM与磁盘之间的交换总是以整个页面为单元进行的。&lt;/p&gt;

&lt;p&gt;转换：&lt;/p&gt;

&lt;p&gt;程序执行 指令 MOV REG， 0 将虚拟地址 0 送到MMU， MMU 看到u虚拟地址落在页面0，根据映射结果 该页面对应得是页框是2（8192-12287）  因此 MMU把地址变换为8192 并将地址 8192发送到总线上，内存对MMU一无所知，他知道看到一个读写地址 8192 的请求并执行它，MMU从而有效的将 程序虚拟地址空间0-4095 映射到 8192-12287。&lt;/p&gt;

&lt;p&gt;通过且当的设定 MMU，可以讲16个虚拟页面，映射到 8个页表框中的任何一个。但是这并没有解决 虚拟地址空间大于物理内存空间的问题。   当程序需要访问 第9个页面的时候，会发生什么情况呢？ MMU注意到 第9个页面并没有被影射到内存中， 于是使cpu陷入到操作系统 ，称为缺页中断 或者缺页错误。 操作系统找到一个很少使用的页框 并把他的内容写入到磁盘中，随后把需要访问的页面 读到刚才 回收的页框中，修改映射关系，然后重新执行引起缺页中断的指令。&lt;/p&gt;

&lt;p&gt;缺页处理的具体步骤为：&lt;br /&gt;
1） 如果操作系统决定放弃页框1， 将虚拟页面8 装入物理地址4096，然后对MMU做两处修改，&lt;br /&gt;
1） 将虚拟页面1 标记为未映射，以便 以后任何对于 虚拟地址 4096-8191的访问 都会导致 缺页中断&lt;br /&gt;
2） 将虚拟页面8的标记页框为1，因此在重新执行引起缺页中断的指令时，能够将虚拟地址 32780 映射为物理地址 4108&lt;/p&gt;

&lt;p&gt;MMU内部结构如下：&lt;/p&gt;

&lt;p&gt;可以将16位的虚拟地址，划分为 4位的 页号 + 12 位的便宜里那个。 4位的页号 可以表达16个 页面 ， 12位的偏移地址 可以为一页内部的全部4096个字节编码。&lt;br /&gt;
使用页号作为页表的索引。以找出对于该虚拟页面的页框号， 如果 不在 则 引发一个缺页中断， 如果在 ，则 将在页表中查找到的 页框号 + 虚拟地址的偏移量  构成一个 物理地址。 输出到物理内存地址总线上。&lt;/p&gt;

&lt;p&gt;页表：&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Rust Async</title>
    <link rel="alternate" href="http://geniousbar.github.io/2021/05/09/rust-async/"/>
    <id>http://geniousbar.github.io/2021/05/09/rust-async/</id>
    <published>2021-05-09T00:00:00+00:00</published>
    <updated>2021-05-11T04:24:30+00:00</updated>
    <summary type="html">&lt;h3 id="并发模型"&gt;并发模型&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
&lt;strong&gt;OS threads&lt;/strong&gt;:  1) 不需要改变代码编码模式  2) 线程间 同步困难  3) 性能开销比较大， 线程池 可以一定程度上减少这些开销， 但是并不能够支撑起 庞大的IO 工作&lt;/li&gt;
  &lt;li&gt;
&lt;strong&gt;事件驱动模型(Event-driven)&lt;/strong&gt;： 结合callback, 性能非常好，但是 导致 非线性的控制流， Data flow and error propagation is often hard to follow.&lt;/li&gt;
  &lt;li&gt;
&lt;strong&gt;协程(coroutines)&lt;/strong&gt;： like thread， 不需...&lt;/li&gt;
&lt;/ul&gt;</summary>
    <content type="html">&lt;h3 id="并发模型"&gt;并发模型&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;OS threads&lt;/strong&gt;:  1) 不需要改变代码编码模式  2) 线程间 同步困难  3) 性能开销比较大， 线程池 可以一定程度上减少这些开销， 但是并不能够支撑起 庞大的IO 工作&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;事件驱动模型(Event-driven)&lt;/strong&gt;： 结合callback, 性能非常好，但是 导致 非线性的控制流， Data flow and error propagation is often hard to follow.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;协程(coroutines)&lt;/strong&gt;： like thread， 不需要改变代码编码模式， 共容易使用，提供了包括async 的工具， 支持大量的 任务，但是，其对于 底层的细节抽象 导致 系统编程非常困难&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Actor model&lt;/strong&gt;： 将所有的并行运算抽象为 actor ，其之间的沟通通过 message passing 非常像 分布式系统， 可以实现非常好的性能， 但是留下了许多实际问题 依然没有解决， 比如 flow control and retry logic&lt;/li&gt;
  &lt;li&gt;总结： async 编程 能够让 Rust 此类 &lt;strong&gt;系统编程语言&lt;/strong&gt; 编写出高性能代码，同时具有 thread 与 协程(coroutines) 的优势;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="rust-async-的现状"&gt;Rust Async 的现状&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;Rust Async 的特点：
    &lt;ul&gt;
      &lt;li&gt;Futures是rust 内置的&lt;/li&gt;
      &lt;li&gt;Async是zero-cost 的，即： 并不需要 在堆上 进行内存分配 和动态分发，即高性能（you can use async without heap allocations and dynamic dispatch, which is great for performance!）&lt;/li&gt;
      &lt;li&gt;没有内建的runtime， 由社区提供&lt;/li&gt;
      &lt;li&gt;可以支持 单线程 或者 多线程 的runtime&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Rust Async vs threads 的比较
    &lt;ul&gt;
      &lt;li&gt;threads： 适合少量的工作， 不用改变代码结构， 生成 线程 与线程之间的切换 是非常昂贵的， 线程池可以一定程度上减轻此类开销&lt;/li&gt;
      &lt;li&gt;Async： 可以显著的减少CPU 与 内存的开销， 尤其是在对于 大量IO任务时。 比thread 模式能够处理更多的任务，因为 该模型，使用 较少的 threads 处理大量的 task。 但是其二进制的文件会比传统的非异步编码的代码要大。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;异步编程的支持：
    &lt;ul&gt;
      &lt;li&gt;标准库： 提供 Future trait 抽象&lt;/li&gt;
      &lt;li&gt;Rust Compiler： 提供对  async/await 语法的支持&lt;/li&gt;
      &lt;li&gt;futures crate： 提供 工具类型， macros， 以及 方法&lt;/li&gt;
      &lt;li&gt;async runtime： 提供对 async code, IO, task spawn 的运行。有 TOkio, async-std&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;编译 与  debug：
    &lt;ul&gt;
      &lt;li&gt;为了支持异步代码：  rust 需要使用异常一些更复杂的 语言特性， 比如lifetimes pinning。 你可能将经常遇到此类错误&lt;/li&gt;
      &lt;li&gt;runtime errors： 编译器 遇到 async function，将产生一个 状态机（state machine）， Stack traces 将包含状态机内部的详细信息， 对比 Rust 同步代码, runtime errors debug 要复杂不少&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;New failure modes： 异步Rust中可能会出现一些新颖的故障模式，例如，如果您从异步上下文中调用了阻止函数，或者您错误地实现了Future特性。 这样的错误可以无声地通过编译器，有时甚至可以通过单元测试。 本书旨在为您提供对底层概念的深刻理解，可以帮助您避免这些陷阱。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="rust-异步编程-简单示例"&gt;Rust 异步编程 简单示例：&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;async/.await 语法： rust compiler 为 async 声明的block转换成一个实现了 Future trait 的 state machine。 await 等待Future的完成， 但是将thread yield 出去以允许其他Future执行&lt;/li&gt;
  &lt;li&gt;block_on: 阻塞当前 thread，直到 future 完成， 不允许 thread 运行其他的 Future&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="c"&gt;// Cargo.toml&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;dependencies&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;futures&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"0.3"&lt;/span&gt;

&lt;span class="c"&gt;// main.rs&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;futures&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nn"&gt;executor&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;block_on&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;hello_world&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"hello, world!"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;future&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;hello_world&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c"&gt;// Nothing is printed&lt;/span&gt;
  &lt;span class="nf"&gt;block_on&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;future&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c"&gt;// `future` is run and "hello, world!" is printed&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="c"&gt;// await 示例： &lt;/span&gt;

&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;learn_song&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Song&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* ... */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;sing_song&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;song&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Song&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* ... */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;dance&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* ... */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="c"&gt;// 这里使用 block_on 导致  learn_song  aing_song dance 的 串行执行, 因为block_on 将阻塞thread，直到 Future 执行完成&lt;/span&gt;
&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;song&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;block_on&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;learn_song&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
  &lt;span class="nf"&gt;block_on&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sing_song&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;song&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
  &lt;span class="nf"&gt;block_on&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;dance&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;



&lt;span class="c"&gt;// 这里使用await 可以将 thread 让出，以便  Future f2 执行。 join 能够同时执行 两个 future&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;learn_and_sing&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="c"&gt;// Wait until the song has been learned before singing it.&lt;/span&gt;
  &lt;span class="c"&gt;// We use `.await` here rather than `block_on` to prevent blocking the // thread, which makes it possible to `dance` at the same time.&lt;/span&gt;
  &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;song&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;learn_song&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="nf"&gt;sing_song&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;song&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;async_main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;f1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;learn_and_sing&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; 
  &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;f2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;dance&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
  &lt;span class="c"&gt;// `join!` is like `.await` but can wait for multiple futures concurrently. &lt;/span&gt;
  &lt;span class="c"&gt;// If we're temporarily blocked in the `learn_and_sing` future, the `dance`&lt;/span&gt;
  &lt;span class="c"&gt;// future will take over the current thread. If `dance` becomes blocked, &lt;/span&gt;
  &lt;span class="c"&gt;// `learn_and_sing` can take back over. If both futures are blocked, then &lt;/span&gt;
  &lt;span class="c"&gt;// `async_main` is blocked and will yield to the executor. &lt;/span&gt;
  &lt;span class="nn"&gt;futures&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;join!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;f2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;



&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
  &lt;span class="nf"&gt;block_on&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async_main&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="future-trait-rust-异步编程的-核心点-future-即是一个可以产生-value-的异步计算抽象简单的-future-可以如下"&gt;Future Trait: rust 异步编程的 核心点， Future 即是一个可以产生 value 的异步计算抽象。简单的 Future 可以如下：&lt;/h4&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="k"&gt;trait&lt;/span&gt; &lt;span class="n"&gt;SimpleFuture&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;poll&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;wake&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Poll&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nn"&gt;Self&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;Poll&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nf"&gt;Ready&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="n"&gt;Pending&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;pub&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;SocketRead&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;'a&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nv"&gt;'a&lt;/span&gt; &lt;span class="n"&gt;Socket&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;SimpleFuture&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;SocketRead&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;'_&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="n"&gt;Output&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;Vec&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;u8&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;poll&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;wake&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Poll&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nn"&gt;Self&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="py"&gt;.socket&lt;/span&gt;&lt;span class="nf"&gt;.has_data_to_read&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="c"&gt;// The socket has data-- read it into a buffer and return it.&lt;/span&gt;
            &lt;span class="nn"&gt;Poll&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;Ready&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="py"&gt;.socket&lt;/span&gt;&lt;span class="nf"&gt;.read_buf&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="c"&gt;// The socket does not yet have data. //&lt;/span&gt;
            &lt;span class="c"&gt;// Arrange for `wake` to be called once data is available.&lt;/span&gt;
            &lt;span class="c"&gt;// When data becomes available, `wake` will be called, and the&lt;/span&gt;
            &lt;span class="c"&gt;// user of this `Future` will know to call `poll` again and&lt;/span&gt;
            &lt;span class="c"&gt;// receive data. self.socket.set_readable_callback(wake); Poll::Pending&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;poll func 为Future 接口， 如果future 完成  则返回 Poll::Ready(result), 否则 返回 Poll::Pending, 并在当 Future 可以取得进一步进展时 调用 wake() 函数， 当wake 函数调用， Future 的 executor 将再次 在future 调用poll 以取得进展&lt;/li&gt;
  &lt;li&gt;wake 的作用： 如果没有wake 则 executor 将没有任何知识 能够知道 一个特定的future 可以取得进展， 除非周期性的在 每个future 上进行poll。 wake的存在能够让 executor 知道 那个 future 需要被poll&lt;/li&gt;
  &lt;li&gt;Timer Future 的简单实现：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;
&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::{&lt;/span&gt;
    &lt;span class="nn"&gt;future&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Future&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nn"&gt;pin&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Pin&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nn"&gt;sync&lt;/span&gt;&lt;span class="p"&gt;::{&lt;/span&gt;&lt;span class="nb"&gt;Arc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Mutex&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="nn"&gt;task&lt;/span&gt;&lt;span class="p"&gt;::{&lt;/span&gt;&lt;span class="n"&gt;Context&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Poll&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Waker&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="n"&gt;thread&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nn"&gt;time&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Duration&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;


&lt;span class="k"&gt;pub&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;TimerFuture&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;shared_state&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;Arc&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Mutex&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;SharedState&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c"&gt;// 需要使用锁， 跨 thread 更改变量&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c"&gt;/// Shared state between the future and the waiting thread&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;SharedState&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c"&gt;/// Whether or not the sleep time has elapsed&lt;/span&gt;
    &lt;span class="n"&gt;completed&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;bool&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

    &lt;span class="c"&gt;// The waker for the task that `TimerFuture` is running on.&lt;/span&gt;
    &lt;span class="c"&gt;// The thread can use this after setting `completed = true` to tell&lt;/span&gt;
    &lt;span class="c"&gt;// `TimerFuture`'s task to wake up, see that `completed = true`, and&lt;/span&gt;
    &lt;span class="c"&gt;// move forward.&lt;/span&gt;
    &lt;span class="n"&gt;waker&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;Option&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Waker&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;Future&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;TimerFuture&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="n"&gt;Output&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="c"&gt;// 需要注意 这里面 self参数类型为Pin&amp;lt;&amp;amp;mut Self&amp;gt; 以及cx 为Context&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;poll&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Pin&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;Self&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cx&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;Context&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;'_&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Poll&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nn"&gt;Self&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c"&gt;// Look at the shared state to see if the timer has already completed.&lt;/span&gt;
        &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;shared_state&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="py"&gt;.shared_state&lt;/span&gt;&lt;span class="nf"&gt;.lock&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="nf"&gt;.unwrap&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;shared_state&lt;/span&gt;&lt;span class="py"&gt;.completed&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nn"&gt;Poll&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;Ready&lt;/span&gt;&lt;span class="p"&gt;(())&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="c"&gt;// Set waker so that the thread can wake up the current task&lt;/span&gt;
            &lt;span class="c"&gt;// when the timer has completed, ensuring that the future is polled&lt;/span&gt;
            &lt;span class="c"&gt;// again and sees that `completed = true`.&lt;/span&gt;
            &lt;span class="c"&gt;//&lt;/span&gt;
            &lt;span class="c"&gt;// It's tempting to do this once rather than repeatedly cloning&lt;/span&gt;
            &lt;span class="c"&gt;// the waker each time. However, the `TimerFuture` can move between&lt;/span&gt;
            &lt;span class="c"&gt;// tasks on the executor, which could cause a stale waker pointing&lt;/span&gt;
            &lt;span class="c"&gt;// to the wrong task, preventing `TimerFuture` from waking up&lt;/span&gt;
            &lt;span class="c"&gt;// correctly.&lt;/span&gt;
            &lt;span class="c"&gt;//&lt;/span&gt;
            &lt;span class="c"&gt;// N.B. it's possible to check for this using the `Waker::will_wake`&lt;/span&gt;
            &lt;span class="c"&gt;// function, but we omit that here to keep things simple.&lt;/span&gt;
            &lt;span class="n"&gt;shared_state&lt;/span&gt;&lt;span class="py"&gt;.waker&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;Some&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cx&lt;/span&gt;&lt;span class="nf"&gt;.waker&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="nf"&gt;.clone&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
            &lt;span class="nn"&gt;Poll&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Pending&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;TimerFuture&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c"&gt;// Create a new `TimerFuture` which will complete after the provided&lt;/span&gt;
    &lt;span class="c"&gt;// timeout.&lt;/span&gt;
    &lt;span class="k"&gt;pub&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;duration&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Duration&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Self&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;shared_state&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;Arc&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nn"&gt;Mutex&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SharedState&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;completed&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;false&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;waker&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="p"&gt;}));&lt;/span&gt;

        &lt;span class="c"&gt;// Spawn the new thread&lt;/span&gt;
        &lt;span class="c"&gt;// 这个 Future 实现的 比较奇怪，直接 使用另一个 thread 中sleep 进行 timer 的实现, 所以 在上面 TimerFuture 中的 Sharedstate 需要进行 Mutex 进行保护&lt;/span&gt;
        &lt;span class="c"&gt;// 这也是后面提到 Runtime  需要提供 Timer的 重要原因吧&lt;/span&gt;
        &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;thread_shared_state&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;shared_state&lt;/span&gt;&lt;span class="nf"&gt;.clone&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="nn"&gt;thread&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;spawn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;move&lt;/span&gt; &lt;span class="p"&gt;||&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nn"&gt;thread&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;duration&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;shared_state&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;thread_shared_state&lt;/span&gt;&lt;span class="nf"&gt;.lock&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="nf"&gt;.unwrap&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="c"&gt;// Signal that the timer has completed and wake up the last&lt;/span&gt;
            &lt;span class="c"&gt;// task on which the future was polled, if one exists.&lt;/span&gt;
            &lt;span class="n"&gt;shared_state&lt;/span&gt;&lt;span class="py"&gt;.completed&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="nf"&gt;Some&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;waker&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;shared_state&lt;/span&gt;&lt;span class="py"&gt;.waker&lt;/span&gt;&lt;span class="nf"&gt;.take&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;waker&lt;/span&gt;&lt;span class="nf"&gt;.wake&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;});&lt;/span&gt;

        &lt;span class="n"&gt;TimerFuture&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;shared_state&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="c"&gt;// Executor 的实现：&lt;/span&gt;

&lt;span class="c"&gt;/// Task executor that receives tasks off of a channel and runs them.&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Executor&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;ready_queue&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Receiver&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;Arc&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Task&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c"&gt;/// `Spawner` spawns new futures onto the task channel.&lt;/span&gt;
&lt;span class="nd"&gt;#[derive(Clone)]&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Spawner&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;task_sender&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;SyncSender&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;Arc&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Task&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c"&gt;/// A future that can reschedule itself to be polled by an `Executor`.&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Task&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c"&gt;/// In-progress future that should be pushed to completion.&lt;/span&gt;
    &lt;span class="c"&gt;///&lt;/span&gt;
    &lt;span class="c"&gt;/// The `Mutex` is not necessary for correctness, since we only have&lt;/span&gt;
    &lt;span class="c"&gt;/// one thread executing tasks at once. However, Rust isn't smart&lt;/span&gt;
    &lt;span class="c"&gt;/// enough to know that `future` is only mutated from one thread,&lt;/span&gt;
    &lt;span class="c"&gt;/// so we need to use the `Mutex` to prove thread-safety. A production&lt;/span&gt;
    &lt;span class="c"&gt;/// executor would not need this, and could use `UnsafeCell` instead.&lt;/span&gt;
    &lt;span class="n"&gt;future&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Mutex&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;Option&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;BoxFuture&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;'static&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

    &lt;span class="c"&gt;/// Handle to place the task itself back onto the task queue.&lt;/span&gt;
    &lt;span class="n"&gt;task_sender&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;SyncSender&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;Arc&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Task&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;new_executor_and_spawner&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Executor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Spawner&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c"&gt;// Maximum number of tasks to allow queueing in the channel at once.&lt;/span&gt;
    &lt;span class="c"&gt;// This is just to make `sync_channel` happy, and wouldn't be present in&lt;/span&gt;
    &lt;span class="c"&gt;// a real executor.&lt;/span&gt;
    &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;MAX_QUEUED_TASKS&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;usize&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10_000&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;task_sender&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ready_queue&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;sync_channel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MAX_QUEUED_TASKS&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Executor&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;ready_queue&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="n"&gt;Spawner&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;task_sender&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;Spawner&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;spawn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;future&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;Future&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Output&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nv"&gt;'static&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;Send&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;future&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;future&lt;/span&gt;&lt;span class="nf"&gt;.boxed&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;task&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;Arc&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Task&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;future&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nn"&gt;Mutex&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;Some&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;future&lt;/span&gt;&lt;span class="p"&gt;)),&lt;/span&gt;
            &lt;span class="n"&gt;task_sender&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="py"&gt;.task_sender&lt;/span&gt;&lt;span class="nf"&gt;.clone&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;
        &lt;span class="p"&gt;});&lt;/span&gt;
        &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="py"&gt;.task_sender&lt;/span&gt;&lt;span class="nf"&gt;.send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;.expect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"too many tasks queued"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;ArcWake&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;Task&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;wake_by_ref&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arc_self&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nb"&gt;Arc&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Self&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c"&gt;// Implement `wake` by sending this task back onto the task channel&lt;/span&gt;
        &lt;span class="c"&gt;// so that it will be polled again by the executor.&lt;/span&gt;
        &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;cloned&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arc_self&lt;/span&gt;&lt;span class="nf"&gt;.clone&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;arc_self&lt;/span&gt;
            &lt;span class="py"&gt;.task_sender&lt;/span&gt;
            &lt;span class="nf"&gt;.send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cloned&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="nf"&gt;.expect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"too many tasks queued"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;Executor&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;run&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="nf"&gt;Ok&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="py"&gt;.ready_queue&lt;/span&gt;&lt;span class="nf"&gt;.recv&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="c"&gt;// Take the future, and if it has not yet completed (is still Some),&lt;/span&gt;
            &lt;span class="c"&gt;// poll it in an attempt to complete it.&lt;/span&gt;
            &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;future_slot&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="py"&gt;.future&lt;/span&gt;&lt;span class="nf"&gt;.lock&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="nf"&gt;.unwrap&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="nf"&gt;Some&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;future&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;future_slot&lt;/span&gt;&lt;span class="nf"&gt;.take&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="c"&gt;// Create a `LocalWaker` from the task itself&lt;/span&gt;
                &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;waker&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;waker_ref&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="nn"&gt;Context&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;from_waker&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;*&lt;/span&gt;&lt;span class="n"&gt;waker&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="c"&gt;// `BoxFuture&amp;lt;T&amp;gt;` is a type alias for&lt;/span&gt;
                &lt;span class="c"&gt;// `Pin&amp;lt;Box&amp;lt;dyn Future&amp;lt;Output = T&amp;gt; + Send + 'static&amp;gt;&amp;gt;`.&lt;/span&gt;
                &lt;span class="c"&gt;// We can get a `Pin&amp;lt;&amp;amp;mut dyn Future + Send + 'static&amp;gt;`&lt;/span&gt;
                &lt;span class="c"&gt;// from it by calling the `Pin::as_mut` method.&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="nn"&gt;Poll&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Pending&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;future&lt;/span&gt;&lt;span class="nf"&gt;.as_mut&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="nf"&gt;.poll&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                    &lt;span class="c"&gt;// We're not done processing the future, so put it&lt;/span&gt;
                    &lt;span class="c"&gt;// back in its task to be run again in the future.&lt;/span&gt;
                    &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;future_slot&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;Some&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;future&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;



&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;executor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;spawner&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;new_executor_and_spawner&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="c"&gt;// Spawn a task to print before and after waiting on a timer.&lt;/span&gt;
    &lt;span class="n"&gt;spawner&lt;/span&gt;&lt;span class="nf"&gt;.spawn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"howdy!"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="c"&gt;// Wait for our timer future to complete after two seconds.&lt;/span&gt;
        &lt;span class="nn"&gt;TimerFuture&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nn"&gt;Duration&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"done!"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;});&lt;/span&gt;

    &lt;span class="c"&gt;// Drop the spawner so that our executor knows it is finished and won't&lt;/span&gt;
    &lt;span class="c"&gt;// receive more incoming tasks to run.&lt;/span&gt;
    &lt;span class="k"&gt;drop&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;spawner&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c"&gt;// Run the executor until the task queue is empty.&lt;/span&gt;
    &lt;span class="c"&gt;// This will print "howdy!", pause, and then print "done!".&lt;/span&gt;
    &lt;span class="n"&gt;executor&lt;/span&gt;&lt;span class="nf"&gt;.run&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="executors-and-system-io"&gt;Executors and System IO:&lt;/h3&gt;
&lt;h4 id="executor-谁来调用-future-的poll-方法-答案是-future-executor-executor-调用一大堆-futures-的poll方法-以便让future-取得进展-当-future-能够-取得进一步进展时通过调用wake-方法-以便-executor-再次执行-future"&gt;Executor： 谁来调用 Future 的poll 方法？ 答案是 Future Executor。 executor 调用一大堆 Futures 的poll方法 以便让Future 取得进展， 当 Future 能够 取得进一步进展时，通过调用wake 方法， 以便 executor 再次执行 Future。&lt;/h4&gt;
&lt;h4 id="system-io-在上面的-simplefuture-代码中-谁来执行-wake-方法呢-selfsocketset_readable_callbackwake-又是如何处罚呢-答案是-epoll-的io多路复用可以让我们-使用thread-对-socket文件进行-监听循环检测-io-事件"&gt;System IO: 在上面的 SimpleFuture 代码中， 谁来执行 wake 方法呢？ self.socket.set_readable_callback(wake) 又是如何处罚呢？ 答案是 epoll 的IO多路复用，可以让我们 使用thread 对 socket文件进行 监听，循环检测 IO 事件。&lt;/h4&gt;
&lt;h4 id="executors-单线程-与-多线程"&gt;Executors: 单线程 与 多线程&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;多线程执行程序可同时在多个任务上取得进展。 对于具有许多任务的工作负载，它可以极大地加快执行速度，但是在任务之间同步数据通常会更加昂贵。 在单线程和多线程运行时之间进行选择时，建议测量应用程序的性能。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;任务可以在创建任务的线程上运行，也可以在单独的线程上运行。 异步运行时通常提供将任务生成到单独线程上的功能。 即使任务在单独的线程上执行，它们也应该是非阻塞的。 为了在多线程执行器上安排任务，它们也必须是Send。 一些运行时提供了生成非发送任务的功能，以确保每个任务都在生成它的线程上执行。 它们还可以提供用于将阻塞任务生成到专用线程上的功能，这对于从其他库运行阻塞同步代码很有用。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;async Lifetimes， async move， 因为异步的存在， 导致 async { /../ } 可以 传递给变量 并进行 .await， 导致  block {} 中 的包含的变量，以及 引用 需要与 Future 存在的周期相同。 async move 允许 like normal block 一样， 允许将 block中变量 移入到 block中， 并跟随 Future 一样的生命周期&lt;/li&gt;
  &lt;li&gt;当使用 多线程的 executor时， Future 可能在 threads 中进行移动，所以 在async block中的 any variables 必须同样能够在 threads中进行移动， 意味着  任何没有实现 &lt;a href="https://doc.rust-lang.org/std/marker/trait.Send.html"&gt;Send trait&lt;/a&gt;、reference type 没有 实现 &lt;a href="https://doc.rust-lang.org/std/marker/trait.Sync.html"&gt;Sync trait&lt;/a&gt; 的都不能够 在async block中使用。&lt;/li&gt;
  &lt;li&gt;锁：不能使用 传统的 non-futures-aware lock, 因为Future 可能在threads 中进行移动 从而导致死锁，应该使用  futures::lock 中的Mutex&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="工具以及-trait"&gt;工具以及 trait:&lt;/h3&gt;

&lt;h4 id="pin"&gt;Pin:&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Pin： maker， 保证 对象 implement !Unpin 永远不会被移动。因为比较难以理解， 下面为英文：&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;The Pin type wraps pointer types, guaranteeing that the values behind the pointer won’t be moved. For example, Pin&amp;lt;&amp;amp;mut T&amp;gt; , Pin&amp;lt;&amp;amp;T&amp;gt; , Pin&amp;lt;Box&lt;T&gt;&amp;gt; all guarantee that T won't be moved if T: !Unpin .
Most types don't have a problem being moved. These types implement a trait called Unpin . Pointers to Unpin types can be freely placed into or taken out of Pin . For example, u8 is
Unpin , so Pin&amp;lt;&amp;amp;mut u8&amp;gt; behaves just like a normal &amp;amp;mut u8 .
However, types that can't be moved after they're pinned have a marker called !Unpin .
Futures created by async/await is an example of this.&lt;/T&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Pinning: 大概的以为是 是一个编译器 标记（marker） 用来保证 impl  !Unpin 的对象 在内存中 不被移动，即pin:&lt;/li&gt;
  &lt;li&gt;Pin Summary:
    &lt;ol&gt;
      &lt;li&gt;If T: Unpin (which is the default), then Pin&amp;lt;’a, T&amp;gt; is entirely equivalent to &amp;amp;’a mut T. in other words: Unpin means it’s OK for this type to be moved even when pinned, so Pin will have no effect on such a type.&lt;/li&gt;
      &lt;li&gt;Getting a &amp;amp;mut T to a pinned T requires unsafe if T: !Unpin.&lt;/li&gt;
      &lt;li&gt;Most standard library types implement Unpin. The same goes for most “normal” types you encounter in Rust. A Future generated by async/await is an exception to this rule.&lt;/li&gt;
      &lt;li&gt;You can add a !Unpin bound on a type on nightly with a feature flag, or by adding std::marker::PhantomPinned to your type on stable.&lt;/li&gt;
      &lt;li&gt;You can either pin data to the stack or to the heap.&lt;/li&gt;
      &lt;li&gt;Pinning a !Unpin object to the stack requires unsafe&lt;/li&gt;
      &lt;li&gt;Pinning a !Unpin object to the heap does not require unsafe. There is a shortcut for doing this using Box::pin.&lt;/li&gt;
      &lt;li&gt;For pinned data where T: !Unpin you have to maintain the invariant that its memory will not get invalidated or repurposed from the moment it gets pinned until when drop is called. This is an important part of the pin contract.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="stream-trait-like-future-但是能够-在完成之前-传递多个数值-like-iterator即-返回对象为---polloptionselfitem--stream-可以实现并行函数有-for_each_concurrent-try_for_each_concurrent"&gt;Stream Trait: like Future 但是能够 在完成之前 传递多个数值 like Iterator，即： 返回对象为   Poll&amp;lt;Option&amp;lt;Self::Item&amp;gt; &amp;gt;。 stream 可以实现并行，函数有 for_each_concurrent， try_for_each_concurrent&lt;/h4&gt;
&lt;h4 id="多个future-同时执行"&gt;多个Future 同时执行:&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;工具方法:
    &lt;ol&gt;
      &lt;li&gt;join! : waits for futures to all complete&lt;/li&gt;
      &lt;li&gt;select! : waits for one of several futures to complete&lt;/li&gt;
      &lt;li&gt;Spawning: creates a top-level task which ambiently runs a future to completion&lt;/li&gt;
      &lt;li&gt;FuturesUnordered : a group of futures which yields the result of each subfuture&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;join! 示例代码: try_join!  在其中一个 Future 返回错误的时候，立即返回&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="c"&gt;// book 与 music 串行执行， music 等待book 执行完 才能执行&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;get_book_and_music&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Book&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Music&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;book&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;get_book&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;music&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;get_music&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;book&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;music&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c"&gt;// 错误的尝试，将 book 与 music 并行执行&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;get_book_and_music&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Book&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Music&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;book_future&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;get_book&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;music_future&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;get_music&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;book_future&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;music_future&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c"&gt;// 真正的并行执行&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;get_book_and_music&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Book&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Music&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;book_fut&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;get_book&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;music_fut&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;get_music&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="nd"&gt;join!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;book_fut&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;music_fut&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;select! 示例代码： select macro 的使用风格比较奇怪， 需要在深入理解一下&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;
&lt;span class="nd"&gt;#![allow(unused)]&lt;/span&gt;
&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;futures&lt;/span&gt;&lt;span class="p"&gt;::{&lt;/span&gt;
    &lt;span class="nn"&gt;future&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;FutureExt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c"&gt;// for `.fuse()`&lt;/span&gt;
    &lt;span class="n"&gt;pin_mut&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;select&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;task_one&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* ... */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;task_two&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* ... */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;race_tasks&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;task_one&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="nf"&gt;.fuse&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;t2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;task_two&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="nf"&gt;.fuse&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="nd"&gt;pin_mut!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;t2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="nd"&gt;select!&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"task one completed first"&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;t2&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"task two completed first"&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;Unpin ： Unpin 是必须的， 因为在 select 中 数值是使用mut reference，而非take ownership 的， 没有完成的future 依然可以在后面的select 中使用。&lt;/li&gt;
  &lt;li&gt;FusedFuture: 同样是必须的， 因为 select 中 必须 not poll 已经完成的Future， FusedFuture 实现了 跟踪 Future 是否已经完成，&lt;/li&gt;
  &lt;li&gt;这两个 trait 能够让 select 在 loop block 中使用。 如下代码示例：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="nd"&gt;#![allow(unused)]&lt;/span&gt;
&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;futures&lt;/span&gt;&lt;span class="p"&gt;::{&lt;/span&gt;&lt;span class="n"&gt;future&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;select&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;count&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;a_fut&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;future&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;ready&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;b_fut&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;future&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;ready&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;total&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nd"&gt;select!&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a_fut&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;total&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b_fut&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;total&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;complete&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;default&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;unreachable!&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="c"&gt;// never runs (futures are ready, then complete)&lt;/span&gt;
        &lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nd"&gt;assert_eq!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;total&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="async-blocks-编码存在的一些问题"&gt;Async Blocks 编码存在的一些问题:&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;？: 在 async block 中  使用 ? 需要  额外的 声明 Error type 来帮助 编译器确定 错误类型， 如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="c"&gt;// 产生 编译错误&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;fut&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nf"&gt;Ok&lt;/span&gt;&lt;span class="p"&gt;(())&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="c"&gt;// 正确的解决方法&lt;/span&gt;
&lt;span class="nd"&gt;#![allow(unused)]&lt;/span&gt;
&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;MyError&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Result&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;MyError&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nf"&gt;Ok&lt;/span&gt;&lt;span class="p"&gt;(())&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Result&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;MyError&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nf"&gt;Ok&lt;/span&gt;&lt;span class="p"&gt;(())&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;fut&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nn"&gt;Ok&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;MyError&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(())&lt;/span&gt; &lt;span class="c"&gt;// &amp;lt;- note the explicit type annotation here&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;Future 是否 能够 send： 有些Future state machines 可以安全地被send, 而有些则不能。 是否Future 可以被 send 取决于是否在.await点上保留 non-send type。 当可能在.await点上保留值时，编译器会尽力进行近似，但是编译器的分析在许多地方都过于保守。 如下面代码示例：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="c"&gt;// 通过编译&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nn"&gt;rc&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nb"&gt;Rc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nd"&gt;#[derive(Default)]&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nf"&gt;NotSend&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;Rc&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nn"&gt;NotSend&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;default&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;require_send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;_&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="nb"&gt;Send&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nf"&gt;require_send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c"&gt;// 产生编译错误&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nn"&gt;rc&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nb"&gt;Rc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nd"&gt;#[derive(Default)]&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nf"&gt;NotSend&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;Rc&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;NotSend&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;default&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;require_send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;_&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="nb"&gt;Send&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="nf"&gt;require_send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="c"&gt;// 正确的解决方法&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nn"&gt;rc&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nb"&gt;Rc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nd"&gt;#[derive(Default)]&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nf"&gt;NotSend&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;Rc&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;NotSend&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;default&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;require_send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;_&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="nb"&gt;Send&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="nf"&gt;require_send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;递归问题： 因async fn 内部的状态机 实现导致 递归的使用 需要 额外 解决方案. 如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="c"&gt;// This function:&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nf"&gt;step_one&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nf"&gt;step_two&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c"&gt;// generates a type like this:&lt;/span&gt;
&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;Foo&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nf"&gt;First&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;StepOne&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="nf"&gt;Second&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;StepTwo&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c"&gt;// So this function:&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;recursive&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nf"&gt;recursive&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nf"&gt;recursive&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c"&gt;// generates a type like this:  因为类型对象存在递归，导致 无法通过编译，需要通过 Box 进行封装 来进行规避&lt;/span&gt;
&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;Recursive&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nf"&gt;First&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Recursive&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="nf"&gt;Second&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Recursive&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c"&gt;// --------------------&lt;/span&gt;
&lt;span class="c"&gt;// In order to allow this, we have to introduce an indirection using Box. Unfortunately, compiler limitations mean that just wrapping the calls to recursive() in Box::pin isn't enough. To make this work, we have to make recursive into a non-async function which returns a .boxed() async block:&lt;/span&gt;

&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;futures&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nn"&gt;future&lt;/span&gt;&lt;span class="p"&gt;::{&lt;/span&gt;&lt;span class="n"&gt;BoxFuture&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;FutureExt&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;recursive&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;BoxFuture&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;'static&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;move&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nf"&gt;recursive&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="nf"&gt;recursive&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="nf"&gt;.boxed&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="async-生态"&gt;Async 生态:&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Async Runtimes = reactor + one or more executors&lt;/li&gt;
  &lt;li&gt;Reactors： 提供对于 外部事件 比如: 异步IO 进程内通讯 timer 等 简单的订阅方式 (provide subscription mechanisms for external events, like async I/O, interprocess communication, and timers. In an async runtime, subscribers are typically futures representing low-level I/O operations)&lt;/li&gt;
  &lt;li&gt;Executors: Future 具体的执行者， 因为只有 thread ，process 才能够执行代码，所以Future等 抽象事物，依然需要具体的executor  (handle the scheduling and execution of tasks. They keep track of running and suspended tasks, poll futures to completion, and wake tasks when they can make progress)&lt;/li&gt;
  &lt;li&gt;Futures Crate： 包含 async code 有用的trait 与 函数， 包含trait有： Stream, Sink, AsyncRead, AsyncWrite  , 工具有： join! select! etc （这些可能将成为 标准库 的一部分） future 实现了自己的 executor， 但是并没有 reactor。 所以一个常见的组合是： Future 的工具 + 其他crate 的executor&lt;/li&gt;
  &lt;li&gt;常见的 Async runtime:
    &lt;ul&gt;
      &lt;li&gt;Tokio: A popular async ecosystem with HTTP, gRPC, and tracing frameworks. async-std: A crate that provides asynchronous counterparts to standard library components.&lt;/li&gt;
      &lt;li&gt;smol: A small, simplified async runtime. Provides the Async trait that can be used to wrap structs like*  UnixStream or TcpListener&lt;/li&gt;
      &lt;li&gt;fuchsia-async: An executor for use in the Fuchsia OS.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="相关资料"&gt;相关资料：&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Event-driven programming（事件驱动 模型， rust future 就是此类模型 ） https://en.wikipedia.org/wiki/Event-driven_programming&lt;/li&gt;
  &lt;li&gt;event driven  同样存在多种形式， refactor  pattern &amp;amp; https://en.wikipedia.org/wiki/Proactor_pattern&lt;/li&gt;
  &lt;li&gt;相关资料： 有： http://www.alan-g.me.uk/l2p/tutevent.htm http://www.dre.vanderbilt.edu/~schmidt/PDF/reactor-siemens.pdf  https://altushost-swe.dl.sourceforge.net/project/eventdrivenpgm/event_driven_programming.pdf&lt;/li&gt;
  &lt;li&gt;在rust 的 async program 中： 主要有  rust async 的语法支持， 社区提供的 future 模型， 以及 对应 runtime executor 实现，则有： async-std, tokio， smol， fuchsia-async。 future 的抽象只有一种，而对应的 runtime executor 因为 与 操作系统 生态有关，则有多种的实现&lt;/li&gt;
  &lt;li&gt;Coroutines （协程， 即是语言在 OS上 对于 轻量线程的抽象， 在 《现代操作系统》 中 有详细介绍过此类模型，但是因为其 一些根源性问题， 对于系统信号、调度等并不友好）&lt;/li&gt;
  &lt;li&gt;The actor model: 将单元划分为 actor， 使用消息进行 通讯， Erlang 是典型的 actor并发代表&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>Mysql</title>
    <link rel="alternate" href="http://geniousbar.github.io/2021/04/11/mysql-relearn/"/>
    <id>http://geniousbar.github.io/2021/04/11/mysql-relearn/</id>
    <published>2021-04-11T00:00:00+00:00</published>
    <updated>2021-04-22T02:50:09+00:00</updated>
    <summary type="html">&lt;h2 id="mysql-relearn"&gt;Mysql Relearn&lt;/h2&gt;
&lt;h3 id="内存模型"&gt;内存模型：&lt;/h3&gt;
&lt;p&gt;&lt;img src="../../../../images/innodb-change-buffer-5fbd1a84.png" alt="memory-cache"&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Change BUffer： 缓存 不在Buffer pool 中的 索引页的变动， 变动 可能由 insert update， delete 等操作 导致， 将在以后 页面 被加载到 Buffer pool时 被合并
    &lt;ul&gt;
      &lt;li&gt;[image]&lt;/li&gt;
      &lt;li&gt;不同于 聚簇索引， 普通的索引 通常是不唯一的，索引 的插入 删除 更新 通常是 random 的， 随后 将 change Buffer 的合并到 Buffer pool（当...&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    <content type="html">&lt;h2 id="mysql-relearn"&gt;Mysql Relearn&lt;/h2&gt;
&lt;h3 id="内存模型"&gt;内存模型：&lt;/h3&gt;
&lt;p&gt;&lt;img src="../../../../images/innodb-change-buffer-5fbd1a84.png" alt="memory-cache" /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Change BUffer： 缓存 不在Buffer pool 中的 索引页的变动， 变动 可能由 insert update， delete 等操作 导致， 将在以后 页面 被加载到 Buffer pool时 被合并
    &lt;ul&gt;
      &lt;li&gt;[image]&lt;/li&gt;
      &lt;li&gt;不同于 聚簇索引， 普通的索引 通常是不唯一的，索引 的插入 删除 更新 通常是 random 的， 随后 将 change Buffer 的合并到 Buffer pool（当索引页被load 到 buffer pool时） 将减少 随机 的IO 操作。&lt;/li&gt;
      &lt;li&gt;当系统 空闲时，或者缓慢关闭时 会定时的进行清理操作（将cache 写回到 硬盘中） 清理操作 将 一系列的 索引更新 写入到磁盘中 的速度 远高于 每个更新立即写入&lt;/li&gt;
      &lt;li&gt;当存在大量的 受影响的row 和 众多的 索引时， change Buffer 的合并（这里的合并 应该不是简单的与 Buffer pool的合并，而是 合并之后，需要写回到 硬盘中吧） 可能 需要数个小时， 在这期间， IO将显著增加， 导致 磁盘绑定查询（意思是 需要 访问硬盘？） 的速度显著变慢，&lt;/li&gt;
      &lt;li&gt;在Memory中， change buff 是Buffer pool 的一部分， 在disk上， change buff 是 system tablespace 的一部分（当服务器关闭是， 索引的更改change buff 可能保存其中）&lt;/li&gt;
      &lt;li&gt;配置：
        &lt;ol&gt;
          &lt;li&gt;innodb_change_buffering 因为 change buffer 虽然能够 减少IO操作，但 依然占用了 部分的 Buffer pool, 所以提供了此变量 来精确的控制 insert， delete， purge（physical deletion happen in background）， changes(insert + delete) 操作 是否使用  change buffer&lt;/li&gt;
          &lt;li&gt;innodb_change_buffer_max_size 可以控制 buffer的大小，数值为 其所占 Buffer pool 的百分比， 默认为 25，最高 为 50&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;Monitor：
        &lt;ul&gt;
          &lt;li&gt;show engine Innodb status 中的 INSERT BUFFER AND ADAPTIVE HASH INDEX 段&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;  -------------------------------------
  INSERT BUFFER AND ADAPTIVE HASH INDEX
  -------------------------------------
  Ibuf: size 1, free list len 0, seg size 2, 0 merges
  merged operations:
   insert 0, delete mark 0, delete 0
  discarded operations:
   insert 0, delete mark 0, delete 0
  Hash table size 4425293, used cells 32, node heap has 1 buffer(s)
  13577.57 hash searches/s, 202.47 non-hash searches/s

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;ul&gt;
      &lt;li&gt;数据库方式： information_schema 中 相关的table 可以查询到相关信息 &lt;a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-change-buffer.html#innodb-change-buffer-maximum-size"&gt;url&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="自适应hash-索引"&gt;自适应Hash 索引：&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Hash 索引： 通过 索引 的前缀 构建 hash 的 key， 通过监控到的搜索， 如果InnoDB 认为可以 让查询从 简历Hash索引中 收益， 他会自动构建。&lt;/li&gt;
  &lt;li&gt;在一些负载比较繁重的情况下， 导致 监控 争用 Hash索引 的开销 并不能够 使其 受益，则可以选择关闭 该选项， 以为很难判定 这种情况的出现， 则 应该使用 准确的基准测试 之后来决定&lt;/li&gt;
  &lt;li&gt;自适应 Hash索引： 已经实现了 分区(partition)， 每个索引都绑定到特定的分区（并不知道有啥用,这里要讲啥?） 分区数量由 innodb_adaptive_hash_index_parts  控制，在 8…512 范围内&lt;/li&gt;
  &lt;li&gt;可以 在 show engine innodb  status 中的  SEMAPHORES 段 来查看 btr0sea.c 的rw 锁 争用情况， 可以考虑增加 Hash索引的分区数值，或者关闭 该功能&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="log-buffer"&gt;Log Buffer:&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Log buffer 用来缓存 将要写入 disk 的 log file的数据，&lt;/li&gt;
  &lt;li&gt;配置：
    &lt;ol&gt;
      &lt;li&gt;innodb_log_buffer_size  用来控制Buffer 的大小， default is 16MB, 定期 刷新到 disk, 一个大 的 log buffer 可以让一个 da的 transaction 在commit 提交前 不需要将 redo log 刷新到disk 中。&lt;/li&gt;
      &lt;li&gt;innodb_flush_log_at_trx_commit  控制 log buffer 而如何 同步到disk中&lt;/li&gt;
      &lt;li&gt;innodb_flush_log_at_timeout： 控制log buffer 同步的频率&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="innodb-磁盘数据结构"&gt;InnoDB 磁盘数据结构：&lt;/h3&gt;

&lt;h4 id="table"&gt;Table&lt;/h4&gt;
&lt;h4 id="创建表-create-table"&gt;创建表： create table,&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt;   &lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;TABLE&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="nb"&gt;INT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="nb"&gt;CHAR&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="k"&gt;PRIMARY&lt;/span&gt; &lt;span class="k"&gt;KEY&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="n"&gt;ENGINE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;Innodb 默认 table 的存储方式 为一个 文件 一个table， 配置 innodb_file_per_table 用来打开、关闭 此行为
    &lt;h4 id="row-format"&gt;Row format：&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;row 的格式，决定了 InnoDB 行 在物理上的disk 的存储，支持 4中format， 每个格式 都有对应的存储特性。格式有：
    &lt;ul&gt;
      &lt;li&gt;redundant： 冗余&lt;/li&gt;
      &lt;li&gt;compact： 紧凑&lt;/li&gt;
      &lt;li&gt;dynamic： 动态&lt;/li&gt;
      &lt;li&gt;compressed： 压缩&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;row 格式控制： 默认为 dynamic， 变量 innodb_default_row_format 可以控制 默认的row 存储格式， create table, alter table 也同样可以控制 row 格式&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="primary-key"&gt;Primary key&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;建议 为每个table 创建自己的 primary key, 选取 primary key 的column 规则为：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;重要查询所使用&lt;/li&gt;
      &lt;li&gt;永远不会存储空&lt;/li&gt;
      &lt;li&gt;永远不会存储重复数值&lt;/li&gt;
      &lt;li&gt;插入之后 很少更新的数值&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;如果没有 明显的选择的话， 则 可以创建一个 type 为number auto-increment 的column 作为主建&lt;/li&gt;
  &lt;li&gt;尽管在没有定义主键的情况下表可以正常工作，但是主键涉及性能的许多方面，并且对于任何大型或经常使用的表都是至关重要的设计方面。 建议始终在CREATE TABLE语句中指定主键&lt;/li&gt;
  &lt;li&gt;查看table的相关的属性：
    &lt;ol&gt;
      &lt;li&gt;SHOW TABLE STATUS&lt;/li&gt;
    &lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt;   &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;SHOW&lt;/span&gt; &lt;span class="k"&gt;TABLE&lt;/span&gt; &lt;span class="n"&gt;STATUS&lt;/span&gt; &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt; &lt;span class="k"&gt;LIKE&lt;/span&gt; &lt;span class="s1"&gt;'t%'&lt;/span&gt; &lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="k"&gt;G&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="o"&gt;***************************&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="k"&gt;row&lt;/span&gt; &lt;span class="o"&gt;***************************&lt;/span&gt;
              &lt;span class="n"&gt;Name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt;
            &lt;span class="n"&gt;Engine&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt;
           &lt;span class="k"&gt;Version&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
        &lt;span class="n"&gt;Row_format&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;Dynamic&lt;/span&gt;
              &lt;span class="k"&gt;Rows&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="n"&gt;Avg_row_length&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
       &lt;span class="n"&gt;Data_length&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;16384&lt;/span&gt;
   &lt;span class="n"&gt;Max_data_length&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
      &lt;span class="n"&gt;Index_length&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
         &lt;span class="n"&gt;Data_free&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="n"&gt;Auto_increment&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;NULL&lt;/span&gt;
       &lt;span class="n"&gt;Create_time&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2021&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;02&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;18&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;18&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;28&lt;/span&gt;
       &lt;span class="n"&gt;Update_time&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;NULL&lt;/span&gt;
        &lt;span class="n"&gt;Check_time&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;NULL&lt;/span&gt;
         &lt;span class="k"&gt;Collation&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;utf8mb4_0900_ai_ci&lt;/span&gt;
          &lt;span class="n"&gt;Checksum&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;NULL&lt;/span&gt;
    &lt;span class="n"&gt;Create_options&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; 
           &lt;span class="k"&gt;Comment&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;从 INFORMATION_SCHEMA.INNODB_TABLES 中获取信息:&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt;
  &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;INFORMATION_SCHEMA&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;INNODB_TABLES&lt;/span&gt; &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;NAME&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'test/t1'&lt;/span&gt; &lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="k"&gt;G&lt;/span&gt;
 &lt;span class="o"&gt;***************************&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="k"&gt;row&lt;/span&gt; &lt;span class="o"&gt;***************************&lt;/span&gt;
      &lt;span class="n"&gt;TABLE_ID&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1144&lt;/span&gt;
          &lt;span class="n"&gt;NAME&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;t1&lt;/span&gt;
          &lt;span class="n"&gt;FLAG&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;33&lt;/span&gt;
        &lt;span class="n"&gt;N_COLS&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;
         &lt;span class="k"&gt;SPACE&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;
    &lt;span class="n"&gt;ROW_FORMAT&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;Dynamic&lt;/span&gt;
 &lt;span class="n"&gt;ZIP_PAGE_SIZE&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="n"&gt;SPACE_TYPE&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Single&lt;/span&gt;
  &lt;span class="n"&gt;INSTANT_COLS&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="在其他目录中存储-数据即-外部创建表"&gt;在其他目录中存储 数据：（即 外部创建表）&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Using the DATA DIRECTORY Clause： 在 create table syntax 中 可以 添加  DATA DIRECTORY 来制定数据的存储目录&lt;/li&gt;
  &lt;li&gt;Using TABLESPACE Clause: 在create table syntax 中添加 TABLESPACE = innodb_file_per_table 配合 data dictory 使用&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;示例：&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt;&lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;USE&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;Database&lt;/span&gt; &lt;span class="n"&gt;changed&lt;/span&gt;

&lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;TABLE&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c1&lt;/span&gt; &lt;span class="nb"&gt;INT&lt;/span&gt; &lt;span class="k"&gt;PRIMARY&lt;/span&gt; &lt;span class="k"&gt;KEY&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;DATA&lt;/span&gt; &lt;span class="n"&gt;DIRECTORY&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'/external/directory'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="n"&gt;MySQL&lt;/span&gt; &lt;span class="n"&gt;creates&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="k"&gt;table&lt;/span&gt;&lt;span class="s1"&gt;'s data file in a schema directory
# under the external directory

shell&amp;gt; cd /external/directory/test
shell&amp;gt; ls
t1.ibd
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="导入-innodb-表"&gt;导入 InnoDB 表：&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;可能应用的场景有：
    &lt;ol&gt;
      &lt;li&gt;利用 线上 的数据做报表，而不像 增加额外的负担 在线上 2） 复制数据给 replica server 3） 从backup 上恢复 表 4）&lt;/li&gt;
      &lt;li&gt;比import a dump file 更快的 移动数据 的方法&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;先决条件
    &lt;ol&gt;
      &lt;li&gt;innodb_file_per_table  变量 必须是打开的&lt;/li&gt;
      &lt;li&gt;source server &amp;amp; desitnation server  的 page size of tablespace 配置必须相同，  innodb_page_size  变量控制&lt;/li&gt;
      &lt;li&gt;foreign key 的关系， 如果 导出表 有 foreign key，  在 执行 discard talbespace 之前， 则 需要 foreign_key_checks 需要关闭， 还需要导出所有外键 关联的表，因为ALTER TABLE … IMPORT TABLESPACE不会对导入的数据实施外键约束。 为此 需要 停止更新 相关的表， 提交所有 transaction， 获取表 的 S锁，然后执行 export 操作&lt;/li&gt;
      &lt;li&gt;导出导入 的mysql version  必须兼容&lt;/li&gt;
      &lt;li&gt;导出导入server 的 data directory 必须 相同, 导致 schema mismatch error&lt;/li&gt;
      &lt;li&gt;导出导入server 的 ROW_FORMAT 需要相同, 导致 schema mismatch errorgg&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;示例
    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;在 destination server 上 创建表， schema 需要与 source server 表的 syntax 相同&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt; &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;USE&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;TABLE&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c1&lt;/span&gt; &lt;span class="nb"&gt;INT&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;ENGINE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;INNODB&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;      &lt;/li&gt;
      &lt;li&gt;在destination server 上， 执行 discard tablespace 命令
        &lt;ul&gt;
          &lt;li&gt;table 将会 上 X 锁&lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;tablespace 与table 分离&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt; &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;ALTER&lt;/span&gt; &lt;span class="k"&gt;TABLE&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="n"&gt;DISCARD&lt;/span&gt; &lt;span class="n"&gt;TABLESPACE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;在source server 上 执行 flush tables … for export， 执行之后 只能允许 读表请求， 将产生 .cfg, .ibd文件
        &lt;ul&gt;
          &lt;li&gt;导出的table 将会上S锁， 并将更新 flush 到disk&lt;/li&gt;
          &lt;li&gt;停止 purge thread&lt;/li&gt;
          &lt;li&gt;Dirty page sync to disk&lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;table metadata write to .cfg file&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt; &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;USE&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;FLUSH&lt;/span&gt; &lt;span class="n"&gt;TABLES&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="k"&gt;FOR&lt;/span&gt; &lt;span class="n"&gt;EXPORT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

 &lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="err"&gt;可能看到的&lt;/span&gt; &lt;span class="err"&gt;输出为&lt;/span&gt;
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Note&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Sync&lt;/span&gt; &lt;span class="k"&gt;to&lt;/span&gt; &lt;span class="n"&gt;disk&lt;/span&gt; &lt;span class="k"&gt;of&lt;/span&gt; &lt;span class="s1"&gt;'"test"."t1"'&lt;/span&gt; &lt;span class="n"&gt;started&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Note&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Stopping&lt;/span&gt; &lt;span class="n"&gt;purge&lt;/span&gt;
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Note&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Writing&lt;/span&gt; &lt;span class="k"&gt;table&lt;/span&gt; &lt;span class="n"&gt;metadata&lt;/span&gt; &lt;span class="k"&gt;to&lt;/span&gt; &lt;span class="s1"&gt;'./test/t1.cfg'&lt;/span&gt;
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Note&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;Table&lt;/span&gt; &lt;span class="s1"&gt;'"test"."t1"'&lt;/span&gt; &lt;span class="n"&gt;flushed&lt;/span&gt; &lt;span class="k"&gt;to&lt;/span&gt; &lt;span class="n"&gt;disk&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;复制数据：&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt; &lt;span class="n"&gt;shell&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;scp&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="k"&gt;to&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;datadir&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="n"&gt;ibd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;cfg&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt; &lt;span class="n"&gt;destination&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="k"&gt;to&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;datadir&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;      &lt;/li&gt;
      &lt;li&gt;在 source server 上执行 unlock tables
        &lt;ul&gt;
          &lt;li&gt;删除 .cfg 文件&lt;/li&gt;
          &lt;li&gt;table上的S锁 被释放&lt;/li&gt;
          &lt;li&gt;purge thread 被重启&lt;/li&gt;
        &lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt;  &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;USE&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;UNLOCK&lt;/span&gt; &lt;span class="n"&gt;TABLES&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="err"&gt;可能的输出&lt;/span&gt;&lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="err"&gt;为&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Note&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Deleting&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;meta&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;data&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="s1"&gt;'./test/t1.cfg'&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Note&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Resuming&lt;/span&gt; &lt;span class="n"&gt;purge&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
      &lt;li&gt;在 destination server 上import tablespace
        &lt;ul&gt;
          &lt;li&gt;每个 tablespace page 会被 校验是否正确&lt;/li&gt;
          &lt;li&gt;The space ID and log sequence numbers (LSNs) on each page are updated.&lt;/li&gt;
          &lt;li&gt;Flags are validated and LSN updated for the header page.&lt;/li&gt;
          &lt;li&gt;Btree pages are updated.&lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;The page state is set to dirty so that it is written to disk.&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt; &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;USE&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;ALTER&lt;/span&gt; &lt;span class="k"&gt;TABLE&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="n"&gt;IMPORT&lt;/span&gt; &lt;span class="n"&gt;TABLESPACE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

 &lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="err"&gt;可能输出&lt;/span&gt; &lt;span class="n"&gt;log&lt;/span&gt; &lt;span class="err"&gt;为：&lt;/span&gt;

 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Note&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Importing&lt;/span&gt; &lt;span class="n"&gt;tablespace&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="k"&gt;table&lt;/span&gt; &lt;span class="s1"&gt;'test/t1'&lt;/span&gt; &lt;span class="n"&gt;that&lt;/span&gt; &lt;span class="n"&gt;was&lt;/span&gt; &lt;span class="n"&gt;exported&lt;/span&gt;
 &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="k"&gt;host&lt;/span&gt; &lt;span class="s1"&gt;'host_name'&lt;/span&gt;
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Note&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Phase&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="k"&gt;Update&lt;/span&gt; &lt;span class="k"&gt;all&lt;/span&gt; &lt;span class="n"&gt;pages&lt;/span&gt;
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Note&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Sync&lt;/span&gt; &lt;span class="k"&gt;to&lt;/span&gt; &lt;span class="n"&gt;disk&lt;/span&gt;
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Note&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Sync&lt;/span&gt; &lt;span class="k"&gt;to&lt;/span&gt; &lt;span class="n"&gt;disk&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;done&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Note&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Phase&lt;/span&gt; &lt;span class="n"&gt;III&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;Flush&lt;/span&gt; &lt;span class="n"&gt;changes&lt;/span&gt; &lt;span class="k"&gt;to&lt;/span&gt; &lt;span class="n"&gt;disk&lt;/span&gt;
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Note&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Phase&lt;/span&gt; &lt;span class="n"&gt;IV&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;Flush&lt;/span&gt; &lt;span class="n"&gt;complete&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="auto_increment-在innodb-中的处理方式"&gt;AUTO_INCREMENT 在InnoDB 中的处理方式&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在表中 添加 AUTO_INCREMENT 字段， 是InnoDB 提高性能 与 稳定性的一种方式， 为了有效利用 AUTO_INCREMENT ， 必须将 AUTO_INCREMENT 字段设为索引， 以便 执行 select max(col) 以获得 最大值，&lt;/li&gt;
  &lt;li&gt;AUTO_INCREMENT 锁的 集中方式，其中的区别 以及 每种对 replic 的影响&lt;/li&gt;
  &lt;li&gt;数据插入的集中方式： 所有生成 新row的 语句， 包括 insert, insert .. select, replace, replace .. select, load data 包含
    &lt;ol&gt;
      &lt;li&gt;simple-insert: 可以预先知道 插入 行数 的 insert 语句，比如简单的单行， 多行 insert&lt;/li&gt;
      &lt;li&gt;bulk-insert: 插入行数未知  的语句，比如： insert .. select ,replace .. select, load data 语句&lt;/li&gt;
      &lt;li&gt;mixed-mode insert: 指定 auto_increment 数值的 insert 语句 或者  INSERT … ON DUPLICATE KEY UPDATE 等复杂的 语句，这些语句可能不会使用 auto_increment 分配的数值 比如：&lt;/li&gt;
    &lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt;   &lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'a'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'b'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'c'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'d'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
  &lt;li&gt;innodb_autoinc_lock_mode 可能的模式有： 0 (traditional), 1(consecutive), 2(interleaved) Mysql 8.0 默认为 interleaved 模式， 8.0 之前 默认为 consecutive 模式
    &lt;h5 id="lock-mode-的变化-反映了-mysql-从--基于语句-replica-转变到-基于-row-replica-的转变-基于语句复制-需要-一个-consecutive-的lock-mode--来确保-auto-increment-数值的-可以预测-可重复-性-因为-在replic时候-同步的是-sql-执行语句只有这样才能够保证-replic与-master-server-的数据一致性-而基于-row-replica-对于-语句的执行顺序并不敏感"&gt;lock mode 的变化 反映了 Mysql 从  基于语句 replica 转变到 基于 row replica 的转变。 基于语句复制 需要 一个 consecutive 的lock mode  来确保 auto-increment 数值的 可以预测 可重复 性 （因为 在replic时候， 同步的是 sql 执行语句，只有这样才能够保证 replic与 master server 的数据一致性）， 而基于 row replica 对于 语句的执行顺序并不敏感&lt;/h5&gt;
    &lt;ol&gt;
      &lt;li&gt;traditional: 该种模式下， 所有的inert like 语句 斗殴需要获取 一个特殊的 table-level  auto-inc lock， 该锁 需要把持到 语句的结束（非 transaction 结束） 来 保证 auto-increment 数值 的可重复性 与 可预见性， 同时保证了  auto-increment 字段数值的 连续性。 假设在 基于 语句 的复制模式中， 这意味着 sql语句 replic 到 replica server上的时候，将产生 与 source server上 完全相同的数值。 如果 让 多个 insert 语句 交替执行，则将导致 结果 不可重现， 即 replica server 与 source server数据 并不相同。 下面示例：&lt;/li&gt;
    &lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt;  &lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;TABLE&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;c1&lt;/span&gt; &lt;span class="nb"&gt;INT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;11&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;NOT&lt;/span&gt; &lt;span class="k"&gt;NULL&lt;/span&gt; &lt;span class="n"&gt;AUTO_INCREMENT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;c2&lt;/span&gt; &lt;span class="nb"&gt;VARCHAR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;DEFAULT&lt;/span&gt; &lt;span class="k"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="k"&gt;PRIMARY&lt;/span&gt; &lt;span class="k"&gt;KEY&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;ENGINE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="c1"&gt;----------&lt;/span&gt;
  &lt;span class="n"&gt;Tx1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt; &lt;span class="k"&gt;rows&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;another&lt;/span&gt; &lt;span class="k"&gt;table&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;
  &lt;span class="n"&gt;Tx2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'xxx'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;


  &lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt; &lt;span class="err"&gt;并不能知道&lt;/span&gt; &lt;span class="n"&gt;Tx1&lt;/span&gt; &lt;span class="err"&gt;中到底有多少数据&lt;/span&gt; &lt;span class="err"&gt;需要插入，&lt;/span&gt; &lt;span class="err"&gt;使用&lt;/span&gt; &lt;span class="err"&gt;一个&lt;/span&gt; &lt;span class="k"&gt;table&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;level&lt;/span&gt; &lt;span class="err"&gt;的&lt;/span&gt;&lt;span class="k"&gt;lock&lt;/span&gt; &lt;span class="err"&gt;，可以&lt;/span&gt; &lt;span class="err"&gt;使&lt;/span&gt; &lt;span class="err"&gt;在同一时间&lt;/span&gt; &lt;span class="err"&gt;只执行&lt;/span&gt; &lt;span class="err"&gt;一个&lt;/span&gt; &lt;span class="k"&gt;sql&lt;/span&gt; &lt;span class="err"&gt;语句。&lt;/span&gt; &lt;span class="err"&gt;所以&lt;/span&gt; &lt;span class="err"&gt;当在&lt;/span&gt; &lt;span class="n"&gt;replica&lt;/span&gt; &lt;span class="n"&gt;server&lt;/span&gt; &lt;span class="err"&gt;上&lt;/span&gt; &lt;span class="err"&gt;使用&lt;/span&gt; &lt;span class="err"&gt;基于&lt;/span&gt;  &lt;span class="nb"&gt;binary&lt;/span&gt; &lt;span class="n"&gt;log&lt;/span&gt; &lt;span class="err"&gt;重放&lt;/span&gt; &lt;span class="k"&gt;sql&lt;/span&gt; &lt;span class="err"&gt;语句时候，无论是&lt;/span&gt;&lt;span class="n"&gt;Tx1&lt;/span&gt; &lt;span class="err"&gt;与&lt;/span&gt; &lt;span class="n"&gt;Tx2&lt;/span&gt; &lt;span class="err"&gt;谁先执行，&lt;/span&gt; &lt;span class="err"&gt;都会产生相同的结果。当然&lt;/span&gt; &lt;span class="err"&gt;一个&lt;/span&gt;&lt;span class="k"&gt;table&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;level&lt;/span&gt;&lt;span class="err"&gt;的&lt;/span&gt;&lt;span class="k"&gt;lock&lt;/span&gt; &lt;span class="err"&gt;必然会限制&lt;/span&gt; &lt;span class="err"&gt;并发&lt;/span&gt; &lt;span class="err"&gt;与&lt;/span&gt; &lt;span class="err"&gt;可伸缩性&lt;/span&gt; &lt;span class="err"&gt;的发挥&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;consecutive mode: 在该种模式下，
    &lt;ul&gt;
      &lt;li&gt;“bulk inserts” 使用特殊的 AUTO-INC table level lock 并一直把持到 语句的最后。该类规则将 应用到 所有 的 insert ..select, replace .. select, load data 的语句中，同一时间 只有 一个把持 AUTO-INC 的语句 能够执行，&lt;/li&gt;
      &lt;li&gt;“simple inserts”: 因为可以预先知道插入的数量， 可以使用 特殊的 轻量级 X锁（只在auto-increment 分配阶段 保持），来避免  table-level AUTO-INC 锁。如果存在 其他的 transaction 持有 table-level 的 AUTO-INC lock 则 需要等待 该 transaction 完成&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;”mixed-mode inserts“: 分配的数值增量 要大于 插入的行数， 自动分配的数值 也是连续的。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;简单的说， consecutive lock mode 下， 在 保证 基于语句的 replic 正确下，提高了 并发与可伸缩性， 完美兼容 tranditional mode&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;interleaved mode: 不使用 table-level auto-inc lock， 而且可以同时执行多个insert 语句， 是最快的，可伸缩 的 lock 模式， 但是对于 基于语句 复制的 server来说 并不安全。 在这种锁定模式下，保证auto-increment column 是唯一的，并且在所有同时执行的“类似INSERT”语句中单调递增。 但是，由于多个语句可以同时生成数字（也就是说，在语句之间交错分配数字），因此为任何给定语句插入的行生成的值可能不是连续的。即： 在 simple insert 语句中， auto-increment 中的column是连续的， mixed-mode insert 与 bulk insert 中 可能存在 gap&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;auto-increment gap: 自动增量间隙
    &lt;ul&gt;
      &lt;li&gt;在所有的lock mode下： 如果事务发生回滚，则分配给该 transaction 的数值 就丢失了，该值 将不会被重用，因为表中的 auto-increment column 数值 可能存在 gap&lt;/li&gt;
      &lt;li&gt;批量插入： 在 traditional 或者 consecutive 模式下 任何插入 都不会产生 gap，因为批量插入 都需要获得 table-level 的 auto-inr lock 并保持到 活动结束。 在 interleaved 下，”bulk-insert” 可能产生gap。在 consecutive 或者 interleaved 模式下， 在连续的语句之间可能会出现gap，因为对于批量插入，可能不知道每个语句所需的自动递增值的确切数量，并且可能会高估。( 这里面 是不是描述有问题？ 因为已经在前面说了， tranditional or consecutive 模式下 批量插入并不会产生gap， 这里又说会有， 为什么？ &lt;a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html"&gt;文档在此&lt;/a&gt;)&lt;/li&gt;
      &lt;li&gt;mixed mode insert 在各种不同mode下产生的结果： 最近产生的sequence number  is 100：&lt;/li&gt;
    &lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt;    &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;TABLE&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;c1&lt;/span&gt; &lt;span class="nb"&gt;INT&lt;/span&gt; &lt;span class="nb"&gt;UNSIGNED&lt;/span&gt; &lt;span class="k"&gt;NOT&lt;/span&gt; &lt;span class="k"&gt;NULL&lt;/span&gt; &lt;span class="n"&gt;AUTO_INCREMENT&lt;/span&gt; &lt;span class="k"&gt;PRIMARY&lt;/span&gt; &lt;span class="k"&gt;KEY&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
    &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt; &lt;span class="nb"&gt;CHAR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;ENGINE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;INNODB&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

    &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'a'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'b'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'c'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'d'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="k"&gt;lock&lt;/span&gt; &lt;span class="k"&gt;mode&lt;/span&gt; &lt;span class="err"&gt;为&lt;/span&gt; &lt;span class="n"&gt;traditional&lt;/span&gt; &lt;span class="err"&gt;时候，&lt;/span&gt; &lt;span class="err"&gt;执行插入操作&lt;/span&gt;
    &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt; &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="k"&gt;ORDER&lt;/span&gt; &lt;span class="k"&gt;BY&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
     &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="c1"&gt;-----+------+&lt;/span&gt;
     &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;c1&lt;/span&gt;  &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt;   &lt;span class="o"&gt;|&lt;/span&gt;
     &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="c1"&gt;-----+------+&lt;/span&gt;
     &lt;span class="o"&gt;|&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
     &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;101&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
     &lt;span class="o"&gt;|&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="k"&gt;c&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
     &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;102&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
     &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="c1"&gt;-----+------+&lt;/span&gt;

    &lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="k"&gt;lock&lt;/span&gt; &lt;span class="k"&gt;mode&lt;/span&gt; &lt;span class="err"&gt;为&lt;/span&gt; &lt;span class="n"&gt;consecutive&lt;/span&gt; &lt;span class="err"&gt;时候，&lt;/span&gt; &lt;span class="err"&gt;执行插入操作&lt;/span&gt;   

        &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt; &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="k"&gt;ORDER&lt;/span&gt; &lt;span class="k"&gt;BY&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="c1"&gt;-----+------+&lt;/span&gt;
    &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;c1&lt;/span&gt;  &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt;   &lt;span class="o"&gt;|&lt;/span&gt;
    &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="c1"&gt;-----+------+&lt;/span&gt;
    &lt;span class="o"&gt;|&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
    &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;101&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
    &lt;span class="o"&gt;|&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="k"&gt;c&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
    &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;102&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
    &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="c1"&gt;-----+------+&lt;/span&gt;


    &lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="k"&gt;lock&lt;/span&gt; &lt;span class="k"&gt;mode&lt;/span&gt; &lt;span class="err"&gt;为&lt;/span&gt; &lt;span class="n"&gt;interleaved&lt;/span&gt; &lt;span class="err"&gt;时候，&lt;/span&gt; &lt;span class="err"&gt;执行插入操作&lt;/span&gt; 

     &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt; &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="k"&gt;ORDER&lt;/span&gt; &lt;span class="k"&gt;BY&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
     &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="c1"&gt;-----+------+&lt;/span&gt;
     &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;c1&lt;/span&gt;  &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt;   &lt;span class="o"&gt;|&lt;/span&gt;
     &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="c1"&gt;-----+------+&lt;/span&gt;
     &lt;span class="o"&gt;|&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
     &lt;span class="o"&gt;|&lt;/span&gt;   &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
     &lt;span class="o"&gt;|&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="k"&gt;c&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
     &lt;span class="o"&gt;|&lt;/span&gt;   &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
     &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="c1"&gt;-----+------+    &lt;/span&gt;

     &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="err"&gt;代表&lt;/span&gt; &lt;span class="err"&gt;唯一，但是并不能够确定的数值&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;InnoDB AUTO_INCREMENT Counter 的初始化：&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;mysql 5.7 auto-increment 的counter 存储在 main memory not disk， 所以 当server 重启，将执行  类似  SELECT MAX(ai_col) FROM table_name FOR UPDATE; 来 进行 counter 的初始化&lt;/li&gt;
  &lt;li&gt;MySQL 8.0 之后，行为发生了改变， 目前最大的 auto-increment counter 数值 被写入到了 redo log， server 重启直接从 disk 进行初始化counter&lt;/li&gt;
  &lt;li&gt;所以， 5.7 之后，如果transaction 发生rollback之后，重启server， 会出现rollback的 auto-increment id 被重复使用的问题，而 8.0 的server，则不会 重用 id， 因为 其将 counter 写入到了 disk中&lt;/li&gt;
  &lt;li&gt;auto_increment_increment 设定 auto-increment 的起始点， 默认为1， auto_increment_increment 设置 增量 默认为 1&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="index-没个-innodb-表-都有一个-特殊的index-称为-聚簇索引-用来保存-row-data-通常-聚簇索引-与-primary-key主键-同意-为了-请求获得-更好的性能-理解-innodb-如何使用-聚簇索引-来-进行优化-查询和-dml-操作-是非常重要-的"&gt;index: 没个 InnoDB 表， 都有一个 特殊的index 称为 聚簇索引， 用来保存 row data， 通常 聚簇索引 与 primary key(主键) 同意， 为了 请求获得 更好的性能， 理解 InnoDB 如何使用 聚簇索引 来 进行优化 查询，和 DML 操作 是非常重要 的&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;当你定义table 的Primary key时， InnoDB 用它作为聚簇索引， 如果没有 逻辑上的 唯一 非空 作为主键的情况下， 可以添加一个 auto-increment column 作为 主键&lt;/li&gt;
  &lt;li&gt;如果没有为 table 设定 Primary key（ 主键） 时， InnoDB 使用第一个 Unique &amp;amp; 所有column not null 的index 作为聚簇索引&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果table 没有 Primary key 和 合适的Unique index， 则 InnoDB 生成一个隐藏的名称为 GEN_CLUST_INDEX 的聚簇索引， 该字段为 6-byte 的单调递增&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;聚簇索引 如何 加快查询：
    &lt;blockquote&gt;
      &lt;p&gt;Accessing a row through the clustered index is fast because the index search leads directly to the page that contains the row data. If a table is large, the clustered index architecture often saves a disk I/O operation when compared to storage organizations that store row data using a different page from the index record.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;二级索引 是如何关联到 聚簇索引的： 二级索引定义为： 除 聚簇索引之外的索引&lt;/li&gt;
  &lt;li&gt;二级索引的每个条目（记录） 中 都包含 主键 + 二级索引 包含的column，InnoDB 使用 包含的主键 来 在聚簇索引中进行查找&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;所以 如果聚簇索引 很大的话，将加大 二级索引 的空间占用&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;InnoDB index 的物理结构：&lt;/li&gt;
  &lt;li&gt;InnoDB 所以为B-tree， 索引记录 存储在 B-tree 的 页子 page 中， 默认的 index page 大小为 16KB， 可以通过   innodb_page_size  进行设定&lt;/li&gt;
  &lt;li&gt;当插入 新纪录 到 聚簇索引时， InnoDB 尝试留下  1/16 的 空间 来满足 未来的insert update。 如果数据时按照 顺序插入的，则 index page 将占用 15/16 空间， 如果数据按照 random 顺序插入的，则可能 占用 1/2 - 15/16， innodb_fill_factor  用来控制 空间占用百分比&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果InnoDB 索引页的占用率下降到 MERGE_THRESHOLD(默认为50%) 时， InnoDB 将尝试 收缩索引 以 释放页面&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href="https://dev.mysql.com/doc/refman/8.0/en/sorted-index-builds.html"&gt;Sorted index builde&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="the-system-tablespace"&gt;The System Tablespace:&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;change buffer 在 disk 上存储到 system tablespace, 如果在system tablespace 而非 file-per-table 或者 general tablespace 则 其中还包含 table 和 index data的数据。 8.0之前 还存储 doublewrite buffer， innodb data dictionary， 8.0之后 则分开存储&lt;/li&gt;
  &lt;li&gt;system tablespace 可以有多个 data 文件， 默认的 一个 ibddata1 在 data directory中，&lt;/li&gt;
  &lt;li&gt;tablespace 的数量 与 大小 在 启动项 innodb_data_file_path  进行设定&lt;/li&gt;
  &lt;li&gt;可以进行调整，&lt;a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-system-tablespace.html"&gt;文档在此&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="file-per-table-tablespace-包含-table中的-data-和-index存储在系统中-单个文件中"&gt;File-Per-Table Tablespace: 包含 table中的 data 和 index，存储在系统中 单个文件中&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;innodb_file_per_table 控制开关， 默认为 打开状态。关闭将导致 InnoDB 存储table 数据到 system tablespace 中&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;file-per-table tablespace 在mysql 的 data directory(DATA DIRECTORY 可以在create table syntax 中指定) 目录下 存储 table_name.idb ，下面为示例：&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt;&lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;USE&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;TABLE&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
   &lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="nb"&gt;INT&lt;/span&gt; &lt;span class="k"&gt;PRIMARY&lt;/span&gt; &lt;span class="k"&gt;KEY&lt;/span&gt; &lt;span class="n"&gt;AUTO_INCREMENT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
   &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="nb"&gt;VARCHAR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;ENGINE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;shell&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="k"&gt;to&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="k"&gt;data&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;
&lt;span class="n"&gt;shell&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;ls&lt;/span&gt;
&lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ibd&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/li&gt;
  &lt;li&gt;File-per-table 的优势：
    &lt;ol&gt;
      &lt;li&gt;当 发生drop file， table_name.idb 直接被删掉， 存储空间 可以快速的归还给操作系统&lt;/li&gt;
      &lt;li&gt;Truncate table 表现的比较好&lt;/li&gt;
      &lt;li&gt;可以将 data directory 指定到 单独的设备上&lt;/li&gt;
      &lt;li&gt;创建在 改 tablespace 的table， 支持 dynamic compressed 存储格式(System tablespace 不支持)&lt;/li&gt;
      &lt;li&gt;比较容易恢复和 备份&lt;/li&gt;
      &lt;li&gt;允许单独监控 操作系统的 文件系统&lt;/li&gt;
      &lt;li&gt;减少空间限制&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="general-tablespace-通用-tablespace"&gt;General Tablespace： 通用 Tablespace&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;使用create  tablespace 创建的 共享的 tablespace, 其属性 是 file-per-tablespace 与 system tablespace 的结合。 可以 像 file-per-table tablespace 一样 指定目录存储 general tablespace， 想system tablespace 一样 存储多个 table 在一个文件中， 并可以支持 所有的存储类型。&lt;/li&gt;
  &lt;li&gt;下面是 使用 General Tablespace 的方法：&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;创建&lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt;&lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="n"&gt;TABLESPACE&lt;/span&gt; &lt;span class="n"&gt;tablespace_name&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;ADD&lt;/span&gt; &lt;span class="n"&gt;DATAFILE&lt;/span&gt; &lt;span class="s1"&gt;'file_name'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;FILE_BLOCK_SIZE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ENGINE&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;engine_name&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  

&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="err"&gt;可以&lt;/span&gt; &lt;span class="err"&gt;使用&lt;/span&gt; &lt;span class="err"&gt;变量&lt;/span&gt; &lt;span class="n"&gt;innodb_directories&lt;/span&gt;  &lt;span class="err"&gt;控制&lt;/span&gt; &lt;span class="k"&gt;general&lt;/span&gt; &lt;span class="n"&gt;tablespace&lt;/span&gt; &lt;span class="err"&gt;的存储目录，&lt;/span&gt; 
&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="n"&gt;ts1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;idb&lt;/span&gt; &lt;span class="err"&gt;为相对&lt;/span&gt; &lt;span class="n"&gt;innodb_directories&lt;/span&gt; &lt;span class="err"&gt;目录&lt;/span&gt;
&lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="n"&gt;TABLESPACE&lt;/span&gt; &lt;span class="nv"&gt;`ts1`&lt;/span&gt; &lt;span class="k"&gt;ADD&lt;/span&gt; &lt;span class="n"&gt;DATAFILE&lt;/span&gt; &lt;span class="s1"&gt;'ts1.ibd'&lt;/span&gt; &lt;span class="n"&gt;Engine&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="err"&gt;也可以执行全路径&lt;/span&gt;
&lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="n"&gt;TABLESPACE&lt;/span&gt; &lt;span class="nv"&gt;`ts1`&lt;/span&gt; &lt;span class="k"&gt;ADD&lt;/span&gt; &lt;span class="n"&gt;DATAFILE&lt;/span&gt; &lt;span class="s1"&gt;'/my/tablespace/directory/ts1.ibd'&lt;/span&gt; &lt;span class="n"&gt;Engine&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;使用： 添加table 到 general tablespace:&lt;br /&gt;
  ```sql&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;mysql&amp;gt; CREATE TABLE t1 (c1 INT PRIMARY KEY) TABLESPACE ts1;&lt;br /&gt;
  mysql&amp;gt; ALTER TABLE t2 TABLESPACE ts1;&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;  
   * 使用alter table 可以将table 的tablespace 在各个 tablespace 中进行转换： general tablespace为具体的create tablespace 的名字， file-per-table名称为 innodb_file_per_table， system tablespace 为innodb_system； 如下： 
   
   ```sql
   
   
   ALTER TABLE tbl_name TABLESPACE [=] tablespace_name;
   
   ALTER TABLE tbl_name TABLESPACE [=] innodb_system;
   
   ALTER TABLE tbl_name TABLESPACE [=] innodb_file_per_table;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;重命名tablespace： ALTER TABLESPACE s1 RENAME TO s2;， 重命名操作不能发生在 lock tables， flush tables 作用期间&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;删掉 tablespace： 在tablespace中的所有table 都必须删除掉，才能够成功的 drop tablespace&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt;   
    &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="n"&gt;Use&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;query&lt;/span&gt; &lt;span class="k"&gt;similar&lt;/span&gt; &lt;span class="k"&gt;to&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;following&lt;/span&gt; &lt;span class="k"&gt;to&lt;/span&gt; &lt;span class="n"&gt;identify&lt;/span&gt; &lt;span class="n"&gt;tables&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;general&lt;/span&gt; &lt;span class="n"&gt;tablespace&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; 
     &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NAME&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="n"&gt;space_name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NAME&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="k"&gt;table_name&lt;/span&gt; &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;INFORMATION_SCHEMA&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;INNODB_TABLESPACES&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
          &lt;span class="n"&gt;INFORMATION_SCHEMA&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;INNODB_TABLES&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;SPACE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;SPACE&lt;/span&gt; &lt;span class="k"&gt;AND&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NAME&lt;/span&gt; &lt;span class="k"&gt;LIKE&lt;/span&gt; &lt;span class="s1"&gt;'ts1'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="c1"&gt;------------+------------+&lt;/span&gt;
   &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;space_name&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="k"&gt;table_name&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
   &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="c1"&gt;------------+------------+&lt;/span&gt;
   &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ts1&lt;/span&gt;        &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;t1&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
   &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ts1&lt;/span&gt;        &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;t2&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
   &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ts1&lt;/span&gt;        &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;t3&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
   &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="c1"&gt;------------+------------+&lt;/span&gt;

   &lt;span class="k"&gt;DROP&lt;/span&gt; &lt;span class="n"&gt;TABLESPACE&lt;/span&gt; &lt;span class="n"&gt;ts1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href="https://dev.mysql.com/doc/refman/8.0/en/general-tablespaces.html"&gt;文档在此&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Undo tablespace: 用于保存undo log 的地方， undo log 产生于 insert, update, delete, 等DML 操作， 用于 事务回滚， consistent reading 等&lt;/li&gt;
  &lt;li&gt;默认的undo tablespace 存储在 mysql data dir 中， 可以使用 innodb_undo_directory  进行控制， 默认的 tablespace 文件为  undo_001 , undo_002， 对应的 tablespace名称 为 innodb_undo_001, innodb_undo_002&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-undo-tablespaces.html"&gt;文档在此&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;undo tablespace 作为一个系统使用的tablespace 一样可以允许创建，删除， 但是与 应系统性能表现相关， 比较重要&lt;/li&gt;
&lt;/ul&gt;

</content>
  </entry>
  <entry>
    <title>Redis Client conection</title>
    <link rel="alternate" href="http://geniousbar.github.io/2021/02/21/redis/"/>
    <id>http://geniousbar.github.io/2021/02/21/redis/</id>
    <published>2021-02-21T00:00:00+00:00</published>
    <updated>2021-04-20T08:07:49+00:00</updated>
    <summary type="html">&lt;h2 id="redis-建立链接过程"&gt;Redis 建立链接过程&lt;/h2&gt;
&lt;p&gt;&lt;img src="../../../../images/redis-a3bef2b1.png" alt="redis" /&gt;&lt;/p&gt;
</summary>
    <content type="html">&lt;h2 id="redis-建立链接过程"&gt;Redis 建立链接过程&lt;/h2&gt;
&lt;p&gt;&lt;img src="../../../../images/redis-a3bef2b1.png" alt="redis" /&gt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Rust little book</title>
    <link rel="alternate" href="http://geniousbar.github.io/2021/02/20/rust-little-book/"/>
    <id>http://geniousbar.github.io/2021/02/20/rust-little-book/</id>
    <published>2021-02-20T00:00:00+00:00</published>
    <updated>2021-04-20T04:02:05+00:00</updated>
    <summary type="html">&lt;h2 id="rust-little-book"&gt;Rust little book&lt;/h2&gt;

&lt;h3 id="rustup--rust-complier-的管理工具-可以方便的切换-stable-beta-and-nightly"&gt;rustup:  rust complier 的管理工具， 可以方便的切换 stable, beta, and nightly&lt;/h3&gt;
&lt;h3 id="cargo-是rust的包管理工具-用来-下载-rust的依赖-编译-以及-分发-到-cratesio"&gt;cargo 是rust的包管理工具， 用来 下载 rust的依赖， 编译， 以及 分发 到 crates.io&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;在安装 rust 之后， cargo 也会被自动安装上&lt;/li&gt;
  &lt;li&gt;cargo 提供了一些有用的工具有:
    &lt;ol&gt;
      &lt;li&gt;cargo new package # default –bin 生成 可执行 program...&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    <content type="html">&lt;h2 id="rust-little-book"&gt;Rust little book&lt;/h2&gt;

&lt;h3 id="rustup--rust-complier-的管理工具-可以方便的切换-stable-beta-and-nightly"&gt;rustup:  rust complier 的管理工具， 可以方便的切换 stable, beta, and nightly&lt;/h3&gt;
&lt;h3 id="cargo-是rust的包管理工具-用来-下载-rust的依赖-编译-以及-分发-到-cratesio"&gt;cargo 是rust的包管理工具， 用来 下载 rust的依赖， 编译， 以及 分发 到 crates.io&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;在安装 rust 之后， cargo 也会被自动安装上&lt;/li&gt;
  &lt;li&gt;cargo 提供了一些有用的工具有:
    &lt;ol&gt;
      &lt;li&gt;cargo new package # default –bin 生成 可执行 program, 可以传递 –lib 来产生库程序&lt;/li&gt;
      &lt;li&gt;cargo build&lt;/li&gt;
      &lt;li&gt;cargo 存在的意义：
        &lt;ul&gt;
          &lt;li&gt;剥离 rustc 的复杂度， 类似 make 与 c 一样&lt;/li&gt;
          &lt;li&gt;cargo 最终调用rustc 来编译 项目， 当然可以 直接使用 rustc 来编译项目，但是 需要出入 复杂的参数 来 添加项目 依赖关系， 编译文件， 依赖关系 等，并精心安排顺序 来进行调用。&lt;/li&gt;
          &lt;li&gt;所以使用cargo： make工具， cargo 的功能
            &lt;ol&gt;
              &lt;li&gt;使用两个文件 来 包含 package的信息&lt;/li&gt;
              &lt;li&gt;拉取，构建  package 依赖&lt;/li&gt;
              &lt;li&gt;使用正确的参数 来调用rustc 或者其他 tool， 来构建项目&lt;/li&gt;
              &lt;li&gt;引用约定，方便package 构建&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="cargo-使用笔记"&gt;cargo 使用笔记：&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;cargo new hello_world –bin&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;cd &lt;/span&gt;hello_world
&lt;span class="nv"&gt;$ &lt;/span&gt;tree &lt;span class="nb"&gt;.&lt;/span&gt;
&lt;span class="nb"&gt;.&lt;/span&gt;
├── Cargo.toml
└── src
    └── main.rs

1 directory, 2 files
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;其中 Cargo.toml 被称为 manifest,包含package的元数据&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;fn main&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    println!&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Hello, world!"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;


&lt;span class="nv"&gt;$ &lt;/span&gt;cargo build
   Compiling hello_world v0.1.0 &lt;span class="o"&gt;(&lt;/span&gt;file:///path/to/package/hello_world&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="nv"&gt;$ &lt;/span&gt;./target/debug/hello_world
Hello, world!


&lt;span class="nv"&gt;$ &lt;/span&gt;cargo run
   Compiling hello_world v0.1.0 &lt;span class="o"&gt;(&lt;/span&gt;file:///path/to/package/hello_world&lt;span class="o"&gt;)&lt;/span&gt;
     Running &lt;span class="sb"&gt;`&lt;/span&gt;target/debug/hello_world&lt;span class="sb"&gt;`&lt;/span&gt;
Hello, world!



&lt;span class="nv"&gt;$ &lt;/span&gt;cargo build &lt;span class="nt"&gt;--release&lt;/span&gt;
   Compiling hello_world v0.1.0 &lt;span class="o"&gt;(&lt;/span&gt;file:///path/to/package/hello_world&lt;span class="o"&gt;)&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;cargo build  将会 构建 package&lt;/li&gt;
  &lt;li&gt;cargo run 则 构建并运行它&lt;/li&gt;
  &lt;li&gt;cargo build –release 将 构建 优化的代码&lt;/li&gt;
  &lt;li&gt;cargo 默认的构建 代码优化级别 为 debug, 存在的目录为 target/debug, 构建 优化后的代码需要 显式传递 参数 –release 生成的文件目录为 target/release&lt;/li&gt;
  &lt;li&gt;Dependencies：
    &lt;ul&gt;
      &lt;li&gt;crate.io 为 rust 中间的 package 机构， 用于发现 下载 更新package&lt;/li&gt;
      &lt;li&gt;添加依赖关系： 在 Cargo.toml 中 的dependencies 下，添加项目&lt;/li&gt;
    &lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="o"&gt;[&lt;/span&gt;package]
name &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"hello_world"&lt;/span&gt;
version &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"0.1.0"&lt;/span&gt;
authors &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"Your Name &amp;lt;you@example.com&amp;gt;"&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
edition &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"2018"&lt;/span&gt;

&lt;span class="o"&gt;[&lt;/span&gt;dependencies]
&lt;span class="nb"&gt;time&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"0.1.12"&lt;/span&gt;
regex &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"0.1.41"&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;之后的 cargo build 过程&lt;/li&gt;
    &lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;cargo build
      Updating crates.io index
   Downloading memchr v0.1.5
   Downloading libc v0.1.10
   Downloading regex-syntax v0.2.1
   Downloading memchr v0.1.5
   Downloading aho-corasick v0.3.0
   Downloading regex v0.1.41
     Compiling memchr v0.1.5
     Compiling libc v0.1.10
     Compiling regex-syntax v0.2.1
     Compiling memchr v0.1.5
     Compiling aho-corasick v0.3.0
     Compiling regex v0.1.41
     Compiling hello_world v0.1.0 &lt;span class="o"&gt;(&lt;/span&gt;file:///path/to/package/hello_world&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="package-构成"&gt;package 构成：&lt;/h4&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;  &lt;span class="nb"&gt;.&lt;/span&gt;
  ├── Cargo.lock
  ├── Cargo.toml
  ├── src/
  │   ├── lib.rs
  │   ├── main.rs
  │   └── bin/
  │       ├── named-executable.rs
  │       ├── another-executable.rs
  │       └── multi-file-executable/
  │           ├── main.rs
  │           └── some_module.rs
  ├── benches/
  │   ├── large-input.rs
  │   └── multi-file-bench/
  │       ├── main.rs
  │       └── bench_module.rs
  ├── examples/
  │   ├── simple.rs
  │   └── multi-file-example/
  │       ├── main.rs
  │       └── ex_module.rs
  └── tests/
      ├── some-integration-tests.rs
      └── multi-file-test/
          ├── main.rs
          └── test_module.rs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;Cargo.toml and Cargo.lock 在项目的根目录&lt;/li&gt;
  &lt;li&gt;src 下 为源代码&lt;/li&gt;
  &lt;li&gt;默认的 library file 为 src/lib.rs&lt;/li&gt;
  &lt;li&gt;默认的 executable file 是 src/main.rc, 其他的 放在 src/bin/&lt;/li&gt;
  &lt;li&gt;基准测试 放在benches 目录下&lt;/li&gt;
  &lt;li&gt;示例代码放在examples 目录下&lt;/li&gt;
  &lt;li&gt;集成测试 放在 tests 目录下&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;其他详细的需要参看 [[https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html]]&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Cargo.toml 与 Cargo.lock: 两种目的，
    &lt;ul&gt;
      &lt;li&gt;cargo.toml 描述 大概的依赖关系 并不准确，是由 人来确定的&lt;/li&gt;
      &lt;li&gt;Cargo.lock 包含准确的依赖关系， 由cargo 来维护&lt;/li&gt;
      &lt;li&gt;[[https://doc.rust-lang.org/cargo/faq.html#why-do-binaries-have-cargolock-in-version-control-but-not-libraries]]&lt;/li&gt;
      &lt;li&gt;示例:&lt;/li&gt;
    &lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;Cargo.toml

&lt;span class="o"&gt;[&lt;/span&gt;package]
name &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"hello_world"&lt;/span&gt;
version &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"0.1.0"&lt;/span&gt;
authors &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"Your Name &amp;lt;you@example.com&amp;gt;"&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;

&lt;span class="o"&gt;[&lt;/span&gt;dependencies]
rand &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; git &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"https://github.com/rust-lang-nursery/rand.git"&lt;/span&gt;, rev &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"9f35b8e"&lt;/span&gt; &lt;span class="o"&gt;}&lt;/span&gt;


Cargo.lock


&lt;span class="o"&gt;[[&lt;/span&gt;package]]
name &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"hello_world"&lt;/span&gt;
version &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"0.1.0"&lt;/span&gt;
dependencies &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;
 &lt;span class="s2"&gt;"rand 0.1.0 (git+https://github.com/rust-lang-nursery/rand.git#9f35b8e439eeedd60b9414c58f389bdc6a3284f9)"&lt;/span&gt;,
&lt;span class="o"&gt;]&lt;/span&gt;

&lt;span class="o"&gt;[[&lt;/span&gt;package]]
name &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"rand"&lt;/span&gt;
version &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"0.1.0"&lt;/span&gt;
&lt;span class="nb"&gt;source&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"git+https://github.com/rust-lang-nursery/rand.git#9f35b8e439eeedd60b9414c58f389bdc6a3284f9"&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
  &lt;li&gt;Cargo.lock 中包含 依赖的确定的 version， 当其他人使用的时候， 他们将使用相同的 sha，即便我们并没有在Cargo.toml 中使用&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;cargo update 更新全部的依赖， cargo update -p rand 只更新依赖 rand&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Test:
    &lt;ul&gt;
      &lt;li&gt;cargo test 执行 package中的所有test， test主要有两种： 1) 在每个 src 目录中的文件， 2） tests/ 目录下的所有文件。 1）中的为单元测试， 2）则为 集成测试，&lt;/li&gt;
    &lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;cargo &lt;span class="nb"&gt;test
   &lt;/span&gt;Compiling rand v0.1.0 &lt;span class="o"&gt;(&lt;/span&gt;https://github.com/rust-lang-nursery/rand.git#9f35b8e&lt;span class="o"&gt;)&lt;/span&gt;
   Compiling hello_world v0.1.0 &lt;span class="o"&gt;(&lt;/span&gt;file:///path/to/package/hello_world&lt;span class="o"&gt;)&lt;/span&gt;
     Running target/test/hello_world-9c2b65bbb79eabce

running 0 tests

&lt;span class="nb"&gt;test &lt;/span&gt;result: ok. 0 passed&lt;span class="p"&gt;;&lt;/span&gt; 0 failed&lt;span class="p"&gt;;&lt;/span&gt; 0 ignored&lt;span class="p"&gt;;&lt;/span&gt; 0 measured&lt;span class="p"&gt;;&lt;/span&gt; 0 filtered out
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;ul&gt;
      &lt;li&gt;cargo test foo  可以单独执行 名字为foo的测试，&lt;/li&gt;
      &lt;li&gt;cargo test 其实还会执行 额外的测试，包含在 src中的部分 文档中的测试（并不重要，为补充部分）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Cargo Home： 当build package的时候， cargo 将下载的依赖package 存储到 Cargo home 下。当做cache 使用。
    &lt;ul&gt;
      &lt;li&gt;可以通过 改变 环境变量 CARGO_HOME 来改变 cargo home的值， 默认 为 $HOME/.cargo/&lt;/li&gt;
      &lt;li&gt;Cargo Home 目录下的 数据：
        &lt;ul&gt;
          &lt;li&gt;bin 目录： 可执行crate， 包括cargo install 或者 rustup 安装的&lt;/li&gt;
          &lt;li&gt;git/db: crate 依赖git 项目时， cargo clone 项目到 该目录下&lt;/li&gt;
          &lt;li&gt;git/checkouts： git/db 项目中的检出到该文件， 比如 依赖于特定的commit&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;registry： 项目依赖于 crate.io 中的crate 存放在该目录下
    &lt;ul&gt;
      &lt;li&gt;registry/index： crate 的原数据， 包括： version， dependencies 等&lt;/li&gt;
      &lt;li&gt;registry/cache： 下载的crate 储存到该目录下， 存储形式为 .crate 的gzip压缩文件&lt;/li&gt;
      &lt;li&gt;registry/src： cache 的解压形式 存放在 该文件中&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="指定-dependencies"&gt;指定 Dependencies：&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;依赖版本： 版本号各个位置数字的含义： [[https://semver.org/][SemVer compatible]] 与 link 中讲的同样， major.minor.patch&lt;/li&gt;
  &lt;li&gt;Caret requirements： 指定 可以使用 一个 major 版本号 不变的更新， 但是 0 是 一个特殊的数字，标识不与 任何 数字兼容。即是： 0.0.1， 与 0.1.x 不兼容&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;下面为兼容样例：&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;^1.2.3  :&lt;span class="o"&gt;=&lt;/span&gt;  &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;1.2.3, &amp;lt;2.0.0
^1.2    :&lt;span class="o"&gt;=&lt;/span&gt;  &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;1.2.0, &amp;lt;2.0.0
^1      :&lt;span class="o"&gt;=&lt;/span&gt;  &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;1.0.0, &amp;lt;2.0.0
^0.2.3  :&lt;span class="o"&gt;=&lt;/span&gt;  &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;0.2.3, &amp;lt;0.3.0
^0.2    :&lt;span class="o"&gt;=&lt;/span&gt;  &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;0.2.0, &amp;lt;0.3.0
^0.0.3  :&lt;span class="o"&gt;=&lt;/span&gt;  &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;0.0.3, &amp;lt;0.0.4
^0.0    :&lt;span class="o"&gt;=&lt;/span&gt;  &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;0.0.0, &amp;lt;0.1.0
^0      :&lt;span class="o"&gt;=&lt;/span&gt;  &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;0.0.0, &amp;lt;1.0.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/li&gt;
  &lt;li&gt;Tilde requirements:  分为以下情况:
    &lt;ul&gt;
      &lt;li&gt;有 major.minor.patch 或者  major.minor 只有patch version 的升级是允许的&lt;/li&gt;
      &lt;li&gt;有major情况下, minor patch verison的升级 是允许的&lt;/li&gt;
      &lt;li&gt;for example&lt;/li&gt;
    &lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;~1.2.3  :&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;1.2.3, &amp;lt;1.3.0
~1.2    :&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;1.2.0, &amp;lt;1.3.0
~1      :&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;1.0.0, &amp;lt;2.0.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
  &lt;li&gt;Wildcard requirements:
    &lt;ul&gt;
      &lt;li&gt;允许所在位置上的 任何版本&lt;/li&gt;
      &lt;li&gt;for example&lt;/li&gt;
    &lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="se"&gt;\*&lt;/span&gt;     :&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;0.0.0
1.&lt;span class="k"&gt;*&lt;/span&gt;   :&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;1.0.0, &amp;lt;2.0.0
1.2.&lt;span class="k"&gt;*&lt;/span&gt; :&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;1.2.0, &amp;lt;1.3.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="workspaces-workspace-下的一系列package-共享同样的cargolock-output-dir-等配置比如profile-workspace下的packages-被称为-workspace-members"&gt;Workspaces: workspace 下的一系列package 共享同样的Cargo.lock， output dir 等配置（比如profile）， workspace下的packages 被称为 workspace members&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;存在两种形式： 1） [package] 与 [workspace] 共存在 Cargo.toml 中 2） 只有 [workspace] 存在Cargo.toml 中， 被称作 Virtual manifest&lt;/li&gt;
  &lt;li&gt;主要作用：
    &lt;ol&gt;
      &lt;li&gt;共享Cargo.lock&lt;/li&gt;
      &lt;li&gt;共享output dir， Cargo.toml 中 [target]&lt;/li&gt;
      &lt;li&gt;[patch], [replace] and [profile.*] 等 在Cargo.toml 中的 段  只能识别在 workspace 中的 manifest，member package 中的被忽略&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;workspace section 中的配置&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="o"&gt;[&lt;/span&gt;workspace]
members &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"member1"&lt;/span&gt;, &lt;span class="s2"&gt;"path/to/member2"&lt;/span&gt;, &lt;span class="s2"&gt;"crates/*"&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
exclude &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"crates/foo"&lt;/span&gt;, &lt;span class="s2"&gt;"path/to/other"&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/li&gt;
  &lt;li&gt;members 为 成员package 列表， exclude 排除 member
    &lt;ul&gt;
      &lt;li&gt;workspace 寻找： Cargo 自动的 向上目录 寻找 含有 [workspace] 的Cargo.toml， 在 member中可以指定 package.workspace 来 直接指定 workspace 的位置， 来防止自动查找， 这个对于 没有在 workspace 目录下的member package 非常有用&lt;/li&gt;
      &lt;li&gt;member package： cargo command -p package 可以指定 package 来 执行命令， 如果没有指定 package， 则 选择当前所在目录的package， default-members = [“path/to/member2”, “path/to/member3/”] 可以指定默认的 操作的member package&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="rustup-从官方下载rustc-使能够随意的在-stable-beta-nightly-中切换-让-cross-compiling-编译变的简单"&gt;rustup： 从官方下载rustc， 使能够随意的在 stable, beta, nightly 中切换。 让 cross-compiling 编译变的简单&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;工作原理：  rustup 通过 ~/.cargo/bin 下的工具 来实现其功能， 比如 安装在~/.cargo/bin   下的  rustc cargo 等 只是一个 到真正执行工具的 代理，&lt;/li&gt;
  &lt;li&gt;rustup 提供了一个方便的机制来 控制 这些代理的行为， 比如 通过执行rustup default nightly 来切换 nightly 下的工具&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="概念"&gt;概念:&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;channel: rustc 按照 beta, night, stable 三个 channel 进行发布， channel 并没有什么用， 只是个概念而已。&lt;/li&gt;
  &lt;li&gt;toolchain： rustc and cargo 等相关工具。 因为能够控制rustc (即是channel概念下的实际应用)&lt;/li&gt;
  &lt;li&gt;target： rustc 可以为多个平台生成代码。 默认的 rustc 使用host(即本机) 作为target， 为了生成不同target的代码，我们需要 使用rustup target 来安装目标target&lt;/li&gt;
  &lt;li&gt;component: 每个rust版本的发布，都会包含一些 组件， 包括rustc， clippy 等&lt;/li&gt;
  &lt;li&gt;profile： 为了更好的与component 工作， profile 定义了 一组component，&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;toolchain：  rustup 不仅可以 安装stable, beta, nightly 三个channel， 还可以安装 其他的 官方 历史版本&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;channel 的命令规则:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&amp;lt;channel&amp;gt;[-&amp;lt;&lt;span class="nb"&gt;date&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;][&lt;/span&gt;-&amp;lt;host&amp;gt;]

&amp;lt;channel&amp;gt;       &lt;span class="o"&gt;=&lt;/span&gt; stable|beta|nightly|&amp;lt;major.minor&amp;gt;|&amp;lt;major.minor.patch&amp;gt;
&amp;lt;&lt;span class="nb"&gt;date&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;          &lt;span class="o"&gt;=&lt;/span&gt; YYYY-MM-DD
&amp;lt;host&amp;gt;          &lt;span class="o"&gt;=&lt;/span&gt; &amp;lt;target-triple&amp;gt;

&lt;span class="c"&gt;#+end_src&lt;/span&gt;
&lt;span class="k"&gt;**&lt;/span&gt; 其他命令： 保持 rust 更新： 
&lt;span class="c"&gt;#+begin_src &lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;rustup update
info: syncing channel updates &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="s1"&gt;'stable'&lt;/span&gt;
info: downloading component &lt;span class="s1"&gt;'rustc'&lt;/span&gt;
info: downloading component &lt;span class="s1"&gt;'rust-std'&lt;/span&gt;
info: downloading component &lt;span class="s1"&gt;'rust-docs'&lt;/span&gt;
info: downloading component &lt;span class="s1"&gt;'cargo'&lt;/span&gt;
info: installing component &lt;span class="s1"&gt;'rustc'&lt;/span&gt;
info: installing component &lt;span class="s1"&gt;'rust-std'&lt;/span&gt;
info: installing component &lt;span class="s1"&gt;'rust-docs'&lt;/span&gt;
info: installing component &lt;span class="s1"&gt;'cargo'&lt;/span&gt;
info: checking &lt;span class="k"&gt;for &lt;/span&gt;self-updates
info: downloading self-updates

  stable updated: rustc 1.7.0 &lt;span class="o"&gt;(&lt;/span&gt;a5d1e7a59 2016-02-29&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
  &lt;p&gt;如上， rustup update 会更新 stable， component， 以及 rustup self， 可以使用 rustup self update 来手动更新rustup&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id="rust-知识"&gt;Rust 知识：&lt;/h3&gt;
&lt;h4 id="stdfmt"&gt;std::fmt:&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;format! 的使用 方法：  positional params：， named params： ， formating params：&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;示例&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="nd"&gt;format!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Hello, {}!"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"world"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   &lt;span class="c"&gt;// =&amp;gt; "Hello, world!"&lt;/span&gt;
&lt;span class="nd"&gt;format!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"{1} {} {0} {}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c"&gt;// =&amp;gt; "2 1 1 2"&lt;/span&gt;
&lt;span class="nd"&gt;format!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"{argument}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;argument&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"test"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Hello {:1$}!"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"x"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/li&gt;
  &lt;li&gt;formating trait: 实践显式 对于外部的Type  {}确实需要impl Display， 而{:?} 需要 impl Debug
    &lt;ol&gt;
      &lt;li&gt;{} =&amp;gt; Display&lt;/li&gt;
      &lt;li&gt;{:?} =&amp;gt; Debug&lt;/li&gt;
      &lt;li&gt;{:o} =&amp;gt; Octal&lt;/li&gt;
      &lt;li&gt;{:p} =&amp;gt; Pointer&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;fmt::Display vs fmt::Debug
    &lt;ol&gt;
      &lt;li&gt;Display: 断言 实现者 总是返回 UTF-8 的字符串， 并非所有的 都实现了 Display&lt;/li&gt;
      &lt;li&gt;Debug：  应该为所有pub type 实现， 输出为 内部状态， 该Trait 的目的是为了方便Rust Debug， 可以 使用#[derive(Debug)] 来使用默认的内部实现&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="array--slice"&gt;array &amp;amp; Slice&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;array的类型为： [T: len], let mut array: [i32; 3] = [0; 3];&lt;/li&gt;
  &lt;li&gt;Slice: [T]&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="structures-有三种类型-1-tuple-struct-2-classic-struct-3-unit-structs"&gt;structures： 有三种类型： 1） Tuple struct, 2) classic struct 3) Unit structs&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;struct Pair(i32, f32);&lt;/li&gt;
  &lt;li&gt;struct Person {  name: String,    age: u8}&lt;/li&gt;
  &lt;li&gt;struct Unit; unit Struct 没有任何的 field&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="enums-包含多个-变体-的-组合项-任何一个变体-都是一个-正确的-enum-类型"&gt;Enums： 包含多个 变体 的 组合项， 任何一个变体 都是一个 正确的 enum 类型&lt;/h4&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;  &lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;WebEvent&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="c"&gt;// An `enum` may either be `unit-like`,&lt;/span&gt;
      &lt;span class="n"&gt;PageLoad&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="n"&gt;PageUnload&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="c"&gt;// like tuple structs,&lt;/span&gt;
      &lt;span class="nf"&gt;KeyPress&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;char&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
      &lt;span class="nf"&gt;Paste&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;String&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
      &lt;span class="c"&gt;// or c-like structures.&lt;/span&gt;
      &lt;span class="n"&gt;Click&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;i64&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;i64&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="c"&gt;// A function which takes a `WebEvent` enum as an argument and&lt;/span&gt;
  &lt;span class="c"&gt;// returns nothing.&lt;/span&gt;
  &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;inspect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;WebEvent&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
          &lt;span class="nn"&gt;WebEvent&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;PageLoad&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"page loaded"&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
          &lt;span class="nn"&gt;WebEvent&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;PageUnload&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"page unloaded"&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
          &lt;span class="c"&gt;// Destructure `c` from inside the `enum`.&lt;/span&gt;
          &lt;span class="nn"&gt;WebEvent&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;KeyPress&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"pressed '{}'."&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
          &lt;span class="nn"&gt;WebEvent&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;Paste&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"pasted &lt;/span&gt;&lt;span class="se"&gt;\"&lt;/span&gt;&lt;span class="s"&gt;{}&lt;/span&gt;&lt;span class="se"&gt;\"&lt;/span&gt;&lt;span class="s"&gt;."&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
          &lt;span class="c"&gt;// Destructure `Click` into `x` and `y`.&lt;/span&gt;
          &lt;span class="nn"&gt;WebEvent&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Click&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
              &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"clicked at x={}, y={}."&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
          &lt;span class="p"&gt;},&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="type-aliastype-关键字能够-使用-type-name--existingtype-语法来-使用-name-代替-existingtype-使用-self-是一种type-alias"&gt;Type Alias：type 关键字能够 使用 type Name = ExistingType； 语法来 使用 Name 代替 ExistingType 使用。 Self 是一种Type Alias&lt;/h4&gt;

&lt;h4 id="const-static"&gt;const， static&lt;/h4&gt;

&lt;h4 id="variable-bindings-1变量默认-是不可修改的-使用mut-改变-2-可以在内部的scope中-其同样的名字来shadow即使不可见-外部的变量-3可以使用-先声明-后设定数值的形式-使用变量但是rust-会检查-使用-未定义变量的错误-来预防因此产生的问题"&gt;Variable Bindings： 1）变量默认 是不可修改的， 使用mut 改变 2） 可以在内部的scope中 其同样的名字来shadow(即使不可见) 外部的变量 3）可以使用 先声明 后设定数值的形式 使用变量，但是rust 会检查 使用 未定义变量的错误， 来预防因此产生的问题&lt;/h4&gt;

&lt;h4 id="types-1转换-as关键字--2-type-alias-type-nanosecond--u64-3-数值的类型可以添加到--后面最为后缀使用-例如-42i32"&gt;Types: 1）转换 as关键字  2） type alias： type NanoSecond = u64; 3） 数值的类型，可以添加到  后面最为后缀使用， 例如： 42i32&lt;/h4&gt;

&lt;h4 id="conversion-rust-的struct-以及-enum-等自定义类型的-type转换"&gt;Conversion： rust 的struct 以及 enum 等自定义类型的 type转换&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;From &amp;amp; Into:
    &lt;ul&gt;
      &lt;li&gt;From 为一个类型定义， 如何create self 从 另一个type中转变&lt;/li&gt;
      &lt;li&gt;Into 则是From 的 调用者， From&lt;T&gt; for U 自动实现了 Into&lt;u&gt; for T ( blank implement)&lt;/u&gt;&lt;/T&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;TryFrom &amp;amp; TryInto: 类似于 From &amp;amp; Into 不同的是， 转换可能失败，返回Result
    &lt;ul&gt;
      &lt;li&gt;ToString &amp;amp; FromStr:&lt;/li&gt;
      &lt;li&gt;ToString： 单独为 String 类型 定义了一个 ToString Trait，但是并不需要直接实现 ToString，而是实现了 fmt::Display 之后 就自动了提供了 ToString 中的to_string 方法&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;    &lt;span class="nd"&gt;#[stable(feature&lt;/span&gt; &lt;span class="nd"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"rust1"&lt;/span&gt;&lt;span class="nd"&gt;,&lt;/span&gt; &lt;span class="nd"&gt;since&lt;/span&gt; &lt;span class="nd"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"1.0.0"&lt;/span&gt;&lt;span class="nd"&gt;)]&lt;/span&gt;
&lt;span class="k"&gt;impl&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nn"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Display&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="n"&gt;Sized&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;ToString&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c"&gt;// A common guideline is to not inline generic functions. However,&lt;/span&gt;
    &lt;span class="c"&gt;// removing `#[inline]` from this method causes non-negligible regressions.&lt;/span&gt;
    &lt;span class="c"&gt;// See &amp;lt;https://github.com/rust-lang/rust/pull/74852&amp;gt;, the last attempt&lt;/span&gt;
    &lt;span class="c"&gt;// to try to remove it.&lt;/span&gt;
    &lt;span class="nd"&gt;#[inline]&lt;/span&gt;
    &lt;span class="n"&gt;default&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;to_string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;String&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;String&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="nf"&gt;.write_fmt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nd"&gt;format_args!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"{}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="nf"&gt;.expect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"a Display implementation returned an error unexpectedly"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;buf&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="fromstr--parse-将string-转换为其他类型-只需要实现了-fromstr-for-struct-而string-中的parse-方法-只是-对fromstrfrom_strstring-的调用"&gt;FromStr &amp;amp; parse: 将String 转换为其他类型， 只需要实现了 FromStr for struct, 而String 中的parse 方法 只是 对FromStr::from_str(&amp;amp;string) 的调用&lt;/h4&gt;

&lt;h4 id="expression-程序是由一系列表达式组成的-1-赋值表达式-用-结尾-2--也是表达式-如果最后一个表达式-以-结尾则返回---否则为最后一个表达式的-结果"&gt;Expression： 程序是由一系列表达式组成的， 1） 赋值表达式 用; 结尾， 2） {} 也是表达式， 如果最后一个表达式 以; 结尾，则返回  (), 否则为最后一个表达式的 结果&lt;/h4&gt;

&lt;h4 id="flow-of-control"&gt;Flow of control：&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;if-else  也是表达式， 所有的分支必须返回同样的类型&lt;/li&gt;
  &lt;li&gt;loop： loop break continue。 break 用来随时中断退出loop， continue 则用于 用于 跳过剩下的 代码，重新开始一个 循环&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;loop 是可以嵌套的，并起名字, break ，以及continue 可以使用名字来进行 break， 或者continue&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="nd"&gt;#![allow(unreachable_code)]&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nv"&gt;'outer&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Entered the outer loop"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="nv"&gt;'inner&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Entered the inner loop"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

            &lt;span class="c"&gt;// This would break only the inner loop&lt;/span&gt;
            &lt;span class="c"&gt;//break;&lt;/span&gt;

            &lt;span class="c"&gt;// This breaks the outer loop&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt; &lt;span class="nv"&gt;'outer&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"This point will never be reached"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Exited the outer loop"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;counter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;counter&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;counter&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt; &lt;span class="n"&gt;counter&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;

    &lt;span class="nd"&gt;assert_eq!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/li&gt;
  &lt;li&gt;loop 也是可以 返回数值的， 放到break 后面&lt;/li&gt;
  &lt;li&gt;while&lt;/li&gt;
  &lt;li&gt;for: for in 结构用来 遍历 所有实现了 IntoIterator 的对象， 比如简单 range形式： a..b, a..=b
    &lt;ul&gt;
      &lt;li&gt;for loop 会自动调用 into_iter 在参数上，我们可以主动产生下面几类实现IntoIterator 的 Iterator：&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;iter: 产生 引用的 Iterator, 对 ownership不产生影响
    &lt;ul&gt;
      &lt;li&gt;into_iter: 将ownership 交给 Iterator， 调用过之后的对象，将不再可用。产生&lt;/li&gt;
      &lt;li&gt;iter_mut: 产生mut 引用的Iterator， 可以进行修改&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;match:
    &lt;ul&gt;
      &lt;li&gt;c like 方式： 即 match  number&lt;/li&gt;
      &lt;li&gt;解构对象：
        &lt;ul&gt;
          &lt;li&gt;Tuples：  使用.. 来 忽略剩余所有的 tuple&lt;/li&gt;
          &lt;li&gt;Enums:&lt;/li&gt;
          &lt;li&gt;Pointers: *  &amp;amp; ref ref mut 见下面示例&lt;/li&gt;
          &lt;li&gt;Structs: struct 同样可以被match&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Guards: 在match 对象的arm中，同样可以 使用 if 条件判断 即是 guards&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Bindings： match 在 arm中，除了解构对象的同时 可以将变量整体绑定 到一个变量上&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;triple&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="c"&gt;// TODO ^ Try different values for `triple`&lt;/span&gt;

    &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Tell me about {:?}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;triple&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="c"&gt;// Match can be used to destructure a tuple&lt;/span&gt;
    &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="n"&gt;triple&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c"&gt;// Destructure the second and third elements&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"First is `0`, `y` is {:?}, and `z` is {:?}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;..&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"First is `1` and the rest doesn't matter"&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="c"&gt;// `..` can be the used ignore the rest of the tuple&lt;/span&gt;
        &lt;span class="mi"&gt;_&lt;/span&gt;      &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"It doesn't matter what they are"&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="c"&gt;// `_` means don't bind the value to a variable&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c"&gt;//point s &lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c"&gt;// Assign a reference of type `i32`. The `&amp;amp;` signifies there&lt;/span&gt;
    &lt;span class="c"&gt;// is a reference being assigned.&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;reference&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="n"&gt;reference&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c"&gt;// If `reference` is pattern matched against `&amp;amp;val`, it results&lt;/span&gt;
        &lt;span class="c"&gt;// in a comparison like:&lt;/span&gt;
        &lt;span class="c"&gt;// `&amp;amp;i32`&lt;/span&gt;
        &lt;span class="c"&gt;// `&amp;amp;val`&lt;/span&gt;
        &lt;span class="c"&gt;// ^ We see that if the matching `&amp;amp;`s are dropped, then the `i32`&lt;/span&gt;
        &lt;span class="c"&gt;// should be assigned to `val`.&lt;/span&gt;
        &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Got a value via destructuring: {:?}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c"&gt;// To avoid the `&amp;amp;`, you dereference before matching.&lt;/span&gt;
    &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;reference&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Got a value via dereferencing: {:?}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c"&gt;// What if you don't start with a reference? `reference` was a `&amp;amp;`&lt;/span&gt;
    &lt;span class="c"&gt;// because the right side was already a reference. This is not&lt;/span&gt;
    &lt;span class="c"&gt;// a reference because the right side is not one.&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="mi"&gt;_&lt;/span&gt;&lt;span class="n"&gt;not_a_reference&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c"&gt;// Rust provides `ref` for exactly this purpose. It modifies the&lt;/span&gt;
    &lt;span class="c"&gt;// assignment so that a reference is created for the element; this&lt;/span&gt;
    &lt;span class="c"&gt;// reference is assigned.&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;ref&lt;/span&gt; &lt;span class="mi"&gt;_&lt;/span&gt;&lt;span class="n"&gt;is_a_reference&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c"&gt;// Accordingly, by defining 2 values without references, references&lt;/span&gt;
    &lt;span class="c"&gt;// can be retrieved via `ref` and `ref mut`.&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;mut_value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c"&gt;// Use `ref` keyword to create a reference.&lt;/span&gt;
    &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;ref&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Got a reference to a value: {:?}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c"&gt;// Use `ref mut` similarly.&lt;/span&gt;
    &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="n"&gt;mut_value&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;ref&lt;/span&gt; &lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="c"&gt;// Got a reference. Gotta dereference it before we can&lt;/span&gt;
            &lt;span class="c"&gt;// add anything to it.&lt;/span&gt;
            &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"We added 10. `mut_value`: {:?}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Foo&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;u32&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;u32&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;u32&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c"&gt;// Try changing the values in the struct to see what happens&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Foo&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

    &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Foo&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"First of x is 1, b = {},  y = {} "&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;

        &lt;span class="c"&gt;// you can destructure structs and rename the variables,&lt;/span&gt;
        &lt;span class="c"&gt;// the order is not important&lt;/span&gt;
        &lt;span class="n"&gt;Foo&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"y is 2, i = {:?}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;

        &lt;span class="c"&gt;// and you can also ignore some variables:&lt;/span&gt;
        &lt;span class="n"&gt;Foo&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;..&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"y = {}, we don't care about x"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="c"&gt;// this will give an error: pattern does not mention field `x`&lt;/span&gt;
        &lt;span class="c"&gt;//Foo { y } =&amp;gt; println!("y = {}", y),&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;pair&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="c"&gt;// TODO ^ Try different values for `pair`&lt;/span&gt;

    &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Tell me about {:?}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pair&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="n"&gt;pair&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"These are twins"&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="c"&gt;// The ^ `if condition` part is a guard&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Antimatter, kaboom!"&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;_&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"The first one is odd"&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="mi"&gt;_&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"No correlation..."&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="c"&gt;// A function `age` which returns a `u32`.&lt;/span&gt;
&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;age&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;u32&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="mi"&gt;15&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Tell me what type of person you are"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="nf"&gt;age&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="mi"&gt;0&lt;/span&gt;             &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"I haven't celebrated my first birthday yet"&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="c"&gt;// Could `match` 1 ..= 12 directly but then what age&lt;/span&gt;
        &lt;span class="c"&gt;// would the child be? Instead, bind to `n` for the&lt;/span&gt;
        &lt;span class="c"&gt;// sequence of 1 ..= 12. Now the age can be reported.&lt;/span&gt;
        &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="o"&gt;..=&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"I'm a child of age {:?}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt; &lt;span class="mi"&gt;13&lt;/span&gt; &lt;span class="o"&gt;..=&lt;/span&gt; &lt;span class="mi"&gt;19&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"I'm a teen of age {:?}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="c"&gt;// Nothing bound. Return the result.&lt;/span&gt;
        &lt;span class="n"&gt;n&lt;/span&gt;             &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"I'm an old person of age {:?}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;if let: 在判断的同时 进行match&lt;/li&gt;
  &lt;li&gt;while let&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="functions"&gt;Functions:&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;methods: 依附于 对象的函数， 在methods 的block中，能够 通过self使用 对象的 数据&lt;/li&gt;
  &lt;li&gt;closures:  |val| {val + x}
    &lt;ul&gt;
      &lt;li&gt;Capturing： 捕获， 其可以 捕获环境中的 变量， 可以是： &amp;amp;T, &amp;amp;mut T , T（by value）&lt;/li&gt;
      &lt;li&gt;作为参数： 分为三类： Fn, FnMut, FnOnce， 对应ownership  的 &amp;amp;T, &amp;amp;mut T, T. Fn 可以无限次执行， FnMut 则要求 capture 变量的 mut 引用， FnOnce 则 只能执行一次&lt;/li&gt;
      &lt;li&gt;疑问：
        &lt;ol&gt;
          &lt;li&gt;如何 区分  Fn(i64, i64) -&amp;gt; i64 与Fn(&amp;amp;String) -&amp;gt; i64&lt;/li&gt;
          &lt;li&gt;FnOnce 是如何确定的， 有些函数，即便将变量 move 到了block中， 然而依然可以调用多次， 这些优势如何判断的？ 根据内部函数调用的 Fn 属性吗？ 比如mem::drop(p) 则 包含其调用的函数 则为 FnOnce?&lt;/li&gt;
          &lt;li&gt;如何断定 Cloosure 为 Fn or FnMut ?&lt;/li&gt;
        &lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;  &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;f64&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;f64&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="c"&gt;// Implementation block, all `Point` methods go in here&lt;/span&gt;
  &lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="c"&gt;// This is a static method&lt;/span&gt;
      &lt;span class="c"&gt;// Static methods don't need to be called by an instance&lt;/span&gt;
      &lt;span class="c"&gt;// These methods are generally used as constructors&lt;/span&gt;
      &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;origin&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
          &lt;span class="n"&gt;Point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;

      &lt;span class="c"&gt;// Another static method, taking two arguments:&lt;/span&gt;
      &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;f64&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;f64&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
          &lt;span class="n"&gt;Point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="modules"&gt;Modules:&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;mod visibility: mod 的可见性， mod 默认只能在本mod 可见， 需要使用 pub 来对外可见， 定义其中的fn， struct 使用同样的规则， 因为mod 可以nest， 所以 存在pub(self) (等同于private) pub(super) 即让super mod 可见,  而pub(crate)则让crate 可见&lt;/li&gt;
  &lt;li&gt;struct visibility: struct 中包含fn 以及 field，默认都为 对 所在 定义的mod可见， pub 则开放为对外部的 mod可见&lt;/li&gt;
  &lt;li&gt;mod vs struct: struct 的控制比较弱， mod的控制则相对复杂， struct 可能并不需要如此复杂的规则吧&lt;/li&gt;
  &lt;li&gt;关键字 use： 我们可以使用 use mod::struct as another_struct 来 减少路径的拼写， 使用as 更可以 启用别名&lt;/li&gt;
  &lt;li&gt;mod 的 使用类似于 Unix下的 目录 安排， super 代表 .. self 则代表 本mod&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="attributes-可以用来作什么-1-条件编译-2设定crate-属性-3关闭-warning-4启用编译器特性maros-etc-5-link-to-a-foreign-library-6-设定unit-test"&gt;Attributes: 可以用来作什么？ 1） 条件编译， 2）设定crate 属性， 3）关闭 warning 4)启用编译器特性(maros etc) 5） link to a foreign library 6) 设定unit test&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;形式： 当应用到 整个crate： #![crate_attribute], 应用到module 或者 item ： #[item_attribute]&lt;/li&gt;
  &lt;li&gt;还可以接受参数： 1) #[attribute = “value”] 2) #[attribute(key = “value”)] 3) #[attribute(value)]&lt;/li&gt;
  &lt;li&gt;示例：
    &lt;ul&gt;
      &lt;li&gt;#[allow(dead_code)]： 关闭rust 关于没有调用函数的提示&lt;/li&gt;
      &lt;li&gt;#![crate_name = “rary”]&lt;/li&gt;
      &lt;li&gt;cfg(Configuration):  1） #[cfg(…)] 条件编译  2） cfg!(…) 在运行阶段的条件判断， 返回bool值&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;   &lt;span class="c"&gt;// This function only gets compiled if the target OS is linux&lt;/span&gt;
   &lt;span class="nd"&gt;#[cfg(target_os&lt;/span&gt; &lt;span class="nd"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"linux"&lt;/span&gt;&lt;span class="nd"&gt;)]&lt;/span&gt;
   &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;are_you_on_linux&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
       &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"You are running linux!"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
   &lt;span class="p"&gt;}&lt;/span&gt;

   &lt;span class="c"&gt;// And this function only gets compiled if the target OS is *not* linux&lt;/span&gt;
   &lt;span class="nd"&gt;#[cfg(not(target_os&lt;/span&gt; &lt;span class="nd"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"linux"&lt;/span&gt;&lt;span class="nd"&gt;))]&lt;/span&gt;
   &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;are_you_on_linux&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
       &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"You are *not* running linux!"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
   &lt;span class="p"&gt;}&lt;/span&gt;

   &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
       &lt;span class="nf"&gt;are_you_on_linux&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

       &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Are you sure?"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
       &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nd"&gt;cfg!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;target_os&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"linux"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
           &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Yes. It's definitely linux!"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
       &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
           &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Yes. It's definitely *not* linux!"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
       &lt;span class="p"&gt;}&lt;/span&gt;
   &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
</content>
  </entry>
  <entry>
    <title>link compile</title>
    <link rel="alternate" href="http://geniousbar.github.io/2021/02/19/link-compile/"/>
    <id>http://geniousbar.github.io/2021/02/19/link-compile/</id>
    <published>2021-02-19T00:00:00+00:00</published>
    <updated>2021-04-19T08:29:22+00:00</updated>
    <summary type="html">&lt;h2 id="link--compile"&gt;link &amp;amp; compile&lt;/h2&gt;

&lt;h3 id="为什么c语言中的-header-file-h-一定需要-防止重复被include-呢-而为什么一定需要-header-file的存在呢"&gt;为什么c语言中的 header file *.h 一定需要 防止重复被include 呢？ 而为什么一定需要 header file的存在呢？&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;header file 需要存在原因有： 1） .c 文件 变为可执行文件，需要 编译、链接 两个阶段， 而链接中 是可以将 不同的 类型编译过的文件进行 链接的。 随着程序的复杂， 比如 函数参数的 传递顺序等 原因导致，需要 程序调用者 知道 函数调用的结构， 所以 [[https://www.zhihu.com...&lt;/li&gt;
&lt;/ul&gt;</summary>
    <content type="html">&lt;h2 id="link--compile"&gt;link &amp;amp; compile&lt;/h2&gt;

&lt;h3 id="为什么c语言中的-header-file-h-一定需要-防止重复被include-呢-而为什么一定需要-header-file的存在呢"&gt;为什么c语言中的 header file *.h 一定需要 防止重复被include 呢？ 而为什么一定需要 header file的存在呢？&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;header file 需要存在原因有： 1） .c 文件 变为可执行文件，需要 编译、链接 两个阶段， 而链接中 是可以将 不同的 类型编译过的文件进行 链接的。 随着程序的复杂， 比如 函数参数的 传递顺序等 原因导致，需要 程序调用者 知道 函数调用的结构， 所以 [[https://www.zhihu.com/question/280665935][链接]] 2) 如果依赖于系统中的系统库，比如标准库中的系统调用，则只能使用inluce header file 来进行使用，即：被调用方 是已经编译好的文件格式&lt;/li&gt;
  &lt;li&gt;为什么 header file一定需要 预防被重复加载呢？： 经过测试发现，在 header file 中不存在 struct 定义的时候，只是简单的 func 定义的时候， 重复包含并没有问题， 然而在 定义 struct的时候 则出现了 重复定义问题。 而问题也只是出现了 gcc -c 的阶段， 在gcc -E gcc -S 阶段 依然没有任何问题，所以 关于 为什么一定需要 #ifndef #define code …  #endif 的格式，则需要 在gcc 中寻找&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="c-语言-到可执行文件的过程"&gt;C 语言 到可执行文件的过程&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;预处理(Preprocessing)&lt;/li&gt;
  &lt;li&gt;编译(Compilation)&lt;/li&gt;
  &lt;li&gt;汇编(Assembly)&lt;/li&gt;
  &lt;li&gt;链接(Linking): 链接过程主要包括了：
    &lt;ul&gt;
      &lt;li&gt;地址和空间分配&lt;/li&gt;
      &lt;li&gt;符号决议&lt;/li&gt;
      &lt;li&gt;重定位： 当存在a.c 依赖 b.c 的函数时候， 文件是单独编译的，并非 将b.c 的中内容 插入到 a.c 中，然后进行整体编译。所以导致 a.c 中并不知道 b.c 中函数 变量的存在， 所以 在编译 a.c时候， 函数调用 都会 call 0， 函数地址 需要 在链接时候 进行确定，并修改 （即是重定位）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="elf-文件的类型"&gt;elf 文件的类型：&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;type&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
      &lt;th&gt;实例&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;可重定位文件(Relocatable File)&lt;/td&gt;
      &lt;td&gt;可以被可执行文件或 共享目标文件 链接&lt;/td&gt;
      &lt;td&gt;Linux: .o&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;可执行文件(Executable File)&lt;/td&gt;
      &lt;td&gt;可执行程序, 一般没有 扩展名&lt;/td&gt;
      &lt;td&gt;Linux: /bin/bash Windows .exe&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;共享目标文件(Shared Object File )&lt;/td&gt;
      &lt;td&gt;1） 可被 其他 可重定位文件 、共享文件 连接成 目标文件 2） 动态链接器 将其与可执行文件结合，映射为 进程的一部分&lt;/td&gt;
      &lt;td&gt;Linux: .so, Windows: DLL&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;核心转储文件(Core Dump File)&lt;/td&gt;
      &lt;td&gt;进程意外终止时候， 系统可以 将进程的地址空间内容 等信息 转储到  该文件中&lt;/td&gt;
      &lt;td&gt;Linux: core dump&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;vagrant@precise64:/vagrant_data/link_test&lt;span class="nv"&gt;$ &lt;/span&gt;file a.out
a.out: ELF 64-bit LSB executable, x86-64, version 1 &lt;span class="o"&gt;(&lt;/span&gt;SYSV&lt;span class="o"&gt;)&lt;/span&gt;, dynamically linked &lt;span class="o"&gt;(&lt;/span&gt;uses shared libs&lt;span class="o"&gt;)&lt;/span&gt;, &lt;span class="k"&gt;for &lt;/span&gt;GNU/Linux 2.6.24, BuildID[sha1]&lt;span class="o"&gt;=&lt;/span&gt;0x91de252bc2c3703aa5c324e5176b05e6b36a5bfa, not stripped

vagrant@precise64:/vagrant_data/link_test&lt;span class="nv"&gt;$ &lt;/span&gt;file main.o
main.o: ELF 64-bit LSB relocatable, x86-64, version 1 &lt;span class="o"&gt;(&lt;/span&gt;SYSV&lt;span class="o"&gt;)&lt;/span&gt;, not stripped
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="深入-o-文件"&gt;深入 .o 文件&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;可用工具有： 1) objdump, 2) readelf, 3) nm&lt;/li&gt;
  &lt;li&gt;elf 因为 存在段(section) ，而段 是变长的，导致 没有固定的映射方法，所以 Header 为固定长度 异常重要， Header 中存在 多少个段（Number of section headers），  段表偏移(Start of section headers:) 的关键信息， 来使 c代码能够将 段表（section table） 映射到代码中&lt;/li&gt;
  &lt;li&gt;objdump -h main.o&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;
int main&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  int a &lt;span class="o"&gt;=&lt;/span&gt; 10&lt;span class="p"&gt;;&lt;/span&gt;
  name&lt;span class="o"&gt;(&lt;/span&gt;a&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

vagrant@precise64:/vagrant_data/link_test&lt;span class="nv"&gt;$ &lt;/span&gt;objdump &lt;span class="nt"&gt;-h&lt;/span&gt; main.o

main.o:     file format elf64-x86-64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000020  0000000000000000  0000000000000000  00000040  2&lt;span class="k"&gt;**&lt;/span&gt;2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  0000000000000000  0000000000000000  00000060  2&lt;span class="k"&gt;**&lt;/span&gt;2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  0000000000000000  0000000000000000  00000060  2&lt;span class="k"&gt;**&lt;/span&gt;2
                  ALLOC
  3 .comment      0000002b  0000000000000000  0000000000000000  00000060  2&lt;span class="k"&gt;**&lt;/span&gt;0
                  CONTENTS, READONLY
  4 .note.GNU-stack 00000000  0000000000000000  0000000000000000  0000008b  2&lt;span class="k"&gt;**&lt;/span&gt;0
                  CONTENTS, READONLY
  5 .eh_frame     00000038  0000000000000000  0000000000000000  00000090  2&lt;span class="k"&gt;**&lt;/span&gt;3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
vagrant@precise64:/vagrant_data/link_test&lt;span class="nv"&gt;$ &lt;/span&gt;readelf &lt;span class="nt"&gt;-h&lt;/span&gt; main.o
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF64
  Data:                              2&lt;span class="s1"&gt;'s complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              REL (Relocatable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x0
  Start of program headers:          0 (bytes into file)
  Start of section headers:          296 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           0 (bytes)
  Number of program headers:         0
  Size of section headers:           64 (bytes)
  Number of section headers:         12
  Section header string table index: 9

//  注意 在 文件中添加 了 全局变量之后 .data 文件 的size 变大了。
int b = 10;
int main() {
  int a = 10;
  name(a);
}


vagrant@precise64:/vagrant_data/link_test$ objdump -h main.o

main.o:     file format elf64-x86-64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000020  0000000000000000  0000000000000000  00000040  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000004  0000000000000000  0000000000000000  00000060  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  0000000000000000  0000000000000000  00000064  2**2
                  ALLOC
  3 .comment      0000002b  0000000000000000  0000000000000000  00000064  2**0
                  CONTENTS, READONLY
  4 .note.GNU-stack 00000000  0000000000000000  0000000000000000  0000008f  2**0
                  CONTENTS, READONLY
  5 .eh_frame     00000038  0000000000000000  0000000000000000  00000090  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA

vagrant@precise64:/vagrant_data/link_test$ size main.o
   text	   data	    bss	    dec	    hex	filename
     88	      4	      0	     92	     5c	main.o

&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="objdump--s--d-maino-其中---s--将各个段-都打印出来--d-则将-代码段反汇编"&gt;objdump -s -d main.o 其中  -s  将各个段 都打印出来， -d 则将 代码段反汇编&lt;/h4&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;vagrant@precise64:/vagrant_data/link_test&lt;span class="nv"&gt;$ &lt;/span&gt;objdump &lt;span class="nt"&gt;-s&lt;/span&gt; &lt;span class="nt"&gt;-d&lt;/span&gt; main.o

main.o:     file format elf64-x86-64

Contents of section .text:
 0000 554889e5 4883ec10 c745fc0a 0000008b  UH..H....E......
 0010 45fc89c7 b8000000 00e80000 0000c9c3  E...............
Contents of section .data:
 0000 0a000000                             ....
Contents of section .comment:
 0000 00474343 3a202855 62756e74 752f4c69  .GCC: &lt;span class="o"&gt;(&lt;/span&gt;Ubuntu/Li
 0010 6e61726f 20342e36 2e332d31 7562756e  naro 4.6.3-1ubun
 0020 74753529 20342e36 2e3300             tu5&lt;span class="o"&gt;)&lt;/span&gt; 4.6.3.
Contents of section .eh_frame:
 0000 14000000 00000000 017a5200 01781001  .........zR..x..
 0010 1b0c0708 90010000 1c000000 1c000000  ................
 0020 00000000 20000000 00410e10 8602430d  .... ....A....C.
 0030 065b0c07 08000000                    .[......

Disassembly of section .text:

0000000000000000 &amp;lt;main&amp;gt;:
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    &lt;span class="nv"&gt;$0x10&lt;/span&gt;,%rsp
   8:	c7 45 &lt;span class="nb"&gt;fc &lt;/span&gt;0a 00 00 00 	movl   &lt;span class="nv"&gt;$0xa&lt;/span&gt;,-0x4&lt;span class="o"&gt;(&lt;/span&gt;%rbp&lt;span class="o"&gt;)&lt;/span&gt;
   f:	8b 45 &lt;span class="nb"&gt;fc             	&lt;/span&gt;mov    &lt;span class="nt"&gt;-0x4&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;%rbp&lt;span class="o"&gt;)&lt;/span&gt;,%eax
  12:	89 c7                	mov    %eax,%edi
  14:	b8 00 00 00 00       	mov    &lt;span class="nv"&gt;$0x0&lt;/span&gt;,%eax
  19:	e8 00 00 00 00       	callq  1e &amp;lt;main+0x1e&amp;gt;
  1e:	c9                   	leaveq
  1f:	c3                   	retq
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;重定位表：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;  vagrant@precise64:/vagrant_data/link_test&lt;span class="nv"&gt;$ &lt;/span&gt;readelf &lt;span class="nt"&gt;-S&lt;/span&gt; main.o
There are 12 section headers, starting at offset 0x128:

Section Headers:
  &lt;span class="o"&gt;[&lt;/span&gt;Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  &lt;span class="o"&gt;[&lt;/span&gt; 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  &lt;span class="o"&gt;[&lt;/span&gt; 1] .text             PROGBITS         0000000000000000  00000040
       0000000000000020  0000000000000000  AX       0     0     4
  &lt;span class="o"&gt;[&lt;/span&gt; 2] .rela.text        RELA             0000000000000000  00000548
       0000000000000018  0000000000000018          10     1     8
  &lt;span class="o"&gt;[&lt;/span&gt; 3] .data             PROGBITS         0000000000000000  00000060
       0000000000000004  0000000000000000  WA       0     0     4
  &lt;span class="o"&gt;[&lt;/span&gt; 4] .bss              NOBITS           0000000000000000  00000064
       0000000000000000  0000000000000000  WA       0     0     4
  &lt;span class="o"&gt;[&lt;/span&gt; 5] .comment          PROGBITS         0000000000000000  00000064
       000000000000002b  0000000000000001  MS       0     0     1
  &lt;span class="o"&gt;[&lt;/span&gt; 6] .note.GNU-stack   PROGBITS         0000000000000000  0000008f
       0000000000000000  0000000000000000           0     0     1
  &lt;span class="o"&gt;[&lt;/span&gt; 7] .eh_frame         PROGBITS         0000000000000000  00000090
       0000000000000038  0000000000000000   A       0     0     8
  &lt;span class="o"&gt;[&lt;/span&gt; 8] .rela.eh_frame    RELA             0000000000000000  00000560
       0000000000000018  0000000000000018          10     7     8
  &lt;span class="o"&gt;[&lt;/span&gt; 9] .shstrtab         STRTAB           0000000000000000  000000c8
       0000000000000059  0000000000000000           0     0     1
  &lt;span class="o"&gt;[&lt;/span&gt;10] .symtab           SYMTAB           0000000000000000  00000428
       0000000000000108  0000000000000018          11     8     8
  &lt;span class="o"&gt;[&lt;/span&gt;11] .strtab           STRTAB           0000000000000000  00000530
       0000000000000014  0000000000000000           0     0     1
Key to Flags:
  W &lt;span class="o"&gt;(&lt;/span&gt;write&lt;span class="o"&gt;)&lt;/span&gt;, A &lt;span class="o"&gt;(&lt;/span&gt;alloc&lt;span class="o"&gt;)&lt;/span&gt;, X &lt;span class="o"&gt;(&lt;/span&gt;execute&lt;span class="o"&gt;)&lt;/span&gt;, M &lt;span class="o"&gt;(&lt;/span&gt;merge&lt;span class="o"&gt;)&lt;/span&gt;, S &lt;span class="o"&gt;(&lt;/span&gt;strings&lt;span class="o"&gt;)&lt;/span&gt;, l &lt;span class="o"&gt;(&lt;/span&gt;large&lt;span class="o"&gt;)&lt;/span&gt;
  I &lt;span class="o"&gt;(&lt;/span&gt;info&lt;span class="o"&gt;)&lt;/span&gt;, L &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;link &lt;/span&gt;order&lt;span class="o"&gt;)&lt;/span&gt;, G &lt;span class="o"&gt;(&lt;/span&gt;group&lt;span class="o"&gt;)&lt;/span&gt;, T &lt;span class="o"&gt;(&lt;/span&gt;TLS&lt;span class="o"&gt;)&lt;/span&gt;, E &lt;span class="o"&gt;(&lt;/span&gt;exclude&lt;span class="o"&gt;)&lt;/span&gt;, x &lt;span class="o"&gt;(&lt;/span&gt;unknown&lt;span class="o"&gt;)&lt;/span&gt;
  O &lt;span class="o"&gt;(&lt;/span&gt;extra OS processing required&lt;span class="o"&gt;)&lt;/span&gt; o &lt;span class="o"&gt;(&lt;/span&gt;OS specific&lt;span class="o"&gt;)&lt;/span&gt;, p &lt;span class="o"&gt;(&lt;/span&gt;processor specific&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;在列表中，有 type 为RELA  或者 REL  的 rela.text, 为重定位表， main.c 中 调用了一个name 函数， name 存在于name.c 文件中， 链接器在 连接时候，需要 将main.o 中的函数调用 处理为 name.o 中的地址， 其中info 为指向需要重定位的 section index&lt;/li&gt;
  &lt;li&gt;每个需要重定位的段，都需要 一个相应的重定位表， 比如 .text 则为 .rela.text, .eh_frmae .rela.eh_frame,&lt;/li&gt;
  &lt;li&gt;字符串表：因为字符串为变长，比较难映射 所以单独存放一个 段。 .strtab .shstrtab, 类型为 strtab (String table )， .strtab  为 字符串表 用来存储 普通的字符串， 比如符号的名字， .shstrtab 则为 （section header string table） 段表字符串表， 用来保存段表 中 用到的字符串 比如段名&lt;/li&gt;
  &lt;li&gt;对比 header 中的 Section header string table index: 9 项， 正好 为 .shstrtab 在section table中的下标
    &lt;h3 id="符号"&gt;符号&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;符号是， 链接过程中重要的信息数据， 链接过程中  目标文件的相互拼接： 实际上 就是目标文件之间对地址的引用， 即对函数 变量地址的引用。比如 B 需要用到 A中的函数foo， 则是： A中定义了 函数foo， B 引用了 A中的函数foo, 概念同样适用变量，&lt;/li&gt;
  &lt;li&gt;链接中，我们称  函数和变量为符号，函数名 变量名则是 符号名。&lt;/li&gt;
  &lt;li&gt;每个文件中 都包含 函数表， 记录了 文件中使用的所有符号，每个定义的符号都有对应的条目，其中包含符号值， 对于变量和函数来说，符号值 则为 其地址。&lt;/li&gt;
  &lt;li&gt;符号 可能包含的有 以下类型：
    &lt;ol&gt;
      &lt;li&gt;定义在本文件中的全局符号，函数 等，可以被其他文件 引用。 比如: 函数 main, name,&lt;/li&gt;
      &lt;li&gt;外部符号： 再本文件中引用的全局符号，并未在本文件中定义&lt;/li&gt;
      &lt;li&gt;段名： 其数值为 该段的其实地址， 编译器所加。&lt;/li&gt;
      &lt;li&gt;局部符号： 只在该文件中可见，比如static 变量&lt;/li&gt;
      &lt;li&gt;行号信息： 目标文件指令 与 源代码 的对应关系. debug 模式下 会创建 不少的 该类信息 在 符号表中&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;vagrant@precise64:/vagrant_data/link_test&lt;span class="nv"&gt;$ &lt;/span&gt;readelf &lt;span class="nt"&gt;-s&lt;/span&gt; main.o

Symbol table &lt;span class="s1"&gt;'.symtab'&lt;/span&gt; contains 11 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND
     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS main.c
     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1
     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3
     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4
     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    6
     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    7
     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    5
     8: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    3 b
     9: 0000000000000000    32 FUNC    GLOBAL DEFAULT    1 main
    10: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND name  


vagrant@precise64:/vagrant_data/link_test&lt;span class="nv"&gt;$ &lt;/span&gt;objdump &lt;span class="nt"&gt;-t&lt;/span&gt; main.o

main.o:     file format elf64-x86-64

SYMBOL TABLE:
0000000000000000 l    &lt;span class="nb"&gt;df&lt;/span&gt; &lt;span class="k"&gt;*&lt;/span&gt;ABS&lt;span class="k"&gt;*&lt;/span&gt;	0000000000000000 main.c
0000000000000000 l    d  .text	0000000000000000 .text
0000000000000000 l    d  .data	0000000000000000 .data
0000000000000000 l    d  .bss	0000000000000000 .bss
0000000000000000 l    d  .note.GNU-stack	0000000000000000 .note.GNU-stack
0000000000000000 l    d  .eh_frame	0000000000000000 .eh_frame
0000000000000000 l    d  .comment	0000000000000000 .comment
0000000000000000 g     O .data	0000000000000004 b
0000000000000000 g     F .text	0000000000000020 main
0000000000000000         &lt;span class="k"&gt;*&lt;/span&gt;UND&lt;span class="k"&gt;*&lt;/span&gt;	0000000000000000 name
&lt;span class="c"&gt;#+end_src&lt;/span&gt;

&lt;span class="c"&gt;#### 相似段合并：&lt;/span&gt;

&lt;span class="sb"&gt;```&lt;/span&gt;shell
vagrant@precise64:/vagrant_data/link_test&lt;span class="nv"&gt;$ &lt;/span&gt;objdump &lt;span class="nt"&gt;-h&lt;/span&gt; main.o

main.o:     file format elf64-x86-64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000020  0000000000000000  0000000000000000  00000040  2&lt;span class="k"&gt;**&lt;/span&gt;2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000004  0000000000000000  0000000000000000  00000060  2&lt;span class="k"&gt;**&lt;/span&gt;2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  0000000000000000  0000000000000000  00000064  2&lt;span class="k"&gt;**&lt;/span&gt;2
                  ALLOC
  3 .comment      0000002b  0000000000000000  0000000000000000  00000064  2&lt;span class="k"&gt;**&lt;/span&gt;0
                  CONTENTS, READONLY
  4 .note.GNU-stack 00000000  0000000000000000  0000000000000000  0000008f  2&lt;span class="k"&gt;**&lt;/span&gt;0
                  CONTENTS, READONLY
  5 .eh_frame     00000038  0000000000000000  0000000000000000  00000090  2&lt;span class="k"&gt;**&lt;/span&gt;3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
vagrant@precise64:/vagrant_data/link_test&lt;span class="nv"&gt;$ &lt;/span&gt;objdump &lt;span class="nt"&gt;-h&lt;/span&gt; name.o

name.o:     file format elf64-x86-64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         0000000f  0000000000000000  0000000000000000  00000040  2&lt;span class="k"&gt;**&lt;/span&gt;2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  0000000000000000  0000000000000000  00000050  2&lt;span class="k"&gt;**&lt;/span&gt;2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  0000000000000000  0000000000000000  00000050  2&lt;span class="k"&gt;**&lt;/span&gt;2
                  ALLOC
  3 .comment      0000002b  0000000000000000  0000000000000000  00000050  2&lt;span class="k"&gt;**&lt;/span&gt;0
                  CONTENTS, READONLY
  4 .note.GNU-stack 00000000  0000000000000000  0000000000000000  0000007b  2&lt;span class="k"&gt;**&lt;/span&gt;0
                  CONTENTS, READONLY
  5 .eh_frame     00000038  0000000000000000  0000000000000000  00000080  2&lt;span class="k"&gt;**&lt;/span&gt;3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA

ld main.o  name.o &lt;span class="nt"&gt;-e&lt;/span&gt; main &lt;span class="nt"&gt;-o&lt;/span&gt; ab                  
vagrant@precise64:/vagrant_data/link_test&lt;span class="nv"&gt;$ &lt;/span&gt;objdump &lt;span class="nt"&gt;-h&lt;/span&gt; ab

ab:     file format elf64-x86-64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         0000002f  00000000004000e8  00000000004000e8  000000e8  2&lt;span class="k"&gt;**&lt;/span&gt;2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .eh_frame     00000058  0000000000400118  0000000000400118  00000118  2&lt;span class="k"&gt;**&lt;/span&gt;3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .data         00000004  0000000000600170  0000000000600170  00000170  2&lt;span class="k"&gt;**&lt;/span&gt;2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .comment      0000002a  0000000000000000  0000000000000000  00000174  2&lt;span class="k"&gt;**&lt;/span&gt;0
                  CONTENTS, READONLY

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;ld main.o  name.o -e main -o ab&lt;/li&gt;
  &lt;li&gt;注意 VMA LMA:  VMA (Virtual Memory Address) 为 虚拟地址， LMA( Load Memory Address) 即 加载地址， 一般情况下两个数值 都是一样的，有些切入式系统中 两个数值不同。&lt;/li&gt;
  &lt;li&gt;链接器为 目标文件 分配 地址和空间 的理解： 其中地址和空间 含义有两个： 1）输出的可执行文件的空间， 2） 装载后的虚拟地址中的虚拟地址空间， 对于 .text .data 来说， 他们在 文件中 和 虚拟地址 中都有分配空间， .bss 则 仅在 虚拟地址空间中存在。其中 虚拟地址 关系到 链接器对于 地址的重新计算
    &lt;h4 id="链接-步骤-两部链接"&gt;链接 步骤: 两部链接&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;空间和地址分配：
        &lt;ul&gt;
          &lt;li&gt;扫描所有的输入文件，获得各个段的长度、属性、位置。&lt;/li&gt;
          &lt;li&gt;将输入文件中的符号 定义 和符号引用 收集起来，统一为一个 全局符号表&lt;/li&gt;
          &lt;li&gt;合并所有的输入文件的相似段，计算各个合并后的段的长度和位置，并建立映射关系&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;符号解析 与重定位： 链接过程的核心 过程
        &lt;ul&gt;
          &lt;li&gt;读取输入文件中的段的数据、重定位信息、进行符号解析与重定位 调整代码中的地址等&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="重定位表-用来提供-给链接器-关于重定位-的相关信息-比如那些需要被调整怎样调整-重定位表-即用来专门提供这些信息"&gt;重定位表： 用来提供 给链接器 关于重定位 的相关信息， 比如那些需要被调整，怎样调整？ 重定位表 即用来专门提供这些信息&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;每个 需要 包含需要被重定位符号的 段，都有一个对应的 重定位表。 比如 .text 则赌赢 .rel.text&lt;/li&gt;
  &lt;li&gt;重定位表结构：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;   vagrant@precise64:/vagrant_data/link_test&lt;span class="nv"&gt;$ &lt;/span&gt;objdump &lt;span class="nt"&gt;-r&lt;/span&gt; main.o

main.o:     file format elf64-x86-64

RELOCATION RECORDS FOR &lt;span class="o"&gt;[&lt;/span&gt;.text]:
OFFSET           TYPE              VALUE
000000000000001a R_X86_64_PC32     name-0x0000000000000004


RELOCATION RECORDS FOR &lt;span class="o"&gt;[&lt;/span&gt;.eh_frame]:
OFFSET           TYPE              VALUE
0000000000000020 R_X86_64_PC32     .text



vagrant@precise64:/vagrant_data/link_test&lt;span class="nv"&gt;$ &lt;/span&gt;objdump &lt;span class="nt"&gt;-d&lt;/span&gt; main.o

main.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &amp;lt;main&amp;gt;:
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    &lt;span class="nv"&gt;$0x10&lt;/span&gt;,%rsp
   8:	c7 45 &lt;span class="nb"&gt;fc &lt;/span&gt;0a 00 00 00 	movl   &lt;span class="nv"&gt;$0xa&lt;/span&gt;,-0x4&lt;span class="o"&gt;(&lt;/span&gt;%rbp&lt;span class="o"&gt;)&lt;/span&gt;
   f:	8b 45 &lt;span class="nb"&gt;fc             	&lt;/span&gt;mov    &lt;span class="nt"&gt;-0x4&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;%rbp&lt;span class="o"&gt;)&lt;/span&gt;,%eax
  12:	89 c7                	mov    %eax,%edi
  14:	b8 00 00 00 00       	mov    &lt;span class="nv"&gt;$0x0&lt;/span&gt;,%eax
  19:	e8 00 00 00 00       	callq  1e &amp;lt;main+0x1e&amp;gt;
  1e:	c9                   	leaveq
  1f:	c3                   	retq

因为  main中 存在对 外部函数&lt;span class="o"&gt;(&lt;/span&gt;name.c 中name &lt;span class="o"&gt;)&lt;/span&gt; 的调用，所以 call name 命令 的地址 需要被 ld 调整修改，即是 .rel.text 段中需要记录的信息. 在  重定位表 中， offset 代表 改需要被重定位的符号，在段中的偏移，
main.o 中的 rel.text name中的offset 为1a， 即是 main.o 中的代码段 callq 的地址部分。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h5 id="common--块"&gt;common  块&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;符号抉择： 如果链接的输入文件中， 存在多个相同的符号类型，该如何选择？  因为链接器本身并不支持符号类型， 变量，函数定义对于编译器 是透明的。&lt;/li&gt;
  &lt;li&gt;符号类型 不一致的情况 主要由如下三点：
    &lt;ul&gt;
      &lt;li&gt;
        &lt;ol&gt;
          &lt;li&gt;两个或者两个以上的 强符号类型不一致&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;ol&gt;
          &lt;li&gt;有一个强符号，其他都是 弱符号， 出现类型不一致&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;ol&gt;
          &lt;li&gt;两个或两个以上 弱符号类型不一致&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;对于1  无额外处理，即： 链接器直接抛出错误。 2， 3 情况 则需要 common块（common block）机制 来进行处理， common块 很简单， 当不同的 目标文件需要的common块 空间大小不一致时， 以最大的那块为准&lt;/li&gt;
      &lt;li&gt;弱符号： 即是非强符号， 强符号有： 函数定义， 全局变量， 初始化的内部变量，&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ABI： ld 能不能 链接 两个不同编译器 编译出来的目标文件呢？ 能够 满足的条件的目标文件 需要满足如下条件：
    &lt;ul&gt;
      &lt;li&gt;采用相同的文件格式&lt;/li&gt;
      &lt;li&gt;同样的符号修饰标准&lt;/li&gt;
      &lt;li&gt;变量的内存分布方式相同(大端、小端)&lt;/li&gt;
      &lt;li&gt;函数的调用方式相同 （参数push stack的顺序， 是否 使用 寄存器代替stack ）&lt;/li&gt;
      &lt;li&gt;etc…&lt;/li&gt;
      &lt;li&gt;规范这些的即是 二进制兼容性 ABI  (Application Binary Interface)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="静态链接-一种语言的开发环境-往往带有语言库这些苦-就是对操作系统的api-封装其实一个静态库可以简单的堪称一组目标文件的集合很多目标文件经过压缩打包后-形成的一个文件-比如linux-下-usrliblibca"&gt;静态链接: 一种语言的开发环境 往往带有语言库，这些苦 就是对操作系统的api 封装，其实一个静态库可以简单的堪称一组目标文件的集合，很多目标文件经过压缩打包后 形成的一个文件， 比如linux 下 /usr/lib/libc.a&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;glic 本身是c语言开发的， 他有上千个 C语言源代码文件组成， 编译完成后 有相同数量的 目标文件（上千个） 比如 printf.o scanf.o fread.o&lt;/li&gt;
  &lt;li&gt;把这些零散的目标文件直接提供给 开发者，造成组织上的不便， 人们采用 ar 压缩程序将目标文件组合到一起，并对其进行编号索引，以便于查找和检索，形成了lib.a 静态库文件.&lt;/li&gt;
  &lt;li&gt;可以使用ar -t libc.a 来查看文件&lt;/li&gt;
  &lt;li&gt;gcc -static –verbose main.c 可以打印详细的 编译过程&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="链接脚本控制-即是-控制ld-参数的方式"&gt;链接脚本控制： 即是 控制ld 参数的方式：&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;使用命令行指定参数， 比如ld -e -o&lt;/li&gt;
  &lt;li&gt;将连接指令存放在目标文件中， 编译器 会通过此类方法 向链接器 传递指令，比如visual c++ 将参数 放在 PE目标文件的 .drectve 段&lt;/li&gt;
  &lt;li&gt;链接控制脚本， 单独将连接配置放到一个 .lds 文件中， 详细的内容 需要查看参考资料&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="动态连接-页映射"&gt;动态连接: 页映射，&lt;/h3&gt;
&lt;h4 id="装载的方式-程序执行时所需要的指令和数据-都必须在内存中-才能够正常运行将程序的指令和数据-装载到内存中-就称为-装载覆盖装入overlay-和页面映射-paging-是典型的两种装载方法"&gt;装载的方式： 程序执行时所需要的指令和数据 都必须在内存中 才能够正常运行。将程序的指令和数据 装载到内存中 就称为 装载。覆盖装入（overlay） 和页面映射 (Paging) 是典型的两种装载方法。&lt;/h4&gt;
&lt;h5 id="页映射"&gt;页映射：&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;将内存和磁盘中的 数据和指令 按照 页（page） 为单位划分为若干个页，即 装载和操作的单位是页。&lt;/li&gt;
  &lt;li&gt;操作系统角度看 可执行文件的装载：&lt;/li&gt;
  &lt;li&gt;在 程序中使用物理地址直接进行操作时，都需要硬件的MMU 进行 虚拟地址 到 page 的地址转换功能，&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="进程的建立"&gt;进程的建立：&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;创建一个独立的虚拟地址空间
        &lt;ul&gt;
          &lt;li&gt;只需要分配一个页目录 即可， 甚至不需要设定页面映射关系，可以等到后面程序发生页错误的时候 在进行设置&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;读取可执行文件头， 并建立 虚拟空间到 可执行文件的映射关系
        &lt;ul&gt;
          &lt;li&gt;虚拟空间 与 可执行文件的映射关系。 当 发生缺页错误时，操作系统 应该知道 当前所需页 在可执行文件中的哪一个位置，这就是这步骤的目的&lt;/li&gt;
          &lt;li&gt;该数据结构 只保存在 操作系统内部，Linux 将 进程虚拟空间中的一个段 叫做 虚拟内存区域(virtual Memory Area)  操作系统创建进程后&lt;/li&gt;
          &lt;li&gt;会在进程相应的数据结构中设定一个 .text 段的VMA&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;将CPU 的PIC 寄存器 设定为 可执行文件的文件入口地址， 启动运行
        &lt;ul&gt;
          &lt;li&gt;操作系统通过设定CPU的执行寄存器将控制权交给 进程，由此进程开始执行。 看似简单，操作系统层面比较复杂， 涉及到内核堆栈到用户堆栈的切换，CPU运行权限的切换， 等&lt;/li&gt;
          &lt;li&gt;进程角度则 认为操作系统执行了一个跳转指令 到 可执行文件的入口地址， ELF 文件头中的 入口地址&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="进程虚拟空间分布"&gt;进程虚拟空间分布：&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;elf 文件 链接视图 与 执行视图&lt;/li&gt;
  &lt;li&gt;elf 映射到 内存时， 当段的数量增多，就会 产生空间浪费问题， 因为 是以系统的页大小问映射单位，段 映射的长度都是系统页的整数倍。如果不是，那么段 多余的部分也将映射 一个页，那么如何减少空间浪费呢？&lt;/li&gt;
  &lt;li&gt;操作系统视角看 可执行文件，我并不关心 文件的 各个段的内容，我们只关心与装载相关的 权限问题 （即 段是否可以被修改，共享等）， 对于相同权限的段，我们将他们合并到一起当做 一个段进行映射，比如.text .init。 段的权限组合有以下几种：&lt;/li&gt;
  &lt;li&gt;以代码段 为代表的权限为 可读可执行的段&lt;/li&gt;
  &lt;li&gt;以数据段和bss段为代表的权限为 可读可写的段&lt;/li&gt;
  &lt;li&gt;以只读数据段为代表的权限为 只读的段&lt;/li&gt;
  &lt;li&gt;Segment: elf 引入segment，一个segment 包含一个或多个属性类型的section，将.text 与 .init 段合并在一起看做一个 segment&lt;/li&gt;
  &lt;li&gt;装载时候就可以 一起映射。也就说 映射以后 在进程的虚拟空间中 只有一个对应的VMA， 这样的好处就是 明显的减少了 页面的内部碎片&lt;/li&gt;
  &lt;li&gt;Segment 概念实际上上从 装载的角度 重新划分elf 的各个段， 将目标文件连接成可执行文件的时候，链接器会尽量将相同权限属性的各个段 分配在同一Sgemtn中&lt;/li&gt;
  &lt;li&gt;而系统正式按照Segment 而不是section进行映射的&lt;/li&gt;
  &lt;li&gt;再看了通篇 概念之后，我们可能会问， 为什么 最后要按照 segment 把文件组合呢？ 在前面的 重定位 章节中，我们以为 地址的计算是按照 合并各个段 然后进行计算的，&lt;/li&gt;
  &lt;li&gt;其实不是的， &lt;em&gt; VMA 即是最后的 虚拟地址， 重定位的 地址计算也是按照 VMA 得来的。也即是说 链接最后的结果 就是 装载视图。链接视图只是其中的过程而已。&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;描述 segment 的 结构叫做程序头 (Program Header ) 描述了 elf文件该如何被操作系统 映射到进程的 虚拟空间。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id="堆栈在进程的虚拟空间中同样是以-vma-存在的-很多情况下一个进程的堆和栈-都有一个对应的vma-linux可以通过proc-来查看进程的-虚拟空间分布"&gt;堆栈：在进程的虚拟空间中，同样是以 VMA 存在的， 很多情况下，一个进程的堆和栈 都有一个对应的VMA， Linux可以通过/proc 来查看进程的 虚拟空间分布&lt;/h5&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;vagrant@precise64:/vagrant_data/link_test&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;sleep &lt;/span&gt;100 &amp;amp;
&lt;span class="o"&gt;[&lt;/span&gt;1] 3834
vagrant@precise64:/vagrant_data/link_test&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;cat&lt;/span&gt; /proc/3834/maps
00400000-00406000 r-xp 00000000 &lt;span class="nb"&gt;fc&lt;/span&gt;:00 2359461                            /bin/sleep
00605000-00606000 r--p 00005000 &lt;span class="nb"&gt;fc&lt;/span&gt;:00 2359461                            /bin/sleep
00606000-00607000 rw-p 00006000 &lt;span class="nb"&gt;fc&lt;/span&gt;:00 2359461                            /bin/sleep
01ee5000-01f06000 rw-p 00000000 00:00 0                                  &lt;span class="o"&gt;[&lt;/span&gt;heap]
7fba0d791000-7fba0da96000 r--p 00000000 &lt;span class="nb"&gt;fc&lt;/span&gt;:00 3413573                    /usr/lib/locale/locale-archive
7fba0da96000-7fba0dc4d000 r-xp 00000000 &lt;span class="nb"&gt;fc&lt;/span&gt;:00 2752737                    /lib/x86_64-linux-gnu/libc-2.15.so
7fba0dc4d000-7fba0de4c000 &lt;span class="nt"&gt;---p&lt;/span&gt; 001b7000 &lt;span class="nb"&gt;fc&lt;/span&gt;:00 2752737                    /lib/x86_64-linux-gnu/libc-2.15.so
7fba0de4c000-7fba0de50000 r--p 001b6000 &lt;span class="nb"&gt;fc&lt;/span&gt;:00 2752737                    /lib/x86_64-linux-gnu/libc-2.15.so
7fba0de50000-7fba0de52000 rw-p 001ba000 &lt;span class="nb"&gt;fc&lt;/span&gt;:00 2752737                    /lib/x86_64-linux-gnu/libc-2.15.so
7fba0de52000-7fba0de57000 rw-p 00000000 00:00 0
7fba0de57000-7fba0de79000 r-xp 00000000 &lt;span class="nb"&gt;fc&lt;/span&gt;:00 2756455                    /lib/x86_64-linux-gnu/ld-2.15.so
7fba0e06c000-7fba0e06f000 rw-p 00000000 00:00 0
7fba0e077000-7fba0e079000 rw-p 00000000 00:00 0
7fba0e079000-7fba0e07a000 r--p 00022000 &lt;span class="nb"&gt;fc&lt;/span&gt;:00 2756455                    /lib/x86_64-linux-gnu/ld-2.15.so
7fba0e07a000-7fba0e07c000 rw-p 00023000 &lt;span class="nb"&gt;fc&lt;/span&gt;:00 2756455                    /lib/x86_64-linux-gnu/ld-2.15.so
7fff892a4000-7fff892c5000 rw-p 00000000 00:00 0                          &lt;span class="o"&gt;[&lt;/span&gt;stack]
7fff89388000-7fff89389000 r-xp 00000000 00:00 0                          &lt;span class="o"&gt;[&lt;/span&gt;vdso]
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  &lt;span class="o"&gt;[&lt;/span&gt;vsyscall]       
对于 输出结构 的描述：

第一列为 VMA 的地址范围， 第二列 为 权限， 第三列 为偏移，标识VMA对应的Segment 在映射文件中的偏移， 
第四列为 映射文件 所在设备的主、次设备号 （可以为0 即没有映射文件 比如stack heap）， 第五列： 映射文件的节点号， 最后为 映射文件路径
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="进程栈初始化-进程运行存在一些环境变量以及-运行参数-常见的做法-是-操作系统-在进程启动时-将这些基本信息-提前保存到-进程的虚拟空间栈中"&gt;进程栈初始化： 进程运行存在一些环境变量以及 运行参数， 常见的做法 是 操作系统 在进程启动时 将这些基本信息 提前保存到 进程的虚拟空间栈中&lt;/h4&gt;

&lt;h3 id="动态链接"&gt;动态链接：&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;为什么需要动态链接： 1） 静态链接 对于计算机内存和磁盘的空间浪费非常严重， 特别是多进程的时候，极大的浪费了内存空间，  2） 更新、部署 困难， 基础库的更新 导致 所有的依赖程序 需要重新编译&lt;/li&gt;
  &lt;li&gt;解决方法即是： 把程序的模块相互分隔开来，形成独立的文件，而不再将他们静态的链接在一起。即是： 不对那些组成程序的目标文件进行连接，等到程序要运行时 才进行连接。&lt;/li&gt;
  &lt;li&gt;把链接过程推迟到了运行时再进行，这就是动态链接的基本思想
    &lt;h4 id="动态链接过程的优势-动态链接简单过程"&gt;动态链接过程的优势； 动态链接简单过程&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;Programe1 依赖  Lib.o&lt;/li&gt;
  &lt;li&gt;Programe2 依赖  Lib.o&lt;/li&gt;
  &lt;li&gt;运行 Programe1 时，系统加载 Programe1.o 然后加载依赖 Lib.o 如果Lib.o 依赖其他文件，则依次递归加载所有依赖。&lt;/li&gt;
  &lt;li&gt;当所有依赖关系加载完成之后， 开始链接工作，链接工作 与静态链接非常相似， 包括 符号解析，地址重定位等。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;完成上述工作之后，将控制权交给Programe1.o 的程序入口处。程序开始运行，&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;当运行Program2时，系统加载Program2.o，但是不在加载 Lib.o 因为系统已经在运行Program1时，加载了 Lib.o
    &lt;ul&gt;
      &lt;li&gt;
        &lt;ol&gt;
          &lt;li&gt;通过以上过程，可以发现 动态链接 节省了一次Lib.o 的依赖 加载。&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;ol&gt;
          &lt;li&gt;在其中如果更新Lib.o 时，不需要 重新编译 Programe1, 与 Programe2 仅仅 更新Lib.o 在下一次重新运行Program1，2时，即可使用最新的依赖
            &lt;h5 id="程序可扩展性和兼容性"&gt;程序可扩展性和兼容性：&lt;/h5&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;动态链接 可以在 程序运行时 动态的选择加载各种程序模块，这个特点被人们用来开发 插件功能&lt;/li&gt;
      &lt;li&gt;动态链接可以加强程序的兼容性，  一个程序可以再不同的平台运行时 可以动态的链接到右操作系统 提供的动态链接库，比如 程序依赖printf 函数， 操作系统 A与 B 只需要提供 一样的printf 接口，即可实现 程序在操作系统AB上的运行
        &lt;h5 id="动态链接-的基本实现"&gt;动态链接 的基本实现：&lt;/h5&gt;
      &lt;/li&gt;
      &lt;li&gt;动态链接涉及到 各个文件的装载， 需要操作系统的支持， 因为在动态链接的情况下，进程的虚拟地址空间分布 会比 静态链接 情况下更加复杂，&lt;/li&gt;
      &lt;li&gt;内存管理、内存共享、进程线程等机制，在 动态链接下也会有一些变化，Linux 中动态链接文件 称为 动态共享对象(DSO Dynamic Shared Objects) 以.so 为扩展名， Windows中 动态链接文件称为 动态链接库(Dynamical Linking Library) .dll 为扩展名&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="动态链接-导致的问题-因为动态链接-将在程序编译阶段的工作推迟到了-运行时间段导致-程序每次被装载时-都要进行-重新进行连接导致一些程序性能上的损失性能损失-大约在5以下这些损失-换来-程序在空间上的-节省和程序构建升级上的便利性是相当值得的"&gt;动态链接 导致的问题： 因为动态链接 将在程序编译阶段的工作推迟到了 运行时间段，导致 程序每次被装载时 都要进行 重新进行连接。导致一些程序性能上的损失，性能损失 大约在5%以下。这些损失 换来 程序在空间上的 节省和程序构建升级上的便利性，是相当值得的。&lt;/h4&gt;

&lt;h3 id="地址无关代码"&gt;地址无关代码：&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;装载时重定位： 为了能够共享对象在任意地址被装载， 第一个方法为： 装载时重定位， 在链接时，对所有 绝对地址的应用不做重定位，而把这一步推迟到装载时在完成，即：一旦模块装载地址确定 即目标地址确定，name系统就对模块中的所有绝对地址 引用进行重定位，即， 系统需要遍历所有的重定位表，对所有 符号的地址引用进行修改。&lt;/li&gt;
  &lt;li&gt;静态链接中提到的重定位： 链接时重定位， 现在为 装载时重定位。&lt;/li&gt;
  &lt;li&gt;存在问题： 指令中对绝对地址函数的应用，被修改好，不能很好的在多个进程中共享。&lt;br /&gt;
** 地址无关代码 的基本思想： 将指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分可以保持不变，而数据部分可以在每个进程中拥有一个副本。 即是地址无关代码技术(PIC position-indenpendent Code)&lt;/li&gt;
  &lt;li&gt;具体解决方法：共享对象模块中的地址应用 分为两类： 模块内部引用、模块外部应用 按照应用类型不同 又分为 函数引用和数据引用， 可分为4类：
    &lt;ul&gt;
      &lt;li&gt;
        &lt;ol&gt;
          &lt;li&gt;模块内部的函数调用、跳转&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;ol&gt;
          &lt;li&gt;模块内部的数据访问， 如模块中定义的全局变量、静态变量&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;ol&gt;
          &lt;li&gt;模块外部的函数调用、跳转&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;ol&gt;
          &lt;li&gt;模块外部的数据访问， 如 其他模块中定义的全局变量&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;条件对应的 解决方法为：
    &lt;ul&gt;
      &lt;li&gt;
        &lt;ol&gt;
          &lt;li&gt;即是：相对 位置调用， 因为同在模块内，函数间 的地址相对位置是确定的&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;ol&gt;
          &lt;li&gt;相对寻址，我们知道， 一个模块前面一般是若干页的代码 后面跟 若干页 的数据，这些页 的相对位置是固定的， 所以 可以使用 指定+ 相对位置 间隔 来访问模块内部的数据 （这里是否存在其他问题呢？ 确定 系统装载时候， 代码与数据段的相对位置是固定的吗？）&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;ol&gt;
          &lt;li&gt;模块间的 地址访问 （数据访问、函数地址访问） 比较麻烦， 因为 模块间的地址访问 需要等到装载时候才能决定， 要使该类 代码地址无关，基本思想： 把地址相关的部分放到数据段里面，具体 ELF 的做法就是在数据段里面建立一个指向这些变量的数组指针， 称为 全局偏移表(Global offset Table GOT) 当代吗需要引用该全局变量时候，可以通过GOT中的相对应的项间接引用, 图示如下：&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;当指令中：需要访问变量b时，程序会找到GOT， 然后根据GOT中的变量所对应的项找到变量的目标地址， 链接器 在装载模块时，会查找每个变量所在的地址，然后填充GOT中的各个项， 以保证 项目地址指向正确。因为GOT 在数据段中，所以他可以在装载时候被修改，并且每个进程都有独立的副本存在。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;gcc -fPIC -shared -o name.so name.c&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;
      &lt;ol&gt;
        &lt;li&gt;同4中一样， 使用 GOT 来保存 函数地址&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;指令跳转、调用&lt;/th&gt;
      &lt;th&gt;数据访问&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;模块内部&lt;/td&gt;
      &lt;td&gt;相对跳转和调用&lt;/td&gt;
      &lt;td&gt;相对地址访问&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;模块外部&lt;/td&gt;
      &lt;td&gt;间接跳转和调用(GOT)&lt;/td&gt;
      &lt;td&gt;间接访问(GOT)&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;-fpic 与 -fPIC 参数的区别: -fPIC 产生的代码要更大， 更跨平台， 而-fpic 产生的代码更小， 也更快，但是存在一些限制，更与硬件相关&lt;/p&gt;

&lt;h4 id="由上可见-动态链接-会使程序变慢的-原因有-1-动态装载重定位计算-2-共享代码段中-通过got来访问数据调用函数"&gt;由上可见： 动态链接 会使程序变慢的 原因有： 1） 动态装载，重定位计算， 2） 共享代码段中 通过GOT来访问数据，调用函数&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;延迟绑定（Procedure Linkage Table）:  共享模块加载时候，程序需要浪费不少时间来 用于解决模块之间的函数应用的符号查找 以及重定位。 而在实际中 大量的函数很少被使用到， 所以 ELF采用了一种叫做延迟绑定的做法， 基本的思想就是 当函数第一次被用到时候 才进行绑定（符号查找，重定位等）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id="动态链接-文件启动-顺序-与静态链接情况基本一致-首先操作系统-读取可执行文件-的头部检查合法性-并从-header中读取各个segment-映射到进程虚拟空间的对应文职-这时候差异开始显现-静态链接情况下-操作系统将-控制权直接交给-可执行文件的入口地址然后程序开始执行-动态链接情况下-操作系统并不能将控制权交给可执行文件-因为其-依赖的-很多共享对象还没有加载起来所以操作系统-先启动一个动态链接器由动态链接器-来进行一系列的初始化工作并进行动态链接工作当所有-链接工作完成以后-动态联机器将-控制权-交给可执行文件-的入口地址程序开始正式执行"&gt;动态链接 文件启动 顺序： 与静态链接情况基本一致， 首先操作系统 读取可执行文件 的头部，检查合法性， 并从 header中读取各个Segment 映射到进程虚拟空间的对应文职。 这时候差异开始显现， 静态链接情况下， 操作系统将 控制权直接交给 可执行文件的入口地址，然后程序开始执行。 动态链接情况下： 操作系统并不能将控制权交给可执行文件， 因为其 依赖的 很多共享对象，还没有加载起来，所以操作系统 先启动一个动态链接器，由动态链接器 来进行一系列的初始化工作，并进行动态链接工作，当所有 链接工作完成以后， 动态联机器将 控制权 交给可执行文件 的入口地址，程序开始正式执行&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;动态链接器的路径配置：  .interp 段 中 为 ld 的具体路径&lt;/li&gt;
  &lt;li&gt;动态符号表： 为了完成链接， 需要 所依赖的符号和相关文件的信息， 在静态链接中 有 段为 .symtab (Symbol Table) 动态链接中 则为 Dynmic Symbol Table .dynsym 其中只保存 动态链接相关的符号。很多动态链接库中同时存在.dynsym 以及 .symtab 两个表， .symtab 中 保存了所有的符号。其中的符号 字符串 则保存在 .dynstr (Dynamic String Table) 其中往往还有 符号哈希表 用于加快符号查找速度&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;readelf -sD  lib.so&lt;/p&gt;

&lt;p&gt;动态链接 需要在装载时候 进行重定位， 对于 使用 PIC 模式编译的（地址无关代码） 则只需要对GOT进行 重定位， 非PIC编译的，则在装载时候 重定位（即 代码段 也被 修改，而无法与其他程序共享） &lt;br /&gt;
重定位结构： 动态链接中 重定位表 为.rel.dyn, .rel.plt  对应于静态链接中的 .rel.text, .rel.data 分别对应  .got （数据段）, 以及 .got.plt （代码段，函数调用地址的修正）&lt;/p&gt;

&lt;p&gt;root@precise64:/vagrant_data/link_test# readelf -r main.so&lt;/p&gt;

&lt;p&gt;Relocation section ‘.rela.dyn’ at offset 0x420 contains 4 entries:&lt;br /&gt;
  Offset          Info           Type           Sym. Value    Sym. Name + Addend&lt;br /&gt;
000000201010  000000000008 R_X86_64_RELATIVE                    0000000000201010&lt;br /&gt;
000000200fd0  000300000006 R_X86_64_GLOB_DAT 0000000000000000 &lt;strong&gt;gmon_start&lt;/strong&gt; + 0&lt;br /&gt;
000000200fd8  000400000006 R_X86_64_GLOB_DAT 0000000000000000 _Jv_RegisterClasses + 0&lt;br /&gt;
000000200fe0  000500000006 R_X86_64_GLOB_DAT 0000000000000000 __cxa_finalize + 0&lt;/p&gt;

&lt;p&gt;Relocation section ‘.rela.plt’ at offset 0x480 contains 2 entries:&lt;br /&gt;
  Offset          Info           Type           Sym. Value    Sym. Name + Addend&lt;br /&gt;
000000201000  000200000007 R_X86_64_JUMP_SLO 0000000000000000 name + 0&lt;br /&gt;
000000201008  000500000007 R_X86_64_JUMP_SLO 0000000000000000 __cxa_finalize + 0&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;动态链接时候，进程堆栈的初始化信息： 当操作系统将控制权交给 动态链接器的时候， 除了 进程初始化时候的，堆栈里面关于进程执行环境和命令行参数等， 还包含 不少的 动态链接器所需要的辅助信息，比如 可执行文件的入口地址等，&lt;/li&gt;
  &lt;li&gt;这些信息往往由操作系统传递给动态链接器&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="动态链接器自举-因为动态链接器-也是一个共享库而动态链接器是操作系统的程序入口-所以动态链接器如何递归的解决自己的依赖关系完成启动是一个-非常有意思的事情"&gt;动态链接器自举： 因为动态链接器 也是一个共享库，而动态链接器是操作系统的程序入口， 所以动态链接器如何递归的解决自己的依赖关系，完成启动，是一个 非常有意思的事情。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;动态链接器完成自举之后，链接器将 可执行文件和链接器本身的符号表合并到一个符号表中， 称为 全局符号表&lt;/li&gt;
  &lt;li&gt;之后 开始寻找可执行文件所依赖的共享对象， 在.dynamic 段中， 类型为NEEDED 为 可执行文件所依赖的 共享对象，由此 链接器可以获得 可执行文件的所需要的所有的共享对象，其组成的一个集合&lt;/li&gt;
  &lt;li&gt;称为 装载集合， 从装载集合中取出来一个文件，打开 并读取对应的ELF header 和.dynamic 段，将其所依赖的其他的共享对象 加入到家在集合中，如此递归的加载所有依赖的共享对象&lt;/li&gt;
  &lt;li&gt;常见的加载算法为 广度优先&lt;/li&gt;
  &lt;li&gt;当新的共享对象被加载进来的时候，他的符号表会被合并到全局符号表中， 所以 当所有的共享对象 被装载进来的时候，全局符号表里面将函数进程中所有的动态链接所需要的符号&lt;/li&gt;
  &lt;li&gt;所以动态链接器的加载顺序决定了符号的优先级&lt;/li&gt;
  &lt;li&gt;链接器开始变量可执行文件和每个共享对象的重定位表，将他们的 .got.plt 中的每个需要重定位的位置进行修正， 因为此时动态链接器已经拥有了进程的全局符号表，所以这个修正过程会比较容易&lt;/li&gt;
  &lt;li&gt;重定位完成后，如果某个共享对象 存在.init 段， 则动态链接器 会执行.init 段中的代码， 泳衣实现共享对象特有的初始化代过程， 比如 c++中 全局对象的构造过程， 共享对象中的 .finit 段，则在进程退出时执行 实现共享对象 的析构类型操作&lt;/li&gt;
  &lt;li&gt;与 链接器执行的.init 对比，则为 可执行文件的 .init, .finit段的执行者， 需要在后面补充
    &lt;h5 id="符号优先级"&gt;符号优先级：&lt;/h5&gt;
  &lt;/li&gt;
  &lt;li&gt;动态链接器 按照 各个模块之间依赖关系，对他们进行装载并将他们的符号 并入到 全局符号表。 那么就有可能 两个不同的模块定义了 同一个符号，导致符号歧义，&lt;/li&gt;
  &lt;li&gt;该现象称为 共享对象全局符号介入 问题，  那么链接器 如何 解决此类问题呢？ 其规则为： 当一个符号需要加入全局符号表时，如果相同的符号名已经存在，对于&lt;/li&gt;
  &lt;li&gt;则后加的符号 被忽略。由于存在该类问题， 所以 当程序中存在大量的 共享对象 时候，应该非常小心符号的重名问题， 如果 两个符号重名  又执行不同的功能&lt;/li&gt;
  &lt;li&gt;name程序运行时 可能会将所有的该符号的应用解析到 第一个被加入全局符号表的符号，从而导致 莫名其妙的错误&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id="如何-避免全局符号介入问题-对于-导出-符号全局符号-是不可能解决的然而-内部函数调用-可以使用-static-关键字-来避免其成为-全局符号-而被-其他模块覆盖则在内部-程序直接使用-内部-相对地址调用也加快了-程序的调用速度-即-不适用-gotplt-来-进行-间接跳转"&gt;如何 避免全局符号介入问题： 对于 导出 符号（全局符号） 是不可能解决的，然而 内部函数调用， 可以使用 static 关键字 来避免其成为 全局符号 而被 其他模块覆盖，则在内部 程序直接使用 内部 相对地址调用，也加快了 程序的调用速度。 即 不适用 .got.plt 来 进行 间接跳转。&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;则 更一般的规律为： 文件内部函数调用 都采用的 .got.plt 进行跳转调用，除非 被调用函数为static 则不会成为符号，而是用 内部相对地址调用&lt;/li&gt;
  &lt;li&gt;
    &lt;h5 id="动态链接器-的接个问题"&gt;动态链接器 的接个问题：&lt;/h5&gt;
  &lt;/li&gt;
  &lt;li&gt;动态链接器 本身是 动态链接的还是 静态链接的？： 静态链接的， 因为 他不能依赖 与其他共享对象， 其存在的目的 即为 解决 其他elf 动态链接文件 的依赖关系的，所以不能存在依赖&lt;/li&gt;
  &lt;li&gt;动态链接器 本身必须是PIC 的吗？ 并不是， 动态链接器 的目的是帮助其他elf解决依赖关系，本身是否PIC  的 决定 其代码是否 能够共享。如果 PIC 则会更加简单一些，因为 非PIC的话，链接器在自举的时候 往往 还需要重定位自己的代码段&lt;/li&gt;
  &lt;li&gt;动态链接器 是否可以被当做可执行文件运行？ 可运行的话，其装载地址是多少？： 可以当做可执行文件来运行， 其装载地址 没有什么区别 几位 0x00000000 这是一个无效地址 ，作为共享库，内核在装载时， 会为期选择一个合适的装载地址
    &lt;h5 id="显式-运行时链接explicit-run-time-linking-即是程序在运行期间-可以主动的加载指定的-动态链接库-而共享对象-不需要任何的修改-即可-被-运行时装载"&gt;显式 运行时链接(Explicit Run-time Linking) 即是：程序在运行期间 可以主动的加载指定的 动态链接库， 而共享对象 不需要任何的修改 即可 被 运行时装载&lt;/h5&gt;
  &lt;/li&gt;
  &lt;li&gt;这种共享对象往往被叫做 动态装载库 (Dynamic Loading Library) 本质 上与 一般的共享对象 没有任何区别，只是 使用的角度不同而已&lt;/li&gt;
  &lt;li&gt;其理论上 与 可执行文件 依赖 共享对象 一样的执行方式&lt;/li&gt;
  &lt;li&gt;主要API有： dlopen  dlsym, dlerror, dlclose&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id="共享库的-组织方式"&gt;共享库的 组织方式：&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;因为共享对象的优点，导致 大量的程序开始使用共享对象，导致系统中存在数量极为庞大的共享对象， 所以操作系统一般会对共享对象的目录组织和使用方式 有一定的规定，即为 共享库，&lt;/li&gt;
  &lt;li&gt;共享库与共享对象没有任何区别，只是 共享库为共享对象的 组织方式 的另一个称呼 而已
    &lt;h6 id="共享库的兼容性"&gt;共享库的兼容性：&lt;/h6&gt;
  &lt;/li&gt;
  &lt;li&gt;兼容更新：所有的更新只是在原有的共享库基础上添加一些内容， 原接口保持不变&lt;/li&gt;
  &lt;li&gt;不兼容更新： 共享库改变了原有接口， 使用该共享库的原有接口的程序 无法运行&lt;/li&gt;
  &lt;li&gt;这里面讨论的接口为 ABI， 而非其他的接口， 导致ABI发生变化的有以下几种情况：&lt;/li&gt;
  &lt;li&gt;共享库的版本命名： 用于解决 兼容性问题。 使用命名规范来 明确兼容性。共享库的文件命名如下： libname.so.x.y.z&lt;/li&gt;
  &lt;li&gt;x 为主要版本号(Major version number)， y 为子版本号(Minor version number)， z为发布版本号(Release version number)&lt;/li&gt;
  &lt;li&gt;主版本号： 库的重大升级， 不同主版本号之间 是不兼容的，依赖旧版本共享库的程序 需要 重新编译 才能 使用最新的共享库版本， 或者 系统保留 旧的版本，旧程序才能正常运行&lt;/li&gt;
  &lt;li&gt;次版本号： 增量升级， 增加一些新的接口符号，保持原有的符号不变， 高的次要版本号 要 向后兼容低次要版本号的 共享库。 一个依赖 低次要版本号的程序 可以再 高次要版本号的共享库 下运行。&lt;/li&gt;
  &lt;li&gt;发布版本号： 对一些错误的修正、性能的改进等。  不添加新的接口 也不对 接口进行更改， 相同主版本号，次版本号，不同发布版本号 之间完全兼容&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
  </entry>
</feed>
