<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>日常学习</title>
  <id>http://geniousbar.github.io</id>
  <link href="http://geniousbar.github.io"/>
  <link href="http://geniousbar.github.io/feed.xml" rel="self"/>
  <updated>2021-02-19T00:00:00+00:00</updated>
  <author>
    <name>geniousbar</name>
  </author>
  <entry>
    <title>link compile</title>
    <link rel="alternate" href="http://geniousbar.github.io/2021/02/19/link-compile/"/>
    <id>http://geniousbar.github.io/2021/02/19/link-compile/</id>
    <published>2021-02-19T00:00:00+00:00</published>
    <updated>2021-03-23T02:32:39+00:00</updated>
    <summary type="html">&lt;h2 id="link--compile"&gt;link &amp;amp; compile&lt;/h2&gt;

&lt;h4 id="为什么c语言中的-header-file-h-一定需要-防止重复被include-呢-而为什么一定需要-header-file的存在呢"&gt;为什么c语言中的 header file *.h 一定需要 防止重复被include 呢？ 而为什么一定需要 header file的存在呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;header file 需要存在原因有： 1） .c 文件 变为可执行文件，需要 编译、链接 两个阶段， 而链接中 是可以将 不同的 类型编译过的文件进行 链接的。 随着程序的复杂， 比如 函数参数的 传递顺序等 原因导致，需要 程序调用者 知道 函数调用的结构， 所以 [[https://www.zhihu.com...&lt;/li&gt;
&lt;/ul&gt;</summary>
    <content type="html">&lt;h2 id="link--compile"&gt;link &amp;amp; compile&lt;/h2&gt;

&lt;h4 id="为什么c语言中的-header-file-h-一定需要-防止重复被include-呢-而为什么一定需要-header-file的存在呢"&gt;为什么c语言中的 header file *.h 一定需要 防止重复被include 呢？ 而为什么一定需要 header file的存在呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;header file 需要存在原因有： 1） .c 文件 变为可执行文件，需要 编译、链接 两个阶段， 而链接中 是可以将 不同的 类型编译过的文件进行 链接的。 随着程序的复杂， 比如 函数参数的 传递顺序等 原因导致，需要 程序调用者 知道 函数调用的结构， 所以 [[https://www.zhihu.com/question/280665935][链接]] 2) 如果依赖于系统中的系统库，比如标准库中的系统调用，则只能使用inluce header file 来进行使用，即：被调用方 是已经编译好的文件格式&lt;/li&gt;
  &lt;li&gt;为什么 header file一定需要 预防被重复加载呢？： 经过测试发现，在 header file 中不存在 struct 定义的时候，只是简单的 func 定义的时候， 重复包含并没有问题， 然而在 定义 struct的时候 则出现了 重复定义问题。 而问题也只是出现了 gcc -c 的阶段， 在gcc -E gcc -S 阶段 依然没有任何问题，所以 关于 为什么一定需要 #ifndef #define code …  #endif 的格式，则需要 在gcc 中寻找&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="c-语言-到可执行文件的过程"&gt;C 语言 到可执行文件的过程&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;预处理(Preprocessing)&lt;/li&gt;
  &lt;li&gt;编译(Compilation)&lt;/li&gt;
  &lt;li&gt;汇编(Assembly)&lt;/li&gt;
  &lt;li&gt;链接(Linking): 链接过程主要包括了：
    &lt;ul&gt;
      &lt;li&gt;地址和空间分配&lt;/li&gt;
      &lt;li&gt;符号决议&lt;/li&gt;
      &lt;li&gt;重定位： 当存在a.c 依赖 b.c 的函数时候， 文件是单独编译的，并非 将b.c 的中内容 插入到 a.c 中，然后进行整体编译。所以导致 a.c 中并不知道 b.c 中函数 变量的存在， 所以 在编译 a.c时候， 函数调用 都会 call 0， 函数地址 需要 在链接时候 进行确定，并修改 （即是重定位）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;elf 文件的类型： &lt;br /&gt;
| type                              | 说明                                                                                                           | 实例                          |&lt;br /&gt;
|———————————–+—————————————————————————————————————-+——————————-|&lt;br /&gt;
| 可重定位文件(Relocatable File)    | 可以被可执行文件或 共享目标文件 链接                                                                           | Linux: .o                     |&lt;br /&gt;
| 可执行文件(Executable File)       | 可执行程序, 一般没有 扩展名                                                                                    | Linux: /bin/bash Windows .exe |&lt;br /&gt;
| 共享目标文件(Shared Object File ) | 1） 可被 其他 可重定位文件 、共享文件 连接成 目标文件 2） 动态链接器 将其与可执行文件结合，映射为 进程的一部分 | Linux: .so, Windows: DLL      |&lt;br /&gt;
| 核心转储文件(Core Dump File)      | 进程意外终止时候， 系统可以 将进程的地址空间内容 等信息 转储到  该文件中                                       | Linux: core dump               |&lt;/p&gt;

&lt;p&gt;#+begin_src &lt;br /&gt;
vagrant@precise64:/vagrant_data/link_test$ file a.out&lt;br /&gt;
a.out: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, BuildID[sha1]=0x91de252bc2c3703aa5c324e5176b05e6b36a5bfa, not stripped&lt;/p&gt;

&lt;p&gt;vagrant@precise64:/vagrant_data/link_test$ file main.o&lt;br /&gt;
main.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped&lt;br /&gt;
#+end_src&lt;/p&gt;

&lt;h4 id="深入-o-文件"&gt;深入 .o 文件&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;可用工具有： 1) objdump, 2) readelf, 3) nm&lt;/li&gt;
  &lt;li&gt;elf 因为 存在段(section) ，而段 是变长的，导致 没有固定的映射方法，所以 Header 为固定长度 异常重要， Header 中存在 多少个段（Number of section headers），  段表偏移(Start of section headers:) 的关键信息， 来使 c代码能够将 段表（section table） 映射到代码中&lt;/li&gt;
  &lt;li&gt;objdump -h main.o&lt;br /&gt;
#+begin_src&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;int main() {&lt;br /&gt;
  int a = 10;&lt;br /&gt;
  name(a);&lt;br /&gt;
}&lt;/p&gt;

&lt;p&gt;vagrant@precise64:/vagrant_data/link_test$ objdump -h main.o&lt;/p&gt;

&lt;p&gt;main.o:     file format elf64-x86-64&lt;/p&gt;

&lt;p&gt;Sections:&lt;br /&gt;
Idx Name          Size      VMA               LMA               File off  Algn&lt;br /&gt;
  0 .text         00000020  0000000000000000  0000000000000000  00000040  2&lt;strong&gt;2&lt;br /&gt;
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE&lt;br /&gt;
  1 .data         00000000  0000000000000000  0000000000000000  00000060  2&lt;/strong&gt;2&lt;br /&gt;
                  CONTENTS, ALLOC, LOAD, DATA&lt;br /&gt;
  2 .bss          00000000  0000000000000000  0000000000000000  00000060  2&lt;strong&gt;2&lt;br /&gt;
                  ALLOC&lt;br /&gt;
  3 .comment      0000002b  0000000000000000  0000000000000000  00000060  2&lt;/strong&gt;0&lt;br /&gt;
                  CONTENTS, READONLY&lt;br /&gt;
  4 .note.GNU-stack 00000000  0000000000000000  0000000000000000  0000008b  2&lt;strong&gt;0&lt;br /&gt;
                  CONTENTS, READONLY&lt;br /&gt;
  5 .eh_frame     00000038  0000000000000000  0000000000000000  00000090  2&lt;/strong&gt;3&lt;br /&gt;
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA&lt;br /&gt;
vagrant@precise64:/vagrant_data/link_test$ readelf -h main.o&lt;br /&gt;
ELF Header:&lt;br /&gt;
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00&lt;br /&gt;
  Class:                             ELF64&lt;br /&gt;
  Data:                              2’s complement, little endian&lt;br /&gt;
  Version:                           1 (current)&lt;br /&gt;
  OS/ABI:                            UNIX - System V&lt;br /&gt;
  ABI Version:                       0&lt;br /&gt;
  Type:                              REL (Relocatable file)&lt;br /&gt;
  Machine:                           Advanced Micro Devices X86-64&lt;br /&gt;
  Version:                           0x1&lt;br /&gt;
  Entry point address:               0x0&lt;br /&gt;
  Start of program headers:          0 (bytes into file)&lt;br /&gt;
  Start of section headers:          296 (bytes into file)&lt;br /&gt;
  Flags:                             0x0&lt;br /&gt;
  Size of this header:               64 (bytes)&lt;br /&gt;
  Size of program headers:           0 (bytes)&lt;br /&gt;
  Number of program headers:         0&lt;br /&gt;
  Size of section headers:           64 (bytes)&lt;br /&gt;
  Number of section headers:         12&lt;br /&gt;
  Section header string table index: 9&lt;/p&gt;

&lt;p&gt;//  注意 在 文件中添加 了 全局变量之后 .data 文件 的size 变大了。&lt;br /&gt;
int b = 10;&lt;br /&gt;
int main() {&lt;br /&gt;
  int a = 10;&lt;br /&gt;
  name(a);&lt;br /&gt;
}&lt;/p&gt;

&lt;p&gt;vagrant@precise64:/vagrant_data/link_test$ objdump -h main.o&lt;/p&gt;

&lt;p&gt;main.o:     file format elf64-x86-64&lt;/p&gt;

&lt;p&gt;Sections:&lt;br /&gt;
Idx Name          Size      VMA               LMA               File off  Algn&lt;br /&gt;
  0 .text         00000020  0000000000000000  0000000000000000  00000040  2&lt;strong&gt;2&lt;br /&gt;
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE&lt;br /&gt;
  1 .data         00000004  0000000000000000  0000000000000000  00000060  2&lt;/strong&gt;2&lt;br /&gt;
                  CONTENTS, ALLOC, LOAD, DATA&lt;br /&gt;
  2 .bss          00000000  0000000000000000  0000000000000000  00000064  2&lt;strong&gt;2&lt;br /&gt;
                  ALLOC&lt;br /&gt;
  3 .comment      0000002b  0000000000000000  0000000000000000  00000064  2&lt;/strong&gt;0&lt;br /&gt;
                  CONTENTS, READONLY&lt;br /&gt;
  4 .note.GNU-stack 00000000  0000000000000000  0000000000000000  0000008f  2&lt;strong&gt;0&lt;br /&gt;
                  CONTENTS, READONLY&lt;br /&gt;
  5 .eh_frame     00000038  0000000000000000  0000000000000000  00000090  2&lt;/strong&gt;3&lt;br /&gt;
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA&lt;/p&gt;

&lt;p&gt;vagrant@precise64:/vagrant_data/link_test$ size main.o&lt;br /&gt;
   text	   data	    bss	    dec	    hex	filename&lt;br /&gt;
     88	      4	      0	     92	     5c	main.o&lt;br /&gt;
#+end_src&lt;/p&gt;

&lt;h5 id="objdump--s--d-maino-其中---s--将各个段-都打印出来--d-则将-代码段反汇编"&gt;objdump -s -d main.o 其中  -s  将各个段 都打印出来， -d 则将 代码段反汇编&lt;/h5&gt;
&lt;p&gt;#+begin_src&lt;br /&gt;
vagrant@precise64:/vagrant_data/link_test$ objdump -s -d main.o&lt;/p&gt;

&lt;p&gt;main.o:     file format elf64-x86-64&lt;/p&gt;

&lt;p&gt;Contents of section .text:&lt;br /&gt;
 0000 554889e5 4883ec10 c745fc0a 0000008b  UH..H….E……&lt;br /&gt;
 0010 45fc89c7 b8000000 00e80000 0000c9c3  E……………&lt;br /&gt;
Contents of section .data:&lt;br /&gt;
 0000 0a000000                             ….&lt;br /&gt;
Contents of section .comment:&lt;br /&gt;
 0000 00474343 3a202855 62756e74 752f4c69  .GCC: (Ubuntu/Li&lt;br /&gt;
 0010 6e61726f 20342e36 2e332d31 7562756e  naro 4.6.3-1ubun&lt;br /&gt;
 0020 74753529 20342e36 2e3300             tu5) 4.6.3.&lt;br /&gt;
Contents of section .eh_frame:&lt;br /&gt;
 0000 14000000 00000000 017a5200 01781001  ………zR..x..&lt;br /&gt;
 0010 1b0c0708 90010000 1c000000 1c000000  …………….&lt;br /&gt;
 0020 00000000 20000000 00410e10 8602430d  …. ….A….C.&lt;br /&gt;
 0030 065b0c07 08000000                    .[……&lt;/p&gt;

&lt;p&gt;Disassembly of section .text:&lt;/p&gt;

&lt;p&gt;0000000000000000 &amp;lt;main&amp;gt;:&lt;br /&gt;
   0:	55                   	push   %rbp&lt;br /&gt;
   1:	48 89 e5             	mov    %rsp,%rbp&lt;br /&gt;
   4:	48 83 ec 10          	sub    $0x10,%rsp&lt;br /&gt;
   8:	c7 45 fc 0a 00 00 00 	movl   $0xa,-0x4(%rbp)&lt;br /&gt;
   f:	8b 45 fc             	mov    -0x4(%rbp),%eax&lt;br /&gt;
  12:	89 c7                	mov    %eax,%edi&lt;br /&gt;
  14:	b8 00 00 00 00       	mov    $0x0,%eax&lt;br /&gt;
  19:	e8 00 00 00 00       	callq  1e &amp;lt;main+0x1e&amp;gt;&lt;br /&gt;
  1e:	c9                   	leaveq&lt;br /&gt;
  1f:	c3                   	retq&lt;br /&gt;
#+end_src&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;重定位表：&lt;br /&gt;
#+begin_src &lt;br /&gt;
vagrant@precise64:/vagrant_data/link_test$ readelf -S main.o&lt;br /&gt;
There are 12 section headers, starting at offset 0x128:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Section Headers:&lt;br /&gt;
  [Nr] Name              Type             Address           Offset&lt;br /&gt;
       Size              EntSize          Flags  Link  Info  Align&lt;br /&gt;
  [ 0]                   NULL             0000000000000000  00000000&lt;br /&gt;
       0000000000000000  0000000000000000           0     0     0&lt;br /&gt;
  [ 1] .text             PROGBITS         0000000000000000  00000040&lt;br /&gt;
       0000000000000020  0000000000000000  AX       0     0     4&lt;br /&gt;
  [ 2] .rela.text        RELA             0000000000000000  00000548&lt;br /&gt;
       0000000000000018  0000000000000018          10     1     8&lt;br /&gt;
  [ 3] .data             PROGBITS         0000000000000000  00000060&lt;br /&gt;
       0000000000000004  0000000000000000  WA       0     0     4&lt;br /&gt;
  [ 4] .bss              NOBITS           0000000000000000  00000064&lt;br /&gt;
       0000000000000000  0000000000000000  WA       0     0     4&lt;br /&gt;
  [ 5] .comment          PROGBITS         0000000000000000  00000064&lt;br /&gt;
       000000000000002b  0000000000000001  MS       0     0     1&lt;br /&gt;
  [ 6] .note.GNU-stack   PROGBITS         0000000000000000  0000008f&lt;br /&gt;
       0000000000000000  0000000000000000           0     0     1&lt;br /&gt;
  [ 7] .eh_frame         PROGBITS         0000000000000000  00000090&lt;br /&gt;
       0000000000000038  0000000000000000   A       0     0     8&lt;br /&gt;
  [ 8] .rela.eh_frame    RELA             0000000000000000  00000560&lt;br /&gt;
       0000000000000018  0000000000000018          10     7     8&lt;br /&gt;
  [ 9] .shstrtab         STRTAB           0000000000000000  000000c8&lt;br /&gt;
       0000000000000059  0000000000000000           0     0     1&lt;br /&gt;
  [10] .symtab           SYMTAB           0000000000000000  00000428&lt;br /&gt;
       0000000000000108  0000000000000018          11     8     8&lt;br /&gt;
  [11] .strtab           STRTAB           0000000000000000  00000530&lt;br /&gt;
       0000000000000014  0000000000000000           0     0     1&lt;br /&gt;
Key to Flags:&lt;br /&gt;
  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)&lt;br /&gt;
  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)&lt;br /&gt;
  O (extra OS processing required) o (OS specific), p (processor specific)&lt;br /&gt;
  #+end_src&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在列表中，有 type 为RELA  或者 REL  的 rela.text, 为重定位表， main.c 中 调用了一个name 函数， name 存在于name.c 文件中， 链接器在 连接时候，需要 将main.o 中的函数调用 处理为 name.o 中的地址， 其中info 为指向需要重定位的 section index&lt;/li&gt;
  &lt;li&gt;每个需要重定位的段，都需要 一个相应的重定位表， 比如 .text 则为 .rela.text, .eh_frmae .rela.eh_frame,&lt;/li&gt;
  &lt;li&gt;字符串表：因为字符串为变长，比较难映射 所以单独存放一个 段。 .strtab .shstrtab, 类型为 strtab (String table )， .strtab  为 字符串表 用来存储 普通的字符串， 比如符号的名字， .shstrtab 则为 （section header string table） 段表字符串表， 用来保存段表 中 用到的字符串 比如段名&lt;/li&gt;
  &lt;li&gt;对比 header 中的 Section header string table index: 9 项， 正好 为 .shstrtab 在section table中的下标
    &lt;h3 id="符号"&gt;符号&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;符号是， 链接过程中重要的信息数据， 链接过程中  目标文件的相互拼接： 实际上 就是目标文件之间对地址的引用， 即对函数 变量地址的引用。比如 B 需要用到 A中的函数foo， 则是： A中定义了 函数foo， B 引用了 A中的函数foo, 概念同样适用变量，&lt;/li&gt;
  &lt;li&gt;链接中，我们称  函数和变量为符号，函数名 变量名则是 符号名。&lt;/li&gt;
  &lt;li&gt;每个文件中 都包含 函数表， 记录了 文件中使用的所有符号，每个定义的符号都有对应的条目，其中包含符号值， 对于变量和函数来说，符号值 则为 其地址。&lt;/li&gt;
  &lt;li&gt;符号 可能包含的有 以下类型：
    &lt;ol&gt;
      &lt;li&gt;定义在本文件中的全局符号，函数 等，可以被其他文件 引用。 比如: 函数 main, name,&lt;/li&gt;
      &lt;li&gt;外部符号： 再本文件中引用的全局符号，并未在本文件中定义&lt;/li&gt;
      &lt;li&gt;段名： 其数值为 该段的其实地址， 编译器所加。&lt;/li&gt;
      &lt;li&gt;局部符号： 只在该文件中可见，比如static 变量&lt;/li&gt;
      &lt;li&gt;行号信息： 目标文件指令 与 源代码 的对应关系. debug 模式下 会创建 不少的 该类信息 在 符号表中&lt;br /&gt;
#+begin_src &lt;br /&gt;
vagrant@precise64:/vagrant_data/link_test$ readelf -s main.o&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Symbol table ‘.symtab’ contains 11 entries:&lt;br /&gt;
   Num:    Value          Size Type    Bind   Vis      Ndx Name&lt;br /&gt;
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND&lt;br /&gt;
     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS main.c&lt;br /&gt;
     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1&lt;br /&gt;
     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3&lt;br /&gt;
     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4&lt;br /&gt;
     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    6&lt;br /&gt;
     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    7&lt;br /&gt;
     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    5&lt;br /&gt;
     8: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    3 b&lt;br /&gt;
     9: 0000000000000000    32 FUNC    GLOBAL DEFAULT    1 main&lt;br /&gt;
    10: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND name&lt;/p&gt;

&lt;p&gt;vagrant@precise64:/vagrant_data/link_test$ objdump -t main.o&lt;/p&gt;

&lt;p&gt;main.o:     file format elf64-x86-64&lt;/p&gt;

&lt;p&gt;SYMBOL TABLE:&lt;br /&gt;
0000000000000000 l    df &lt;em&gt;ABS&lt;/em&gt;	0000000000000000 main.c&lt;br /&gt;
0000000000000000 l    d  .text	0000000000000000 .text&lt;br /&gt;
0000000000000000 l    d  .data	0000000000000000 .data&lt;br /&gt;
0000000000000000 l    d  .bss	0000000000000000 .bss&lt;br /&gt;
0000000000000000 l    d  .note.GNU-stack	0000000000000000 .note.GNU-stack&lt;br /&gt;
0000000000000000 l    d  .eh_frame	0000000000000000 .eh_frame&lt;br /&gt;
0000000000000000 l    d  .comment	0000000000000000 .comment&lt;br /&gt;
0000000000000000 g     O .data	0000000000000004 b&lt;br /&gt;
0000000000000000 g     F .text	0000000000000020 main&lt;br /&gt;
0000000000000000         &lt;em&gt;UND&lt;/em&gt;	0000000000000000 name&lt;br /&gt;
#+end_src&lt;/p&gt;

&lt;h4 id="相似段合并"&gt;相似段合并：&lt;/h4&gt;

&lt;p&gt;#+begin_src &lt;br /&gt;
vagrant@precise64:/vagrant_data/link_test$ objdump -h main.o&lt;/p&gt;

&lt;p&gt;main.o:     file format elf64-x86-64&lt;/p&gt;

&lt;p&gt;Sections:&lt;br /&gt;
Idx Name          Size      VMA               LMA               File off  Algn&lt;br /&gt;
  0 .text         00000020  0000000000000000  0000000000000000  00000040  2&lt;strong&gt;2&lt;br /&gt;
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE&lt;br /&gt;
  1 .data         00000004  0000000000000000  0000000000000000  00000060  2&lt;/strong&gt;2&lt;br /&gt;
                  CONTENTS, ALLOC, LOAD, DATA&lt;br /&gt;
  2 .bss          00000000  0000000000000000  0000000000000000  00000064  2&lt;strong&gt;2&lt;br /&gt;
                  ALLOC&lt;br /&gt;
  3 .comment      0000002b  0000000000000000  0000000000000000  00000064  2&lt;/strong&gt;0&lt;br /&gt;
                  CONTENTS, READONLY&lt;br /&gt;
  4 .note.GNU-stack 00000000  0000000000000000  0000000000000000  0000008f  2&lt;strong&gt;0&lt;br /&gt;
                  CONTENTS, READONLY&lt;br /&gt;
  5 .eh_frame     00000038  0000000000000000  0000000000000000  00000090  2&lt;/strong&gt;3&lt;br /&gt;
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA&lt;br /&gt;
vagrant@precise64:/vagrant_data/link_test$ objdump -h name.o&lt;/p&gt;

&lt;p&gt;name.o:     file format elf64-x86-64&lt;/p&gt;

&lt;p&gt;Sections:&lt;br /&gt;
Idx Name          Size      VMA               LMA               File off  Algn&lt;br /&gt;
  0 .text         0000000f  0000000000000000  0000000000000000  00000040  2&lt;strong&gt;2&lt;br /&gt;
                  CONTENTS, ALLOC, LOAD, READONLY, CODE&lt;br /&gt;
  1 .data         00000000  0000000000000000  0000000000000000  00000050  2&lt;/strong&gt;2&lt;br /&gt;
                  CONTENTS, ALLOC, LOAD, DATA&lt;br /&gt;
  2 .bss          00000000  0000000000000000  0000000000000000  00000050  2&lt;strong&gt;2&lt;br /&gt;
                  ALLOC&lt;br /&gt;
  3 .comment      0000002b  0000000000000000  0000000000000000  00000050  2&lt;/strong&gt;0&lt;br /&gt;
                  CONTENTS, READONLY&lt;br /&gt;
  4 .note.GNU-stack 00000000  0000000000000000  0000000000000000  0000007b  2&lt;strong&gt;0&lt;br /&gt;
                  CONTENTS, READONLY&lt;br /&gt;
  5 .eh_frame     00000038  0000000000000000  0000000000000000  00000080  2&lt;/strong&gt;3&lt;br /&gt;
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA&lt;/p&gt;

&lt;p&gt;ld main.o  name.o -e main -o ab                  &lt;br /&gt;
vagrant@precise64:/vagrant_data/link_test$ objdump -h ab&lt;/p&gt;

&lt;p&gt;ab:     file format elf64-x86-64&lt;/p&gt;

&lt;p&gt;Sections:&lt;br /&gt;
Idx Name          Size      VMA               LMA               File off  Algn&lt;br /&gt;
  0 .text         0000002f  00000000004000e8  00000000004000e8  000000e8  2&lt;strong&gt;2&lt;br /&gt;
                  CONTENTS, ALLOC, LOAD, READONLY, CODE&lt;br /&gt;
  1 .eh_frame     00000058  0000000000400118  0000000000400118  00000118  2&lt;/strong&gt;3&lt;br /&gt;
                  CONTENTS, ALLOC, LOAD, READONLY, DATA&lt;br /&gt;
  2 .data         00000004  0000000000600170  0000000000600170  00000170  2&lt;strong&gt;2&lt;br /&gt;
                  CONTENTS, ALLOC, LOAD, DATA&lt;br /&gt;
  3 .comment      0000002a  0000000000000000  0000000000000000  00000174  2&lt;/strong&gt;0&lt;br /&gt;
                  CONTENTS, READONLY&lt;/p&gt;

&lt;p&gt;#+end_src&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ld main.o  name.o -e main -o ab&lt;/li&gt;
  &lt;li&gt;注意 VMA LMA:  VMA (Virtual Memory Address) 为 虚拟地址， LMA( Load Memory Address) 即 加载地址， 一般情况下两个数值 都是一样的，有些切入式系统中 两个数值不同。&lt;/li&gt;
  &lt;li&gt;链接器为 目标文件 分配 地址和空间 的理解： 其中地址和空间 含义有两个： 1）输出的可执行文件的空间， 2） 装载后的虚拟地址中的虚拟地址空间， 对于 .text .data 来说， 他们在 文件中 和 虚拟地址 中都有分配空间， .bss 则 仅在 虚拟地址空间中存在。其中 虚拟地址 关系到 链接器对于 地址的重新计算
    &lt;h4 id="链接-步骤-两部链接"&gt;链接 步骤: 两部链接&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;空间和地址分配：&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;** 扫描所有的输入文件，获得各个段的长度、属性、位置。&lt;br /&gt;
** 将输入文件中的符号 定义 和符号引用 收集起来，统一为一个 全局符号表&lt;br /&gt;
** 合并所有的输入文件的相似段，计算各个合并后的段的长度和位置，并建立映射关系&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;符号解析 与重定位： 链接过程的核心 过程&lt;br /&gt;
** 读取输入文件中的段的数据、重定位信息、进行符号解析与重定位 调整代码中的地址等&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="重定位表-用来提供-给链接器-关于重定位-的相关信息-比如那些需要被调整怎样调整-重定位表-即用来专门提供这些信息"&gt;重定位表： 用来提供 给链接器 关于重定位 的相关信息， 比如那些需要被调整，怎样调整？ 重定位表 即用来专门提供这些信息&lt;/h4&gt;
&lt;p&gt;** 每个 需要 包含需要被重定位符号的 段，都有一个对应的 重定位表。 比如 .text 则赌赢 .rel.text&lt;br /&gt;
** 重定位表结构：&lt;br /&gt;
   #+begin_src &lt;br /&gt;
   vagrant@precise64:/vagrant_data/link_test$ objdump -r main.o&lt;/p&gt;

&lt;p&gt;main.o:     file format elf64-x86-64&lt;/p&gt;

&lt;p&gt;RELOCATION RECORDS FOR [.text]:&lt;br /&gt;
OFFSET           TYPE              VALUE&lt;br /&gt;
000000000000001a R_X86_64_PC32     name-0x0000000000000004&lt;/p&gt;

&lt;p&gt;RELOCATION RECORDS FOR [.eh_frame]:&lt;br /&gt;
OFFSET           TYPE              VALUE&lt;br /&gt;
0000000000000020 R_X86_64_PC32     .text&lt;/p&gt;

&lt;p&gt;vagrant@precise64:/vagrant_data/link_test$ objdump -d main.o&lt;/p&gt;

&lt;p&gt;main.o:     file format elf64-x86-64&lt;/p&gt;

&lt;p&gt;Disassembly of section .text:&lt;/p&gt;

&lt;p&gt;0000000000000000 &amp;lt;main&amp;gt;:&lt;br /&gt;
   0:	55                   	push   %rbp&lt;br /&gt;
   1:	48 89 e5             	mov    %rsp,%rbp&lt;br /&gt;
   4:	48 83 ec 10          	sub    $0x10,%rsp&lt;br /&gt;
   8:	c7 45 fc 0a 00 00 00 	movl   $0xa,-0x4(%rbp)&lt;br /&gt;
   f:	8b 45 fc             	mov    -0x4(%rbp),%eax&lt;br /&gt;
  12:	89 c7                	mov    %eax,%edi&lt;br /&gt;
  14:	b8 00 00 00 00       	mov    $0x0,%eax&lt;br /&gt;
  19:	e8 00 00 00 00       	callq  1e &amp;lt;main+0x1e&amp;gt;&lt;br /&gt;
  1e:	c9                   	leaveq&lt;br /&gt;
  1f:	c3                   	retq&lt;/p&gt;

&lt;p&gt;因为  main中 存在对 外部函数(name.c 中name ) 的调用，所以 call name 命令 的地址 需要被 ld 调整修改，即是 .rel.text 段中需要记录的信息. 在  重定位表 中， offset 代表 改需要被重定位的符号，在段中的偏移，&lt;br /&gt;
main.o 中的 rel.text name中的offset 为1a， 即是 main.o 中的代码段 callq 的地址部分。&lt;br /&gt;
  #+end_src&lt;/p&gt;

&lt;h5 id="common--块"&gt;common  块&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;符号抉择： 如果链接的输入文件中， 存在多个相同的符号类型，该如何选择？  因为链接器本身并不支持符号类型， 变量，函数定义对于编译器 是透明的。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;符号类型 不一致的情况 主要由如下三点：&lt;br /&gt;
** 1. 两个或者两个以上的 强符号类型不一致&lt;br /&gt;
** 2. 有一个强符号，其他都是 弱符号， 出现类型不一致&lt;br /&gt;
** 3. 两个或两个以上 弱符号类型不一致&lt;br /&gt;
** 对于1  无额外处理，即： 链接器直接抛出错误。 2， 3 情况 则需要 common块（common block）机制 来进行处理， common块 很简单， 当不同的 目标文件需要的common块 空间大小不一致时， 以最大的那块为准&lt;br /&gt;
** 弱符号： 即是非强符号， 强符号有： 函数定义， 全局变量， 初始化的内部变量，&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;ABI： ld 能不能 链接 两个不同编译器 编译出来的目标文件呢？ 能够 满足的条件的目标文件 需要满足如下条件：&lt;br /&gt;
** 采用相同的文件格式&lt;br /&gt;
** 同样的符号修饰标准&lt;br /&gt;
** 变量的内存分布方式相同(大端、小端)&lt;br /&gt;
** 函数的调用方式相同 （参数push stack的顺序， 是否 使用 寄存器代替stack ）&lt;br /&gt;
**  etc…&lt;br /&gt;
** 规范这些的即是 二进制兼容性 ABI  (Application Binary Interface)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="静态链接-一种语言的开发环境-往往带有语言库这些苦-就是对操作系统的api-封装其实一个静态库可以简单的堪称一组目标文件的集合很多目标文件经过压缩打包后-形成的一个文件-比如linux-下-usrliblibca"&gt;静态链接: 一种语言的开发环境 往往带有语言库，这些苦 就是对操作系统的api 封装，其实一个静态库可以简单的堪称一组目标文件的集合，很多目标文件经过压缩打包后 形成的一个文件， 比如linux 下 /usr/lib/libc.a&lt;/h4&gt;
&lt;p&gt;** glic 本身是c语言开发的， 他有上千个 C语言源代码文件组成， 编译完成后 有相同数量的 目标文件（上千个） 比如 printf.o scanf.o fread.o &lt;br /&gt;
** 把这些零散的目标文件直接提供给 开发者，造成组织上的不便， 人们采用 ar 压缩程序将目标文件组合到一起，并对其进行编号索引，以便于查找和检索，形成了lib.a 静态库文件.&lt;br /&gt;
** 可以使用ar -t libc.a 来查看文件&lt;br /&gt;
** gcc -static –verbose main.c 可以打印详细的 编译过程&lt;/p&gt;

&lt;h4 id="链接脚本控制-即是-控制ld-参数的方式"&gt;链接脚本控制： 即是 控制ld 参数的方式：&lt;/h4&gt;
&lt;p&gt;** 使用命令行指定参数， 比如ld -e -o&lt;br /&gt;
** 将连接指令存放在目标文件中， 编译器 会通过此类方法 向链接器 传递指令，比如visual c++ 将参数 放在 PE目标文件的 .drectve 段&lt;br /&gt;
** 链接控制脚本， 单独将连接配置放到一个 .lds 文件中， 详细的内容 需要查看参考资料&lt;/p&gt;

&lt;h3 id="动态连接-页映射"&gt;动态连接: 页映射，&lt;/h3&gt;
&lt;h4 id="装载的方式-程序执行时所需要的指令和数据-都必须在内存中-才能够正常运行将程序的指令和数据-装载到内存中-就称为-装载覆盖装入overlay-和页面映射-paging-是典型的两种装载方法"&gt;装载的方式： 程序执行时所需要的指令和数据 都必须在内存中 才能够正常运行。将程序的指令和数据 装载到内存中 就称为 装载。覆盖装入（overlay） 和页面映射 (Paging) 是典型的两种装载方法。&lt;/h4&gt;
&lt;h5 id="页映射"&gt;页映射：&lt;/h5&gt;
&lt;p&gt;** 将内存和磁盘中的 数据和指令 按照 页（page） 为单位划分为若干个页，即 装载和操作的单位是页。 &lt;br /&gt;
** 操作系统角度看 可执行文件的装载：&lt;br /&gt;
** 在 程序中使用物理地址直接进行操作时，都需要硬件的MMU 进行 虚拟地址 到 page 的地址转换功能，&lt;/p&gt;
&lt;h4 id="进程的建立"&gt;进程的建立：&lt;/h4&gt;
&lt;p&gt;** 1. 创建一个独立的虚拟地址空间&lt;br /&gt;
&lt;strong&gt;*** 只需要分配一个页目录 即可， 甚至不需要设定页面映射关系，可以等到后面程序发生页错误的时候 在进行设置 &lt;br /&gt;
** 2. 读取可执行文件头， 并建立 虚拟空间到 可执行文件的映射关系&lt;br /&gt;
**&lt;/strong&gt;*  虚拟空间 与 可执行文件的映射关系。 当 发生缺页错误时，操作系统 应该知道 当前所需页 在可执行文件中的哪一个位置，这就是这步骤的目的&lt;br /&gt;
&lt;strong&gt;*** 该数据结构 只保存在 操作系统内部，Linux 将 进程虚拟空间中的一个段 叫做 虚拟内存区域(virtual Memory Area)  操作系统创建进程后&lt;br /&gt;
**&lt;/strong&gt;* 会在进程相应的数据结构中设定一个 .text 段的VMA &lt;br /&gt;
** 3. 将CPU 的PIC 寄存器 设定为 可执行文件的文件入口地址， 启动运行&lt;br /&gt;
&lt;strong&gt;*** 操作系统通过设定CPU的执行寄存器将控制权交给 进程，由此进程开始执行。 看似简单，操作系统层面比较复杂， 涉及到内核堆栈到用户堆栈的切换，CPU运行权限的切换， 等&lt;br /&gt;
**&lt;/strong&gt;* 进程角度则 认为操作系统执行了一个跳转指令 到 可执行文件的入口地址， ELF 文件头中的 入口地址&lt;/p&gt;
&lt;h4 id="进程虚拟空间分布"&gt;进程虚拟空间分布：&lt;/h4&gt;
&lt;p&gt;** elf 文件 链接视图 与 执行视图 &lt;br /&gt;
&lt;strong&gt;*** elf 映射到 内存时， 当段的数量增多，就会 产生空间浪费问题， 因为 是以系统的页大小问映射单位，段 映射的长度都是系统页的整数倍。如果不是，那么段 多余的部分也将映射 一个页，那么如何减少空间浪费呢？&lt;br /&gt;
**&lt;/strong&gt;* 操作系统视角看 可执行文件，我并不关心 文件的 各个段的内容，我们只关心与装载相关的 权限问题 （即 段是否可以被修改，共享等）， 对于相同权限的段，我们将他们合并到一起当做 一个段进行映射，比如.text .init。 段的权限组合有以下几种：&lt;br /&gt;
&lt;strong&gt;**&lt;/strong&gt; 以代码段 为代表的权限为 可读可执行的段&lt;br /&gt;
&lt;strong&gt;**&lt;/strong&gt; 以数据段和bss段为代表的权限为 可读可写的段&lt;br /&gt;
&lt;strong&gt;**&lt;/strong&gt; 以只读数据段为代表的权限为 只读的段&lt;br /&gt;
&lt;strong&gt;*** Segment: elf 引入segment，一个segment 包含一个或多个属性类型的section，将.text 与 .init 段合并在一起看做一个 segment&lt;br /&gt;
**&lt;/strong&gt;* 装载时候就可以 一起映射。也就说 映射以后 在进程的虚拟空间中 只有一个对应的VMA， 这样的好处就是 明显的减少了 页面的内部碎片&lt;br /&gt;
&lt;strong&gt;*** Segment 概念实际上上从 装载的角度 重新划分elf 的各个段， 将目标文件连接成可执行文件的时候，链接器会尽量将相同权限属性的各个段 分配在同一Sgemtn中&lt;br /&gt;
**&lt;/strong&gt;* 而系统正式按照Segment 而不是section进行映射的&lt;br /&gt;
&lt;em&gt;** 再看了通篇 概念之后，我们可能会问， 为什么 最后要按照 segment 把文件组合呢？ 在前面的 重定位 章节中，我们以为 地址的计算是按照 合并各个段 然后进行计算的，&lt;br /&gt;
**&lt;/em&gt; 其实不是的， &lt;em&gt; VMA 即是最后的 虚拟地址， 重定位的 地址计算也是按照 VMA 得来的。也即是说 链接最后的结果 就是 装载视图。链接视图只是其中的过程而已。&lt;/em&gt;&lt;br /&gt;
*** 描述 segment 的 结构叫做程序头 (Program Header ) 描述了 elf文件该如何被操作系统 映射到进程的 虚拟空间。&lt;/p&gt;
&lt;h5 id="堆栈在进程的虚拟空间中同样是以-vma-存在的-很多情况下一个进程的堆和栈-都有一个对应的vma-linux可以通过proc-来查看进程的-虚拟空间分布"&gt;堆栈：在进程的虚拟空间中，同样是以 VMA 存在的， 很多情况下，一个进程的堆和栈 都有一个对应的VMA， Linux可以通过/proc 来查看进程的 虚拟空间分布&lt;/h5&gt;
&lt;p&gt;#+begin_src &lt;br /&gt;
vagrant@precise64:/vagrant_data/link_test$ sleep 100 &amp;amp;&lt;br /&gt;
[1] 3834&lt;br /&gt;
vagrant@precise64:/vagrant_data/link_test$ cat /proc/3834/maps&lt;br /&gt;
00400000-00406000 r-xp 00000000 fc:00 2359461                            /bin/sleep&lt;br /&gt;
00605000-00606000 r–p 00005000 fc:00 2359461                            /bin/sleep&lt;br /&gt;
00606000-00607000 rw-p 00006000 fc:00 2359461                            /bin/sleep&lt;br /&gt;
01ee5000-01f06000 rw-p 00000000 00:00 0                                  [heap]&lt;br /&gt;
7fba0d791000-7fba0da96000 r–p 00000000 fc:00 3413573                    /usr/lib/locale/locale-archive&lt;br /&gt;
7fba0da96000-7fba0dc4d000 r-xp 00000000 fc:00 2752737                    /lib/x86_64-linux-gnu/libc-2.15.so&lt;br /&gt;
7fba0dc4d000-7fba0de4c000 —p 001b7000 fc:00 2752737                    /lib/x86_64-linux-gnu/libc-2.15.so&lt;br /&gt;
7fba0de4c000-7fba0de50000 r–p 001b6000 fc:00 2752737                    /lib/x86_64-linux-gnu/libc-2.15.so&lt;br /&gt;
7fba0de50000-7fba0de52000 rw-p 001ba000 fc:00 2752737                    /lib/x86_64-linux-gnu/libc-2.15.so&lt;br /&gt;
7fba0de52000-7fba0de57000 rw-p 00000000 00:00 0&lt;br /&gt;
7fba0de57000-7fba0de79000 r-xp 00000000 fc:00 2756455                    /lib/x86_64-linux-gnu/ld-2.15.so&lt;br /&gt;
7fba0e06c000-7fba0e06f000 rw-p 00000000 00:00 0&lt;br /&gt;
7fba0e077000-7fba0e079000 rw-p 00000000 00:00 0&lt;br /&gt;
7fba0e079000-7fba0e07a000 r–p 00022000 fc:00 2756455                    /lib/x86_64-linux-gnu/ld-2.15.so&lt;br /&gt;
7fba0e07a000-7fba0e07c000 rw-p 00023000 fc:00 2756455                    /lib/x86_64-linux-gnu/ld-2.15.so&lt;br /&gt;
7fff892a4000-7fff892c5000 rw-p 00000000 00:00 0                          [stack]&lt;br /&gt;
7fff89388000-7fff89389000 r-xp 00000000 00:00 0                          [vdso]&lt;br /&gt;
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]       &lt;br /&gt;
对于 输出结构 的描述：&lt;/p&gt;

&lt;p&gt;第一列为 VMA 的地址范围， 第二列 为 权限， 第三列 为偏移，标识VMA对应的Segment 在映射文件中的偏移， &lt;br /&gt;
第四列为 映射文件 所在设备的主、次设备号 （可以为0 即没有映射文件 比如stack heap）， 第五列： 映射文件的节点号， 最后为 映射文件路径&lt;/p&gt;

&lt;p&gt;#+end_src&lt;/p&gt;
&lt;h5 id="进程栈初始化-进程运行存在一些环境变量以及-运行参数-常见的做法-是-操作系统-在进程启动时-将这些基本信息-提前保存到-进程的虚拟空间栈中"&gt;进程栈初始化： 进程运行存在一些环境变量以及 运行参数， 常见的做法 是 操作系统 在进程启动时 将这些基本信息 提前保存到 进程的虚拟空间栈中&lt;/h5&gt;

&lt;h4 id="动态链接"&gt;动态链接：&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;** 为什么需要动态链接： 1） 静态链接 对于计算机内存和磁盘的空间浪费非常严重， 特别是多进程的时候，极大的浪费了内存空间，  2） 更新、部署 困难， 基础库的更新 导致 所有的依赖程序 需要重新编译&lt;br /&gt;
**&lt;/em&gt; 解决方法即是： 把程序的模块相互分隔开来，形成独立的文件，而不再将他们静态的链接在一起。即是： 不对那些组成程序的目标文件进行连接，等到程序要运行时 才进行连接。 &lt;br /&gt;
*** 把链接过程推迟到了运行时再进行，这就是动态链接的基本思想&lt;/p&gt;
&lt;h5 id="动态链接过程的优势-动态链接简单过程"&gt;动态链接过程的优势； 动态链接简单过程&lt;/h5&gt;
&lt;p&gt;&lt;em&gt;** Programe1 依赖  Lib.o&lt;br /&gt;
**&lt;/em&gt; Programe2 依赖  Lib.o&lt;br /&gt;
&lt;em&gt;** 运行 Programe1 时，系统加载 Programe1.o 然后加载依赖 Lib.o 如果Lib.o 依赖其他文件，则依次递归加载所有依赖。&lt;br /&gt;
**&lt;/em&gt; 当所有依赖关系加载完成之后， 开始链接工作，链接工作 与静态链接非常相似， 包括 符号解析，地址重定位等。&lt;br /&gt;
&lt;em&gt;** 完成上述工作之后，将控制权交给Programe1.o 的程序入口处。程序开始运行，&lt;br /&gt;
**&lt;/em&gt; 当运行Program2时，系统加载Program2.o，但是不在加载 Lib.o 因为系统已经在运行Program1时，加载了 Lib.o&lt;br /&gt;
** 1. 通过以上过程，可以发现 动态链接 节省了一次Lib.o 的依赖 加载。 &lt;br /&gt;
** 2. 在其中如果更新Lib.o 时，不需要 重新编译 Programe1, 与 Programe2 仅仅 更新Lib.o 在下一次重新运行Program1，2时，即可使用最新的依赖&lt;/p&gt;
&lt;h5 id="程序可扩展性和兼容性"&gt;程序可扩展性和兼容性：&lt;/h5&gt;
&lt;p&gt;** 动态链接 可以在 程序运行时 动态的选择加载各种程序模块，这个特点被人们用来开发 插件功能&lt;br /&gt;
** 动态链接可以加强程序的兼容性，  一个程序可以再不同的平台运行时 可以动态的链接到右操作系统 提供的动态链接库，比如 程序依赖printf 函数， 操作系统 A与 B 只需要提供 一样的printf 接口，即可实现 程序在操作系统AB上的运行&lt;/p&gt;
&lt;h5 id="动态链接-的基本实现"&gt;动态链接 的基本实现：&lt;/h5&gt;
&lt;p&gt;** 动态链接涉及到 各个文件的装载， 需要操作系统的支持， 因为在动态链接的情况下，进程的虚拟地址空间分布 会比 静态链接 情况下更加复杂，&lt;br /&gt;
** 内存管理、内存共享、进程线程等机制，在 动态链接下也会有一些变化，Linux 中动态链接文件 称为 动态共享对象(DSO Dynamic Shared Objects) 以.so 为扩展名， Windows中 动态链接文件称为 动态链接库(Dynamical Linking Library) .dll 为扩展名&lt;/p&gt;
&lt;h5 id="动态链接-导致的问题-因为动态链接-将在程序编译阶段的工作推迟到了-运行时间段导致-程序每次被装载时-都要进行-重新进行连接导致一些程序性能上的损失性能损失-大约在5以下这些损失-换来-程序在空间上的-节省和程序构建升级上的便利性是相当值得的"&gt;动态链接 导致的问题： 因为动态链接 将在程序编译阶段的工作推迟到了 运行时间段，导致 程序每次被装载时 都要进行 重新进行连接。导致一些程序性能上的损失，性能损失 大约在5%以下。这些损失 换来 程序在空间上的 节省和程序构建升级上的便利性，是相当值得的。&lt;/h5&gt;

&lt;h5 id="地址无关代码"&gt;地址无关代码：&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;* 装载时重定位： 为了能够共享对象在任意地址被装载， 第一个方法为： 装载时重定位， 在链接时，对所有 绝对地址的应用不做重定位，而把这一步推迟到装载时在完成，即：一旦模块装载地址确定 即目标地址确定，name系统就对模块中的所有绝对地址 引用进行重定位，即， 系统需要遍历所有的重定位表，对所有 符号的地址引用进行修改。&lt;br /&gt;
*** 静态链接中提到的重定位： 链接时重定位， 现在为 装载时重定位。 &lt;br /&gt;
*** 存在问题： 指令中对绝对地址函数的应用，被修改好，不能很好的在多个进程中共享。&lt;br /&gt;
** 地址无关代码 的基本思想： 将指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分可以保持不变，而数据部分可以在每个进程中拥有一个副本。 即是地址无关代码技术(PIC position-indenpendent Code)&lt;br /&gt;
*** 具体解决方法：共享对象模块中的地址应用 分为两类： 模块内部引用、模块外部应用 按照应用类型不同 又分为 函数引用和数据引用， 可分为4类：&lt;br /&gt;
**&lt;/strong&gt;* 1. 模块内部的函数调用、跳转&lt;br /&gt;
&lt;strong&gt;*** 2. 模块内部的数据访问， 如模块中定义的全局变量、静态变量&lt;br /&gt;
**&lt;/strong&gt;* 3. 模块外部的函数调用、跳转&lt;br /&gt;
&lt;strong&gt;*** 4. 模块外部的数据访问， 如 其他模块中定义的全局变量&lt;br /&gt;
*** 条件对应的 解决方法为： &lt;br /&gt;
**&lt;/strong&gt;* 1. 即是：相对 位置调用， 因为同在模块内，函数间 的地址相对位置是确定的&lt;br /&gt;
&lt;strong&gt;*** 2. 相对寻址，我们知道， 一个模块前面一般是若干页的代码 后面跟 若干页 的数据，这些页 的相对位置是固定的， 所以 可以使用 指定+ 相对位置 间隔 来访问模块内部的数据 （这里是否存在其他问题呢？ 确定 系统装载时候， 代码与数据段的相对位置是固定的吗？）&lt;br /&gt;
**&lt;/strong&gt;* 4. 模块间的 地址访问 （数据访问、函数地址访问） 比较麻烦， 因为 模块间的地址访问 需要等到装载时候才能决定， 要使该类 代码地址无关，基本思想： 把地址相关的部分放到数据段里面，具体 ELF 的做法就是在数据段里面建立一个指向这些变量的数组指针， 称为 全局偏移表(Global offset Table GOT) 当代吗需要引用该全局变量时候，可以通过GOT中的相对应的项间接引用, 图示如下： &lt;br /&gt;
&lt;strong&gt;**&lt;/strong&gt; 当指令中：需要访问变量b时，程序会找到GOT， 然后根据GOT中的变量所对应的项找到变量的目标地址， 链接器 在装载模块时，会查找每个变量所在的地址，然后填充GOT中的各个项， 以保证 项目地址指向正确。因为GOT 在数据段中，所以他可以在装载时候被修改，并且每个进程都有独立的副本存在。&lt;/p&gt;

&lt;p&gt;gcc -fPIC -shared -o name.so name.c&lt;br /&gt;
***** 3. 同4中一样， 使用 GOT 来保存 函数地址&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;指令跳转、调用&lt;/th&gt;
      &lt;th&gt;数据访问&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;模块内部&lt;/td&gt;
      &lt;td&gt;相对跳转和调用&lt;/td&gt;
      &lt;td&gt;相对地址访问&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;模块外部&lt;/td&gt;
      &lt;td&gt;间接跳转和调用(GOT)&lt;/td&gt;
      &lt;td&gt;间接访问(GOT)&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;-fpic 与 -fPIC 参数的区别: -fPIC 产生的代码要更大， 更跨平台， 而-fpic 产生的代码更小， 也更快，但是存在一些限制，更与硬件相关&lt;/p&gt;

&lt;h4 id="由上可见-动态链接-会使程序变慢的-原因有-1-动态装载重定位计算-2-共享代码段中-通过got来访问数据调用函数"&gt;由上可见： 动态链接 会使程序变慢的 原因有： 1） 动态装载，重定位计算， 2） 共享代码段中 通过GOT来访问数据，调用函数&lt;/h4&gt;

&lt;p&gt;延迟绑定（Procedure Linkage Table）:  共享模块加载时候，程序需要浪费不少时间来 用于解决模块之间的函数应用的符号查找 以及重定位。 而在实际中 大量的函数很少被使用到， 所以 ELF采用了一种叫做延迟绑定的做法， 基本的思想就是 当函数第一次被用到时候 才进行绑定（符号查找，重定位等）&lt;/p&gt;

&lt;h4 id="动态链接-文件启动-顺序-与静态链接情况基本一致-首先操作系统-读取可执行文件-的头部检查合法性-并从-header中读取各个segment-映射到进程虚拟空间的对应文职-这时候差异开始显现-静态链接情况下-操作系统将-控制权直接交给-可执行文件的入口地址然后程序开始执行-动态链接情况下-操作系统并不能将控制权交给可执行文件-因为其-依赖的-很多共享对象还没有加载起来所以操作系统-先启动一个动态链接器由动态链接器-来进行一系列的初始化工作并进行动态链接工作当所有-链接工作完成以后-动态联机器将-控制权-交给可执行文件-的入口地址程序开始正式执行"&gt;动态链接 文件启动 顺序： 与静态链接情况基本一致， 首先操作系统 读取可执行文件 的头部，检查合法性， 并从 header中读取各个Segment 映射到进程虚拟空间的对应文职。 这时候差异开始显现， 静态链接情况下， 操作系统将 控制权直接交给 可执行文件的入口地址，然后程序开始执行。 动态链接情况下： 操作系统并不能将控制权交给可执行文件， 因为其 依赖的 很多共享对象，还没有加载起来，所以操作系统 先启动一个动态链接器，由动态链接器 来进行一系列的初始化工作，并进行动态链接工作，当所有 链接工作完成以后， 动态联机器将 控制权 交给可执行文件 的入口地址，程序开始正式执行&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;动态链接器的路径配置：  .interp 段 中 为 ld 的具体路径&lt;/li&gt;
  &lt;li&gt;动态符号表： 为了完成链接， 需要 所依赖的符号和相关文件的信息， 在静态链接中 有 段为 .symtab (Symbol Table) 动态链接中 则为 Dynmic Symbol Table .dynsym 其中只保存 动态链接相关的符号。很多动态链接库中同时存在.dynsym 以及 .symtab 两个表， .symtab 中 保存了所有的符号。其中的符号 字符串 则保存在 .dynstr (Dynamic String Table) 其中往往还有 符号哈希表 用于加快符号查找速度&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;readelf -sD  lib.so&lt;/p&gt;

&lt;p&gt;动态链接 需要在装载时候 进行重定位， 对于 使用 PIC 模式编译的（地址无关代码） 则只需要对GOT进行 重定位， 非PIC编译的，则在装载时候 重定位（即 代码段 也被 修改，而无法与其他程序共享） &lt;br /&gt;
重定位结构： 动态链接中 重定位表 为.rel.dyn, .rel.plt  对应于静态链接中的 .rel.text, .rel.data 分别对应  .got （数据段）, 以及 .got.plt （代码段，函数调用地址的修正）&lt;/p&gt;

&lt;p&gt;root@precise64:/vagrant_data/link_test# readelf -r main.so&lt;/p&gt;

&lt;p&gt;Relocation section ‘.rela.dyn’ at offset 0x420 contains 4 entries:&lt;br /&gt;
  Offset          Info           Type           Sym. Value    Sym. Name + Addend&lt;br /&gt;
000000201010  000000000008 R_X86_64_RELATIVE                    0000000000201010&lt;br /&gt;
000000200fd0  000300000006 R_X86_64_GLOB_DAT 0000000000000000 &lt;strong&gt;gmon_start&lt;/strong&gt; + 0&lt;br /&gt;
000000200fd8  000400000006 R_X86_64_GLOB_DAT 0000000000000000 _Jv_RegisterClasses + 0&lt;br /&gt;
000000200fe0  000500000006 R_X86_64_GLOB_DAT 0000000000000000 __cxa_finalize + 0&lt;/p&gt;

&lt;p&gt;Relocation section ‘.rela.plt’ at offset 0x480 contains 2 entries:&lt;br /&gt;
  Offset          Info           Type           Sym. Value    Sym. Name + Addend&lt;br /&gt;
000000201000  000200000007 R_X86_64_JUMP_SLO 0000000000000000 name + 0&lt;br /&gt;
000000201008  000500000007 R_X86_64_JUMP_SLO 0000000000000000 __cxa_finalize + 0&lt;/p&gt;

&lt;p&gt;** 动态链接时候，进程堆栈的初始化信息： 当操作系统将控制权交给 动态链接器的时候， 除了 进程初始化时候的，堆栈里面关于进程执行环境和命令行参数等， 还包含 不少的 动态链接器所需要的辅助信息，比如 可执行文件的入口地址等， &lt;br /&gt;
** 这些信息往往由操作系统传递给动态链接器，&lt;/p&gt;
&lt;h4 id="动态链接器自举-因为动态链接器-也是一个共享库而动态链接器是操作系统的程序入口-所以动态链接器如何递归的解决自己的依赖关系完成启动是一个-非常有意思的事情"&gt;动态链接器自举： 因为动态链接器 也是一个共享库，而动态链接器是操作系统的程序入口， 所以动态链接器如何递归的解决自己的依赖关系，完成启动，是一个 非常有意思的事情。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;动态链接器完成自举之后，链接器将 可执行文件和链接器本身的符号表合并到一个符号表中， 称为 全局符号表&lt;/li&gt;
  &lt;li&gt;之后 开始寻找可执行文件所依赖的共享对象， 在.dynamic 段中， 类型为NEEDED 为 可执行文件所依赖的 共享对象，由此 链接器可以获得 可执行文件的所需要的所有的共享对象，其组成的一个集合&lt;/li&gt;
  &lt;li&gt;称为 装载集合， 从装载集合中取出来一个文件，打开 并读取对应的ELF header 和.dynamic 段，将其所依赖的其他的共享对象 加入到家在集合中，如此递归的加载所有依赖的共享对象&lt;/li&gt;
  &lt;li&gt;常见的加载算法为 广度优先&lt;/li&gt;
  &lt;li&gt;当新的共享对象被加载进来的时候，他的符号表会被合并到全局符号表中， 所以 当所有的共享对象 被装载进来的时候，全局符号表里面将函数进程中所有的动态链接所需要的符号&lt;/li&gt;
  &lt;li&gt;所以动态链接器的加载顺序决定了符号的优先级&lt;/li&gt;
  &lt;li&gt;链接器开始变量可执行文件和每个共享对象的重定位表，将他们的 .got.plt 中的每个需要重定位的位置进行修正， 因为此时动态链接器已经拥有了进程的全局符号表，所以这个修正过程会比较容易&lt;/li&gt;
  &lt;li&gt;重定位完成后，如果某个共享对象 存在.init 段， 则动态链接器 会执行.init 段中的代码， 泳衣实现共享对象特有的初始化代过程， 比如 c++中 全局对象的构造过程， 共享对象中的 .finit 段，则在进程退出时执行 实现共享对象 的析构类型操作&lt;/li&gt;
  &lt;li&gt;与 链接器执行的.init 对比，则为 可执行文件的 .init, .finit段的执行者， 需要在后面补充
    &lt;h5 id="符号优先级"&gt;符号优先级：&lt;/h5&gt;
  &lt;/li&gt;
  &lt;li&gt;动态链接器 按照 各个模块之间依赖关系，对他们进行装载并将他们的符号 并入到 全局符号表。 那么就有可能 两个不同的模块定义了 同一个符号，导致符号歧义，&lt;/li&gt;
  &lt;li&gt;该现象称为 共享对象全局符号介入 问题，  那么链接器 如何 解决此类问题呢？ 其规则为： 当一个符号需要加入全局符号表时，如果相同的符号名已经存在，对于&lt;/li&gt;
  &lt;li&gt;则后加的符号 被忽略。由于存在该类问题， 所以 当程序中存在大量的 共享对象 时候，应该非常小心符号的重名问题， 如果 两个符号重名  又执行不同的功能&lt;/li&gt;
  &lt;li&gt;name程序运行时 可能会将所有的该符号的应用解析到 第一个被加入全局符号表的符号，从而导致 莫名其妙的错误&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id="如何-避免全局符号介入问题-对于-导出-符号全局符号-是不可能解决的然而-内部函数调用-可以使用-static-关键字-来避免其成为-全局符号-而被-其他模块覆盖则在内部-程序直接使用-内部-相对地址调用也加快了-程序的调用速度-即-不适用-gotplt-来-进行-间接跳转"&gt;如何 避免全局符号介入问题： 对于 导出 符号（全局符号） 是不可能解决的，然而 内部函数调用， 可以使用 static 关键字 来避免其成为 全局符号 而被 其他模块覆盖，则在内部 程序直接使用 内部 相对地址调用，也加快了 程序的调用速度。 即 不适用 .got.plt 来 进行 间接跳转。&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;则 更一般的规律为： 文件内部函数调用 都采用的 .got.plt 进行跳转调用，除非 被调用函数为static 则不会成为符号，而是用 内部相对地址调用&lt;/li&gt;
  &lt;li&gt;
    &lt;h5 id="动态链接器-的接个问题"&gt;动态链接器 的接个问题：&lt;/h5&gt;
  &lt;/li&gt;
  &lt;li&gt;动态链接器 本身是 动态链接的还是 静态链接的？： 静态链接的， 因为 他不能依赖 与其他共享对象， 其存在的目的 即为 解决 其他elf 动态链接文件 的依赖关系的，所以不能存在依赖&lt;/li&gt;
  &lt;li&gt;动态链接器 本身必须是PIC 的吗？ 并不是， 动态链接器 的目的是帮助其他elf解决依赖关系，本身是否PIC  的 决定 其代码是否 能够共享。如果 PIC 则会更加简单一些，因为 非PIC的话，链接器在自举的时候 往往 还需要重定位自己的代码段&lt;/li&gt;
  &lt;li&gt;动态链接器 是否可以被当做可执行文件运行？ 可运行的话，其装载地址是多少？： 可以当做可执行文件来运行， 其装载地址 没有什么区别 几位 0x00000000 这是一个无效地址 ，作为共享库，内核在装载时， 会为期选择一个合适的装载地址
    &lt;h5 id="显式-运行时链接explicit-run-time-linking-即是程序在运行期间-可以主动的加载指定的-动态链接库-而共享对象-不需要任何的修改-即可-被-运行时装载"&gt;显式 运行时链接(Explicit Run-time Linking) 即是：程序在运行期间 可以主动的加载指定的 动态链接库， 而共享对象 不需要任何的修改 即可 被 运行时装载&lt;/h5&gt;
  &lt;/li&gt;
  &lt;li&gt;这种共享对象往往被叫做 动态装载库 (Dynamic Loading Library) 本质 上与 一般的共享对象 没有任何区别，只是 使用的角度不同而已&lt;/li&gt;
  &lt;li&gt;其理论上 与 可执行文件 依赖 共享对象 一样的执行方式&lt;/li&gt;
  &lt;li&gt;主要API有： dlopen  dlsym, dlerror, dlclose&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id="共享库的-组织方式"&gt;共享库的 组织方式：&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;因为共享对象的优点，导致 大量的程序开始使用共享对象，导致系统中存在数量极为庞大的共享对象， 所以操作系统一般会对共享对象的目录组织和使用方式 有一定的规定，即为 共享库，&lt;/li&gt;
  &lt;li&gt;共享库与共享对象没有任何区别，只是 共享库为共享对象的 组织方式 的另一个称呼 而已
    &lt;h6 id="共享库的兼容性"&gt;共享库的兼容性：&lt;/h6&gt;
  &lt;/li&gt;
  &lt;li&gt;兼容更新：所有的更新只是在原有的共享库基础上添加一些内容， 原接口保持不变&lt;/li&gt;
  &lt;li&gt;不兼容更新： 共享库改变了原有接口， 使用该共享库的原有接口的程序 无法运行&lt;/li&gt;
  &lt;li&gt;这里面讨论的接口为 ABI， 而非其他的接口， 导致ABI发生变化的有以下几种情况：&lt;/li&gt;
  &lt;li&gt;共享库的版本命名： 用于解决 兼容性问题。 使用命名规范来 明确兼容性。共享库的文件命名如下： libname.so.x.y.z&lt;/li&gt;
  &lt;li&gt;x 为主要版本号(Major version number)， y 为子版本号(Minor version number)， z为发布版本号(Release version number)&lt;/li&gt;
  &lt;li&gt;主版本号： 库的重大升级， 不同主版本号之间 是不兼容的，依赖旧版本共享库的程序 需要 重新编译 才能 使用最新的共享库版本， 或者 系统保留 旧的版本，旧程序才能正常运行&lt;/li&gt;
  &lt;li&gt;次版本号： 增量升级， 增加一些新的接口符号，保持原有的符号不变， 高的次要版本号 要 向后兼容低次要版本号的 共享库。 一个依赖 低次要版本号的程序 可以再 高次要版本号的共享库 下运行。&lt;/li&gt;
  &lt;li&gt;发布版本号： 对一些错误的修正、性能的改进等。  不添加新的接口 也不对 接口进行更改， 相同主版本号，次版本号，不同发布版本号 之间完全兼容&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
  </entry>
  <entry>
    <title>java shell docker</title>
    <link rel="alternate" href="http://geniousbar.github.io/2020/09/15/java-shell-docker/"/>
    <id>http://geniousbar.github.io/2020/09/15/java-shell-docker/</id>
    <published>2020-09-15T00:00:00+00:00</published>
    <updated>2021-04-19T04:41:34+00:00</updated>
    <summary type="html">&lt;h2 id="a-little-book-on-java-的总结"&gt;A Little Book on Java 的总结&lt;/h2&gt;
&lt;h4 id="basic"&gt;Basic&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;编译 与 运行&lt;br&gt;
编译: javac First.java 产生一个 First.class 文件&lt;br&gt;
运行：java First 将运行 编译之后 First.class
    &lt;ul&gt;
      &lt;li&gt;java  编译器 将 源代码 中的每个 class 转变为 对应的 class file 并存储 其 字节码&lt;/li&gt;
      &lt;li&gt;有 main 函数的 class才能够运行，一个项目中存在多个class 有 main 函数 是为了 将 项目...&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    <content type="html">&lt;h2 id="a-little-book-on-java-的总结"&gt;A Little Book on Java 的总结&lt;/h2&gt;
&lt;h4 id="basic"&gt;Basic&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;编译 与 运行&lt;br /&gt;
编译: javac First.java 产生一个 First.class 文件&lt;br /&gt;
运行：java First 将运行 编译之后 First.class
    &lt;ul&gt;
      &lt;li&gt;java  编译器 将 源代码 中的每个 class 转变为 对应的 class file 并存储 其 字节码&lt;/li&gt;
      &lt;li&gt;有 main 函数的 class才能够运行，一个项目中存在多个class 有 main 函数 是为了 将 项目分为不同的 可以运行的单元 方便测试&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;基本类型
    &lt;ul&gt;
      &lt;li&gt;Number, float, double, int&lt;/li&gt;
      &lt;li&gt;Character: char a = ’a’;&lt;/li&gt;
      &lt;li&gt;Boolean: boolean true and false&lt;/li&gt;
      &lt;li&gt;Strings: String title = “A Little Book on Java”;&lt;/li&gt;
      &lt;li&gt;Array: datatype[] ArrayName = new datatype[ArraySize]; 当 使用 index 超过 数组边界 时 会发生 ArrayIndexOutOfBoundsException 错误&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;流程控制语句
    &lt;ul&gt;
      &lt;li&gt;while loop
&lt;div class="highlight"&gt;&lt;pre class="highlight java"&gt;&lt;code&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;boolean&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="n"&gt;statement&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;for loop&lt;br /&gt;
```java&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;for (initial-expression, boolean-expression, increment-expression) st  atement&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;* if
```java

if (boolean-expression)
  statement
else if (boolean-expression) 
  statement
else
  statement
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;break;
    &lt;ol&gt;
      &lt;li&gt;抽象机制&lt;/li&gt;
      &lt;li&gt;Procedures&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;its name,&lt;/li&gt;
  &lt;li&gt;what kinds of parameters it expects (if any),&lt;/li&gt;
  &lt;li&gt;what kind of result it might return.
    &lt;ol&gt;
      &lt;li&gt;class&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Syntax of Class Declarations
&lt;div class="highlight"&gt;&lt;pre class="highlight java"&gt;&lt;code&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Hello&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
  &lt;li&gt;main method; java foo a b c, params as args array
&lt;div class="highlight"&gt;&lt;pre class="highlight java"&gt;&lt;code&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Foo&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;String&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;[]){&lt;/span&gt;
    &lt;span class="cm"&gt;/* Body of main */&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
  &lt;li&gt;static variable &amp;amp; function and usage&lt;br /&gt;
```java&lt;br /&gt;
class Foo {&lt;br /&gt;
static int name;&lt;br /&gt;
public static void showFoo(){&lt;br /&gt;
}&lt;br /&gt;
}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;classname.methodname(parameters); // static method usage&lt;br /&gt;
classname.variablename;           // static variable usage&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;* Visibility Issues （可见控制）: Public data and code is visible to all classes, while private data and code is visible only inside the class that contains it.

7. The Object Concept
* The State of an Object (Instance variables)
```java
class PointIn3D{
  //Instance Variables
  private double x;
  private double y;
  private double z;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;Constructors
&lt;div class="highlight"&gt;&lt;pre class="highlight java"&gt;&lt;code&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;PointIn3D&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
&lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

 &lt;span class="c1"&gt;//Constructors&lt;/span&gt;
&lt;span class="c1"&gt;//This constructor does not take parameters&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;PointIn3D&lt;/span&gt;&lt;span class="o"&gt;(){&lt;/span&gt;
  &lt;span class="cm"&gt;/* Initializing the fields of this object to the origin,
     a default point */&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;//This constructor takes parameters&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;PointIn3D&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="no"&gt;X&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="no"&gt;Y&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="no"&gt;Z&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
  &lt;span class="cm"&gt;/* Initializing fields of this object to values specified by
     the parameters */&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;X&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;Y&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;Z&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
  &lt;li&gt;Creating an Object
&lt;div class="highlight"&gt;&lt;pre class="highlight java"&gt;&lt;code&gt;&lt;span class="c1"&gt;//Creates a PointIn3D object with coordinates (0, 0, 0)&lt;/span&gt;
&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nf"&gt;PointIn3D&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="c1"&gt;//Creates a PointIn3D object with coordinates (10.2, 78, 1) new PointIn3D(10.2, 78, 1);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
  &lt;li&gt;Object References&lt;br /&gt;
```java&lt;br /&gt;
ReferenceType ReferenceName;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PointIn3D p = new PointIn3D(1, 1, 1);&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;* Accessing the Fields of an Object
```java
 ReferenceName.FieldName;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;The Behavior of an Object
&lt;div class="highlight"&gt;&lt;pre class="highlight java"&gt;&lt;code&gt;  &lt;span class="nc"&gt;ObjectReference&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;InstanceMethodName&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;Parameter&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nc"&gt;List&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
  &lt;li&gt;The this reference: Inside an instance method, this is a reference to the object on which the instance method is invoked. Inside a constructor, this refers to the object that the constructor just created.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight java"&gt;&lt;code&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;PointIn3D&lt;/span&gt;&lt;span class="o"&gt;(){&lt;/span&gt;
  &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;z&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="nf"&gt;getX&lt;/span&gt;&lt;span class="o"&gt;(){&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;x&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;Inheritance: extends, super can use in subtype to call supertype methods&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;Rules for Method Lookup and Type Checking.
    &lt;ul&gt;
      &lt;li&gt;First the rules. Remember that there are two phases: compile time, which is when type checking is done and run time, which is when method lookup happens. Compile time is before run time.&lt;/li&gt;
      &lt;li&gt;The type checker has to say that a method call is OK at compile time.&lt;/li&gt;
      &lt;li&gt;All type checking is done based on what the declared type of a reference to an object is.&lt;/li&gt;
      &lt;li&gt;Subtyping is an integral part of type checking. This means if B is a subtype of A and there is a context that gets a B where A was expected there will not be a type error.&lt;/li&gt;
      &lt;li&gt;Method lookup is based on actual type of the object and not the declared type of the reference.&lt;/li&gt;
      &lt;li&gt;When there is overloading (as opposed to overriding) this is resolved by type-checking.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight java"&gt;&lt;code&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;myInt&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;myInt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;getval&lt;/span&gt;&lt;span class="o"&gt;(){&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;increment&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;n&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;myInt&lt;/span&gt; &lt;span class="nf"&gt;add&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;myInt&lt;/span&gt; &lt;span class="no"&gt;N&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nf"&gt;myInt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;n&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="no"&gt;N&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getval&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;show&lt;/span&gt;&lt;span class="o"&gt;(){&lt;/span&gt;
        &lt;span class="nc"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;gaussInt&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;myInt&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;//represents the imaginary part&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;gaussInt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
        &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;m&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;show&lt;/span&gt;&lt;span class="o"&gt;(){&lt;/span&gt;
        &lt;span class="nc"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"realpart is: "&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getval&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;" imagpart is: "&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;realpart&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nf"&gt;getval&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
            &lt;span class="o"&gt;;}&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;imagpart&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;gaussInt&lt;/span&gt; &lt;span class="nf"&gt;add&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gaussInt&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nf"&gt;gaussInt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;realpart&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;realpart&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt;
                            &lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;imagpart&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;imagpart&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;gaussInt&lt;/span&gt; &lt;span class="n"&gt;kreimhilde&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;gaussInt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;kreimhilde&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;show&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;kreimhilde&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;increment&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;kreimhilde&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;show&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="nc"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Now we watch the subtleties of overloading."&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;myInt&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;myInt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;gaussInt&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;gaussInt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;gaussInt&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;myInt&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;myInt&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;add&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//this does type System.out.print("the value of d is:&lt;/span&gt;

        &lt;span class="c1"&gt;// error is this&lt;/span&gt;
        &lt;span class="c1"&gt;// w = z.add(b);// will not type check&lt;/span&gt;
        &lt;span class="c1"&gt;// w = b.add(z); will not type check&lt;/span&gt;
        &lt;span class="n"&gt;w&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gaussInt&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="na"&gt;add&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//this does type check System.out.print("the value of w is: ");&lt;/span&gt;
        &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;show&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;myInt&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;add&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//will this typecheck? System.out.print("the value of c is: ");&lt;/span&gt;
        &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;show&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;
  &lt;li&gt;The Exception Object
    &lt;ul&gt;
      &lt;li&gt;分为两类： unchecked exceptions and checked exceptions.&lt;/li&gt;
      &lt;li&gt;所有的exception 都发生在 runtime， 因为不是的话，要啥编译检查？&lt;/li&gt;
      &lt;li&gt;Unchecked exceptions 与  checked exception 的区别主要在于： Unchecked exceptions happen because of the programmer’s carelessness，也就是说  unchecked exception 是可以预防的，可以避免的。两个主要的 unchecked exception 主要有： rrayIndexOutofBoundsException and NullPointerException&lt;/li&gt;
      &lt;li&gt;所有其他的非 unchecked exception 再是：checked exceptions， 连个主要的exception 有 FileNotFoundException and IOException.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;创建 新的 exception
    &lt;ul&gt;
      &lt;li&gt;新创建的 exception 应该继承 exception 或者 任何 除 RunTimeException 之外的 子类。 因为 新创建的 exception  为 checked exception&lt;/li&gt;
      &lt;li&gt;An exception is thrown to indicate the occurrence of a runtime error. Only checked exceptions should be thrown, as all unchecked exceptions should be eliminated. 意思是： 只有 checked exceptions 需要throw 声明， unchecked exception 因为无法预测，只能 尽量消除掉。（If a method’s header does not contain a throws clause, then the method throws no checked exceptions.）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Throwing an Exception
&lt;div class="highlight"&gt;&lt;pre class="highlight java"&gt;&lt;code&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="kd"&gt;throws&lt;/span&gt; &lt;span class="nc"&gt;IOException&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                                          &lt;span class="nc"&gt;FileNotFoundException&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;ul&gt;
      &lt;li&gt;A method’s header advertises the checked exceptions that may occur when the method executes&lt;/li&gt;
      &lt;li&gt;An exception can occur in two ways: explicitly through the use of a throw statement or implicitly by calling a method that can throw an exception 意思是：异常产生有两种方式：1. 直接抛出异常 2. 调用 能够抛出异常的函数&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Catching an Exception: catch 异常的方式同其他 语言一致， 即是 不断的递归的 解开栈，以找到合适的 catch。如果无法找到适合的 catch 则  使用默认的 default exception handler 来捕获异常，所以default exception handler 是在哪一层？main 层面吗？
&lt;div class="highlight"&gt;&lt;pre class="highlight java"&gt;&lt;code&gt;&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
   &lt;span class="n"&gt;code&lt;/span&gt; &lt;span class="n"&gt;that&lt;/span&gt; &lt;span class="n"&gt;could&lt;/span&gt; &lt;span class="n"&gt;cause&lt;/span&gt; &lt;span class="n"&gt;exceptions&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;catch&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;Exception&lt;/span&gt; &lt;span class="n"&gt;e1&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
   &lt;span class="n"&gt;code&lt;/span&gt; &lt;span class="n"&gt;that&lt;/span&gt; &lt;span class="n"&gt;does&lt;/span&gt; &lt;span class="n"&gt;something&lt;/span&gt; &lt;span class="n"&gt;about&lt;/span&gt; &lt;span class="n"&gt;exception&lt;/span&gt; &lt;span class="n"&gt;e1&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;catch&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;Exception&lt;/span&gt; &lt;span class="n"&gt;e2&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
   &lt;span class="n"&gt;code&lt;/span&gt; &lt;span class="n"&gt;that&lt;/span&gt; &lt;span class="n"&gt;does&lt;/span&gt; &lt;span class="n"&gt;something&lt;/span&gt; &lt;span class="n"&gt;about&lt;/span&gt; &lt;span class="n"&gt;exception&lt;/span&gt; &lt;span class="n"&gt;e2&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="a-little-book-on-shell"&gt;A Little Book on Shell&lt;/h2&gt;
&lt;h4 id="差用-command"&gt;差用 command&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;file cp mv mkdir rm ln &lt;br /&gt;
其中ln  命令 ln file link, 默认 创建 hard link， ln -s file link 才 为 soft link， soft link 同样增加 file 的link count&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Working with Commands (type which  help man apropos info whatis alias)&lt;br /&gt;
| command | meaning                                           |&lt;br /&gt;
|———|—————————————————|&lt;br /&gt;
| type    | Indicate how a command name is interpreted        |&lt;br /&gt;
| which   | Display which executable program will be executed |&lt;br /&gt;
| help    | Get help for shell builtins                       |&lt;br /&gt;
| man     | Display a command’s manual page                   |&lt;br /&gt;
| apropos | Display a list of appropriate commands            |&lt;br /&gt;
| info    | Display a command’s info entry                    |&lt;br /&gt;
| whatis  | Display one-line manual page descriptions         |&lt;br /&gt;
| alias   | Create an alias for a command                     |&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;commands 的来源：
    &lt;ul&gt;
      &lt;li&gt;An executable program: 例如 /usr/bin 下面的 可执行文件，&lt;/li&gt;
      &lt;li&gt;A command built into the shell itself.： bash 支持的内建 的 命令&lt;/li&gt;
      &lt;li&gt;A shell function： shell 函数 Shell functions are miniature shell scripts incorporated into the environment&lt;/li&gt;
      &lt;li&gt;An alias： Aliases are commands that we can define ourselves, built from other commands.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;man 详细内容： Display a Program’s Manual Page。 手册内容 被分为 几个 章节， 出了 使用 man command, 之外 可以使用 man 1 command 来显示 User commands 章节&lt;br /&gt;
| section | contents                                       |&lt;br /&gt;
|———|————————————————|&lt;br /&gt;
| 1       | User commands                                  |&lt;br /&gt;
| 2       | Programming interfaces for kernel system calls |&lt;br /&gt;
| 3       | Programming interfaces to the C library        |&lt;br /&gt;
| 4       | Special files such as device nodes and drivers |&lt;br /&gt;
| 5       | File formats                                   |&lt;br /&gt;
| 6       | Games and amusements such as screen savers     |&lt;br /&gt;
| 7       | Miscellaneous                                  |&lt;br /&gt;
| 8       | System administration commands                                               |&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;apropos – Display Appropriate Commands 展示相关的 命令。通过  apropos ls 可以获得 lscpu, lshw, 等一系列 命令&lt;/li&gt;
  &lt;li&gt;whatis – Display One-line Manual Page Descriptions:  展示一行关于 command的简单描述&lt;/li&gt;
  &lt;li&gt;info 另一种展现形式的 man&lt;/li&gt;
  &lt;li&gt;alias: alias name=’string’ 来构建 名为 name 的command line， type name 可以获得 name 对应的 具体string 内容&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id="redirection"&gt;Redirection&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;cat sort uniq grep wc head tail tee(Read from standard input and write to standard output and files)&lt;/li&gt;
  &lt;li&gt;command line  数据流 有： 标准输入 标准输出 标准错误输出，即： stdin, stdout, stderr, 0, 1, 2&lt;/li&gt;
  &lt;li&gt;重定向 stdout， 使用 &amp;gt; 来将 输出 重定向到 file 中，file中内容将被覆盖。  »  将 数据重定向 到file中，不覆盖 追加到 file 末尾中&lt;/li&gt;
  &lt;li&gt;重定向 stderr, 类似 重定向 stdout 使用 2&amp;gt;, 2» 进行 标准错误输出 的数据重定向&lt;/li&gt;
  &lt;li&gt;将stdout &amp;amp; stderr 重定向 到一个 file 中：
    &lt;ul&gt;
      &lt;li&gt;ls -l /bin/usr &amp;gt; ls-output.txt 2&amp;gt;&amp;amp;1 ， 注意 其中的 2&amp;gt;&amp;amp;1 的写法，以及， &amp;gt; 与 2&amp;gt;&amp;amp;1 的顺序， 其中原因，为shell 语法需要 控制 两次重定向 打开的是同一个文件&lt;/li&gt;
      &lt;li&gt;ls -l /bin/usr &amp;amp;&amp;gt; ls-output.txt 也可以这样 &amp;amp;&amp;gt; 代表 stdout stderr， ls -l /bin/usr &amp;amp;» ls-output.txt 则代表 将stdout stderr 数据流 追加到 文件中&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Disposing of Unwanted Output:  ls -l /bin/usr 2&amp;gt; /dev/null 将 数据流 重定向 到 /dev/null 则可以起到忽略 数据流的作用&lt;/li&gt;
  &lt;li&gt;重定向 stdin, 使用 &amp;lt; 来重定向 stdin 从 键盘 到 file 上， 但是并不是特别有用（很少用到）&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;Pipelines： 使用 pipe operator&lt;/td&gt;
          &lt;td&gt;将 一个command 的标准输出  输送 到 一个command 的标准输入中。 command1&lt;/td&gt;
          &lt;td&gt;command2&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;Pipelines 与 重定向的 区别： 重定向只能 定向到 file， 而 pipelines 则可以 重定向到  一个command&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id="seeing-the-world-as-the-shell-sees-it"&gt;Seeing the World as the Shell Sees It&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;扩展 Expansion: how a simple character sequence, for example *, can have a lot of meaning to the shell. The process that makes this happen is called expansion. With expansion, we enter some- thing and it is expanded into something else before the shell acts upon it. 也就是 说 在 传递 参数给 command， command 接收参数处理前，会被 进行处理，该处理过程 即是： expansion。&lt;/li&gt;
  &lt;li&gt;echo 是如何 显式化  看到 expansion 结果的 重要方式&lt;/li&gt;
  &lt;li&gt;Pathname Expansion （路径扩展）： 如下释义：&lt;br /&gt;
```shell&lt;br /&gt;
[me@linuxbox ~]$ ls&lt;br /&gt;
Desktop ls-output.txt Pictures Templates Documents Music Public Videos&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;[me@linuxbox ~]$ echo D*&lt;br /&gt;
Desktop Documents&lt;/p&gt;

&lt;p&gt;[me@linuxbox ~]$ echo *s&lt;br /&gt;
Documents Pictures Templates Videos&lt;/p&gt;

&lt;p&gt;[me@linuxbox ~]$ echo [[:upper:]]*&lt;br /&gt;
Desktop Documents Music Pictures Public Templates Videos&lt;/p&gt;

&lt;p&gt;[me@linuxbox ~]$ echo /usr/*/share&lt;br /&gt;
/usr/kerberos/share /usr/local/share&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;4. Arithmetic Expansion: $((expression)), expression 是 算术表达式， 操作数 只能是整数， 操作符 有 +, -, *, /, %, **
```shell
[me@linuxbox ~]$ echo $(($((5**2)) * 3))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;Brace Expansion:&lt;br /&gt;
```shell&lt;br /&gt;
[me@linuxbox ~]$ echo Front-{A,B,C}-Back&lt;br /&gt;
Front-A-Back Front-B-Back Front-C-Back&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;[me@linuxbox ~]$ echo Number_{1..5}&lt;br /&gt;
Number_1 Number_2 Number_3 Number_4 Number_5&lt;/p&gt;

&lt;p&gt;[me@linuxbox ~]$ echo {01..15}&lt;br /&gt;
01 02 03 04 05 06 07 08 09 10 11 12 13 14 15&lt;/p&gt;

&lt;p&gt;[me@linuxbox ~]$ echo {001..15}&lt;br /&gt;
001 002 003 004 005 006 007 008 009 010 011 012 013 014 015&lt;/p&gt;

&lt;p&gt;[me@linuxbox ~]$ echo {Z..A}&lt;br /&gt;
Z Y X W V U T S R Q P ON M L K J I H G F E D C B A&lt;/p&gt;

&lt;p&gt;[me@linuxbox ~]$ mkdir Photos&lt;br /&gt;
[me@linuxbox ~]$ cd Photos&lt;br /&gt;
[me@linuxbox Photos]$ mkdir {2007..2009}-{01..12} &lt;br /&gt;
[me@linuxbox Photos]$ ls&lt;br /&gt;
2007-01 2007-07 2008-01 2008-07 2009-01 2009-07 2007-02 2007-08 2008-02 2008-08 2009-02 2009-08 2007-03 2007-09 2008-03 2008-09 2009-03 2009-09 2007-04 2007-10 2008-04 2008-10 2009-04 2009-10 2007-05 2007-11 2008-05 2008-11 2009-05 2009-11 2007-06 2007-12 2008-06 2008-12 2009-06 2009-12&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;6. Parameter Expansion

```shell
[me@linuxbox ~]$ echo $USER 
me
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;
  &lt;li&gt;Command Substitution: 子命令， 允许在表达式中 执行子命令 并展开. $(command sub)
&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="si"&gt;$(&lt;/span&gt;&lt;span class="nb"&gt;ls&lt;/span&gt;&lt;span class="si"&gt;)&lt;/span&gt;
Desktop Documents ls-output.txt Music Pictures Public Templates Videos
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
  &lt;li&gt;Quoting: 可以用来控制 是否进行 扩展 展开。
    &lt;ul&gt;
      &lt;li&gt;下面两个示例：&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;echo &lt;/span&gt;this is a    &lt;span class="nb"&gt;test
&lt;/span&gt;this is a &lt;span class="nb"&gt;test&lt;/span&gt;

&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;echo &lt;/span&gt;The total is &lt;span class="nv"&gt;$100&lt;/span&gt;.00
The total is 00.00
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意 这两个 的存在的问题： 1. 第一个中 shell 将 params 中多余的空格 去掉了， 即是： ‘a    test’中多余的空格， 因为 shell 将 通过 空格 分隔 参数，认为 a test  为两个参数。 2. $100.00 展开为了 00.00 是因为 $1 不存在的缘故&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Double Quotes： 将参数 加上 “” 之后， ““内的内容 将被视为 一个 参数， 但  parameter expansion, arithmetic expansion, and command substitution 依然 有效。&lt;br /&gt;
如下示例:&lt;br /&gt;
```shell&lt;br /&gt;
[me@linuxbox ~]$ ls -l two words.txt&lt;br /&gt;
ls: cannot access two: No such file or directory&lt;br /&gt;
ls: cannot access words.txt: No such file or directory&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[me@linuxbox ~]$ ls -l “two words.txt”&lt;br /&gt;
-rw-rw-r– 1 me me 18 2016-02-20 13:03 two words.txt [me@linuxbox ~]$ mv “two words.txt” two_words.txt&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;
```shell
[me@linuxbox ~]$ echo this is a    test
this is a test

[me@linuxbox ~]$ echo "this is a   test"
this is a   test




(calvagrant@precise64:~$ echo $(cal)
September 2020 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30

vagrant@precise64:~$ echo "$(cal)"
   September 2020
Su Mo Tu We Th Fr Sa
       1  2  3  4  5
 6  7  8  9 10 11 12
13 14 15 16 17 18 19
20 21 22 23 24 25 26
27 28 29 30

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;Single Quotes： 单引号 中的内容 扩展 全部 失效。&lt;/li&gt;
  &lt;li&gt;Escaping Characters： \&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;escape sequence&lt;/th&gt;
      &lt;th&gt;meaning&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;\a&lt;/td&gt;
      &lt;td&gt;Bell&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\b&lt;/td&gt;
      &lt;td&gt;Backspace&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\n&lt;/td&gt;
      &lt;td&gt;Newline&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\r&lt;/td&gt;
      &lt;td&gt;Carriage return&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\t&lt;/td&gt;
      &lt;td&gt;Tab&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;Signals: Signals are one of several ways that the operating system communicates with programs
    &lt;ul&gt;
      &lt;li&gt;kill: The kill command doesn’t exactly “kill” processes: rather it sends them signals &lt;br /&gt;
 kill [-signal] PID…&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;keyboard&lt;/th&gt;
      &lt;th&gt;signal&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl-c&lt;/td&gt;
      &lt;td&gt;INT&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl-z&lt;/td&gt;
      &lt;td&gt;TSTP&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;| Number | Name  | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |&lt;br /&gt;
|——–|——-|——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————–|&lt;br /&gt;
| 1      | HUP   | Hangup. This is a vestige of the good old days when terminals were attached to remote computers with phone lines and modems. The signal is used to indicate to programs that the controlling terminal has “hung up.” The effect of this signal can be demonstrated by closing a terminal session. The foreground program running on the terminal will be sent the signal and will terminate.                                                                                                           |&lt;br /&gt;
| 2      | INT   | Interrupt. This performs the same function as a Ctrl-c sent from the terminal. It will usually terminate a program.                                                                                                                                                                                                                                                                                                                                                                                    |&lt;br /&gt;
| 9      | KILL  | Kill. This signal is special. Whereas programs may choose to handle signals sent to them in different ways, including ignoring them all together, the KILL signal is never actually sent to the target program. Rather, the kernel immediately terminates the process. When a process is terminated in this manner, it is given no opportunity to “clean up” after itself or save its work. For this reason, the KILL signal should be used only as a last resort when other termination signals fail. |&lt;br /&gt;
| 15     | TERM  | Terminate. This is the default signal sent by the kill command. If a program is still “alive” enough to receive signals, it will terminate.                                                                                                                                                                                                                                                                                                                                                            |&lt;br /&gt;
| 18     | CONT  | Continue. This will restore a process after a STOP or TSTP signal. This signal is sent by the bg and fg commands.                                                                                                                                                                                                                                                                                                                                                                                      |&lt;br /&gt;
| 19     | STOP  | Stop. This signal causes a process to pause without terminating. Like the KILL signal, it is not sent to the target process, and thus it cannot be ignored.                                                                                                                                                                                                                                                                                                                                            |&lt;br /&gt;
| 20     | TSTP  | Terminal stop. This is the signal sent by the terminal when Ctrl-z is pressed. Unlike the STOP signal, the TSTP signal is received by the program, but the program may choose to ignore it.                                                                                                                                                                                                                                                                                                            |&lt;br /&gt;
| 3      | QUIT  | Quit                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |&lt;br /&gt;
| 11     | SEGV  | Segmentation violation. This signal is sent if a program makes illegal use of memory, that is, if it tried to write somewhere it was not allowed to write.                                                                                                                                                                                                                                                                                                                                             |&lt;br /&gt;
| 28     | WINCH | Window change. This is the signal sent by the system when a window changes size. Some programs , such as top and less will respond to this signal by redrawing themselves to fit the new window dimensions.                                                                                                                                                                                                                                                                                            |&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;example, kill -number | -Name 也即是说 kill 可以接受 number 或者 显示的名称
&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;kill&lt;/span&gt; &lt;span class="nt"&gt;-1&lt;/span&gt; 13546
&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;kill&lt;/span&gt; &lt;span class="nt"&gt;-SIGINT&lt;/span&gt; 13608
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="configuration-and-the-environment"&gt;Configuration and the Environment&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;Environment: shell 维护 一个 shell的 session 信息 称为 环境； shell 中保存 environment variables and shell variables 在环境中。但是无法区分 两种类型的变量。
    &lt;ul&gt;
      &lt;li&gt;printenv： 用来展现所有的 变量&lt;/li&gt;
      &lt;li&gt;set： 不带参数 展现所有变量以及 shell函数&lt;/li&gt;
      &lt;li&gt;alias： 展现所有 alias 相关的&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Environment 中的变量是 如何定义的：
    &lt;ul&gt;
      &lt;li&gt;A login shell session： A login shell session is one in which we are prompted for our username and password. This happens when we start a virtual console session, for example.&lt;/li&gt;
      &lt;li&gt;A non-login shell session： A non-login shell session typically occurs when we launch a terminal session in the GUI.&lt;/li&gt;
      &lt;li&gt;Login Shell Sessions 读取配置文件&lt;br /&gt;
| File            | Contents                                                                                                                                                   |&lt;br /&gt;
|—————–|————————————————————————————————————————————————————|&lt;br /&gt;
| /etc/profile    | A global configuration script that applies to all users.                                                                                                   |&lt;br /&gt;
| ~/.bash_profile | A user’s personal startup file. This can be used to extend or override settings in the global configuration script.                                        |&lt;br /&gt;
| ~/.bash_login   | If ~/.bash_profile is not found, bash attempts to read this script.                                                                                        |&lt;br /&gt;
| ~/.profile      | If neither ~/.bash_profile nor ~/.bash_login is found, bash attempts to read this file. This is the default in Debian-based distributions, such as Ubuntu. |&lt;br /&gt;
|                 |                                                                                                                                                            |&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;Non-Login Shell Sessions 读取配置文件： non-login shells inherit the environ- ment from their parent process, usually a login shell. Non-login 会 继承  Login shell 的环境&lt;br /&gt;
| File             | Contents                                                                                                           |&lt;br /&gt;
|——————|——————————————————————————————————————–|&lt;br /&gt;
| /etc/bash.bashrc | A global configuration script that applies to all users                                                            |&lt;br /&gt;
| ~/.bashrc        | A user’s personal startup file. It can be used to extend or  override settings in the global configuration script. |&lt;br /&gt;
|                  |                                                                                                                    |&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;命令查找： ls 命令的 定义在哪里， 又是如何找到的呢？
    &lt;ul&gt;
      &lt;li&gt;shell 从 PATH 变量中 包含的 Path 中 顺序查找
&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="nv"&gt;PATH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$PATH&lt;/span&gt;:&lt;span class="nv"&gt;$HOME&lt;/span&gt;/bin
&lt;span class="nb"&gt;export &lt;/span&gt;PATH
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;p&gt;简单的将 $HOME/bin 添加到 PATH 中 (注意 $HOME 会在此处求值)&lt;br /&gt;
xport PATH 让 shell之后的process 中的PATH都改变&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id="查找文件"&gt;查找文件&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;locate : 非常简单有效，只能使用 filename 用来查找。 locate 足够高效 因为 其从 updatedb command 更新的数据库中来进行查找，updatedb 经常 放在cron job 来执行（需要确认下，因为没有找到 相关的配置文件）&lt;/li&gt;
  &lt;li&gt;find 寻找文件 则显得 复杂 而详尽。可以根据给定的 目录 以及 各个限定 来查找文件。&lt;br /&gt;
可选参数与 含义&lt;br /&gt;
| 参数           | 可选值                                                                                                                                                                                                                                                                                                        |&lt;br /&gt;
|—————-|—————————————————————————————————————————————————————————————————————————————————————————————————————|&lt;br /&gt;
| -type          | b: Block special device file; c: Character special device file; d: Directory; f: regular file; l Symbolic link                                                                                                                                                                                                |&lt;br /&gt;
| -size          | c Bytes; w: 2-byte words; k: kilobytes; M: megabytes; G: Gigabytes;                                                                                                                                                                                                                                           |&lt;br /&gt;
| -cmin n        | Match files or directories whose content or attributes were last modified exactly n minutes ago. To specify less than n minutes ago, use -n, and to specify more than n minutes ago, use +n.                                                                                                                  |&lt;br /&gt;
| -cnewer file   | Match files or directories whose contents or attributes were last modified more recently than those of file.                                                                                                                                                                                                  |&lt;br /&gt;
| -ctime n       | Match files or directories whose contents or attributes were last modified n&lt;em&gt;24 hours ago.                                                                                                                                                                                                                    |&lt;br /&gt;
| -empty         | Match empty files and directories.                                                                                                                                                                                                                                                                            |&lt;br /&gt;
| -iname pattern | Like the -name test but case-insensitive.                                                                                                                                                                                                                                                                     |&lt;br /&gt;
| -inum n        | Match files with inode number n. This is helpful for finding all the hard links to a particular inode.                                                                                                                                                                                                        |&lt;br /&gt;
| -mmin n        | Match files or directories whose contents were last modified n minutes ago.                                                                                                                                                                                                                                   |&lt;br /&gt;
| -mtime n       | Match files or directories whose contents were last modified n&lt;/em&gt;24 hours ago.                                                                                                                                                                                                                                  |&lt;br /&gt;
| -name pattern  | Match files and directories with the specified wildcard pattern.                                                                                                                                                                                                                                              |&lt;br /&gt;
| -newer file    | Match files and directories whose contents were modified more recently than the specified file. This is useful when writing shell scripts that perform file backups. Each time you make a backup, update a file (such as a log) and then use find to determine which files have changed since the last update |&lt;br /&gt;
| -samefile name | Similar to the -inum test. Match files that share the same inode number as file name                                                                                                                                                                                                                          |&lt;br /&gt;
| -user name     | Match files or directories belonging to user name. The user may be expressed by a username or by a numeric user ID.                                                                                                                                                                                           |&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;for example
&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;find ~ &lt;span class="nt"&gt;-type&lt;/span&gt; f &lt;span class="nt"&gt;-name&lt;/span&gt; &lt;span class="s2"&gt;"*.JPG"&lt;/span&gt; &lt;span class="nt"&gt;-size&lt;/span&gt; +1M | &lt;span class="nb"&gt;wc&lt;/span&gt; &lt;span class="nt"&gt;-l&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;p&gt;注意 其中的 -name 参数需要添加 “” 来防止 pathname expansion， size: 则使用 +1M 表示大于 1M 的文件&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;find logical Operators： find 则可以更复杂的 使用 -and -or -not () 等来进行  logic 之间的 与或 操作 来设定更复杂的 test 关系
&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="o"&gt;(&lt;/span&gt; expression 1 &lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="nt"&gt;-or&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt; expression 2 &lt;span class="o"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Predefined Actions: &lt;br /&gt;
| Action  | Meaning                            |&lt;br /&gt;
|———|————————————|&lt;br /&gt;
| -delete | delete match file                  |&lt;br /&gt;
| -ls     | ls -dils match file                |&lt;br /&gt;
| -print  | output full pathname of match file |&lt;br /&gt;
| -quit   | Quit once a match has been made    |&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;User-Defined Actions： -exec rm ‘{}’ ‘;’： {} 代表 match file 的pathname。 这里面 存在的问题是： -exec 中的命令会被  实例化 多次，在每次match file的时候 就会实例化一次。可以简单的 实例化多次 修改为 实例化一次 。 即：&lt;br /&gt;
```shell&lt;br /&gt;
find ~ -type f -name ‘foo*’ -exec ls -l ‘{}’ ‘;’&lt;br /&gt;
-rwxr-xr-x 1 me me 224 2007-10-29 18:44 /home/me/bin/foo &lt;br /&gt;
-rw-r–r– 1 me me 0 2016-09-19 12:53 /home/me/foo.txt&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;// 修改后&lt;br /&gt;
find ~ -type f -name ‘foo*’ -exec ls -l ‘{}’ +&lt;br /&gt;
-rwxr-xr-x 1 me me 224 2007-10-29 18:44 /home/me/bin/foo &lt;br /&gt;
-rw-r–r– 1 me me 0 2016-09-19 12:53 /home/me/foo.txt&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;* xargs: 用于将 接受的input 的信息 作为参数 传递给 command. xargs存在的原因在于： 一些 命令 接受 命令行参数+标准输入，但是其他一些命令 则 只接受命令行 输入，所以需要 xargs 将标准输入 转换为 命令行参数
Some commands such as grep and awk can take input either as command-line arguments or from the standard input. However, others such as cp and echo can only take input as arguments, which is why xargs is necessary. [[name]](https://en.wikipedia.org/wiki/Xargs)
xargs 中存在一些 问题，主要是 关于 filename 中的空格，等分隔符号 对整个 shell的参数接收 都有影响。 所以 接受filename 的时候 --null 参数 将 是xargs 不被 ‘ ’分隔（ 使用 空字符串 作为分隔）， -d ' 

#### Archiving and Backup：
1. compressor command: gzip bzip2
gzip options
```shell

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;| Option  | Long Option  | Desc                                                                                                                                                                                                                                  |&lt;br /&gt;
|———|————–|—————————————————————————————————————————————————————————————————————————————|&lt;br /&gt;
| -c      | –stdout     | Write output to standard output and keep the original files.                                                                                                                                                                          |&lt;br /&gt;
| -d      | –decompress | Decompress This causes gzip act like gunzip                                                                                                                                                                                           |&lt;br /&gt;
| -f      | –force      | force compress event if a compressed file already exists                                                                                                                                                                              |&lt;br /&gt;
| -l      | –list       | 应用 已压缩文件 展示 压缩信息                                                                                                                                                                                                         |&lt;br /&gt;
| -r      | –recursive  | 递归压缩目录下的文件（目录下的文件各自压缩为 各自的压缩文件，所以 依然需要archive 程序）                                                                                                                                                                         |&lt;br /&gt;
| -v      | –verbose    | Display verbose messages while compressing.                                                                                                                                                                                           |&lt;br /&gt;
| -number |              | Set amount of compression. number is an integer in the range of 1 (fastest, least compression) to 9 (slowest, most compression). The values 1 and 9 may also be expressed as –fast and –best, respectively. The default value is 6. |&lt;/p&gt;

&lt;p&gt;bzip2 同gzip 一样 为压缩程序，其中的参数 都大概相同，除了-r -number 外。 bunzip2 bzcat 用于解压缩。 bzip2recover 可以恢复受损的 压缩文件&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;archive command: tar zip:  Archiving is the process of gathering up many files and bundling them together into a single large file.&lt;br /&gt;
| Mode | Meaning                                                    |&lt;br /&gt;
|——|————————————————————|&lt;br /&gt;
| c    | Create an archive from a list of files and/or directories. |&lt;br /&gt;
| x    | Extract an archive.                                        |&lt;br /&gt;
| r    | Append specified pathnames to the end of an archive        |&lt;br /&gt;
| t    | List the content of an archive                             |&lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;gzip &lt;/span&gt;foo.txt
&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;ls&lt;/span&gt; &lt;span class="nt"&gt;-l&lt;/span&gt; foo.&lt;span class="k"&gt;*&lt;/span&gt;
&lt;span class="nt"&gt;-rw-r--r--&lt;/span&gt; 1 me me 3230 2018-10-14 07:15 foo.txt.gz

&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;gzip&lt;/span&gt; &lt;span class="nt"&gt;-d&lt;/span&gt; foo.txt.gz

&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;gunzip &lt;/span&gt;foo.txt
&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;ls&lt;/span&gt; &lt;span class="nt"&gt;-l&lt;/span&gt; foo.&lt;span class="k"&gt;*&lt;/span&gt;
&lt;span class="nt"&gt;-rw-r--r--&lt;/span&gt; 1 me me 15738 2018-10-14 07:15 foo.txt


&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;bzip2 foo.txt
&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;ls&lt;/span&gt; &lt;span class="nt"&gt;-l&lt;/span&gt; foo.txt.bz2
&lt;span class="nt"&gt;-rw-r--r--&lt;/span&gt; 1 me me 2792 2018-10-17 13:51 foo.txt.bz2
&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;bunzip2 foo.txt.bz2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;tar： 只能以 相对路径 archive 文件。unarchive 的时候 在 当前路径下 以相对路径 恢复文件。example&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;tar &lt;/span&gt;cf playground2.tar ~/playground

&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;cd &lt;/span&gt;foo
&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox foo]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;tar &lt;/span&gt;xf ../playground2.tar
&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox foo]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;ls
&lt;/span&gt;home playground
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;–wildcards 可以用来过滤掉 特定的 match 文件&lt;/p&gt;

&lt;p&gt;find 经常用来 与 tar 配合进行 批量 archive&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;find playground &lt;span class="nt"&gt;-name&lt;/span&gt; &lt;span class="s1"&gt;'file-A'&lt;/span&gt; &lt;span class="nt"&gt;-exec&lt;/span&gt; &lt;span class="nb"&gt;tar &lt;/span&gt;rf playground.tar &lt;span class="s1"&gt;'{}'&lt;/span&gt; &lt;span class="s1"&gt;'+'&lt;/span&gt;

find playground &lt;span class="nt"&gt;-name&lt;/span&gt; &lt;span class="s1"&gt;'file-A'&lt;/span&gt; | &lt;span class="nb"&gt;tar &lt;/span&gt;cf - &lt;span class="nt"&gt;--files-from&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;- | &lt;span class="nb"&gt;gzip&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; playground.tgz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二条命令比较 特殊，在其中  tar cf - –files-from=- 中， - 代表 标准 标准输入或者输出&lt;/p&gt;

&lt;p&gt;tar 可以通过添加 z j 参数，直接 使用gzip bzip2 进行压缩, z: gzip .tgz, j: bzip2 .tbz&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;find playground &lt;span class="nt"&gt;-name&lt;/span&gt; &lt;span class="s1"&gt;'file-A'&lt;/span&gt; | &lt;span class="nb"&gt;tar &lt;/span&gt;czf playground.tgz &lt;span class="nt"&gt;-T&lt;/span&gt; -
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过网络进行 文件备份：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;ssh remote-sys &lt;span class="s1"&gt;'tar cf - Documents'&lt;/span&gt; | &lt;span class="nb"&gt;tar &lt;/span&gt;xf -
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;zip, unzip： 的命令 比较详细，所以只列出简短  的示例：&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;zip &lt;span class="nt"&gt;-r&lt;/span&gt; playground.zip playground // &lt;span class="nt"&gt;-r&lt;/span&gt; 是必须，这样才能 得到 playground 下的所有 archive
unzip ../playground.zip // 不同与 &lt;span class="nb"&gt;tar&lt;/span&gt;, zip 使用unzip 来进行 unarchive
unzip &lt;span class="nt"&gt;-l&lt;/span&gt; ../playground.zip
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;sync command: rsync  rsync options source destination&lt;br /&gt;
where source and destination are one of the following:&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;A local file or directory&lt;/li&gt;
  &lt;li&gt;A remote file or directory in the form of [user@]host:path&lt;/li&gt;
  &lt;li&gt;A remote rsync server specified with a URI of rsync://[user@]host[:port]/path&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意： source destination 其中之一 必须 为 本地的文件， 远程 到 远程的 copy 是不被允许的。&lt;br /&gt;
示例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;rsync &lt;span class="nt"&gt;-av&lt;/span&gt; &lt;span class="nb"&gt;source &lt;/span&gt;destination // &lt;span class="nt"&gt;-a&lt;/span&gt; 代表 archive mode， v verbose output
rsync &lt;span class="nt"&gt;-av&lt;/span&gt; &lt;span class="nb"&gt;source&lt;/span&gt;/ destination
// 两种方式不同的地方在于 后一种 只拷贝 &lt;span class="nb"&gt;source &lt;/span&gt;中的内容到 destination, 而 第一种 则将source 目录也 拷贝到 destination 中.

rsync &lt;span class="nt"&gt;-av&lt;/span&gt; &lt;span class="nt"&gt;--delete&lt;/span&gt; &lt;span class="nb"&gt;source&lt;/span&gt;/ destination   // delete 参数 为 完全拷贝， &lt;span class="nb"&gt;source &lt;/span&gt;中删除掉的file 将在 destination 中删除掉。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Using rsync Over a Network： 的两种方式&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;source 安装了 rsync  的机器 以及 destination 安装了 远程shell 程序， 如： ssh&lt;/li&gt;
  &lt;li&gt;destination 安装了 rsync server， rsync 可以配置为 daemon 模式 等待 sync 请求&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="nb"&gt;sudo &lt;/span&gt;rsync &lt;span class="nt"&gt;-av&lt;/span&gt; &lt;span class="nt"&gt;--delete&lt;/span&gt; &lt;span class="nt"&gt;--rsh&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;ssh /etc /home /usr/local remote-sys:/backup
// 这里面 &lt;span class="nt"&gt;--rsh&lt;/span&gt; 指定为 ssh， 使 rsync 能够 使用ssh 来进行同步操作
rsync &lt;span class="nt"&gt;-av&lt;/span&gt; –delete rsync://archive.linux.duke.edu/ fedora/linux/development/rawhide/Everything/x86_64/os/ fedora-devel
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="text-processing"&gt;Text Processing&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;cat： 可以这样使用
&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;cat&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; foo.txt // ctrl-d结束输入
&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;cat&lt;/span&gt; &lt;span class="nt"&gt;-A&lt;/span&gt; foo.txt // 其中 ^I 代表 tab, &lt;span class="nv"&gt;$ &lt;/span&gt;代表 line末尾， 所以可以用此来 区分 tab 与 space
&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;cat&lt;/span&gt; &lt;span class="nt"&gt;-nA&lt;/span&gt; foo.txt // n 显式 line number
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
  &lt;li&gt;[[https://www.gnu.org/software/coreutils/manual/html_node/sort-invocation.html#sort-invocation][sort]]:  对输入进行排序， 是一个比较复杂，有用的命令：下面是详细参数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;| Option | Long Option             | meaning                                                                               |&lt;br /&gt;
|——–|————————-|—————————————————————————————|&lt;br /&gt;
| -b     | –ignore-leading-blanks | 使忽略掉 行前的 空格，使用第一个非空格排序                                            |&lt;br /&gt;
| -f     | –ignore-case           |                                                                                       |&lt;br /&gt;
| -n     | –numeric-sort          | 将字符串当做number 来进行比较                                                         |&lt;br /&gt;
| -r     | –reverse               | reverse order 排序                                                                    |&lt;br /&gt;
| -k     | –key=field1[,field2]   | 使用 field1..field2 作为排序的key, field1 不存在则为1， field2 不存在则 从field1直至末尾， field1 都可以是如此形式 f[.c][opts]  .c 为内部的offset                                            |&lt;br /&gt;
| -m     | –merge                 | 将每个参数作为预排序文件的名称。 将多个文件合并为单个排序结果，而不执行任何其他排序。 |&lt;br /&gt;
| -o     | –output=file           | 输出到 file 而非 标准输出                                                             |&lt;br /&gt;
| -t     | –field-separator=char  | 使用 char 作为分隔符，默认为 space 或者tab                                            |&lt;br /&gt;
|      | –debug  | 将用作sort 的key 进行标记                                            |&lt;br /&gt;
下面是几个示例&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;du&lt;/span&gt; &lt;span class="nt"&gt;-s&lt;/span&gt; /usr/share/&lt;span class="k"&gt;*&lt;/span&gt; | &lt;span class="nb"&gt;head
&lt;/span&gt;252 /usr/share/aclocal
96 /usr/share/acpi-support
8 /usr/share/adduser
196 /usr/share/alacarte 344 /usr/share/alsa
8 /usr/share/alsa-base 12488 /usr/share/anthy
8 /usr/share/apmd


//  下面对结果进行排序 其中 &lt;span class="nt"&gt;-nr&lt;/span&gt; 将string作为number 处理并 翻转排序, 这里面之所有管用，是因为 第一列 为 数字, 即 默认按照第一列进行排序
&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;du&lt;/span&gt; &lt;span class="nt"&gt;-s&lt;/span&gt; /usr/share/&lt;span class="k"&gt;*&lt;/span&gt; | &lt;span class="nb"&gt;sort&lt;/span&gt; &lt;span class="nt"&gt;-nr&lt;/span&gt; | &lt;span class="nb"&gt;head
&lt;/span&gt;509940 /usr/share/locale-langpack
242660 /usr/share/doc
197560 /usr/share/fonts
179144 /usr/share/gnome
146764 /usr/share/myspell
144304 /usr/share/gimp
135880 /usr/share/dict
76508 /usr/share/icons
68072 /usr/share/apps
62844 /usr/share/foomatic

// 如果是这样的又如何排序?
&lt;span class="o"&gt;[&lt;/span&gt;shaohua.li@10-11-112-3 ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;ls&lt;/span&gt; &lt;span class="nt"&gt;-l&lt;/span&gt; /usr/bin/ | &lt;span class="nb"&gt;head
&lt;/span&gt;total 58404
&lt;span class="nt"&gt;-rwxr-xr-x&lt;/span&gt;  1 root root     33408 Nov 10  2015 &lt;span class="o"&gt;[&lt;/span&gt;
&lt;span class="nt"&gt;-rwxr-xr-x&lt;/span&gt;  1 root root    106792 Nov 10  2015 a2p
&lt;span class="nt"&gt;-rwxr-xr-x&lt;/span&gt;&lt;span class="nb"&gt;.&lt;/span&gt; 1 root root     14984 Aug 18  2010 acpi_listen
&lt;span class="nt"&gt;-rwxr-xr-x&lt;/span&gt;&lt;span class="nb"&gt;.&lt;/span&gt; 1 root root     23488 Nov 11  2010 addftinfo
&lt;span class="nt"&gt;-rwxr-xr-x&lt;/span&gt;  1 root root     24904 Jul 23  2015 addr2line
&lt;span class="nt"&gt;-rwxr-xr-x&lt;/span&gt;&lt;span class="nb"&gt;.&lt;/span&gt; 1 root root      1786 Feb 21  2013 apropos
&lt;span class="nt"&gt;-rwxr-xr-x&lt;/span&gt;  1 root root     56624 Jul 23  2015 ar
&lt;span class="nt"&gt;-rwxr-xr-x&lt;/span&gt;  1 root root    328392 Jul 23  2015 as
&lt;span class="nt"&gt;-rwxr-xr-x&lt;/span&gt;&lt;span class="nb"&gt;.&lt;/span&gt; 1 root root     10400 Sep 23  2011 attr

// &lt;span class="nt"&gt;-k&lt;/span&gt; 5 使用 第 5 field 作为key 用作 排序使用
&lt;span class="o"&gt;[&lt;/span&gt;shaohua.li@10-11-112-3 ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;ls&lt;/span&gt; &lt;span class="nt"&gt;-l&lt;/span&gt; /usr/bin/ | &lt;span class="nb"&gt;sort&lt;/span&gt; &lt;span class="nt"&gt;-nr&lt;/span&gt; &lt;span class="nt"&gt;-k&lt;/span&gt; 5 | &lt;span class="nb"&gt;head&lt;/span&gt;
&lt;span class="nt"&gt;-rwxr-xr-x&lt;/span&gt;  1 root root   3214440 Dec 12  2016 mysql
&lt;span class="nt"&gt;-rwxr-xr-x&lt;/span&gt;  1 root root   3051080 Dec 12  2016 mysqlbinlog
&lt;span class="nt"&gt;-rwxr-xr-x&lt;/span&gt;  1 root root   2998400 Dec 12  2016 mysqldump
&lt;span class="nt"&gt;-rwxr-xr-x&lt;/span&gt;  1 root root   2948832 Dec 12  2016 mysqlslap
&lt;span class="nt"&gt;-rwxr-xr-x&lt;/span&gt;  1 root root   2936680 Dec 12  2016 mysqladmin
&lt;span class="nt"&gt;-rwxr-xr-x&lt;/span&gt;  1 root root   2935688 Dec 12  2016 mysqlcheck
&lt;span class="nt"&gt;-rwxr-xr-x&lt;/span&gt;  1 root root   2933128 Dec 12  2016 mysqlimport
&lt;span class="nt"&gt;-rwxr-xr-x&lt;/span&gt;  1 root root   2931712 Dec 12  2016 mysqlshow
&lt;span class="nt"&gt;-rwxr-xr-x&lt;/span&gt;  1 root root   2814328 Dec 12  2016 my_print_defaults
&lt;span class="nt"&gt;-rwxr-xr-x&lt;/span&gt;  1 root root   2811544 Dec 12  2016 mysql_waitpid


// 下面是 比较复杂的示例
root@precise64:~/shell_test#  &lt;span class="nb"&gt;cat &lt;/span&gt;distros.txt
Fedora  5    03/20/2006
Fedora  6    10/24/2006
Fedora  7    05/31/2007
Fedora  8    11/08/2007
Fedora  9    05/13/2008
Fedora  10   11/25/2008
SUSE    10.1 05/11/2006
SUSE    10.2 12/07/2006
SUSE    10.3 10/04/2007
SUSE    11.0 06/19/2008
Ubuntu  6.06 06/01/2006
Ubuntu  6.10 10/26/2006
Ubuntu  7.04 04/19/2007
Ubuntu  7.10 10/18/2007
Ubuntu  8.04 04/24/2008
Ubuntu  8.10 10/30/2008

// 如何对 distros 按照其 发布的版本 以及 发布时间 进行排序呢？

// 单纯的 按照 发布版本排序
root@precise64:~/shell_test# &lt;span class="nb"&gt;sort &lt;/span&gt;distros.txt  &lt;span class="nt"&gt;-nrk&lt;/span&gt; 2
SUSE    11.0 06/19/2008
SUSE    10.3 10/04/2007
SUSE    10.2 12/07/2006
SUSE    10.1 05/11/2006
Fedora  10   11/25/2008
Fedora  9    05/13/2008
Ubuntu  8.10 10/30/2008
Ubuntu  8.04 04/24/2008
Fedora  8    11/08/2007
Ubuntu  7.10 10/18/2007
Ubuntu  7.04 04/19/2007
Fedora  7    05/31/2007
Ubuntu  6.10 10/26/2006
Ubuntu  6.06 06/01/2006
Fedora  6    10/24/2006
Fedora  5    03/20/2006

// 综合排序， 使用多个key， 版本，以及版本号 进行综合排序
root@precise64:~/shell_test# &lt;span class="nb"&gt;sort&lt;/span&gt; &lt;span class="nt"&gt;--key&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1,1 &lt;span class="nt"&gt;--key&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;2n distros.txt
Fedora  5    03/20/2006
Fedora  6    10/24/2006
Fedora  7    05/31/2007
Fedora  8    11/08/2007
Fedora  9    05/13/2008
Fedora  10   11/25/2008
SUSE    10.1 05/11/2006
SUSE    10.2 12/07/2006
SUSE    10.3 10/04/2007
SUSE    11.0 06/19/2008
Ubuntu  6.06 06/01/2006
Ubuntu  6.10 10/26/2006
Ubuntu  7.04 04/19/2007
Ubuntu  7.10 10/18/2007
Ubuntu  8.04 04/24/2008
Ubuntu  8.10 10/30/2008

// k 可以为 f[.c][opts]  可以指定 field 中的 c pos 用来比较
root@precise64:~/shell_test# &lt;span class="nb"&gt;sort&lt;/span&gt; &lt;span class="nt"&gt;-k&lt;/span&gt; 3.7nbr &lt;span class="nt"&gt;-k&lt;/span&gt; 3.1nbr &lt;span class="nt"&gt;-k&lt;/span&gt; 3.4nbr distros.txt
Fedora  10   11/25/2008
Ubuntu  8.10 10/30/2008
SUSE    11.0 06/19/2008
Fedora  9    05/13/2008
Ubuntu  8.04 04/24/2008
Fedora  8    11/08/2007
Ubuntu  7.10 10/18/2007
SUSE    10.3 10/04/2007
Fedora  7    05/31/2007
Ubuntu  7.04 04/19/2007
SUSE    10.2 12/07/2006
Ubuntu  6.10 10/26/2006
Fedora  6    10/24/2006
Ubuntu  6.06 06/01/2006
SUSE    10.1 05/11/2006
Fedora  5    03/20/2006


// &lt;span class="nt"&gt;--debug&lt;/span&gt; 选项 是比较有意思的，用来在 不知道 key 以及sort情况时候，用来展现 其内部sort key 的方式
root@precise64:~/shell_test# &lt;span class="nb"&gt;cat&lt;/span&gt; /etc/passwd | &lt;span class="nb"&gt;sort&lt;/span&gt; &lt;span class="nt"&gt;-t&lt;/span&gt; &lt;span class="s1"&gt;':'&lt;/span&gt; &lt;span class="nt"&gt;-k&lt;/span&gt; 7 &lt;span class="nt"&gt;--debug&lt;/span&gt; | &lt;span class="nb"&gt;head
sort&lt;/span&gt;: using &lt;span class="sb"&gt;`&lt;/span&gt;en_US&lt;span class="s1"&gt;' sorting rules
root:x:0:0:root:/root:/bin/bash
                      _________
_______________________________
vagrant:x:1000:1000:vagrant,,,:/home/vagrant:/bin/bash
                                             _________
______________________________________________________
messagebus:x:102:105::/var/run/dbus:/bin/false
                                    __________
______________________________________________
mysql:x:106:111:MySQL Server,,,:/nonexistent:/bin/false
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;uniq: 去除 重复的 条目, 比较有意思的是 需要在sort之后 使用，也就是说 uniq只能去除掉 相邻的 重复的条目&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;cat&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; foo.txt 
a
b
c
a
b
c

&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;uniq &lt;/span&gt;foo.txt 
a
b
c
a
b
c

&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;sort &lt;/span&gt;foo.txt | &lt;span class="nb"&gt;uniq 
&lt;/span&gt;a
b
c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;cut: 用于 使用 -d, –delimiter=DELIM 默认为tab 分隔line， 然后提取 field， characters 等&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;root@precise64:~/shell_test# &lt;span class="nb"&gt;cat&lt;/span&gt; /etc/passwd | &lt;span class="nb"&gt;cut&lt;/span&gt; &lt;span class="nt"&gt;-d&lt;/span&gt; &lt;span class="s1"&gt;':'&lt;/span&gt; &lt;span class="nt"&gt;-f&lt;/span&gt; 1 | &lt;span class="nb"&gt;head
&lt;/span&gt;root
daemon
bin
sys
&lt;span class="nb"&gt;sync
&lt;/span&gt;games
man
lp
mail
news
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;comm: 用于比较 两个文本的变化差异: comm file1 file2 其结果 第一列 显式 file1 独有的，第二列 显示 file2 独有的， 第三列 显示 file1 file2 共同的&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;root@precise64:~/shell_test# &lt;span class="nb"&gt;cat &lt;/span&gt;file1.text
a
b
c
d

root@precise64:~/shell_test# &lt;span class="nb"&gt;cat &lt;/span&gt;file2.text
b
c
d
e

// 注意 其展现形式， 第一列only file1 have  第二列 only file2 have  第三列 &lt;span class="nb"&gt;comm
&lt;/span&gt;root@precise64:~/shell_test# &lt;span class="nb"&gt;comm &lt;/span&gt;file1.text file2.text
a
		b
		c
		d
	e
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;https://toroid.org/unix-pipe-implementation&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;diff: diff file1.txt file2.txt； diff 展现的格式 都为 更改 file1.txt 转变到 file2.txt 的操作序列，即是 字符串 之间最小编辑记录 在文件中的应用。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;root@precise64:~/shell_test# &lt;span class="nb"&gt;cat &lt;/span&gt;file1.text
a
b
c
d
root@precise64:~/shell_test# &lt;span class="nb"&gt;cat &lt;/span&gt;file2.text
b
c
d
e

root@precise64:~/shell_test# diff file1.text  file2.text
1d0
&amp;lt; a
4a4
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; e
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Change&lt;/th&gt;
      &lt;th&gt;meaning&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;r1ar2&lt;/td&gt;
      &lt;td&gt;将 file2 中的 r2行 追加到 file1 中的 r1 行中&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;r1cr2&lt;/td&gt;
      &lt;td&gt;将 file1 中 r1 行 替换为 file2中的 r2 行&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;r1dr2&lt;/td&gt;
      &lt;td&gt;将 file1中的r1行删除掉，下一行将出现在 file2中的 r2 行&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;此格式为默认格式，但是因为不够直观，所以这种格式并不常用。&lt;/p&gt;

&lt;p&gt;上下文格式：diff -c file1.txt file2.txt&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;root@precise64:~/shell_test# diff &lt;span class="nt"&gt;-c&lt;/span&gt; file1.text  file2.text
&lt;span class="k"&gt;***&lt;/span&gt; file1.text	2020-09-24 08:02:08.202406914 +0000 // &lt;span class="k"&gt;**&lt;/span&gt; 代表 file1.txt，其后是 时间戳
&lt;span class="nt"&gt;---&lt;/span&gt; file2.text	2020-09-24 08:02:15.854515682 +0000 // &lt;span class="nt"&gt;--&lt;/span&gt; 代表 file2.txt 其后是 时间戳
&lt;span class="k"&gt;***************&lt;/span&gt;
&lt;span class="k"&gt;***&lt;/span&gt; 1,4 &lt;span class="k"&gt;****&lt;/span&gt; // &lt;span class="k"&gt;**&lt;/span&gt; 代表 file1.txt
- a
  b
  c
  d
&lt;span class="nt"&gt;---&lt;/span&gt; 1,4 &lt;span class="nt"&gt;----&lt;/span&gt; // &lt;span class="nt"&gt;--&lt;/span&gt; 代表 file2.txt
  b
  c
  d
+ e
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Indicator&lt;/th&gt;
      &lt;th&gt;Meaning&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;blank&lt;/td&gt;
      &lt;td&gt;此行 两个文件没有差别&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;需要删除该行(只会出现在 file1中，因为目的是 将file1 转向 file2)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;+&lt;/td&gt;
      &lt;td&gt;添加该行 （只会出现在file2中，代表 需要将该行添加到 file1中）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;!&lt;/td&gt;
      &lt;td&gt;两个文件中都会出现，代表 file1中的该行 需要被 file2中的 对应行 替换&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;统一格式： diff -u file1.txt file2.txt&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;root@precise64:~/shell_test# diff &lt;span class="nt"&gt;-u&lt;/span&gt; file1.text file2.text
&lt;span class="nt"&gt;---&lt;/span&gt; file1.text	2020-09-24 08:02:08.202406914 +0000
+++ file2.text	2020-09-25 04:41:15.154310271 +0000
@@ &lt;span class="nt"&gt;-1&lt;/span&gt;,4 +1,4 @@
&lt;span class="nt"&gt;-a&lt;/span&gt;
 b
 c
 d
+e
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Character&lt;/th&gt;
      &lt;th&gt;Meaning&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;blank&lt;/td&gt;
      &lt;td&gt;no change&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;从file1 文件中删除该行&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;+&lt;/td&gt;
      &lt;td&gt;从file1 文件中添加该行&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;也就是说 统一格式 中，将 ！替换操作去除了，通过 - + 来实现了 替换操作&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;patch: 用来将diff 出的结果 apply。 即是： diff -Naur old_file new_file &amp;gt; diff_file; patch &amp;lt; diff_file; 之后 old_file 会转变为 same as new_file&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="shell-语法"&gt;shell 语法&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;Variables and Constants
    &lt;ul&gt;
      &lt;li&gt;shell 中的变量 是 动态的，不需要预先声明 与类型指定（因为没有类型，可能都为字符串），对于 使用 未定义 未赋值 的变量 其 数值 为 空。 所以我们需要 注意自己的拼写错误，因为 shell可能会将其视为 新变量。&lt;/li&gt;
      &lt;li&gt;常量： 规范 使用 全大写 命名 常量，以区分于 普通变量。 也可以使用 declare -r TITLE=”Page Title” 来进行声明&lt;/li&gt;
      &lt;li&gt;赋值： variable=value  shell 并不区分 value的类型， value 全部被视为 string， 注意= 左右没有空格&lt;/li&gt;
      &lt;li&gt;变量数值引用 需要注意， 因为语法原因 可能 需要使用 {} 来避免 变量名与表达式 的歧义&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;z &lt;span class="c"&gt;# a 赋值为 string z&lt;/span&gt;
&lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"a string"&lt;/span&gt;
&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"a string and &lt;/span&gt;&lt;span class="nv"&gt;$b&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="c"&gt;# c &lt;/span&gt;

&lt;span class="nv"&gt;d&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="si"&gt;$(&lt;/span&gt;&lt;span class="nb"&gt;ls&lt;/span&gt; &lt;span class="nt"&gt;-l&lt;/span&gt; foo.txt&lt;span class="si"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="c"&gt;# value 为子命令结果&lt;/span&gt;
&lt;span class="nv"&gt;e&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$((&lt;/span&gt;&lt;span class="m"&gt;5&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="m"&gt;7&lt;/span&gt;&lt;span class="k"&gt;))&lt;/span&gt; &lt;span class="c"&gt;# 数值计算展开&lt;/span&gt;

&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;5 &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"string"&lt;/span&gt; &lt;span class="c"&gt;# 多个变量可以 同时声明&lt;/span&gt;

&lt;span class="nv"&gt;filename&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"myfile"&lt;/span&gt;
&lt;span class="nb"&gt;touch&lt;/span&gt; &lt;span class="nv"&gt;$filename&lt;/span&gt;
&lt;span class="nb"&gt;mv&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$filename&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$filename1&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;  &lt;span class="c"&gt;# 这里面的本意是 更改myfile 文件为 myfile1，但是因为并没有 区分 $filename1 是变量还是表达式, 所以这里需要 使用新的形势 来进行区分&lt;/span&gt;
&lt;span class="nb"&gt;mv&lt;/span&gt;: missing destination file operand after &lt;span class="sb"&gt;`&lt;/span&gt;myfile&lt;span class="s1"&gt;'
Try `mv --help'&lt;/span&gt; &lt;span class="k"&gt;for &lt;/span&gt;more information.

&lt;span class="nb"&gt;mv&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$filename&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;filename&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;1"&lt;/span&gt; &lt;span class="c"&gt;# 使用 {} 来解决歧义&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="function-define"&gt;function define:&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="k"&gt;function &lt;/span&gt;name &lt;span class="o"&gt;{&lt;/span&gt;
    commands
    &lt;span class="k"&gt;return&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

name&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    commands
    &lt;span class="k"&gt;return&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;local var: 局部变量， local foo=&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="flow-control"&gt;Flow Control:&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;if
&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="k"&gt;if &lt;/span&gt;commands&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then 
&lt;/span&gt;commands
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="k"&gt;elif &lt;/span&gt;commands&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then 
&lt;/span&gt;commands...]
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="k"&gt;else 
&lt;/span&gt;commands]
&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
  &lt;li&gt;exit status: 一般为 为一个 0-255 的数值， 0 代表 success， 其他值代表不同的错误。所以0 代表true，false 代表1， 不同于其他语言中的惯例。$? 代表 上个命令执行的返回结果
&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;root@precise64:~/shell_test# &lt;span class="nb"&gt;ls&lt;/span&gt; &lt;span class="nt"&gt;-d&lt;/span&gt; /usr/bin/
/usr/bin/
root@precise64:~/shell_test# &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$?&lt;/span&gt;
0
root@precise64:~/shell_test# &lt;span class="nb"&gt;ls&lt;/span&gt; &lt;span class="nt"&gt;-d&lt;/span&gt; /bin/usr
&lt;span class="nb"&gt;ls&lt;/span&gt;: cannot access /bin/usr: No such file or directory
root@precise64:~/shell_test# &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$?&lt;/span&gt;
2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
  &lt;li&gt;test： 配合if 使用，返回condition 结果: 两种形式. 成功返回0， 失败 返回1&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="nb"&gt;test &lt;/span&gt;expression

&lt;span class="o"&gt;[&lt;/span&gt;expression]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id="相关的测试expression"&gt;相关的测试expression&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;file Expression&lt;br /&gt;
| Expression      | Is True?                                           |&lt;br /&gt;
|—————–|—————————————————-|&lt;br /&gt;
| file1 -ef file2 | file1 inode eq file2 inode true                    |&lt;br /&gt;
| file1 -nt file2 | file1 is newer than file2                          |&lt;br /&gt;
| file1 -ot file2 | file1 is older than file2                          |&lt;br /&gt;
| -b file         | file exist and is a block-special file             |&lt;br /&gt;
| -c file         | file exist and is a char-special file              |&lt;br /&gt;
| -d file         | file exists and is a dir                           |&lt;br /&gt;
| -e file         | file exists                                        |&lt;br /&gt;
| -f file         | file exists and a regular file                     |&lt;br /&gt;
| -g file         | file exists and is set-group-id                    |&lt;br /&gt;
| -G file         | file exists and is owner by the effective group ID |&lt;br /&gt;
| -k file         | file exists and has its ‘sticky bit’ sit           |&lt;br /&gt;
| -L file         | file exists and is a sym link                      |&lt;br /&gt;
| -p file         | file exists and a named pipe                       |&lt;br /&gt;
| -r file         | file exists and can readable                       |&lt;br /&gt;
| -s file         | file exists and has a length greater than zero     |&lt;br /&gt;
| -S file         | file exists and a socket                           |&lt;br /&gt;
| -w file         | file exists and writable                           |&lt;br /&gt;
| -x fiel         | file exists and executeable                        |&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;string expression&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Expression&lt;/th&gt;
      &lt;th&gt;Meaning&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;string&lt;/td&gt;
      &lt;td&gt;string is not null&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-n string&lt;/td&gt;
      &lt;td&gt;string len is not zero&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-z string&lt;/td&gt;
      &lt;td&gt;string len is zero&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;str1 == str2&lt;/td&gt;
      &lt;td&gt;equal&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;str1 != str2&lt;/td&gt;
      &lt;td&gt;not equal&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;str1 &amp;gt; str2&lt;/td&gt;
      &lt;td&gt;str1 sorts after str2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;str1 &amp;lt; str2&lt;/td&gt;
      &lt;td&gt;str1 sort before str2&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这里面 需要注意: the &amp;gt; and &amp;lt; expression operators must be quoted (or escaped with a backslash) when used with test. If they are not, they will be interpreted by the&lt;br /&gt;
shell as redirection operators&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Integer Expressions&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Expression&lt;/th&gt;
      &lt;th&gt;Meaning&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;int1 -eq int2&lt;/td&gt;
      &lt;td&gt;equal&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;int1 -ne int2&lt;/td&gt;
      &lt;td&gt;not equal&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;int1 -le int2&lt;/td&gt;
      &lt;td&gt;int1 &amp;lt;= int2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;int1 -lt int2&lt;/td&gt;
      &lt;td&gt;int1 &amp;lt; int2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;int1 -ge int2&lt;/td&gt;
      &lt;td&gt;int1 &amp;gt;= int2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;int1 -gt int2&lt;/td&gt;
      &lt;td&gt;int1 &amp;gt; int2&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;[[ expression ]] : 类似于 [ expression ], 大使可以测试 string1 =~ regex&lt;/li&gt;
  &lt;li&gt;(( )): Designed for Integers, 用于测试 数学计算， 如果 数值 为非0 则是true， 0 则为false。在(()) 中变量可以直接 使用，不用带 $, 例如, 在其中 可以使用 所有的数学表达式，比如 &amp;gt;, &amp;lt;, &amp;gt;=, &amp;lt;=, ==, %, /, * etc&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="nv"&gt;INT&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;5
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;((&lt;/span&gt;INT &lt;span class="o"&gt;==&lt;/span&gt; 0&lt;span class="o"&gt;))&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then
    &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"INT is zero"&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;Combining Expressions:&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Operation&lt;/th&gt;
      &lt;th&gt;test&lt;/th&gt;
      &lt;th&gt;[[]] and (())&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;AND&lt;/td&gt;
      &lt;td&gt;-a&lt;/td&gt;
      &lt;td&gt;&amp;amp;&amp;amp;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;OR&lt;/td&gt;
      &lt;td&gt;-o&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;NOT&lt;/td&gt;
      &lt;td&gt;!&lt;/td&gt;
      &lt;td&gt;!&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;for example:&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="c"&gt;#!/bin/bash&lt;/span&gt;

&lt;span class="nv"&gt;MIN_VAL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1
&lt;span class="nv"&gt;MAX_VAL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;100


&lt;span class="nv"&gt;INT&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;50
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[[&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$INT&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;~ ^-?[0-9]+&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="o"&gt;]]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then
    if&lt;/span&gt; &lt;span class="o"&gt;[[&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$INT&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="nt"&gt;-ge&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$MIN_VAL&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$INT&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="nt"&gt;-le&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$MAX_VAL&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;]]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then
        &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$INT&lt;/span&gt;&lt;span class="s2"&gt; is within &lt;/span&gt;&lt;span class="nv"&gt;$MIN_VAL&lt;/span&gt;&lt;span class="s2"&gt; to &lt;/span&gt;&lt;span class="nv"&gt;$MAX_VAL&lt;/span&gt;&lt;span class="s2"&gt;."&lt;/span&gt;
    &lt;span class="k"&gt;else
        &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$INT&lt;/span&gt;&lt;span class="s2"&gt; is out of range."&lt;/span&gt;
    &lt;span class="k"&gt;fi
else
    &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"INT is not an integer."&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&amp;amp;2
    &lt;span class="nb"&gt;exit &lt;/span&gt;1
&lt;span class="k"&gt;fi&lt;/span&gt;


&lt;span class="c"&gt;# 等价的另一种方式&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$INT&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="nt"&gt;-ge&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$MIN_VAL&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="nt"&gt;-a&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$INT&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="nt"&gt;-le&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$MAX_VAL&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then
  &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$INT&lt;/span&gt;&lt;span class="s2"&gt; is within &lt;/span&gt;&lt;span class="nv"&gt;$MIN_VAL&lt;/span&gt;&lt;span class="s2"&gt; to &lt;/span&gt;&lt;span class="nv"&gt;$MAX_VAL&lt;/span&gt;&lt;span class="s2"&gt;."&lt;/span&gt;
&lt;span class="k"&gt;else
  &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$INT&lt;/span&gt;&lt;span class="s2"&gt; is out of range."&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="read-read-用于-从标准输入中-读取数值"&gt;read: read 用于 从标准输入中 读取数值。&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Options&lt;/th&gt;
      &lt;th&gt;Desc&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-a array&lt;/td&gt;
      &lt;td&gt;将输入赋值（转化）给 数组&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-e&lt;/td&gt;
      &lt;td&gt;使用 Readline 模式 处理输入&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-i string&lt;/td&gt;
      &lt;td&gt;默认数值，在玩家仅仅按 enter的时候 有用&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-p prompt&lt;/td&gt;
      &lt;td&gt;输入的 提示信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-r&lt;/td&gt;
      &lt;td&gt;Raw mode. Do not interpret backslash characters as escapes.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-s&lt;/td&gt;
      &lt;td&gt;slient mode, 用于密码输入&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-t seconds&lt;/td&gt;
      &lt;td&gt;Timeout after seconds&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-u fd&lt;/td&gt;
      &lt;td&gt;使用file 作为输入，而不是标准输入&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;read：将 标准输入 转到 变量 的使用格式： read  [-options] [variable…]&lt;/li&gt;
  &lt;li&gt;read 存在默认变量 REPLY，即当没有 variable 传递的时候&lt;/li&gt;
  &lt;li&gt;for example&lt;br /&gt;
```shell&lt;br /&gt;
#!/bin/bash&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;echo -n “please enter an integer -&amp;gt; “&lt;br /&gt;
read int&lt;/p&gt;

&lt;p&gt;if [[ “$int” =~ ^-?[0-9]+$ ]]; then&lt;br /&gt;
    if (( int == 0 )); then&lt;br /&gt;
        echo “int is zero”&lt;br /&gt;
    else&lt;br /&gt;
        if (( int &amp;lt; 0)); then&lt;br /&gt;
            echo “$int is negative”&lt;br /&gt;
        else&lt;br /&gt;
            echo “$int is positive”&lt;br /&gt;
        fi&lt;br /&gt;
    fi&lt;br /&gt;
fi&lt;/p&gt;

&lt;h1 id="read-多个var-测试-与ruby-array-复制差不多"&gt;read 多个var 测试, 与ruby array 复制差不多，&lt;/h1&gt;
&lt;h1 id="即是当多个-参数数目--变量数目-时-剩余的变量为空值当-参数数目--变量数目时-最后后一个变量-存储多个数值"&gt;即是：当多个 参数数目 &amp;gt; 变量数目 时 剩余的变量为空值，当 参数数目 &amp;lt; 变量数目时 最后后一个变量 存储多个数值&lt;/h1&gt;

&lt;p&gt;#!/bin/bash&lt;/p&gt;
&lt;h1 id="read-multiple-read-multiple-values-from-keyboard"&gt;read-multiple: read multiple values from keyboard&lt;/h1&gt;
&lt;p&gt;echo -n “Enter one or more values &amp;gt; “&lt;br /&gt;
read var1 var2 var3 var4 var5&lt;br /&gt;
echo “var1 = ‘$var1’”&lt;br /&gt;
echo “var2 = ‘$var2’”&lt;br /&gt;
echo “var3 = ‘$var3’”&lt;br /&gt;
echo “var4 = ‘$var4’”&lt;br /&gt;
echo “var5 = ‘$var5’”&lt;/p&gt;

&lt;p&gt;vagrant@precise64:/vagrant_data/shell_test$ ./read-multiple.sh&lt;br /&gt;
Enter one or more values &amp;gt; 1 2 3 4 4 45 5&lt;br /&gt;
var1 = ‘1’&lt;br /&gt;
var2 = ‘2’&lt;br /&gt;
var3 = ‘3’&lt;br /&gt;
var4 = ‘4’&lt;br /&gt;
var5 = ‘4 45 5’&lt;/p&gt;

&lt;p&gt;vagrant@precise64:/vagrant_data/shell_test$ ./read-multiple.sh&lt;br /&gt;
Enter one or more values &amp;gt; 1&lt;br /&gt;
var1 = ‘1’&lt;br /&gt;
var2 = ‘’&lt;br /&gt;
var3 = ‘’&lt;br /&gt;
var4 = ‘’&lt;br /&gt;
var5 = ‘’&lt;/p&gt;

&lt;h1 id="read-不传递-var-时候默认使用变量-reply"&gt;read 不传递 var 时候，默认使用变量 REPLY&lt;/h1&gt;
&lt;p&gt;#!/bin/bash&lt;/p&gt;
&lt;h1 id="read-single-read-multiple-values-into-default-variable"&gt;read-single: read multiple values into default variable&lt;/h1&gt;
&lt;p&gt;echo -n “Enter one or more values &amp;gt; “&lt;br /&gt;
read&lt;br /&gt;
echo “REPLY = ‘$REPLY’”&lt;/p&gt;

&lt;p&gt;vagrant@precise64:/vagrant_data/shell_test$ ./read-single.sh&lt;br /&gt;
Enter one or more values &amp;gt; 1&lt;br /&gt;
REPLY = ‘1’&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;
* IFS （Internal Field Separator） : 用来控制 read 分隔line 的分隔符， 默认的IFS 包含 space, tab, newline
* 使用read的 这种方式， 可以很简单的 做 字符串的 split

```shell
IFS=":" read user pw uid gid name home shell &amp;lt;&amp;lt;&amp;lt; "root:x:0:0:root:/root:/bin/bash"
echo "string: ${user}, pw: ${pw}, uid: ${uid}, shell: ${shell}"
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="flow-control-looping-with-whileuntil"&gt;Flow Control: Looping with while/until&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;while: shell 中 同样存在 continue break 可供使用，以便提前 循环、或者 终止循环&lt;br /&gt;
```shell&lt;br /&gt;
while commands; do&lt;br /&gt;
  commands&lt;br /&gt;
done&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;count=1&lt;br /&gt;
while [[ “$count” -le 5 ]];&lt;br /&gt;
    do echo “$count”&lt;br /&gt;
    count=$((count + 1))&lt;br /&gt;
done&lt;br /&gt;
echo “Finished.”&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;* until: 与while 同样的基本结构，不过测试条件相反

```shell
#!/bin/bash
# until-count: display a series of numbers count=1
until [[ "$count" -gt 5 ]]; do
    echo "$count"
    count=$((count + 1))
done
echo "Finished."
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;读取文件的循环示例：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="c"&gt;#!/bin/bash&lt;/span&gt;
&lt;span class="c"&gt;# while-read: read lines from a file&lt;/span&gt;
&lt;span class="k"&gt;while &lt;/span&gt;&lt;span class="nb"&gt;read &lt;/span&gt;distro version release&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do
    &lt;/span&gt;&lt;span class="nb"&gt;printf&lt;/span&gt; &lt;span class="s2"&gt;"Distro: %s&lt;/span&gt;&lt;span class="se"&gt;\t&lt;/span&gt;&lt;span class="s2"&gt;Version: %s&lt;/span&gt;&lt;span class="se"&gt;\t&lt;/span&gt;&lt;span class="s2"&gt;Released: %s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
        &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$distro&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
        &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$version&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
        &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$release&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
&lt;span class="k"&gt;done&lt;/span&gt; &amp;lt; distros.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;shell 的测试： 1） 除了 print 大法好(在这里是echo 之外) 2) #!/bin/bash -x  这样在脚本运行期间，将会 展示详细信息, 可以 使用 set +x 关闭 tracing set -x开启 tracing&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;case:  使用 pattern 进行匹配，) 结束 匹配。 还可以参考链接 http://tiswww.case.edu/php/chet/bash/bashref.html#SEC21 http://tldp.org/LDP/abs/html/testbranch.html 因为这里面介绍的十分简单&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Pattern&lt;/th&gt;
      &lt;th&gt;Desc&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;a)&lt;/td&gt;
      &lt;td&gt;Match if word equal ‘a’&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[[:aplpha:]])&lt;/td&gt;
      &lt;td&gt;Match if word is a single alphabetic char&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;???)&lt;/td&gt;
      &lt;td&gt;Match if word is exactly three char long&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;*.txt)&lt;/td&gt;
      &lt;td&gt;Match if word ends with the char “.txt”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;*)&lt;/td&gt;
      &lt;td&gt;Matches anyy value of word&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="k"&gt;case&lt;/span&gt; word &lt;span class="k"&gt;in&lt;/span&gt;
    &lt;span class="o"&gt;[&lt;/span&gt;pattern &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt; pattern]...&lt;span class="p"&gt;)&lt;/span&gt; commands &lt;span class="p"&gt;;;&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;...
&lt;span class="k"&gt;esac&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;for example&lt;br /&gt;
```shell&lt;br /&gt;
#!/bin/bash -x&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;read -p “Enter selection [0-3] &amp;gt; “&lt;br /&gt;
case “$REPLY” in&lt;br /&gt;
    0) echo “Program terminated.”&lt;br /&gt;
       exit&lt;br /&gt;
       ;;&lt;br /&gt;
    1) echo “Hostname: $HOSTNAME”&lt;br /&gt;
       uptime&lt;br /&gt;
       ;;&lt;br /&gt;
    2) df -h&lt;br /&gt;
       ;;&lt;br /&gt;
    3) if [[ “$(id -u)” -eq 0 ]]; then&lt;br /&gt;
           echo “Home Space Utilization (All Users)”&lt;br /&gt;
           du -sh /home/*&lt;br /&gt;
       else&lt;br /&gt;
           echo “Home Space Utilization ($USER)”&lt;br /&gt;
           du -sh “$HOME”&lt;br /&gt;
       fi&lt;br /&gt;
       ;;&lt;br /&gt;
    *) echo “Invalid entry” &amp;gt;&amp;amp;2&lt;br /&gt;
       exit 1&lt;br /&gt;
       ;;&lt;br /&gt;
esac&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;
#### Accessing the Command Line: 
* shell 中 通过 $0-$9 来接受 command line 传递的参数。其中9 并不是 参数个数的上线，可以使用 更多的比如 $11, $100000 来使用 第 1000000 个参数。
*  $# 标志 参数个数。其中 $0 总是为 shell本身
*  shift： shift可以将 将 $1后续的变量，转移到 $1上， 同时 $# 减少

```shell
#!/bin/bash
# posit-param2: script to display all arguments count=1
while [[ $# -gt 0 ]]; do
  echo "Argument $count = $1"
  count=$((count + 1))
  shift
done
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;同样是 作为 函数 传递参数的方式：&lt;/li&gt;
  &lt;li&gt;常量： PROGNAME当前shell运行的函数， FUNCNAME 为shell当前运行的shell函数&lt;/li&gt;
  &lt;li&gt;$* $@ “$*” “$@” : “$@” 在这里面是最为 重要的，以为保留了 原来参数传递的样式&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;// fun_test.sh file
&lt;span class="c"&gt;#!/bin/bash&lt;/span&gt;
&lt;span class="c"&gt;# posit-params3: script to demonstrate $* and $@&lt;/span&gt;
print_params &lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\$&lt;/span&gt;&lt;span class="s2"&gt;1 = &lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\$&lt;/span&gt;&lt;span class="s2"&gt;2 = &lt;/span&gt;&lt;span class="nv"&gt;$2&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\$&lt;/span&gt;&lt;span class="s2"&gt;3 = &lt;/span&gt;&lt;span class="nv"&gt;$3&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\$&lt;/span&gt;&lt;span class="s2"&gt;4 = &lt;/span&gt;&lt;span class="nv"&gt;$4&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
pass_params &lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nt"&gt;-e&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="s1"&gt;'$*'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; print_params &lt;span class="nv"&gt;$*&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nt"&gt;-e&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="s1"&gt;'$*'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; print_params &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$*&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nt"&gt;-e&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="s1"&gt;'$@'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; print_params &lt;span class="nv"&gt;$@&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nt"&gt;-e&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="s1"&gt;'$@'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; print_params &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$@&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
pass_params &lt;span class="s2"&gt;"word"&lt;/span&gt; &lt;span class="s2"&gt;"words with spaces"&lt;/span&gt;


// ./fun_test.sh 测试
root@precise64:/vagrant_data/shell_test# ./fun_test.sh

 &lt;span class="nv"&gt;$*&lt;/span&gt;
&lt;span class="nv"&gt;$1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; word
&lt;span class="nv"&gt;$2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; words
&lt;span class="nv"&gt;$3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; with
&lt;span class="nv"&gt;$4&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; spaces

 &lt;span class="nv"&gt;$*&lt;/span&gt;
&lt;span class="nv"&gt;$1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; word words with spaces
&lt;span class="nv"&gt;$2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
&lt;span class="nv"&gt;$3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
&lt;span class="nv"&gt;$4&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;

 &lt;span class="nv"&gt;$@&lt;/span&gt;
&lt;span class="nv"&gt;$1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; word
&lt;span class="nv"&gt;$2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; words
&lt;span class="nv"&gt;$3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; with
&lt;span class="nv"&gt;$4&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; spaces

 &lt;span class="nv"&gt;$@&lt;/span&gt;
&lt;span class="nv"&gt;$1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; word
&lt;span class="nv"&gt;$2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; words with spaces
&lt;span class="nv"&gt;$3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
&lt;span class="nv"&gt;$4&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="for-loop"&gt;for loop:&lt;/h4&gt;
&lt;p&gt;传统形式&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="k"&gt;for &lt;/span&gt;variable &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="k"&gt;in &lt;/span&gt;words]&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do 
  &lt;/span&gt;commands
&lt;span class="k"&gt;done&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;c语言形式： 只支持 在对 数字 进行操作的时候&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;((&lt;/span&gt; expression1&lt;span class="p"&gt;;&lt;/span&gt; expression2&lt;span class="p"&gt;;&lt;/span&gt; expression3 &lt;span class="o"&gt;))&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do
  &lt;/span&gt;commands
&lt;span class="k"&gt;done

for&lt;/span&gt; &lt;span class="o"&gt;((&lt;/span&gt; &lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0&lt;span class="p"&gt;;&lt;/span&gt; i&amp;lt;5&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;i+1 &lt;span class="o"&gt;))&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do
    &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$i&lt;/span&gt;
&lt;span class="k"&gt;done&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;example&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="k"&gt;for &lt;/span&gt;i &lt;span class="k"&gt;in &lt;/span&gt;A B C D&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;done
&lt;/span&gt;A
B
C
D


&lt;span class="k"&gt;for &lt;/span&gt;i &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;A..D&lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;done
&lt;/span&gt;A
B
C
D

&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="k"&gt;for &lt;/span&gt;i &lt;span class="k"&gt;in &lt;/span&gt;distros&lt;span class="k"&gt;*&lt;/span&gt;.txt&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$i&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;done
&lt;/span&gt;distros-by-date.txt
distros-dates.txt
distros-key-names.txt
distros-key-vernums.txt
distros-names.txt
distros.txt
distros-vernums.txt
distros-versions.txt



&lt;span class="c"&gt;# ./for_test.sh file&lt;/span&gt;
&lt;span class="k"&gt;for &lt;/span&gt;i&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do
    &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"i in ---------- &lt;/span&gt;&lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt;&lt;span class="s2"&gt; &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
&lt;span class="k"&gt;done&lt;/span&gt;


&lt;span class="c"&gt;# 可以使用如此的方式，循环打印 command line 参数&lt;/span&gt;
root@precise64:/vagrant_data/shell_test# ./for_test.sh  a b c d e f j
i &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="nt"&gt;----------&lt;/span&gt; a &lt;span class="se"&gt;\n&lt;/span&gt;
i &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="nt"&gt;----------&lt;/span&gt; b &lt;span class="se"&gt;\n&lt;/span&gt;
i &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="nt"&gt;----------&lt;/span&gt; c &lt;span class="se"&gt;\n&lt;/span&gt;
i &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="nt"&gt;----------&lt;/span&gt; d &lt;span class="se"&gt;\n&lt;/span&gt;
i &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="nt"&gt;----------&lt;/span&gt; e &lt;span class="se"&gt;\n&lt;/span&gt;
i &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="nt"&gt;----------&lt;/span&gt; f &lt;span class="se"&gt;\n&lt;/span&gt;
i &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="nt"&gt;----------&lt;/span&gt; j &lt;span class="se"&gt;\n&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="strings-and-numbers"&gt;Strings and Numbers&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;expression&lt;/th&gt;
      &lt;th&gt;meaning&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;${para:-word}&lt;/td&gt;
      &lt;td&gt;para 为空 express result 为 word&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;${para:=word}&lt;/td&gt;
      &lt;td&gt;para 为空 express &amp;amp; para result 为 word (position 参数不能够如此赋值)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;${pars:?word}&lt;/td&gt;
      &lt;td&gt;pars 为空 则exit，word被输出到 stderr&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;${para:+word}&lt;/td&gt;
      &lt;td&gt;para不为空，则 expres 为 word&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;${!prefix*} 或者  ${!prefix@}&lt;/td&gt;
      &lt;td&gt;返回 以 prefix 为前缀的 变量名称&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;${#para}&lt;/td&gt;
      &lt;td&gt;para length, 如果 para 为 @ 或者 * 则 展开为 command line params size&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;${para:offset} ${para:offset:length}&lt;/td&gt;
      &lt;td&gt;用于string 的片段截取，没有length时候，则直到末尾, para为 @时候, 则为 参数 从 offset开始 到结尾&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;${para#pattern} ${para##pattern}&lt;/td&gt;
      &lt;td&gt;将字符串remove pattern match的部分，结果为 剩下的部分， #pattern remove 最短的 match 部分， ## 则remove 最长的match&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;${para%pattern}  ${para%%pattern}&lt;/td&gt;
      &lt;td&gt;同上，但是 remove 片段从string 的末尾开始，而非开头开始&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;${para/pattern/string} ${para//pattern/string} ${para/#pattern/string} ${para/%pattern/string}&lt;/td&gt;
      &lt;td&gt;string 的查找替换操作，使用 string 替换 para中的 pattern matched，第一个只替换第一个， 第二个则全部替换， 第三个 则替换开头， 第四个只替换末尾&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;case conversion parameter&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Format&lt;/th&gt;
      &lt;th&gt;Result&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;${pars,,}&lt;/td&gt;
      &lt;td&gt;展开为  para 的 全部小写形式&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;${para,}&lt;/td&gt;
      &lt;td&gt;展开式 para 首字母 小写&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;${para^^}&lt;/td&gt;
      &lt;td&gt;展开为 para 的全部 大写形式&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;${para^}&lt;/td&gt;
      &lt;td&gt;展开为 para 首字母 大写形式&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id="数字操作-expression-基本形式"&gt;数字操作: $((expression)) 基本形式&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Operators&lt;br /&gt;
| Operator             | Desc |   |   |&lt;br /&gt;
|———————-|——|—|—|&lt;br /&gt;
| +                    |      |   |   |&lt;br /&gt;
| -                    | *    |   |   |&lt;br /&gt;
| *                    |      |   |   |&lt;br /&gt;
| /                    |      |   |   |&lt;br /&gt;
| **                   |      |   |   |&lt;br /&gt;
| %                    |      |   |   |&lt;br /&gt;
| para = value         |      |   |   |&lt;br /&gt;
| para += value        |      |   |   |&lt;br /&gt;
| para -= value        |      |   |   |&lt;br /&gt;
| para *= value        |      |   |   |&lt;br /&gt;
| para /= value        |      |   |   |&lt;br /&gt;
| para %= value        |      |   |   |&lt;br /&gt;
| para ++              |      |   |   |&lt;br /&gt;
| para –              |      |   |   |&lt;br /&gt;
| ++ para              |      |   |   |&lt;br /&gt;
| – para              |      |   |   |&lt;br /&gt;
| &amp;lt;=                   |      |   |   |&lt;br /&gt;
| &amp;gt;=                   |      |   |   |&lt;br /&gt;
| &amp;lt;                    |      |   |   |&lt;br /&gt;
| &amp;gt;                    |      |   |   |&lt;br /&gt;
| ==                   |      |   |   |&lt;br /&gt;
| !=                   |      |   |   |&lt;br /&gt;
| &amp;amp;&amp;amp;                   |      |   |   |&lt;br /&gt;
| expre1?expre2:expre3 |      |   |   |&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="array-bash-version2-才得到支持在原先的shell中-并不支持-array"&gt;Array: bash version2 才得到支持，在原先的shell中 并不支持 array&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Create a Array :&lt;br /&gt;
```shell&lt;br /&gt;
a[1]=foo&lt;br /&gt;
echo ${a[1]}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;declare -a a&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;* Assigning Values to an Array: name[subscript]=value; name=(value1 value2 ...)
* Array Operations: 遍历数组

```shell
[me@linuxbox ~]$ animals=("a dog" "a cat" "a fish") 
[me@linuxbox ~]$ for i in ${animals[*]}; do echo $i; done 
a
dog
a
cat
a
fish

[me@linuxbox ~]$ for i in ${animals[@]}; do echo $i; done a
dog
a
cat
a
fish

[me@linuxbox ~]$ for i in "${animals[*]}"; do echo $i; done
a dog a cat a fish

[me@linuxbox ~]$ for i in "${animals[@]}"; do echo $i; done
a dog
a cat
a fish

# "${!array[*]}", "${!array[@]}"
[me@linuxbox ~]$ foo=([2]=a [4]=b [6]=c)

[me@linuxbox ~]$ for i in "${foo[@]}"; do echo $i; done 
a
b
c

# 展示数组 有value的 indexs
[me@linuxbox ~]$ for i in "${!foo[@]}"; do echo $i; done
2
4
6

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;Sorting an Array:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="c"&gt;#!/bin/bash&lt;/span&gt;
&lt;span class="c"&gt;# array-sort: Sort an array a=(f e d c b a)&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"Original array: &lt;/span&gt;&lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[@]&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
&lt;span class="c"&gt;# 传统的数组排序方式，因为shell并不会构建复杂的 类型系统 来进行 数组函数排序&lt;/span&gt;
&lt;span class="nv"&gt;a_sorted&lt;/span&gt;&lt;span class="o"&gt;=(&lt;/span&gt;&lt;span class="si"&gt;$(&lt;/span&gt;&lt;span class="k"&gt;for &lt;/span&gt;i &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[@]&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;done&lt;/span&gt; | &lt;span class="nb"&gt;sort&lt;/span&gt;&lt;span class="si"&gt;)&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"Sorted array: &lt;/span&gt;&lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;a_sorted&lt;/span&gt;&lt;span class="p"&gt;[@]&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;Deleting an Array: unset array; unset ‘array[index]’ array=xxxx 修改 array[0] 中的数值&lt;br /&gt;
```shell&lt;br /&gt;
[me@linuxbox ~]$ foo=(a b c d e f)&lt;br /&gt;
[me@linuxbox ~]$ echo ${foo[@]}&lt;br /&gt;
a b c d e f&lt;br /&gt;
[me@linuxbox ~]$ unset foo&lt;br /&gt;
[me@linuxbox ~]$ echo ${foo[@]}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[me@linuxbox ~]$&lt;/p&gt;

&lt;p&gt;[me@linuxbox ~]$ foo=(a b c d e f)&lt;br /&gt;
[me@linuxbox ~]$ echo ${foo[@]}&lt;br /&gt;
a b c d e f&lt;br /&gt;
[me@linuxbox ~]$ unset ‘foo[2]’&lt;br /&gt;
[me@linuxbox ~]$ echo ${foo[@]}&lt;br /&gt;
a b d e f&lt;/p&gt;

&lt;p&gt;[me@linuxbox ~]$ foo=(a b c d e f)&lt;br /&gt;
[me@linuxbox ~]$ foo=&lt;br /&gt;
[me@linuxbox ~]$ echo ${foo[@]}&lt;br /&gt;
b c d e f&lt;/p&gt;

&lt;p&gt;[me@linuxbox ~]$ foo=(a b c d e f)&lt;br /&gt;
[me@linuxbox ~]$ echo ${foo[@]}&lt;br /&gt;
a b c d e f&lt;br /&gt;
[me@linuxbox ~]$ foo=A&lt;br /&gt;
[me@linuxbox ~]$ echo ${foo[@]}&lt;br /&gt;
A b c d e f&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;
#### Group Commands and Subshells:
* { command1; command2; [command3; ...] }
* (command1; command2; [command3;...])
group commands  可以将  其中的command 的结果 很方便的 合并到一个 数据流汇总，例如：

```shell
(ls -l; echo "Listing of foo.txt"; cat foo.txt) &amp;gt; output.txt
{ ls -l; echo "Listing of foo.txt"; cat foo.txt; } &amp;gt; output.txt

#等同于： 
ls -l &amp;gt; output.txt
echo "Listing of foo.txt" &amp;gt;&amp;gt; output.txt
cat foo.txt &amp;gt;&amp;gt; output.txt

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="process-substitution-区别于-group-commands--process-sub-运行在-子进程-中而group-command-则运行在当前进程中-所以从效率上来说-group-command-要快于-process-substitution-该技术使得--子进程-中的输出-到当前进程中-进行处理通常-将-子进程中的数据流-输出到当前-进程使用-read-处理"&gt;Process Substitution： 区别于 group commands ， Process sub 运行在 子进程 中，而group command 则运行在当前进程中， 所以从效率上来说 group command 要快于 process substitution, 该技术使得  子进程 中的输出 到当前进程中 进行处理。通常 将 子进程中的数据流 输出到当前 进程使用 read 处理。&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;形式为： &amp;lt;(list)， &amp;gt;(list)。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;for example&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;
&lt;span class="c"&gt;#!/bin/bash&lt;/span&gt;
&lt;span class="c"&gt;# pro-sub: demo of process substitution&lt;/span&gt;
&lt;span class="k"&gt;while &lt;/span&gt;&lt;span class="nb"&gt;read &lt;/span&gt;attr links owner group size &lt;span class="nb"&gt;date time &lt;/span&gt;filename&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do
done&lt;/span&gt; &amp;lt; &amp;lt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;ls&lt;/span&gt; &lt;span class="nt"&gt;-l&lt;/span&gt; | &lt;span class="nb"&gt;tail&lt;/span&gt; &lt;span class="nt"&gt;-n&lt;/span&gt; +2&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="traps-处理-信号trap-argument-signal-signal--其中-argument-为string-例如"&gt;Traps: 处理 信号。trap argument signal [signal…]  其中 argument 为string， 例如：&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="nb"&gt;trap&lt;/span&gt; &lt;span class="s2"&gt;"echo 'I am ignoring you.'"&lt;/span&gt; SIGINT SIGTERM

&lt;span class="nb"&gt;trap &lt;/span&gt;exit_on_signal_SIGINT SIGINT
&lt;span class="nb"&gt;trap &lt;/span&gt;exit_on_signal_SIGTERM SIGTERM
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="docker-书籍"&gt;Docker 书籍&lt;/h4&gt;
&lt;h5 id="docker-的结构--客户端--服务器-docker-服务器-为一个守护进程下层抽象-docker-容器与客户端配合-提供了-一个restful-api-给-客户端"&gt;Docker 的结构：  客户端 + 服务器。 Docker 服务器 为一个守护进程，下层抽象 Docker 容器，与客户端配合 提供了 一个RESTful API 给 客户端。&lt;/h5&gt;
&lt;h5 id="概念-镜像-与-容器镜像是docker世界的基石类似于-面向对象中的-类-所有容器-都是基于-镜像-运行的也就是说-容器类似于-实例对象镜像-是-docker生命周期-中的-构建或-打包阶段容器则是启动和-执行阶段"&gt;概念： 镜像 与 容器。镜像是Docker世界的基石，类似于 面向对象中的 类， 所有容器 都是基于 镜像 运行的。也就是说 容器类似于 实例对象。镜像 是 Docker生命周期 中的 构建或 打包阶段，容器则是启动和 执行阶段。&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;Docker容器： 一个镜像格式，一系列标准的操作，一个执行环境
    &lt;h5 id="docker-能够帮助我们做什么"&gt;docker 能够帮助我们做什么：&lt;/h5&gt;
  &lt;/li&gt;
  &lt;li&gt;加速本地开发和构建流程，因为其高效轻量，可以方便本地开发人员进行构建&lt;/li&gt;
  &lt;li&gt;能够让独立服务在不同的应用环境中，得到相同的运行结果。&lt;/li&gt;
  &lt;li&gt;创建隔离的环境进行测试&lt;/li&gt;
  &lt;li&gt;都建一个多用户的平台及服务（PaaS）基础设施&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id="docker的特性-linux-namespace-的作用"&gt;Docker的特性？ linux namespace 的作用：&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;文件系统隔离：每个容器都有自己的root文件系统&lt;/li&gt;
  &lt;li&gt;进程隔离： 每个容器都运行在自己的进程环境中&lt;/li&gt;
  &lt;li&gt;网络隔离：荣期间的虚拟网络接口和IP地址都是分开的&lt;/li&gt;
  &lt;li&gt;资源隔离和分组： 使用cgroups 将CPU 和内存之类的资源独立分配给每个Docker容器&lt;/li&gt;
  &lt;li&gt;写时复制： 文件系统都是通过写时复制创建的，这就意味着文件系统是分层的、快速的、占用小的磁盘空间&lt;/li&gt;
  &lt;li&gt;日志： 容器产生的STDOUT stderr, stdin 这些IO都会被收集并记录入日志，用来进行日志分析和故常排查&lt;/li&gt;
  &lt;li&gt;交互式shell： 用户可以创建一个伪造tty中断连接的，STDIN，为容器提供一个交互式的Shell
    &lt;h5 id="docker-守护进程服务器"&gt;Docker 守护进程（服务器）：&lt;/h5&gt;
  &lt;/li&gt;
  &lt;li&gt;需要以root权限运行，以便处理 诸如 挂载文件系统 等特殊操作。&lt;/li&gt;
  &lt;li&gt;守护进程 监听 /var/run/docker.sock Unix套接字 来获得 Docker客户端的请求。&lt;/li&gt;
  &lt;li&gt;启动： ubuntu 中 start docker, stop docker， centos 中 service docker stop service docker start
    &lt;h5 id="docker-操作docker容器-则为-docker的运行态运行着-用户的process-容器内部同linux-namespace-一样进行了完全的隔离"&gt;Docker 操作：Docker容器 则为 Docker的运行态，运行着 用户的process， 容器内部同linux namespace 一样，进行了完全的隔离&lt;/h5&gt;
  &lt;/li&gt;
  &lt;li&gt;创建容器： docker run -i -t ubuntu /bin/bash  -i 标志打开容器的STDIN， -t 为容器 分配一个伪 tty 终端&lt;/li&gt;
  &lt;li&gt;停止容器： docker stop daemon_dave; docker stop 2q3412c&lt;/li&gt;
  &lt;li&gt;删除容器： docker rm daemon_dave // 容器停止运行并不会自动清理，而需要 手动 rm，因为可能存在 重新 start 的需求。类似于进程&lt;/li&gt;
  &lt;li&gt;命名容器： docker run –name test_container -i -t ubuntu /bin/bash 容器的命名必须是唯一的。&lt;/li&gt;
  &lt;li&gt;创建守护式容器： (daemonized container): docker run –name daemon_dave -d ubuntu /bin/bash -c “while true; do echo hello world; sleep 1; done”//  -d 为 daemon运行的标志， 容器中的进程不能够退出&lt;/li&gt;
  &lt;li&gt;重启已经停止的容器： docker start test_container
    &lt;ul&gt;
      &lt;li&gt;附着到容器： docker attach test_container&lt;/li&gt;
      &lt;li&gt;查看容器日志： docker logs -f daemon_dave //&lt;/li&gt;
      &lt;li&gt;查看容器内进程： docker top daemon_dave&lt;/li&gt;
      &lt;li&gt;在容器内运行进程： docker exec -d daemon_dave touch /etc/new_config_file 可以在现有的容器内 启动新进程，无论是后台任务还是交互式任务, docker exec -it &lt;container_id_or_name&gt; /bin/bash&lt;/container_id_or_name&gt;&lt;/li&gt;
      &lt;li&gt;自动重启容器： docker run –restart=always –name daemon_dave // docker可以通过设定  –restart 标志来检测 容器的退出代码 来决定是否重启容器&lt;/li&gt;
      &lt;li&gt;深入容器： docker inspect daemon_dave&lt;/li&gt;
      &lt;li&gt;查看运行中的容器： docker ps&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id="docker-镜像"&gt;Docker 镜像:&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;列出镜像：docker images&lt;/li&gt;
  &lt;li&gt;拉取镜像： docker pull ubuntu&lt;/li&gt;
  &lt;li&gt;查找镜像: docker search puppet&lt;/li&gt;
  &lt;li&gt;使用Dockerfile构建镜像：
    &lt;h6 id="使用dockerfile构建镜像-dockerfile-有一系列-指令和参数构成每条命令-都必须为大写字母-比如-run-from-后面跟随参数-dockerfile-从上到下执行每条指令都会创建一个新的镜像层并对镜像进行提交流程如下"&gt;使用Dockerfile构建镜像： Dockerfile 有一系列 指令和参数构成，每条命令 都必须为大写字母 比如 RUN FROM 后面跟随参数， Dockerfile 从上到下执行，每条指令都会创建一个新的镜像层并对镜像进行提交。流程如下：&lt;/h6&gt;
    &lt;p&gt;```shell&lt;br /&gt;
FROM ubuntu:14.04&lt;br /&gt;
RUN apt-get update&lt;br /&gt;
RUN apt-get install -y nginx&lt;br /&gt;
RUN echo ‘Hi, I am in your container’ &amp;gt; /usr/share/nginx/html/index.html&lt;br /&gt;
EXPOSE 80&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;docker build -t=”static_web” ./&lt;br /&gt;
docker run -d -p 80 –name static_web static_web nginx -g “daemon off;”&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;
####### 1. 流程:
  * Docker 从基础镜像运行一个容器
  * 执行一条指令，对容器做出修改
  * 执行类似docker commit 操作，提交一个新的镜像层
  * Docker在基于刚才提交的镜像层运行一个新容器
  * 执行Dockerfile 中的下一条命令，知道所有指令运行完毕
####### 2. 详细： 
  * 每个Dockerfile 的第一条指令 都是从FROM 开始的，该镜像 被称为基础镜像
  * expose 指令 指明 容器 使用的端口号，但 docker 在运行容器时候，并不会打开端口，需要使用指令来明确docker 打开特定的端口号
  * Dockerfile 的构建方式，导致如果 在因为一些命令失败，则可以得到一个 最近成功命令 的镜像，可以基于该命令 运行一个交换式的容器 来方便调试, 比如 docker run -t -i 最后commit  /bin/bash
####### 构建: docker build -t="xxxx" ./
  * docker 构建 过程会添加缓存： 可以如此 docker build --no-cache -t="xxxx" 来跳过缓存
  * docker 在修改命令之后的 的命令 重建缓存
  * 可以添加 ENV REFRESHED_AT 2020-10-09 在头部，当希望 重建镜像时候，可以更改 其时间来 进行  之后命令的重建
  * 查看镜像： docker images; 
  * 查看镜像的构造过程: docker history
  * 容器端口： -p 用来指定端口， 方式有： -p 80:80 -p 127.0.0.1:80:80, -p 127.0.0.1::80 -P 前两个指定端口绑定到 容器中的端口， 后面两个则 将随机端口绑定到 容器中的端口， -P 表示 将随机的本地端口 绑定到 Dockerfile中的expose 的端口

####### Dockerfile 指令: 
  * CMD: 指定容器启动时候的运行的命令， 区分于RUN 为镜像被构建时运行的命令，CMD 则是容器启动时候运行的命令。同docker run时候指定的命令， docker run中的命令会覆盖CMD命令，即 docker run中指定了命令，则CMD中的命令将不会被执行
  * ENTRYPOINT： 区分于 CMD，不会被 docker run中的命令 所替代，而是 替代 CMD 一起传递给 ENTRYPOINT，示例： 
    ```shell
    ENTRYPOINT ["/usr/sbin/nginx"]
    CMD ["-h"]

      docker  run -t -i static_web -g "daemon off;"
    ```
  * WORKDIR: 为后续的指令 执行  设定工作目录， 
  * ENV: 指定环境变量， 在后续的 RUN 中使用，也可以在其他命令中使用环境变量。 该变量 持久的保存到 从我们的镜像创建的任何容器中。 相反 在docker run -e 中传递的环境变量 则一次性有效
    ```shell
    ENV RVM_PATH /home/rvm
    RUN gem install unicorn
    // 等同于  RVM_PATH=/home/rvm gem install unicorn

    ENV TARGET_DIR /opt/app
    WORKDIR $TARGET_DIR
    ```
  * VOLUME: 向 从该镜像创建的容器 添加卷。卷是容器中的特殊目录 ，可以跨越文件系统，进行共享，提供持久化功能，有如下特性
    * 卷 可以再 容器间 共享和重用
    * 一个容器 可以不是必须 和 其他容器共享卷
    * 对卷的修改 立即生效
    * 对卷的修改不会影响镜像
    * 卷会一直存在知道没有任何 容器使用它。(标志着 卷 是由 docker管理的，而非容器，也非操作系统)
    * VOLUME ["/opt/project", "/data"] 可以使用数组形式 创建多个挂载点
  * ADD: 将 构建环境下 的文件或 目录  复制到 镜像中。ADD software /opt/application/software; ADD source target 
    * 其中source可以是 文件或者目录 或者url，不能对构建目录之外的文件进行ADD操作。(因为docker只关心 构建环建， 构建环境之外的任何东西 在命令中都是不可用的)
    * target 如果目录不存在的话，则 docker会创建 全路径，新建文件目录的权限 为0755
    * ADD命令会屎之后的命令不能够使用缓存。
    * ADD 会将 归档文件 进行 解压，例如 ADD latest.tar.gz /var/www/wordpress/
  * COPY： 区分于 ADD， copy只做纯粹的复制操作。不会进行解压缩操作.
  * 产出镜像： docker rmi static_web

##### 实践：
-v 允许我们将宿主机的目录作为卷，挂在到容器里。-v source:target 

* 构建 Redis 镜像
```shell
FROM ubuntu:14.04
ENV REFRESHED_AT 2020-10-09
RUN apt-get update
RUN apt-get -y install redis-server redis-tools
EXPOSE 6379
ENTRYPOINT ["/usr/bin/redis-server"]
CMD []
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;连接到 redis 容器: 容器之间 互连。 如果使用 映射到宿主机 的ip 来连接到 对应的容器，在 容器重启之后，因为其port会改变（当然可以使用 参数固定 其对应的宿主机 port） 会导致 之前的链接配置失效，从而无法使用 该种 方法 建立长久的固定的链接。&lt;/li&gt;
  &lt;li&gt;docker 提供了另一种方法: –link 使用 该标志 创建两个容器的父子链接。链接让 父容器有能力访问子容器， 并将子容器的一些详细信息分享给父容器，应用程序可以利用 这些信息 建立链接。示例：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;docker run  &lt;span class="nt"&gt;-d&lt;/span&gt; &lt;span class="nt"&gt;--name&lt;/span&gt; redis_con  redis

docker run &lt;span class="nt"&gt;-p&lt;/span&gt; 4567 &lt;span class="nt"&gt;--name&lt;/span&gt; webapp &lt;span class="nt"&gt;--link&lt;/span&gt; redis:db &lt;span class="nt"&gt;-t&lt;/span&gt; &lt;span class="nt"&gt;-i&lt;/span&gt; sinatra /bin/bash
// 该命令中 使用--link标志创建了  sinatra 到 redis_conn 的父子链接关系
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;链接的特点：
    &lt;ul&gt;
      &lt;li&gt;使子链接 无需公开端口，从而更安全一些。容器端口不需要在宿主机 上 公开，就可以限制被攻击的方面，减少应用暴露的网络&lt;/li&gt;
      &lt;li&gt;被连接的容器 必须运行在同一个 Docker宿主机上，不同的Docker宿主机 上的容器不能够互相链接&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;链接的实现方法： docker 在父容器里的两个地方写入了链接信息。
    &lt;ul&gt;
      &lt;li&gt;/etc/hosts 文件&lt;/li&gt;
      &lt;li&gt;包含链接信息的环境变量 ( 自动创建的环境变量包括： 子容器的名字， 子容器服务所运行的 协议 ip 端口 )&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;
docker run &lt;span class="nt"&gt;-d&lt;/span&gt; &lt;span class="nt"&gt;--name&lt;/span&gt; redis_con redis
docker run &lt;span class="nt"&gt;--link&lt;/span&gt; redis:db &lt;span class="nt"&gt;-i&lt;/span&gt; &lt;span class="nt"&gt;-t&lt;/span&gt; ubuntu /bin/bash

root@31c4f6ac36a4:/# &lt;span class="nb"&gt;cat&lt;/span&gt; /etc/hosts
127.0.0.1	localhost
::1	localhost ip6-localhost ip6-loopback
fe00::0	ip6-localnet
ff00::0	ip6-mcastprefix
ff02::1	ip6-allnodes
ff02::2	ip6-allrouters
172.17.0.3	db 949baab68dd4 redis_con
172.17.0.4	31c4f6ac36a4


root@31c4f6ac36a4:/# &lt;span class="nb"&gt;env

&lt;/span&gt;&lt;span class="nv"&gt;DB_PORT_6379_TCP_ADDR&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;172.17.0.3
&lt;span class="nv"&gt;DB_PORT_6379_TCP&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;tcp://172.17.0.3:6379
&lt;span class="nv"&gt;DB_PORT&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;tcp://172.17.0.3:6379
....
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;所以： 在应用程序中  通过使用 环境变量 来链接 子容器 是非常方便的方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;require &lt;span class="s1"&gt;'uri

uri = URI.parse(ENV['&lt;/span&gt;DB_PORT&lt;span class="s1"&gt;'])
redis = Redis.new(:host =&amp;gt; uri.host, :port =&amp;gt; uri.port)
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="实践-通过-jekyll-apache-来构建-自动构建一个博客网站"&gt;实践： 通过 Jekyll Apache 来构建 自动构建一个博客网站&lt;/h4&gt;

&lt;p&gt;jekyll 镜像&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;FROM ubuntu:14.04
ENV refreshed_at 2020-10-10

RUN apt-get update
RUN apt-get &lt;span class="nb"&gt;install&lt;/span&gt; &lt;span class="nt"&gt;-y&lt;/span&gt; ruby ruby-dev make nodejs
RUN gem &lt;span class="nb"&gt;install&lt;/span&gt; &lt;span class="nt"&gt;--no-rdoc&lt;/span&gt; &lt;span class="nt"&gt;--no-ri&lt;/span&gt; jekyll

VOLUME /data
VOLUME /var/www/html

WORKDIR /data

ENTRYPOINT &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;"jekyll"&lt;/span&gt;, &lt;span class="s2"&gt;"build"&lt;/span&gt;, &lt;span class="s2"&gt;"--destination=/var/www/html"&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;

docker build &lt;span class="nt"&gt;-t&lt;/span&gt; jekyll ./
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;apache 镜像&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;FROM ubuntu:14.04
ENV REFRESHED_AT 2020-10-10

RUN apt-get update
RUN apt-get &lt;span class="nb"&gt;install&lt;/span&gt; &lt;span class="nt"&gt;-y&lt;/span&gt; apache2

VOLUME &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;"/var/www/html"&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
WORKDIR /var/www/html

ENV APACHE_RUN_USER www-data
ENV APACHE_RUN_GROUP www-data
ENV APACHE_LOG_DIR /var/logapache2
ENV APACHE_PID_FILE /var/run/apache2.pid
ENV APACHE_RUN_DIR /var/run/apache2
ENV APACHE_LOCK_DIR /var/lock/apache2

RUN &lt;span class="nb"&gt;mkdir&lt;/span&gt; &lt;span class="nt"&gt;-p&lt;/span&gt; &lt;span class="nv"&gt;$apache_run_dir&lt;/span&gt; &lt;span class="nv"&gt;$apache_lock_dir&lt;/span&gt; &lt;span class="nv"&gt;$apache_log_dir&lt;/span&gt;
EXPOSE 80

ENTRYPOINT &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;"/usr/sbin/apache2"&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
CMD &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"-D"&lt;/span&gt;, &lt;span class="s2"&gt;"foreground"&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;

docker build &lt;span class="nt"&gt;-t&lt;/span&gt; apache ./
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;docker run -v /home/james/blog:/data/ –name jekyll_con jekyll&lt;/p&gt;

&lt;p&gt;docker run -d -P –volumns-from jekyll_con –name apache_conn apache&lt;/p&gt;

&lt;p&gt;// 这里使用了 标志 –volumes-from 标志 将指定容器 中的所有卷 添加到 新创建 的容器中。意味着容器 apache_conn 可以访问 容器 jekyll_conn 中的所有卷，即： 可以访问 jekyll_conn 产生的博客文件 目录 /var/www/html 中的内容。&lt;br /&gt;
// 卷 只有在没有容器 使用的时候才会被清理，也就是说 在 删除 docker rm jekyll_conn 之后 /var/www/html 中的内容就不复存在了 （这里面是否需要 同时删除 apache_conn 才可以？ 因为apache_conn 依然在使用，把持 该卷. 可以进行实验验证）&lt;/p&gt;

&lt;p&gt;备份卷：&lt;/p&gt;

&lt;p&gt;docker run –rm –volumnes-from jekyll_conn -v $(pwd):/backup ubuntu tar cvf /backup/blog.tar /var/www/html&lt;/p&gt;

&lt;p&gt;创建一个 docker 容器，将 共享的 /var/www/html 卷，进行打包 到 外部目录中。&lt;/p&gt;

&lt;h6 id="不使用-ssh-管理-docker-容器"&gt;不使用 ssh 管理 Docker 容器&lt;/h6&gt;

&lt;p&gt;传统上将，通过ssh 登入运行环境或者虚拟机 来管理服务，在Docker世界中， 大部分容器只运行一个进程，所以不能够使用该方法进行访问。可以通过如下方式进行访问： 使用卷 或者 链接 完成大部分管理操作。比如服务通过某个网络接口做管理， 或者使用 Unix套接字 做管理， 就可以通过 卷 来公开这个套接字，或者发信号 可以 docker kill -s &lt;signal&gt; &lt;container&gt;&lt;/container&gt;&lt;/signal&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;如果是登录 容器，则可以使用 nsenter 工具。使用方法如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;  &lt;span class="nv"&gt;PID&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="si"&gt;$(&lt;/span&gt;docker inspect &lt;span class="nt"&gt;--format&lt;/span&gt; &lt;span class="o"&gt;{{&lt;/span&gt;.State.Pid&lt;span class="o"&gt;}}&lt;/span&gt; 949baab68dd4&lt;span class="si"&gt;)&lt;/span&gt;
  nsenter &lt;span class="nt"&gt;--target&lt;/span&gt; 16870 &lt;span class="nt"&gt;--mount&lt;/span&gt; &lt;span class="nt"&gt;--uts&lt;/span&gt; &lt;span class="nt"&gt;--ipc&lt;/span&gt; &lt;span class="nt"&gt;--net&lt;/span&gt; &lt;span class="nt"&gt;--pid&lt;/span&gt;
  nsenter &lt;span class="nt"&gt;--target&lt;/span&gt; 16870 &lt;span class="nt"&gt;--mount&lt;/span&gt; &lt;span class="nt"&gt;--uts&lt;/span&gt; &lt;span class="nt"&gt;--ipc&lt;/span&gt; &lt;span class="nt"&gt;--net&lt;/span&gt; &lt;span class="nt"&gt;--pid&lt;/span&gt; &lt;span class="nb"&gt;ls&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h6 id="对-docker-容器的编排或者是非常重要的一步-k8s"&gt;对 Docker 容器的编排，或者是非常重要的一步. K8s&lt;/h6&gt;
</content>
  </entry>
  <entry>
    <title>finace report</title>
    <link rel="alternate" href="http://geniousbar.github.io/2020/03/19/finace-report/"/>
    <id>http://geniousbar.github.io/2020/03/19/finace-report/</id>
    <published>2020-03-19T00:00:00+00:00</published>
    <updated>2021-04-19T05:03:06+00:00</updated>
    <summary type="html">&lt;h2 id="入门"&gt;入门&lt;/h2&gt;
&lt;h4 id="三张表-资产负债表利润表现金流量表-每张表分别存在-合并报表-和母公司报表"&gt;三张表： 资产负债表、利润表、现金流量表， 每张表分别存在 合并报表 和母公司报表&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;上市公司本部的经营情况: 母公司资产负债表、母公司利润表、母公司现金流量表，加上母公司所有者权益变动表&lt;/li&gt;
  &lt;li&gt;合并报表: 并不是一个真实存在的法律实体. 它合并了上市公司本部经营及其控制的子公司、孙公司经营情况。合并时，会抵销这些母子公司、子孙公司之间的投资、交易和债权债务。&lt;/li&gt;
  &lt;li&gt;财报中其他用到“母公司”一词时，指的是上市公司的控股股东，因为财报是上市公司说的话。&lt;/li&gt;
  &lt;li&gt;由于子公司、孙公司是企业经营...&lt;/li&gt;
&lt;/ol&gt;</summary>
    <content type="html">&lt;h2 id="入门"&gt;入门&lt;/h2&gt;
&lt;h4 id="三张表-资产负债表利润表现金流量表-每张表分别存在-合并报表-和母公司报表"&gt;三张表： 资产负债表、利润表、现金流量表， 每张表分别存在 合并报表 和母公司报表&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;上市公司本部的经营情况: 母公司资产负债表、母公司利润表、母公司现金流量表，加上母公司所有者权益变动表&lt;/li&gt;
  &lt;li&gt;合并报表: 并不是一个真实存在的法律实体. 它合并了上市公司本部经营及其控制的子公司、孙公司经营情况。合并时，会抵销这些母子公司、子孙公司之间的投资、交易和债权债务。&lt;/li&gt;
  &lt;li&gt;财报中其他用到“母公司”一词时，指的是上市公司的控股股东，因为财报是上市公司说的话。&lt;/li&gt;
  &lt;li&gt;由于子公司、孙公司是企业经营的重要组成部分，所以投资者主要关心合并报表数据
    &lt;h4 id="资产负债表"&gt;资产负债表&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;资产负债表右边，分为负债和权益两大项. 右边：钱的去处，组成企业资产。资产按照变现便捷度排列。最容易变现的当然是货币，放在最前面。最不易变现的固定资产、无形资产、商誉等，放在最后面。&lt;/li&gt;
  &lt;li&gt;应收票据、应收账款、应付账款、预付款项、预收款项几个项目，可以看出公司与上下游之间的地位，展示公司竞争力的强弱&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id="利润表"&gt;利润表&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;利润表也叫“损益表”。资本市场喜欢看，也最容易造假。容易造假的根源是权责发生制。&lt;/li&gt;
  &lt;li&gt;依照权责发生制，没收到的钱，可能被算作收入；没付出的钱，可能被记录为成本；又或者收到的钱，不算作收入；已经付出去的钱，不被记录为成本。&lt;/li&gt;
  &lt;li&gt;营业利润:
    &lt;ul&gt;
      &lt;li&gt;不考虑投资收益和资产减值损失的话，收入减去各类支出&lt;/li&gt;
      &lt;li&gt;营业利润是一家公司的核心利润，是持续竞争力的体现，是利润表上需要重点关心的数字。&lt;/li&gt;
      &lt;li&gt;营业利润  + 主营业务以外的收支（营业外收支占比大的公司，一般要警惕，都是些不让人省心的货） = 利润总额&lt;/li&gt;
      &lt;li&gt;利润总额 - 缴清所得税后 = 净利润&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;少数股东损益:
    &lt;ul&gt;
      &lt;li&gt;并非每家子公司都是由上市公司100%持股的。那些在子公司里占点股份的股东，他们股份对应的资产，在资产负债表里叫作“少数股东权益”&lt;/li&gt;
      &lt;li&gt;利润表中叫少数股东损益&lt;/li&gt;
      &lt;li&gt;他们股份对应的利润或亏损，在利润表里就叫“&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;归属于母公司所有者的净利润: == 净利润 - 少数股东损益&lt;/li&gt;
  &lt;li&gt;每股收益: 归属于母公司所有者的净利润 / 公司总股本&lt;/li&gt;
  &lt;li&gt;PE(Price/ Earning) = 股票价格 / 每股收益. 投资回报率的倒数. 私募股权投资(Private Equity)
    &lt;h4 id="现金流量表"&gt;现金流量表&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;现金流量表记录公司的现金流入和流出。但其中经营活动现金流入流出不是通过完整记录公司现金流水做出的，而是以利润表为基础，参考资产负债表应收应付科目，调整后得出的。所以，表里最准确的数字是期初现金总额、期末现金总额及两者之差。&lt;/li&gt;
  &lt;li&gt;三大投资活动：
    &lt;ul&gt;
      &lt;li&gt;经营活动、投资活动、筹资活动&lt;/li&gt;
      &lt;li&gt;经营活动：是企业销售商品或提供劳务带来的现金收入及对应的现金支出， 经营活动现金流净额为负的企业，通常日子不好过（银行除外）。这个容易懂，就是日常说的入不敷出&lt;/li&gt;
      &lt;li&gt;投资活动，是企业对内对 外投资的支出 和 收到之前投资回报的情况。投资行为，
        &lt;ul&gt;
          &lt;li&gt;一要看投的项目 是否在企业能力范围内。通常，跨行业扩张，不妙的概率大。&lt;/li&gt;
          &lt;li&gt;二要看投资回报率： 投资回报率如果不是显著高于社会资金平均回报水平，管理层就是乱来的，反之，就是对股东有利的投资&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;筹资活动: 包含公司回购股票、向股东分配红利、借债或发行股票收到的现金以及相关成本。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;附注: 企业必须披露却又不太想让你明白的东西都在附注里. 对三张表有任何疑问，都需要在附注中找解释.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="财报阅读"&gt;财报阅读&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;会计师出具意见&lt;br /&gt;
+—–+—–+—–+&lt;br /&gt;
| 会计师出具意见 | 会计师真实意思  |   |&lt;br /&gt;
+—–+—–+—–+&lt;br /&gt;
| 标准无保留意见的审计报告 | 造价吉祥未被本人发现 |   |&lt;br /&gt;
+—–+—–+—–+&lt;br /&gt;
| 附带说明的无保留意见审计报告 | 黑锅有人背，本人大胆收钱  |   |&lt;br /&gt;
+—–+—–+—–+&lt;br /&gt;
| 保留意见审计报告 | 假报表，别看了 |   |&lt;br /&gt;
+—–+—–+—–+&lt;br /&gt;
| 无法出具意见审计报告 | 本恶人拒绝和拙劣的骗子合作 |   |&lt;br /&gt;
+—–+—–+—–+&lt;br /&gt;
| 否定意见审计报告稿 | 本人举报诈骗犯 |   |&lt;br /&gt;
+—–+—–+—–+&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;分红： 由于合并报表体现的并不是一个法律意义上的公司实体，而分红行为只能由法律意义上的公司对自己的股东实施。因此，盈余公积也是按照母公司利润表净利润数据的10%提取。所以，可以实施分红的金额上限，是母公司报表的未分配利润数。当然，由于母公司对整个合并报表范围内的子公司利润具有支配权，母公司是可以通过安排子公司分红来调度利润的。&lt;/li&gt;
  &lt;li&gt;责权记账法 对利润表产生的 影响：
&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;若其今年花了70元买原材料，同时产生30元生产制造费用，40元其他税费，然后被乙公司打了张200元的欠条把货拉走。甲公司会在报表上认认真真地记录60元税前利润，并按照25%的所得税率，上缴15元给税务局，而后向股东汇报今年获得净利润45元——其实到目前为止，一毛钱进账也没有，倒是贴出去不少现金。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
  &lt;li&gt;盈余公积金:
    &lt;ul&gt;
      &lt;li&gt;盈余公积金是法律不让公司分配的利润。中国的《公司法》规定，一个公司盈利后，必须留存至少10%作为盈余公积. 是政府强制公司进行扩大再生产的手段。&lt;/li&gt;
      &lt;li&gt;按法律规定，盈余公积累计超过注册资金的50%后，由董事会自行决定是否继续计提&lt;/li&gt;
      &lt;li&gt;用途： 只能用于 弥补经营亏损，或派送红股。其中分红派送：还要保证送股后，盈余公积仍然大于注册资本的25%。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;为何送红股要被扣税。老唐在这里解释一下，送红股，是被视为先拿现金出来分给股东，然后又按照股票面值价格，帮你认购了公司新发行的股票。因为首先是大秤分金银的过程，所以税务局要向股东征收所得税。&lt;/li&gt;
  &lt;li&gt;送红股这个过程，公司并没有真拿钱出来。股东的持股，也因为所有股东同比扩大而价值不变（一个饼分100份时占10份，和这个饼分110份时占11份，一样多），反而要损失税款。唯一得利的，只有税务局。只是因为资本市场喜欢这个数字游戏，也就有人乐&lt;/li&gt;
  &lt;li&gt;未分配利润或盈余公积送股，习惯叫作“派送红股×股”。用资本公积项目里的钱送股，习惯叫作“转增×股”。转增股看上去和红股一样，账户上都是收到额外的股票，但转增股不用缴税。&lt;/li&gt;
  &lt;li&gt;一般风险准备： 是专门要求金融企业提取的款项，用于弥补未来“莫须有（可能有）”的亏损。有 金融企业 子公司 需要拥有此项目&lt;/li&gt;
  &lt;li&gt;未分配利润: 从历年净利润总和中，去掉计提盈余公积和分红后的剩余
    &lt;ul&gt;
      &lt;li&gt;乍看过去，令人十分高兴，似乎公司有这么多钱等着分。其实不然。&lt;/li&gt;
      &lt;li&gt;这里面很多现金，已经变成土地厂房、固定资产、在建工程及其他投资&lt;/li&gt;
      &lt;li&gt;有些公司的净利润，是通过无现金流入的方式创造的，只有数字没有钱，永远也无法分配。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id="财报的结构"&gt;财报的结构&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;财务会计报告、董事会报告和重要事项。&lt;/li&gt;
  &lt;li&gt;薪酬情况： 用资产负债表的“应付员工薪酬”期末值减期初值，加上现金流量表的“支付给职工以及为职工支付的现金”数据，得出员工薪酬总额。薪酬总额除以员工总数，计算出当年平均薪酬。&lt;/li&gt;
  &lt;li&gt;支付给职工以及为职工支付的现金，不能直接理解为员工所得。因为这里面还包括为员工（除在建工程人员）缴纳的各种保险、福利、补偿等。据计算，若公司以税前工资1万元/月的标准聘请一位员工，公司仅法定必须向社保及公积金管理机构缴纳的与该员工有关的五险一金就合计达4410元，由此，公司实际聘用代价约为14410元。而员工在缴纳了规定由个人承担的三险一金及个税后，到手现金为7454元。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id="货币资金"&gt;货币资金：&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;“货币资金”只需关注合并报表数据.合并报表展示的，是公司本部及其下属子公司合计控制着多少货币资金。至于多少放在股份公司本部（母公司资产负债表里），多少放在子公司账户，那只是一个内部划拨行为罢了。&lt;/li&gt;
  &lt;li&gt;上市公司可以通过预收子公司款项或决定让子公司分配红利，轻松地将货币从子公司账户划拨至上市公司账户。之所以要划拨，通常是因为某些支出，必须以上市公司为主体，如向股东分红或者进行新的投资支出等。所以，老唐在这里要提醒新朋友，预收子公司款项，仅仅是公司内部资金划拨行为，母公司资产负债表中的“预收款项”科目没有观察价值。&lt;/li&gt;
  &lt;li&gt;现金流量表负责展示资产负债表货币资金科目里“现金及现金等价物”的变化过程。&lt;/li&gt;
  &lt;li&gt;存放于央行的准备金. 指的是金融机构（银行、财务公司等）存放于央行的钱，一般工商企业是没有的。准备金也分法定准备金和超额准备金。法定准备金，是吸收到存款后，必须按照央行规定比例存于央行的，不可以随时支取，不属于现金等价物；超额准备金，是金融机构自愿存于央行收利息的钱，可以随时支取，属于现金等价物。&lt;/li&gt;
  &lt;li&gt;母公司资产负债表“货币资金”数额，与合并报表“货币资金”数额的差额，是下属全资子公司或控股子公司账户里的货币资金&lt;/li&gt;
  &lt;li&gt;现金流量表负责展示 资产负债表货币资金科目里 “现金及现金等价物”的变化过程。  资产负债表中 并没有此类科目啊。 并没有现金及现金等价物的存在啊&lt;/li&gt;
  &lt;li&gt;现金及现金等价物 的定义是： 包括库存现金、银行存款、其他货币资金、存放中央银行可随时支取的备付金、存放同业款项、拆放同业款项、同业间买入返售证券，以及企业持有的期限短（一般指从购买日起三个月内到期）、流动性强、易于转换为已知金额现金、价值变动风险很小的投&lt;/li&gt;
&lt;/ol&gt;
</content>
  </entry>
  <entry>
    <title>week book</title>
    <link rel="alternate" href="http://geniousbar.github.io/2019/09/01/week-book/"/>
    <id>http://geniousbar.github.io/2019/09/01/week-book/</id>
    <published>2019-09-01T00:00:00+00:00</published>
    <updated>2020-10-13T11:35:54+00:00</updated>
    <summary type="html">&lt;h3 id="week-book"&gt;Week book&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;总结、回顾了 Rust语法， 因为rust的语法，实在有些奇怪，rust the book是非常好 指南，然而其 介绍的内容是非常 循序渐进的，缺少一个完整的、提纲挈领的  总结性视角。导致阅读周期很长的话，总是不能够通篇概览，所以有必要写一篇概览的文章。&lt;/li&gt;
  &lt;li&gt;在总结完成之后，对rust代码也不会存在一个 抵触、懵逼的状态。所以简单的完成了， rune buff的世界boss战斗代码&lt;/li&gt;
  &lt;li&gt;尝试解决一些jira，但是tournament丢分问题，一致没有找到非常的...&lt;/li&gt;
&lt;/ol&gt;</summary>
    <content type="html">&lt;h3 id="week-book"&gt;Week book&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;总结、回顾了 Rust语法， 因为rust的语法，实在有些奇怪，rust the book是非常好 指南，然而其 介绍的内容是非常 循序渐进的，缺少一个完整的、提纲挈领的  总结性视角。导致阅读周期很长的话，总是不能够通篇概览，所以有必要写一篇概览的文章。&lt;/li&gt;
  &lt;li&gt;在总结完成之后，对rust代码也不会存在一个 抵触、懵逼的状态。所以简单的完成了， rune buff的世界boss战斗代码&lt;/li&gt;
  &lt;li&gt;尝试解决一些jira，但是tournament丢分问题，一致没有找到非常的，完整的记录。大概的问题 出现在 我的认知范围 外 导致的（因为除了详尽的bi记录之外，依然没有查找到 问题所在）&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="见识"&gt;见识&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;看完了《美国工厂》， 纪录片并没有什么太引人入胜、情节跌宕起伏的样子。角度并不怎么好，但是纪录片所试图记录的主题是非常有争议性的话题，导致对他的评价很难非常少。&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>rust synatx</title>
    <link rel="alternate" href="http://geniousbar.github.io/2019/08/25/rust-synatx/"/>
    <id>http://geniousbar.github.io/2019/08/25/rust-synatx/</id>
    <published>2019-08-25T00:00:00+00:00</published>
    <updated>2020-10-13T11:35:54+00:00</updated>
    <summary type="html">&lt;h3 id="ownership-rules"&gt;Ownership Rules&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Each value in Rust has a variable that’s called its owner.&lt;/li&gt;
  &lt;li&gt;There can only be one owner at a time.&lt;/li&gt;
  &lt;li&gt;When the owner goes out of scope, the value will be dropped.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Scope : { //scope }&lt;br&gt;
  内存申请 let s = String::from(“xx”);&lt;br&gt;
  内存释放：...&lt;/p&gt;</summary>
    <content type="html">&lt;h3 id="ownership-rules"&gt;Ownership Rules&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Each value in Rust has a variable that’s called its owner.&lt;/li&gt;
  &lt;li&gt;There can only be one owner at a time.&lt;/li&gt;
  &lt;li&gt;When the owner goes out of scope, the value will be dropped.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Scope : { //scope }&lt;br /&gt;
  内存申请 let s = String::from(“xx”);&lt;br /&gt;
  内存释放： s 超出scop，变为不可用。rust自动添加drop调动代码， 归还内存&lt;br /&gt;
  所有权规则：&lt;/p&gt;

&lt;p&gt;堆、栈 中变量的其他 赋值方式：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;stack-only: copy
&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c"&gt;// x, y  都可用， 因为x 为栈上分配， 对于内存方式为 copy， 不影响所有权&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
  &lt;li&gt;Heap: clone、所有权转移
&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;  &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;s1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;String&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;from&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"hello"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;s2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;s1&lt;/span&gt;&lt;span class="nf"&gt;.clone&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="c"&gt;// s2 copy s1的内存，s1 依然可用&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;  &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;s1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;String&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;from&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"xx"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;s2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;s1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c"&gt;// s1 不在可用， s2为 字符串的 owner, 这里只是转移 指向 string的指针，而非 copy string&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="function-调用"&gt;Function 调用：&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Function 调用参数： 跟 赋值 一样的所有权  转移一样&lt;/li&gt;
  &lt;li&gt;Function 返回参数： 堆上的内存，作为返回值的时候， 两种情况： 1. 转移所有权 到 函数调用者 2. drop掉 （因为超过 函数中的作用域 scope）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="引用-function-调用-每次都需要转移所有权在将所有权转回到调用者非常麻烦-所以设计了-引用"&gt;引用： Function 调用： 每次都需要转移所有权，在将所有权转回到调用者。非常麻烦， 所以设计了 引用&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;指向变量的指针， 并不具有 ownership， 所以drop并不会，释放内存，使得引用的变量不可用。在Function 中使用 非常合适，因为不需要ownership传递回去， 因为根本没有ownership的转移&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可变 mut 引用: 可以 改变 引用指向的内容。&lt;/li&gt;
  &lt;li&gt;不可变引用&lt;/li&gt;
  &lt;li&gt;引用 规则:&lt;br /&gt;
    1. 任何时候，只有一个 可更改引用，或者 同时多个不可变应用&lt;br /&gt;
    2. 引用需要总是有效的。即： 引用的scope应该小于变量的scope&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;  &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;no_dangle&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nb"&gt;String&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;String&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;from&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"hello"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="c"&gt;// 函数返回， s 会drop掉， 所以会造成空指针 null reference&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;错误的函数，s在 函数中分配内存，但是只返回引用，&lt;strong&gt;引用变量作用于大于 指向的变量作用域&lt;/strong&gt;&lt;br /&gt;
  &lt;em&gt;slice: 同refrence， 引用一个连续的collection，但是没有ownership。 这里用来防止，在同样的作用域使用 mut refrence， 或者 mut 调用 (因为不能同时存在  mut 引用，和 非mut引用。所以自动的添加一份检查)&lt;/em&gt;&lt;/p&gt;

&lt;h3 id="generic-define--syntax"&gt;Generic define &amp;amp; syntax&lt;/h3&gt;
&lt;p&gt;定义 函数参数签名（告诉编译器 参数类型）, 形式如下:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;  &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="n"&gt;largest&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="c"&gt;// x, y 是同一类型， 也可以写成不一样的类型&lt;/span&gt;
  &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;U&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;U&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;impl&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;x&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="py"&gt;.x&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt; 
  &lt;span class="c"&gt;// 这里为什么显得如此怪异的原因， 在于 我们可以写出 impl Point&amp;lt;String&amp;gt; 来定定制 T=String 时候特有的方法定义。所以我们需要写成如此 impl&amp;lt;T&amp;gt; 来区分于 impl Point&amp;lt;String&amp;gt; , 声明 T 代表是一个place holder&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;并不会牺牲性能，没有runtime的耗时， 在编译阶段， rust 会填充 placeholder, 来完成， 不同类型的定义。&lt;/p&gt;

&lt;h3 id="trait-defining-shared-behavior"&gt;Trait: Defining Shared Behavior&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;impl 定义 及其 实现
&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt; &lt;span class="k"&gt;pub&lt;/span&gt; &lt;span class="k"&gt;trait&lt;/span&gt; &lt;span class="n"&gt;Summary&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
     &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;summarize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;String&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
     &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;speak&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
         &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="nf"&gt;.summarize&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
         &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"speak"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
     &lt;span class="p"&gt;}&lt;/span&gt;
 &lt;span class="p"&gt;}&lt;/span&gt;

 &lt;span class="k"&gt;pub&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;NewsArticle&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
 &lt;span class="p"&gt;}&lt;/span&gt;

 &lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;Summary&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;NewsArticle&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
     &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;summarize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;String&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
         &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"---------"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
     &lt;span class="p"&gt;}&lt;/span&gt;
 &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
  &lt;li&gt;Trait 类似于Interface， 共享 行为（函数） 定义，还可以 实现 类似 模板调用的方法。&lt;/li&gt;
  &lt;li&gt;Trait 当 Function 参数
&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;  &lt;span class="k"&gt;pub&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;notify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;Summary&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"---------"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="c"&gt;// Trait Bound syntax&lt;/span&gt;
  &lt;span class="k"&gt;pub&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="n"&gt;notify&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Summary&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"---------"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="c"&gt;// multiple Trait Bound&lt;/span&gt;
  &lt;span class="k"&gt;pub&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="n"&gt;notify&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Summary&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;Display&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"---------"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="c"&gt;// use where&lt;/span&gt;
  &lt;span class="k"&gt;pub&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="n"&gt;some_function&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;U&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;one&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;two&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;U&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Display&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;Clone&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;U&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Clone&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;Debug&lt;/span&gt;
  &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"---------"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
  &lt;li&gt;Trait 当做Function 的return type, 但是 存在一些限制： 主要有， 返回值不能是不同类型， 而只能是一个确定的类型 impl trait（例如{} 中 通过if else 返回一个完全不同类型，却实现了同样的Trait 的类型）&lt;/li&gt;
  &lt;li&gt;Trait with Generic 可以 约束 impl Generic 的 类型为实现了 Trait 的类型。
&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;  &lt;span class="k"&gt;impl&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Display&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;PartialOrd&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;only_some&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="c"&gt;// 只有实现了 Display &amp;amp; PartialOrd trait的 Point&amp;lt;_&amp;gt; 类型，才会有 only_some 方法&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
  &lt;li&gt;Advanced Traits: Traits with placeholder
&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt; &lt;span class="k"&gt;pub&lt;/span&gt; &lt;span class="k"&gt;trait&lt;/span&gt; &lt;span class="n"&gt;Iterator&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="n"&gt;Item&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;next&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;Option&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nn"&gt;Self&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Item&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="p"&gt;}&lt;/span&gt;
 &lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;Iterator&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;Counter&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
     &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="n"&gt;Item&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;u32&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

     &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;next&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;Option&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nn"&gt;Self&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Item&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
     &lt;span class="p"&gt;}&lt;/span&gt;
 &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;p&gt;为什么不适用这样的实现呢？&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;  &lt;span class="k"&gt;pub&lt;/span&gt; &lt;span class="k"&gt;trait&lt;/span&gt; &lt;span class="n"&gt;Iterator&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;next&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;Option&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;p&gt;原因在于 如果采用第二种实现， 我们需要 写成这样&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;  &lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;Iterator&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;Counter&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;Iterator&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;i32&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;Counter&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里面存在多种实现方式。 更重要的是，我们在调用next时候，需要显式的指定 .next::&amp;lt;Iterator&lt;String&gt;&amp;gt; 来 指导 rust使用哪个Iterator&lt;T&gt; for Counter 的代码实现。所以第一种更可取
但是确实存在 Generic 与 Trait 结合的例子：&lt;/T&gt;&lt;/String&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;
&lt;span class="k"&gt;trait&lt;/span&gt; &lt;span class="nb"&gt;Add&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;RHS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;Self&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;RHS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nn"&gt;Self&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c"&gt;// 常用的声明可以如下:&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;i32&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;i32&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="nb"&gt;Add&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="n"&gt;Output&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="py"&gt;.x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="py"&gt;.x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="py"&gt;.y&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="py"&gt;.y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c"&gt;// 然而我们依然可以这样，指定 RHS Generic参数， 来实现， Millimeters + Meters 的函数调用实现, 只不过，placeholder 并没有作为返回值，所有，可以直接+ 而不需要显示的，指定 + 之后的返回数值类型&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nf"&gt;Millimeters&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;u32&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nf"&gt;Meters&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;u32&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="nb"&gt;Add&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Meters&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;Millimeters&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="n"&gt;Output&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Millimeters&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Meters&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Millimeters&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nf"&gt;Millimeters&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="na"&gt;.0&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="na"&gt;.0&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;多个Trait 出现同样函数名字的情况：&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;
&lt;span class="k"&gt;trait&lt;/span&gt; &lt;span class="n"&gt;Pilot&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;fly&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;trait&lt;/span&gt; &lt;span class="n"&gt;Wizard&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;fly&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c"&gt;//两个 Trait 拥有同样的函数名称，不同的函数实现。那如何在调用时候，决策函数调用实体呢？&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Human&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;Pilot&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;Human&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;fly&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"This is your captain speaking."&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;Wizard&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;Human&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;fly&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Up!"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;Human&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;fly&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"*waving arms furiously*"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c"&gt;// 下面，person.fly 默认调用 Human 自己的实现， 如果需要 显式的调用 Pilot::fly 则需要， 如下格式&lt;/span&gt;
&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;person&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Human&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="nf"&gt;.fly&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="nn"&gt;Pilot&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;fly&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="nn"&gt;Wizard&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;fly&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="nf"&gt;.fly&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c"&gt;// 因为其为实例方法， 存在&amp;amp;self， 如果不存在呢？ 下面示例:&lt;/span&gt;

&lt;span class="k"&gt;trait&lt;/span&gt; &lt;span class="n"&gt;Animal&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;baby_name&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;String&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Dog&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;Dog&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;baby_name&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;String&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nn"&gt;String&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;from&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Spot"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;Animal&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;Dog&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;baby_name&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;String&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nn"&gt;String&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;from&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"puppy"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"A baby dog is called a {}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nn"&gt;Dog&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;baby_name&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;&lt;span class="c"&gt;// Ok&lt;/span&gt;
    &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"A baby dog is called a {}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nn"&gt;Animal&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;baby_name&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt; &lt;span class="c"&gt;// Error, 下面是正解&lt;/span&gt;
    &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"A baby dog is called a {}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Dog&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;Animal&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;baby_name&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SuperTriat： 超级 Trait， 依赖于一个Trait的实现， 示例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;
&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c"&gt;// 声明语法如下： trait SuperTrait: Trait {}&lt;/span&gt;
&lt;span class="k"&gt;trait&lt;/span&gt; &lt;span class="n"&gt;OutlinePrint&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nn"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Display&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;outline_print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;output&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="nf"&gt;.to_string&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"output is --- {}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c"&gt;// 我们只需要为point 实现 Display， 即可 拥有 outline_print 方法&lt;/span&gt;
&lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="nn"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Display&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="nn"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Formatter&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nn"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Result&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nd"&gt;write!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"({}, {})"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="py"&gt;.x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="py"&gt;.y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;OutlinePrint&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;NewType: 因为 impl Trait for Type, 中的type需要在本地的crate，而不是 引用库 中的Type。 所以 可以通过Newtype类来包装 Type，实现一些 Trait. &lt;br /&gt;
这里面包含另外一些需要东西： 如何让 NewType， 伪装成Type？&lt;br /&gt;
实现 Deref Trait。&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;  &lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nf"&gt;Wrapper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;Vec&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c"&gt;// 新的type 类似于下边的&lt;/span&gt;
  &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nf"&gt;Color&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;i32&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;i32&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;i32&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nf"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;i32&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;i32&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;i32&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="nn"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Display&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;Wrapper&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="nn"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Formatter&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nn"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Result&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
          &lt;span class="nd"&gt;write!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"[{}]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="na"&gt;.0&lt;/span&gt;&lt;span class="nf"&gt;.join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;", "&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;Wrapper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nd"&gt;vec!&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nn"&gt;String&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;from&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"hello"&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nn"&gt;String&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;from&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"world"&lt;/span&gt;&lt;span class="p"&gt;)]);&lt;/span&gt;
      &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"w = {}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="generic-生命周期-syntax-用于区分函数中-参数生命周期-对比-参数返回值-等-生命周期之间的关系-确保-参数传递生命周期符合-函数声明-生命周期-需要关联-参数与返回值才会有效果只有参数的生命周期没有用处"&gt;Generic 生命周期 syntax： 用于区分函数中 参数生命周期， 对比 参数、返回值 等 生命周期之间的关系。 确保 参数传递生命周期符合 函数声明. 生命周期 需要关联 参数与返回值，才会有效果，只有参数的生命周期没有用处&lt;/h3&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;  &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;longest&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="nf"&gt;.len&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="nf"&gt;.len&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;x&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="c"&gt;// error, rust并不能知道 函数返回值， 是x还是y， 无法检查生命周期&lt;/span&gt;

  &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="n"&gt;longest&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;'a&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nv"&gt;'a&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nv"&gt;'a&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nv"&gt;'a&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="nf"&gt;.len&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="nf"&gt;.len&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
          &lt;span class="n"&gt;x&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
          &lt;span class="n"&gt;y&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="c"&gt;// 要求 函数返回值，应该小于等于 参数， x y的生命周期, 所以下面的函数调用是可以pass的&lt;/span&gt;
  &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;string1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;String&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;from&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"long string is long"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

      &lt;span class="p"&gt;{&lt;/span&gt;
          &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;string2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;String&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;from&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"xyz"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
          &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;longest&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string1&lt;/span&gt;&lt;span class="nf"&gt;.as_str&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;string2&lt;/span&gt;&lt;span class="nf"&gt;.as_str&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
          &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"The longest string is {}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="c"&gt;// 而这个， 则是编译失败的，因为 返回值的生命周期 大于其中参数 y 的生命周期， 会导致 dangling refrence, 比如， result指向 y, 而y 在 内部的scope中已经销毁了&lt;/span&gt;
  &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;string1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;String&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;from&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"long string is long"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="p"&gt;{&lt;/span&gt;
          &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;string2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;String&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;from&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"xyz"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
          &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;longest&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string1&lt;/span&gt;&lt;span class="nf"&gt;.as_str&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;string2&lt;/span&gt;&lt;span class="nf"&gt;.as_str&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
      &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"The longest string is {}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="c"&gt;// 还可以这样， 总是 返回其中的一个值&lt;/span&gt;
  &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="n"&gt;longest&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;'a&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nv"&gt;'a&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nv"&gt;'a&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;x&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;Struct 的生命周期： struct 保持的refrence 的生命周期 与struct 生命周期关联。struct 不应该 长于 内部变量的refrence。
&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;  &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;ImportantExcerpt&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;'a&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="n"&gt;part&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nv"&gt;'a&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;novel&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;String&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;from&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Call me Ishmael. Some years ago..."&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;first_sentence&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;novel&lt;/span&gt;&lt;span class="nf"&gt;.split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;'.'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="nf"&gt;.next&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="nf"&gt;.expect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Could not find a '.'"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ImportantExcerpt&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;part&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;first_sentence&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="c"&gt;// 其中 i 的生命从周期不应该长于 novel&lt;/span&gt;
  &lt;span class="c"&gt;// impl Struct Generic 方法时候的 声明语法， 同 impl Generic。 其中声明方法时候，需要不要 生命周期 声明，需要看，是否与struct field 、 返回值 相关&lt;/span&gt;
 &lt;span class="k"&gt;impl&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;'a&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;ImportantExcerpt&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;'a&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
 &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;announce_and_return_part&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;announcement&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
     &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Attention please: {}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;announcement&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
     &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="py"&gt;.part&lt;/span&gt;
 &lt;span class="p"&gt;}&lt;/span&gt;
 &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;p&gt;Static lifetime， 静态生命周期，表明变量， 将贯穿于整个program, 将直接保存于， 代码的二进制中。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="closures"&gt;Closures:&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;/&lt;/td&gt;
          &lt;td&gt;x/&lt;/td&gt;
          &lt;td&gt;{}&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;FnOnce: 获取参数的ownership&lt;/li&gt;
  &lt;li&gt;FnMut： 获取参数的 mut 引用&lt;/li&gt;
  &lt;li&gt;Fn： 获取参数的 非mut引用&lt;/li&gt;
  &lt;li&gt;以上三种 为 Trait， 可以声明类型为 FN(i32) -&amp;gt; i32&lt;/li&gt;
  &lt;li&gt;function as paramas： Function Pointer(fn a Type diff with Fn) ， fn 类型，实现了， Fn, FnMut, FnOnce 的实现， 即 impl Fn, FnMut, FnOnce for fn {….} 所以，可以传递 fn 到 接受 closures的 函数中。 还可以声明接受fn类型的 函数&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;  &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;add_one&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;i32&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;i32&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;do_twice&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;i32&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;i32&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;i32&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;i32&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;answer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;do_twice&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add_one&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

      &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"The answer is: {}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;answer&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="c"&gt;// 可以 传递参数fn 类型&lt;/span&gt;
  &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;list_of_numbers&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nd"&gt;vec!&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
  &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;list_of_strings&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;Vec&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;list_of_numbers&lt;/span&gt;
      &lt;span class="nf"&gt;.iter&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
      &lt;span class="nf"&gt;.map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nn"&gt;ToString&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;to_string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="nf"&gt;.collect&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;macros:&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>linux-interface-zombie-process</title>
    <link rel="alternate" href="http://geniousbar.github.io/2019/06/25/linux-interface-zombie-process/"/>
    <id>http://geniousbar.github.io/2019/06/25/linux-interface-zombie-process/</id>
    <published>2019-06-25T00:00:00+00:00</published>
    <updated>2020-10-13T11:35:54+00:00</updated>
    <summary type="html">&lt;h3 id="僵尸进程"&gt;僵尸进程&lt;/h3&gt;

&lt;p&gt;在父进程执行wait之前， 其子进程就已经终止，这将会发生什么？此处的重点在于： 即使子进程已经结束，系统仍然需要允许父进程在其之后的某一时间去执行wait，来获取子进程的结束状态。&lt;/p&gt;

&lt;p&gt;所以内核将子进程转为僵尸进程来完成情况的处理，无法通过信号来杀死僵尸进程，这保证了父进程总是能够使用wait方法。这时候会释放子进程把持的发部分资源。以便供其他进程重新使用，其所保留的仅有内核进程表中的一条记录（其中包含了进程ID、终止状态、资源使用状况等信息）。&lt;/p&gt;

&lt;p&gt;两种情况：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;当父进程执...&lt;/li&gt;
&lt;/ol&gt;</summary>
    <content type="html">&lt;h3 id="僵尸进程"&gt;僵尸进程&lt;/h3&gt;

&lt;p&gt;在父进程执行wait之前， 其子进程就已经终止，这将会发生什么？此处的重点在于： 即使子进程已经结束，系统仍然需要允许父进程在其之后的某一时间去执行wait，来获取子进程的结束状态。&lt;/p&gt;

&lt;p&gt;所以内核将子进程转为僵尸进程来完成情况的处理，无法通过信号来杀死僵尸进程，这保证了父进程总是能够使用wait方法。这时候会释放子进程把持的发部分资源。以便供其他进程重新使用，其所保留的仅有内核进程表中的一条记录（其中包含了进程ID、终止状态、资源使用状况等信息）。&lt;/p&gt;

&lt;p&gt;两种情况：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;当父进程执行完wait后，不再需要子进程剩余的最后信息，内核会将删除僵尸进程，&lt;/li&gt;
  &lt;li&gt;父进程没有执行wait，退出之后，init进程将接管子进程，并自动调用wait，从而删除僵尸进程。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所以，一个长周期的父进程，应该总是执行wait方法，以防止僵尸进程的大量产生，导致无用的信息填满内核进程表。&lt;br /&gt;
杀死僵尸进程的唯一方法是：杀死其父进程，从而使init进程接管僵尸进程，并移除僵尸进程。&lt;/p&gt;

&lt;p&gt;具体避免长寿僵尸进程的几种方法：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;父进程调用wait方法来接受子进程。一种为阻塞式，一种为非阻塞，轮询方式&lt;/li&gt;
  &lt;li&gt;使用SIGCHLD信号处理程序： 可以对SIGCHLD信号安装处理程序，来对子进程的终止做出反应，在其中wait子进程，因为信号的中断处理方式，导致处理函数需要避免几个问题： 1）防止信号丢弃，导致少调用wait方法 2）需要提前安装信号处理器 3）信号传递特征导致的信号通病。&lt;/li&gt;
  &lt;li&gt;显式的忽略终止的子进程： 显式的将SIGCHLD 处置为SIG_IGN, 系统在子进程终止后立即删除，没有转换为僵尸进程的状态过程，也不需要wait调用。不过较老的UNIX实现并不能够正确处理这样的情况，导致不具有可移植性。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;class A&lt;br /&gt;
  @@name = “A”&lt;br /&gt;
  @name = “a”&lt;br /&gt;
  def self.a&lt;br /&gt;
    p @@name&lt;br /&gt;
    p @name&lt;br /&gt;
  end&lt;br /&gt;
  def a&lt;br /&gt;
    p @@name&lt;br /&gt;
    self.class.a&lt;br /&gt;
  end&lt;br /&gt;
end&lt;/p&gt;

&lt;p&gt;class B &amp;lt; A&lt;/p&gt;

&lt;p&gt;def self.b&lt;br /&gt;
    p @@name&lt;br /&gt;
    self.a&lt;br /&gt;
  end&lt;/p&gt;

&lt;p&gt;def b&lt;br /&gt;
    p @@name&lt;br /&gt;
    self.class.b&lt;br /&gt;
    p “-“ * 20&lt;br /&gt;
    self.class.b&lt;br /&gt;
  end&lt;/p&gt;

&lt;p&gt;end&lt;/p&gt;

&lt;p&gt;@name 类变量， 为 ruby 的类的实例变量， 不为继承体系所继承，&lt;br /&gt;
@@name 类变量， 为继承体系所继承&lt;/p&gt;
</content>
  </entry>
</feed>
