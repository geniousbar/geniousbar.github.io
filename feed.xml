<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>日常学习</title>
  <id>http://geniousbar.github.io</id>
  <link href="http://geniousbar.github.io"/>
  <link href="http://geniousbar.github.io/feed.xml" rel="self"/>
  <updated>2019-08-25T08:00:00+08:00</updated>
  <author>
    <name>geniousbar</name>
  </author>
  <entry>
    <title>rust synatx</title>
    <link rel="alternate" href="http://geniousbar.github.io/2019/08/25/rust-synatx/"/>
    <id>http://geniousbar.github.io/2019/08/25/rust-synatx/</id>
    <published>2019-08-25T08:00:00+08:00</published>
    <updated>2019-08-27T10:18:36+08:00</updated>
    <summary type="html">&lt;p&gt;Ownership Rules&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Each value in Rust has a variable that’s called its owner.&lt;/li&gt;
  &lt;li&gt;There can only be one owner at a time.&lt;/li&gt;
  &lt;li&gt;When the owner goes out of scope, the value will be dropped.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Scope : { //scope }&lt;br&gt;
  内存申请 let s = String::from(“xx”);&lt;br&gt;
  内存释放：...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;Ownership Rules&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Each value in Rust has a variable that’s called its owner.&lt;/li&gt;
  &lt;li&gt;There can only be one owner at a time.&lt;/li&gt;
  &lt;li&gt;When the owner goes out of scope, the value will be dropped.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Scope : { //scope }&lt;br /&gt;
  内存申请 let s = String::from(“xx”);&lt;br /&gt;
  内存释放： s 超出scop，变为不可用。rust自动添加drop调动代码， 归还内存&lt;br /&gt;
  所有权规则：&lt;/p&gt;

&lt;p&gt;堆、栈 中变量的其他 赋值方式：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;stack-only: copy
&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c"&gt;// x, y  都可用， 因为x 为栈上分配， 对于内存方式为 copy， 不影响所有权&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
  &lt;li&gt;Heap: clone、所有权转移
&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;  &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;s1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;String&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;from&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"hello"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;s2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;s1&lt;/span&gt;&lt;span class="nf"&gt;.clone&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="c"&gt;// s2 copy s1的内存，s1 依然可用&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;  &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;s1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;String&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;from&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"xx"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;s2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;s1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c"&gt;// s1 不在可用， s2为 字符串的 owner, 这里只是转移 指向 string的指针，而非 copy string&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
  &lt;li&gt;Function 调用参数： 跟 赋值 一样。&lt;/li&gt;
  &lt;li&gt;Function 返回参数： 堆上的内存，作为返回值的时候， 两种情况： 1. 转移到 函数调用者中 2. drop掉 （因为超过 函数中的作用域 scope）&lt;/li&gt;
  &lt;li&gt;Function 调用： 每次都需要转移所有权，在将所有权转回到调用者。非常麻烦， 所以设计了 引用 。&lt;/li&gt;
  &lt;li&gt;引用： 指向变量的指针， 并不具有 ownership， 所以drop并不会，释放内存，使得引用的变量不可用。在Function 中使用 非常合适，因为不需要ownership传递回去， 因为根本没有ownership&lt;br /&gt;
  可变 mut 引用： 可以 改变 引用指向的内容。&lt;br /&gt;
  引用 规则：
    &lt;ol&gt;
      &lt;li&gt;任何时候，只有一个 可更改引用，或者 一个 不可更改引用。 或者 同时多个不可变应用&lt;/li&gt;
      &lt;li&gt;引用需要总是有效的。即： 引用的scope应该小于变量的scope
&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;  &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;no_dangle&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nb"&gt;String&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;String&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;from&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"hello"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="c"&gt;// 函数返回， s 会drop掉， 所以会造成空指针 null reference&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;p&gt;错误的函数，s在 函数中分配内存，但是只返回引用，引用变量作用于大于 指向的变量作用域&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;slice: 同refrence， 引用一个连续的collection，但是没有ownership。 这里用来防止，在同样的作用域使用 mut refrence， 或者 mut 调用 (因为不能同时存在  mut 引用，和 非mut引用。添加一份检查)&lt;/p&gt;

&lt;p&gt;Generic define &amp;amp; syntax,&lt;br /&gt;
  定义 函数参数签名（告诉编译器 参数类型）, 形式如下:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;  &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="n"&gt;largest&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="c"&gt;// x, y 是同一类型， 也可以写成不一样的类型&lt;/span&gt;
  &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;U&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;U&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;impl&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;x&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="py"&gt;.x&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="c"&gt;// 这里为什么显得如此怪异的原因， 在于 我们可以写出 impl Point&amp;lt;String&amp;gt; 来定定制 T=String 时候特有的方法定义。所以我们需要写成如此 impl&amp;lt;T&amp;gt; 来区分于 impl Point&amp;lt;String&amp;gt; , 声明 T 代表是一个place holder&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;并不会牺牲性能，没有runtime的耗时， 在编译阶段， rust 会填充 placeholder, 来完成， 不同类型的定义。&lt;/p&gt;

&lt;p&gt;Trait: Defining Shared Behavior&lt;br /&gt;
  impl  实现&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;    &lt;span class="k"&gt;pub&lt;/span&gt; &lt;span class="k"&gt;trait&lt;/span&gt; &lt;span class="n"&gt;Summary&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;summarize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;String&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;speak&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="nf"&gt;.summarize&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"speak"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;pub&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;NewsArticle&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;Summary&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;NewsArticle&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;summarize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;String&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"---------"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;Trait 类似于Interface， 共享 行为（函数） 定义，还可以 实现 类似 模板调用的方法。&lt;/li&gt;
  &lt;li&gt;Trait 当 Function 参数z
&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;  &lt;span class="k"&gt;pub&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;notify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;Summary&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"---------"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="c"&gt;// Trait Bound syntax&lt;/span&gt;
  &lt;span class="k"&gt;pub&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="n"&gt;notify&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Summary&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"---------"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="c"&gt;// multiple Trait Bound&lt;/span&gt;
  &lt;span class="k"&gt;pub&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="n"&gt;notify&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Summary&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;Display&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"---------"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="c"&gt;// use where&lt;/span&gt;
  &lt;span class="k"&gt;pub&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="n"&gt;some_function&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;U&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;one&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;two&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;U&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;where&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Display&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;Clone&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;U&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Clone&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;Debug&lt;/span&gt;
  &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"---------"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
  &lt;li&gt;Trait 当做Function 的return type, 但是 存在一些限制： 主要有， 返回值不能是不同类型， 而只能是一个确定的类型 impl trait&lt;/li&gt;
  &lt;li&gt;Trait with Generic 可以 约束 impl Generic 的 类型为实现了 Trait 的类型。
&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;  &lt;span class="k"&gt;impl&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Display&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;PartialOrd&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;only_some&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="c"&gt;// 只有实现了 Display &amp;amp; PartialOrd trait的 Point&amp;lt;_&amp;gt; 类型，才会有 only_some 方法&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;p&gt;Advanced Traits: Traits with placeholder&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;  &lt;span class="k"&gt;pub&lt;/span&gt; &lt;span class="k"&gt;trait&lt;/span&gt; &lt;span class="n"&gt;Iterator&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="n"&gt;Item&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;next&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;Option&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nn"&gt;Self&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Item&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="p"&gt;}&lt;/span&gt;
 &lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;Iterator&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;Counter&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
 &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="n"&gt;Item&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;u32&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

 &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;next&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;Option&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nn"&gt;Self&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Item&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
 &lt;span class="p"&gt;}&lt;/span&gt;
 &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;p&gt;为什么不适用这样的实现呢？&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="k"&gt;pub&lt;/span&gt; &lt;span class="k"&gt;trait&lt;/span&gt; &lt;span class="n"&gt;Iterator&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;next&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;Option&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;p&gt;原因在于 如果采用第二种实现， 我们需要 写成这样&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;  &lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;Iterator&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;Counter&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;Iterator&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;i32&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;Counter&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

  &lt;span class="p"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里面存在多种实现方式。 更重要的是，我们在调用next时候，需要显式的指定 .next::&amp;lt;Iterator&lt;String&gt;&amp;gt; 来 指导 rust使用哪个Iterator&lt;T&gt; for Counter 的代码实现。所以第一种更可取
但是确实存在 Generic 与 Trait 结合的例子：&lt;/T&gt;&lt;/String&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;
&lt;span class="k"&gt;trait&lt;/span&gt; &lt;span class="nb"&gt;Add&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;RHS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;Self&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;RHS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nn"&gt;Self&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c"&gt;// 常用的声明可以如下: &lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;i32&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;i32&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="nb"&gt;Add&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="n"&gt;Output&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="py"&gt;.x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="py"&gt;.x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="py"&gt;.y&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="py"&gt;.y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c"&gt;// 然而我们依然可以这样，指定 RHS Generic参数， 来实现， Millimeters + Meters 的函数调用实现, 只不过，placeholder 并没有作为返回值，所有，可以直接+ 而不需要显示的，指定 + 之后的返回数值类型&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nf"&gt;Millimeters&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;u32&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nf"&gt;Meters&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;u32&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="nb"&gt;Add&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Meters&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;Millimeters&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="n"&gt;Output&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Millimeters&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Meters&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Millimeters&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nf"&gt;Millimeters&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="err"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="err"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;多个Trait 出现同样函数名字的情况：&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;
&lt;span class="k"&gt;trait&lt;/span&gt; &lt;span class="n"&gt;Pilot&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;fly&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;trait&lt;/span&gt; &lt;span class="n"&gt;Wizard&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;fly&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c"&gt;//两个 Trait 拥有同样的函数名称，不同的函数实现。那如何在调用时候，决策函数调用实体呢？&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Human&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;Pilot&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;Human&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;fly&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"This is your captain speaking."&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;Wizard&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;Human&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;fly&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Up!"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;Human&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;fly&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"*waving arms furiously*"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c"&gt;// 下面，person.fly 默认调用 Human 自己的实现， 如果需要 显式的调用 Pilot::fly 则需要， 如下格式&lt;/span&gt;
&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;person&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Human&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="nf"&gt;.fly&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="nn"&gt;Pilot&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;fly&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="nn"&gt;Wizard&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;fly&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="nf"&gt;.fly&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c"&gt;// 因为其为实例方法， 存在&amp;amp;self， 如果不存在呢？ 下面示例:&lt;/span&gt;

&lt;span class="k"&gt;trait&lt;/span&gt; &lt;span class="n"&gt;Animal&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;baby_name&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;String&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Dog&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;Dog&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;baby_name&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;String&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nn"&gt;String&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;from&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Spot"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;Animal&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;Dog&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;baby_name&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;String&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nn"&gt;String&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;from&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"puppy"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"A baby dog is called a {}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nn"&gt;Dog&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;baby_name&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;&lt;span class="c"&gt;// Ok&lt;/span&gt;
    &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"A baby dog is called a {}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nn"&gt;Animal&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;baby_name&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt; &lt;span class="c"&gt;// Error, 下面是正解&lt;/span&gt;
    &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"A baby dog is called a {}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Dog&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;Animal&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;baby_name&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;SuperTriat： 超级 Trait， 依赖于一个Trait的实现， 示例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;
&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c"&gt;// 声明语法如下： trait SuperTrait: Trait {}&lt;/span&gt;
&lt;span class="k"&gt;trait&lt;/span&gt; &lt;span class="n"&gt;OutlinePrint&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nn"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Display&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;outline_print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;output&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="nf"&gt;.to_string&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"output is --- {}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c"&gt;// 我们只需要为point 实现 Display， 即可 拥有 outline_print 方法&lt;/span&gt;
&lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="nn"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Display&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="nn"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Formatter&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nn"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Result&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nd"&gt;write!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"({}, {})"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="py"&gt;.x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="py"&gt;.y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;OutlinePrint&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;NewType: 因为 impl Trait for Type, 中的type需要在本地的crate，而不是 引用库 中的Type。 所以 可以通过Newtype类来包装 Type，实现一些 Trait. &lt;br /&gt;
这里面包含另外一些需要东西： 如何让 NewType， 伪装成Type？&lt;br /&gt;
实现 Deref Trait。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nf"&gt;Wrapper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;Vec&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c"&gt;// 新的type 类似于下边的&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nf"&gt;Color&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;i32&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;i32&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;i32&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nf"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;i32&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;i32&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;i32&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="nn"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Display&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;Wrapper&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="nn"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Formatter&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nn"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Result&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nd"&gt;write!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"[{}]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="nf"&gt;.join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;", "&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;Wrapper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nd"&gt;vec!&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nn"&gt;String&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;from&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"hello"&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nn"&gt;String&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;from&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"world"&lt;/span&gt;&lt;span class="p"&gt;)]);&lt;/span&gt;
    &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"w = {}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Generic 生命周期 syntax： 用于区分函数中 参数生命周期， 对比 参数、返回值 等 生命周期之间的关系。 确保 参数传递生命周期符合 函数声明. 生命周期 需要关联 参数与返回值，才会有效果，只有参数的生命周期没有用处&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;
  &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;longest&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="nf"&gt;.len&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="nf"&gt;.len&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;x&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="c"&gt;// error, rust并不能知道 函数返回值， 是x还是y， 无法检查生命周期&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="n"&gt;longest&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;'a&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nv"&gt;'a&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nv"&gt;'a&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nv"&gt;'a&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="nf"&gt;.len&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="nf"&gt;.len&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;x&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c"&gt;// 要求 函数返回值，应该小于等于 参数， x y的生命周期, 所以下面的函数调用是可以pass的&lt;/span&gt;
&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;string1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;String&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;from&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"long string is long"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;string2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;String&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;from&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"xyz"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;longest&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string1&lt;/span&gt;&lt;span class="nf"&gt;.as_str&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;string2&lt;/span&gt;&lt;span class="nf"&gt;.as_str&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
        &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"The longest string is {}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c"&gt;// 而这个， 则是编译失败的，因为 返回值的生命周期 大于其中参数 y 的生命周期， 会导致 dangling refrence, 比如， result指向 y, 而y 在 内部的scope中已经销毁了&lt;/span&gt;
&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;string1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;String&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;from&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"long string is long"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;string2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;String&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;from&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"xyz"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;longest&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string1&lt;/span&gt;&lt;span class="nf"&gt;.as_str&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;string2&lt;/span&gt;&lt;span class="nf"&gt;.as_str&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"The longest string is {}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c"&gt;// 还可以这样， 总是 返回其中的一个值&lt;/span&gt;
&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="n"&gt;longest&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;'a&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nv"&gt;'a&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nv"&gt;'a&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;Struct 的生命周期： struct 保持的refrence 的生命周期 与struct 生命周期关联。struct 不应该 长于 内部变量的refrence。
&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;  &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;ImportantExcerpt&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;'a&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="n"&gt;part&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nv"&gt;'a&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;novel&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;String&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;from&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Call me Ishmael. Some years ago..."&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;first_sentence&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;novel&lt;/span&gt;&lt;span class="nf"&gt;.split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;'.'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="nf"&gt;.next&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="nf"&gt;.expect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Could not find a '.'"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ImportantExcerpt&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;part&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;first_sentence&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="c"&gt;// 其中 i 的生命从周期不应该长于 novel&lt;/span&gt;
  &lt;span class="c"&gt;// impl Struct Generic 方法时候的 声明语法， 同 impl Generic。 其中声明方法时候，需要不要 生命周期 声明，需要看，是否与struct field 、 返回值 相关&lt;/span&gt;
 &lt;span class="k"&gt;impl&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;'a&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;ImportantExcerpt&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;'a&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
 &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;announce_and_return_part&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;announcement&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
     &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Attention please: {}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;announcement&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
     &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="py"&gt;.part&lt;/span&gt;
 &lt;span class="p"&gt;}&lt;/span&gt;
 &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;p&gt;Static lifetime， 静态生命周期，表明变量， 将贯穿于整个program, 将直接保存于， 代码的二进制中。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Closures:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;x&lt;/td&gt;
          &lt;td&gt;{}&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;FnOnce: 获取参数的ownership&lt;/li&gt;
  &lt;li&gt;FnMut： 获取参数的 mut 引用&lt;/li&gt;
  &lt;li&gt;Fn： 获取参数的 非mut引用&lt;/li&gt;
  &lt;li&gt;以上三种 为 Trait， 可以声明类型为 FN(i32) -&amp;gt; i32&lt;/li&gt;
  &lt;li&gt;function as paramas： Function Pointer(fn a Type diff with Fn) ， fn 类型，实现了， Fn, FnMut, FnOnce 的实现， 即 impl Fn, FnMut, FnOnce for fn {….} 所以，可以传递 fn 到 接受 closures的 函数中。 还可以声明接受fn类型的 函数&lt;br /&gt;
 ```rust&lt;br /&gt;
fn add_one(x: i32) -&amp;gt; i32 {&lt;br /&gt;
x + 1&lt;br /&gt;
}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;fn do_twice(f: fn(i32) -&amp;gt; i32, arg: i32) -&amp;gt; i32 {&lt;br /&gt;
    f(arg) + f(arg)&lt;br /&gt;
}&lt;/p&gt;

&lt;p&gt;fn main() {&lt;br /&gt;
    let answer = do_twice(add_one, 5);&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;println!("The answer is: {}", answer); }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;// 可以 传递参数fn 类型&lt;br /&gt;
let list_of_numbers = vec![1, 2, 3];&lt;br /&gt;
let list_of_strings: Vec&lt;String&gt; = list_of_numbers
    .iter()
    .map(ToString::to_string)
    .collect();
 ```&lt;/String&gt;&lt;/p&gt;

&lt;p&gt;macros:&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>linux-interface-zombie-process</title>
    <link rel="alternate" href="http://geniousbar.github.io/2019/06/25/linux-interface-zombie-process/"/>
    <id>http://geniousbar.github.io/2019/06/25/linux-interface-zombie-process/</id>
    <published>2019-06-25T08:00:00+08:00</published>
    <updated>2019-08-05T12:20:07+08:00</updated>
    <summary type="html">&lt;h3 id="僵尸进程"&gt;僵尸进程&lt;/h3&gt;

&lt;p&gt;在父进程执行wait之前， 其子进程就已经终止，这将会发生什么？此处的重点在于： 即使子进程已经结束，系统仍然需要允许父进程在其之后的某一时间去执行wait，来获取子进程的结束状态。&lt;/p&gt;

&lt;p&gt;所以内核将子进程转为僵尸进程来完成情况的处理，无法通过信号来杀死僵尸进程，这保证了父进程总是能够使用wait方法。这时候会释放子进程把持的发部分资源。以便供其他进程重新使用，其所保留的仅有内核进程表中的一条记录（其中包含了进程ID、终止状态、资源使用状况等信息）。&lt;/p&gt;

&lt;p&gt;两种情况：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;当父进程执...&lt;/li&gt;
&lt;/ol&gt;</summary>
    <content type="html">&lt;h3 id="僵尸进程"&gt;僵尸进程&lt;/h3&gt;

&lt;p&gt;在父进程执行wait之前， 其子进程就已经终止，这将会发生什么？此处的重点在于： 即使子进程已经结束，系统仍然需要允许父进程在其之后的某一时间去执行wait，来获取子进程的结束状态。&lt;/p&gt;

&lt;p&gt;所以内核将子进程转为僵尸进程来完成情况的处理，无法通过信号来杀死僵尸进程，这保证了父进程总是能够使用wait方法。这时候会释放子进程把持的发部分资源。以便供其他进程重新使用，其所保留的仅有内核进程表中的一条记录（其中包含了进程ID、终止状态、资源使用状况等信息）。&lt;/p&gt;

&lt;p&gt;两种情况：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;当父进程执行完wait后，不再需要子进程剩余的最后信息，内核会将删除僵尸进程，&lt;/li&gt;
  &lt;li&gt;父进程没有执行wait，退出之后，init进程将接管子进程，并自动调用wait，从而删除僵尸进程。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所以，一个长周期的父进程，应该总是执行wait方法，以防止僵尸进程的大量产生，导致无用的信息填满内核进程表。&lt;br /&gt;
杀死僵尸进程的唯一方法是：杀死其父进程，从而使init进程接管僵尸进程，并移除僵尸进程。&lt;/p&gt;

&lt;p&gt;具体避免长寿僵尸进程的几种方法：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;父进程调用wait方法来接受子进程。一种为阻塞式，一种为非阻塞，轮询方式&lt;/li&gt;
  &lt;li&gt;使用SIGCHLD信号处理程序： 可以对SIGCHLD信号安装处理程序，来对子进程的终止做出反应，在其中wait子进程，因为信号的中断处理方式，导致处理函数需要避免几个问题： 1）防止信号丢弃，导致少调用wait方法 2）需要提前安装信号处理器 3）信号传递特征导致的信号通病。&lt;/li&gt;
  &lt;li&gt;显式的忽略终止的子进程： 显式的将SIGCHLD 处置为SIG_IGN, 系统在子进程终止后立即删除，没有转换为僵尸进程的状态过程，也不需要wait调用。不过较老的UNIX实现并不能够正确处理这样的情况，导致不具有可移植性。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;class A&lt;br /&gt;
  @@name = “A”&lt;br /&gt;
  @name = “a”&lt;br /&gt;
  def self.a&lt;br /&gt;
    p @@name&lt;br /&gt;
    p @name&lt;br /&gt;
  end&lt;br /&gt;
  def a&lt;br /&gt;
    p @@name&lt;br /&gt;
    self.class.a&lt;br /&gt;
  end&lt;br /&gt;
end&lt;/p&gt;

&lt;p&gt;class B &amp;lt; A&lt;/p&gt;

&lt;p&gt;def self.b&lt;br /&gt;
    p @@name&lt;br /&gt;
    self.a&lt;br /&gt;
  end&lt;/p&gt;

&lt;p&gt;def b&lt;br /&gt;
    p @@name&lt;br /&gt;
    self.class.b&lt;br /&gt;
    p “-“ * 20&lt;br /&gt;
    self.class.b&lt;br /&gt;
  end&lt;/p&gt;

&lt;p&gt;end&lt;/p&gt;

&lt;p&gt;@name 类变量， 为 ruby 的类的实例变量， 不为继承体系所继承，&lt;br /&gt;
@@name 类变量， 为继承体系所继承&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>linux-interface-14</title>
    <link rel="alternate" href="http://geniousbar.github.io/2019/06/14/linux-interface-14/"/>
    <id>http://geniousbar.github.io/2019/06/14/linux-interface-14/</id>
    <published>2019-06-14T08:00:00+08:00</published>
    <updated>2019-06-25T15:16:10+08:00</updated>
    <summary type="html">&lt;h2 id="文件系统"&gt;文件系统&lt;/h2&gt;

&lt;h3 id="文件系统是对文件和目录的组织集合"&gt;文件系统是对文件和目录的组织集合&lt;/h3&gt;

&lt;h2 id="设备"&gt;设备&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;划分
    &lt;ul&gt;
      &lt;li&gt;实际设备（键盘、鼠标、磁盘）和虚拟设备（不存在与之对应的硬件，内核为其提供的一种抽象。比如ssh登录？）&lt;/li&gt;
      &lt;li&gt;字符类型，块设备。字符类型有键盘、终端等。典型的块类型设备是磁盘&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;设备专用文件: 与系统的某个设备相对应，每个设备类型都有与之相对应的设备驱动程序。用来处理设备的所有IO请求。设备驱动程序属于内核代码，由设备驱动程序提供的API是固定的，主要包含（open, close...&lt;/li&gt;
&lt;/ul&gt;</summary>
    <content type="html">&lt;h2 id="文件系统"&gt;文件系统&lt;/h2&gt;

&lt;h3 id="文件系统是对文件和目录的组织集合"&gt;文件系统是对文件和目录的组织集合&lt;/h3&gt;

&lt;h2 id="设备"&gt;设备&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;划分
    &lt;ul&gt;
      &lt;li&gt;实际设备（键盘、鼠标、磁盘）和虚拟设备（不存在与之对应的硬件，内核为其提供的一种抽象。比如ssh登录？）&lt;/li&gt;
      &lt;li&gt;字符类型，块设备。字符类型有键盘、终端等。典型的块类型设备是磁盘&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;设备专用文件: 与系统的某个设备相对应，每个设备类型都有与之相对应的设备驱动程序。用来处理设备的所有IO请求。设备驱动程序属于内核代码，由设备驱动程序提供的API是固定的，主要包含（open, close, read, write, mmap, ioctl）,由于这些统一一致的API，隐藏了每个设备在操作方面的差异。&lt;/li&gt;
  &lt;li&gt;如何确定驱动程序:
    &lt;ol&gt;
      &lt;li&gt;设备文件的I节点中记录了设备的主、辅ID。&lt;/li&gt;
      &lt;li&gt;主、辅ID:  主ID标识一般的设备等级，内核用来寻找设备驱动程序，辅号在主ID中的标识唯一的特定设备。ls -l 会展现出设备文件的主、辅ID。（不知道是不是需要对于设备类型文件才行）&lt;/li&gt;
      &lt;li&gt;设备驱动程序会向内核注册 自己与特定 主ID的关联关系。内核基于此建立 设备到设备驱动程序的关联关系。（内核是不会通过设备文件名来查找驱动程序的，猜想也是如此， 不可能根绝简单的字符串来匹配驱动程序）&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="磁盘"&gt;磁盘&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;磁盘分区: 可以将磁盘分成一个或者多个分区，内核将每个分区视为/dev路径下的单独设备。可以使用fdisk 来决定磁盘分区的编号、大小和类型。fdisk -l 列出磁盘的所有分区， linux 文件/proc/partitions 记录了分区的主辅设备编号、大小和名称。&lt;/li&gt;
  &lt;li&gt;磁盘分区可以容纳任何类型的信息，但通常包含以下:
    &lt;ul&gt;
      &lt;li&gt;文件系统&lt;/li&gt;
      &lt;li&gt;数据区域，作为裸设备对其进行访问&lt;/li&gt;
      &lt;li&gt;交换区域: 供内核的内存管理用。可以通过mkswap命令创建交换区域，系统调用swapon, swapoff, 启用、关闭磁盘作为内存交换区。linux文件 /proc/swaps 用来查看当前激活的交换区信息。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="文件系统-1"&gt;文件系统&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;linux支持的文件系统有:
    &lt;ul&gt;
      &lt;li&gt;传统的ext2&lt;/li&gt;
      &lt;li&gt;各种原生的UNIX文件系统，比如Minix， System V以及BSD文件系统&lt;/li&gt;
      &lt;li&gt;微软的FAT，FAT32已经NTFS文件系统&lt;/li&gt;
      &lt;li&gt;ISO9660 CD-ROM文件系统&lt;/li&gt;
      &lt;li&gt;Apple Macintosh 的 HFS&lt;/li&gt;
      &lt;li&gt;一系列日志文件系统: 还包括etx3, ext4， JFS，XFS等&lt;/li&gt;
      &lt;li&gt;linux 2.6.14中添加了 FUSE（用户空间文件系统）工具，采用这一机制，可谓内核添加挂钩，以便以用户空间程序 来是实现完整的文件系统，而无需对内核进行修补和重新编译&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="以下为ext2文件系统-为例"&gt;以下为ext2文件系统 为例&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;文件系统的组成部分:
    &lt;ul&gt;
      &lt;li&gt;引导块: 文件系统的首块，不能为文件系统所用，用来引导操作系统的信息。操作系统只需要一个引导块，但是所有的文件系统都设有引导块。&lt;/li&gt;
      &lt;li&gt;超级块: 紧随引导块之后的一个独立块。其包含文件系统有关的详细参数: 1）i节点表容量。 2）文件系统中的逻辑块大小， 3）以逻辑块计，文件系统的大小。驻留于同一块磁盘上的不同文件系统，其类型、大小以及参数设定都有所不同（比如逻辑块）这也是将一块磁盘划分多个分区的原因之一。&lt;/li&gt;
      &lt;li&gt;i节点表:与文件系统中的每个文件、目录 一一对应。记录了文件的相关信息&lt;/li&gt;
      &lt;li&gt;数据块: 用于存放数据，占据文件系统空间中的大部分空间&lt;br /&gt;
&lt;img src="../../../../images/file_system_partition-810c09f5.png" alt="file_system" /&gt;  &lt;br /&gt;
&lt;img src="../../../../images/file_system_i_node_list-ebd188e1.png" alt="i_node_list" /&gt;
        &lt;h3 id="i节点"&gt;i节点&lt;/h3&gt;
        &lt;p&gt;&lt;strong&gt;对于文件系统中的每个文件（所有东西，包括:目录、链接、etc） 都有一个i节点与之对应。对i节点的标识为顺序数字，ls -li命令第一列为i节点号&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;其维护的信息主要有
    &lt;ul&gt;
      &lt;li&gt;文件类型（常规文件、目录、符号链接、设备等）&lt;/li&gt;
      &lt;li&gt;文件属主（UID）&lt;/li&gt;
      &lt;li&gt;文件属主（GID）&lt;/li&gt;
      &lt;li&gt;3个权限&lt;/li&gt;
      &lt;li&gt;3个时间戳&lt;/li&gt;
      &lt;li&gt;指向文件的硬链接数（hard link）&lt;/li&gt;
      &lt;li&gt;文件的大小（字节为单位）&lt;/li&gt;
      &lt;li&gt;实际分配给时间的块数量 （不同于上面的文件大小，因为文件空洞的存在）&lt;/li&gt;
      &lt;li&gt;指向文件数据块的指针(i-node-entry)&lt;br /&gt;
&lt;img src="../../../../images/file_system_i_node_data_block_pointers-67ea4037.png" alt="i_node_list" /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="虚拟文件系统vfs"&gt;虚拟文件系统(VFS)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;是一种内核特征，通过为文件系统操作创建抽象层来解决、屏蔽，各种不同文件系统的不同的实现细节&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;VSF对文件系统定义了一套通用接口，所有与文件相关的程序都会使用这一接口&lt;/li&gt;
  &lt;li&gt;每种文件系统都会提供VFS接口的实现&lt;/li&gt;
  &lt;li&gt;接口的操作与涉及文件系统和目录的所有常规系统调用相对应，有: open, read, write, lseek, close, truncate, stat, mount, umount, mmap, mkdir, link, unlink, symlink, rename&lt;/li&gt;
  &lt;li&gt;并不是所有的文件系统都支持所有的VFS操作，对于这种情况， 底层文件系统调用将错误代码传回VFS层面，并传递到应用层面&lt;br /&gt;
  &lt;img src="../../../../images/file_system_vfs-f6afa08a.png" alt="i_node_list" /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="挂载-mount"&gt;挂载 mount&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;mount 命令:
    &lt;ul&gt;
      &lt;li&gt;mount device directory, 将device的文件系统挂在到directory所指定的目录下。可以使用umount卸载，并在其他地方重新挂载。（linux 2.4.19） 之后内核支持针对每个进程的挂载空间，每个进程都能够拥有自己的挂载空间。&lt;/li&gt;
      &lt;li&gt;mount 不带参数， 可以列出当前已挂载的文件系统&lt;/li&gt;
      &lt;li&gt;linux /proc/mounts 可以查看当前已经挂载的文件系统列表。因为是内核数据结构的接口，所以是比较精确的。在引入经程级别的挂载空间后， /proc/PID/mouns 为进程的挂载信息，而 /proc/mounts 链接到 /proc/self/mounts&lt;/li&gt;
      &lt;li&gt;/etc/mtab 包含同样的信息，只是会更加详细些，其中会包含了传递mount命令的参数， mount,umount 命令会自动维护 该文件，然而 系统调用 mount, umount 并不会维护该文件，导致可能会不够准确&lt;/li&gt;
      &lt;li&gt;/proc/mounts, /etc/mtab 文件的格式如下:
&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;/dev/sda1 / ext2 rw 0 0
从左到右的意思是: 挂载设备名，挂载点，文件系统类型， 挂载标志， （后面的详细参看手册）
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;相关系统调用:&lt;br /&gt;
&lt;strong&gt;mount系统调用中的mountflags具有重要作用，其决定着对整个设备文件系统类型的处理。例如， MS_RDONLY, 以只读方式挂载，在此文件系统上只能读，而不能创建和修改。&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;在多个挂载点挂载文件系统: 在挂载点一做出的改变，在挂载点二下立即可见。因为存在进程级别的挂载空间，所以操作并不影响之前的进程，只影响之后的进程挂载点。&lt;/li&gt;
      &lt;li&gt;umount, umount2 系统调用卸载已挂载的文件系统。无法卸载正在使用中的文件系统， 这一文件系统中有文件被打开，或者进程的当前工作目录在此文件系统下，是无法被卸载的，返回EBUSY错误。&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;umount2(const char * target, int flags): 其中flags有如下几个选项， MNT_DETACH(lazy卸载， 不在允许新的进程访问挂载点， 等使用中进程不在使用挂载点时候，卸载文件系统), MNT_EXPIRE（首次调用并且处于空闲状态，将被标记 为到期，非空闲失败，二次调用，仍处于到期状态，则卸载文件系统。可用于卸载在某段时间内未用的文件系统）, MNT_FORCE（强行卸载文件系统，可能会造成数据丢失）&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;绑定挂载: 可以在文件系统目录层级 挂载目录或者文件。将导致文件或者目录在两处都可见。不同于多个挂载点挂载、有些类似于硬链接，区别在于: 1） 绑定挂载可以跨越多个文件系统挂载点 2）可针对目录执行绑定挂载。绑定挂载需要指定特殊标志才能够递归的挂载 子挂载&lt;br /&gt;
&lt;code&gt;shell
mkdir d1
mkdir d2
mount --bind d1 d2
&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="虚拟内存文件系统tmpfs"&gt;虚拟内存文件系统（tmpfs）:&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;linux支持驻留于内存的虚拟文件系统。tmpfs最为复杂。不仅使用RAM还能够利用交换空间。/proc/mount 即是此类文件系统的实现，可以创建tmpfs文件系统并挂载至/tmp来改善编译器类似的频繁使用/tmp目录的应用程序的性能。&lt;/strong&gt;&lt;br /&gt;
内核还将此类文件系统用于:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;实现System V共享内存和共享匿名内存映射&lt;/li&gt;
  &lt;li&gt;挂载于/dev/shm的tmpfs文件系统，为glibc用以实现POSIX共享内存和信号量&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="文件属性"&gt;文件属性&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;int stat(const char * pathname, stuct stat * statbuf): 系统调用: 获取与文件有关的信息， 大部分都来自于i节点, struct stat结构如下:
&lt;div class="highlight"&gt;&lt;pre class="highlight c"&gt;&lt;code&gt;&lt;span class="n"&gt;stuct&lt;/span&gt; &lt;span class="n"&gt;stat&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="n"&gt;dev_t&lt;/span&gt; &lt;span class="n"&gt;st_dev&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
&lt;span class="n"&gt;dev_t&lt;/span&gt; &lt;span class="n"&gt;st_rdev&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
&lt;span class="n"&gt;ino_t&lt;/span&gt; &lt;span class="n"&gt;st_ino&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;mode_t&lt;/span&gt; &lt;span class="n"&gt;std_mode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;n_link_t&lt;/span&gt; &lt;span class="n"&gt;st_nlink&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;uid_t&lt;/span&gt; &lt;span class="n"&gt;st_uid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;g_id_t&lt;/span&gt; &lt;span class="n"&gt;st_gid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;time_t&lt;/span&gt; &lt;span class="n"&gt;st_atime&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;time_t&lt;/span&gt; &lt;span class="n"&gt;st_mtime&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;time_t&lt;/span&gt; &lt;span class="n"&gt;st_ctime&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;p&gt;部分详细解释：&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;st_devo 字段标识文件所驻留的设备。st_ino 为文件的i节点，两者标识文件系统中的唯一文件。设备文件的i节点，st_rdev 字段包含了主、辅ID， 否则st_dev 包含信息&lt;/li&gt;
      &lt;li&gt;st_uid, st_gid 标识文件属主。 st_nlink 包含了指向文件的硬链接数目。 st_mode 标识了文件类型、已经权限。&lt;/li&gt;
      &lt;li&gt;st_atime, st_mtime, st_ctime, 为文件时间戳， 分别标识: 文件上次访问时间、修改时间、以及文件状态修改时间。&lt;/li&gt;
      &lt;li&gt;系统调用: utime, utimes, utimensat 都可以修改文件的时间戳。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;新建文件的属性: 新建文件时的属主取决于进程的有效用户ID。新建文件的组ID是多变的，下面为ext2下面新建文件组ID所遵循的规则:&lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;文件系统mount选项&lt;/th&gt;
      &lt;th&gt;父目录设定set-group-id 标记&lt;/th&gt;
      &lt;th&gt;新建文件的组ID取值&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-o grpid, -o bsdgroups&lt;/td&gt;
      &lt;td&gt;忽略&lt;/td&gt;
      &lt;td&gt;父目录组ID&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-o nogrpid, -0 sysvgroups&lt;/td&gt;
      &lt;td&gt;无&lt;/td&gt;
      &lt;td&gt;进程的组id&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-o nogrpid, -0 sysvgroups&lt;/td&gt;
      &lt;td&gt;有&lt;/td&gt;
      &lt;td&gt;父目录组id&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;chown 系统调用， 可以更改文件属主， 权限为: 1）特权级别进程（root） 2）进程的有效用户ID与文件的用户ID匹配。当文件的属主或者属组发生了改变时，set-user-id, set-group-id 权限位会关闭。改变的是目录的时候， 其set-group-id并不会发生改变。目录的set-group-id 并不是为了创建 set-group-id程序，而是为了控制在该目录下创建文件的所有权。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;目录下的权限&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;权限:&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
      &lt;li&gt;读权限: 可以ls 目录下的内容。&lt;/li&gt;
      &lt;li&gt;写权限: 可在目录下创建、删除文件（删除文件对文件本身并不需要权限）&lt;/li&gt;
      &lt;li&gt;可执行权限: 可访问目录中的文件，也成为search权限&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;访问文件时候， 需要拥有对路径名所有的目录的执行权限， /home/mtk/x, 需要对 /、/home、/home/mtk 拥有可执行权限。但是若在/home/mtk/sub1下，通过相对路径 ../sub2/x 访问。那么只需要 /home/mtk 、/home/mtk/sub2 这两个目录的可执行权限，而不需要 /、/home 的权限。（奇怪，应该保持一致性比较好）&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对目录权限的解释: &lt;br /&gt;
因为目录的特殊结构（目录的内容其下的文件、目录等的i节点列表），可以这样理解设定三种权限的理由: 读权限， 可以访问目录的数据结构。可执行权限，则可以查看目录内容的i节点详细信息。写权限，意味着可以修改目录内容，所以可以删除目录下的文件（即是修改目录内容的i节点列表）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;若是拥有对目录的可执行权限， 而没有读权限。只需要知道目录内的文件名称，则仍可以进行访问，但不能列出目录下的内容。在控制对公共目录内容的访问时，非常有用。&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;文件系统的权限检查（包含目录、文件):只在初次调用时候，进行检查，open文件之后的fd，再次对其进行操作，是不再会进行检查的。规则如下:
    &lt;ul&gt;
      &lt;li&gt;特权进程， 授予访问权限&lt;/li&gt;
      &lt;li&gt;若进程的有效用户ID与文件的用户ID相同，内核会根据文件的属主权限，授予进程相同的权限。&lt;/li&gt;
      &lt;li&gt;若进程的有效组ID或任意附属组ID与文件的组ID相匹配。根据文件的属组权限，授予进程&lt;/li&gt;
      &lt;li&gt;若上面都不满足， 内核根绝other授予进程权限。&lt;br /&gt;
  内核检查会在最后时候，即是未能通过调用规则的检查的时候，才会检查检查是否属于特权进程。&lt;br /&gt;
  上述检查可能造就一些奇怪的现象（从代码逻辑上来看是正常的）: 比如文件的owner没有rw权限， &lt;br /&gt;
同样适用于目录的权限检查， 但是特权进程总是拥有可执行权限（即是总是可以搜索），特权进程总是拥有通过任何的权限检查&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Sticky位: 现在的UNIX的Sticky权限位 其限制删除的作用，为目录设定权限位时候， 表明非特权进程时，只有对目录有写权限+为文件或目录的属主时才能对目录下的文件进行 删除、重命名操作。（可以用于建立多个用户共享的目录文件， 每个用户管理自己的文件、访问其他人的文件。但是不能删除其他人的文件） 典型的应用在/tmp 目录下， chmod +t 可以添加 sticky位，&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;进程的文件创建掩码: umask 是一种进程属性， 当进程创建文件或者目录时候，该属性执行屏蔽那些权限位。进程的umask通常继承父shell， 所以可以在shell中使用umask来改变shell进程的umask，进而影响所有的shell子进程。umask(mode_t mask) 系统调用总是调用成功，并返回之前的umask数值。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;i节点扩展属性（EA）&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="目录和链接的实现结构"&gt;目录和链接的实现结构&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;目录的实现结构:
    &lt;ul&gt;
      &lt;li&gt;i节点的类型标记为目录&lt;/li&gt;
      &lt;li&gt;目录内容是经过特殊组织的文件表格(硬链接列表): 文件名和i-node编号。&lt;/li&gt;
      &lt;li&gt;不能够read目录内容， 直接编辑目录内容是不允许的，不具有可移植性。需要使用相关的系统调用， open, link, mkdir, symlink ,unlink, rmdir etc&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;硬链接: 创建链接指向相同的i-node节点，成为硬链接。会改变 指向文件的i-node节点的 链接数。限制有: 1) 因为采用i-node编号，导致不能跨越文件系统。 2）不能为目录创建硬链接，会导致诸多的系统程序陷入混乱的链接环路中。&lt;/li&gt;
  &lt;li&gt;符号链接: 特殊的文件类型， 内容为另一个文件的名称（字符串）
    &lt;ul&gt;
      &lt;li&gt;ln -s 创建， 内容可以是绝对路径和相对路径，解释相对路径时，以链接本身的位置作为参照点。&lt;/li&gt;
      &lt;li&gt;符号链接的地位不如硬链接，i节点并不体现符号链接数量。即便移除了文件，链接依然存在，成为空连接。甚至可以创建不存在文件的链接。&lt;/li&gt;
      &lt;li&gt;因为符号链接的内容为字符串，所以可以跨越文件系统。一些系统调用中对符号链接进行解析，因为可能存在环路问题，所以规定了街引用的一个次数范围。_POSIX_SYMLOOP_MAX 常量规定了最大次数限制。（无论系统调用是否对符号链接进行解析，其总是对符号链接中的目录部分进行接引用，区分在于是否对文件接引用），&lt;/li&gt;
      &lt;li&gt;权限为引用的文件的权限。&lt;br /&gt;
&lt;img src="../../../../images/file_system_dir-34782625.png" alt="dir" /&gt;&lt;br /&gt;
&lt;img src="../../../../images/file_system_symbol_link-b005d109.png" alt="dir" /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id="系统调用"&gt;系统调用:&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;link（const char * oldpath, const char * newpath）; 创建硬链接， oldpath 不应为符号链接，否则不具有可移植性。&lt;/li&gt;
  &lt;li&gt;unlink(const char * pathname): 如果此链接为最后一个指向文件的，此操作还会删除文件本身。&lt;/li&gt;
  &lt;li&gt;都不能操作目录， 与符号链接&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;文件内容的删除: 内核除了维持i-node节点的链接数目之外，还对文件的打开文件描述符计数。只有全部的计数为0时候，文件才会真正的消失。这意味着， 存在多个硬链接， 只有删除全部删除硬链接的时候，才会删除文件本身，且不存在打开的文件描述符。否则文件本身依然存在，并且可以被读取。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;rename(const char * oldpath, const char * newpath): 可以重命名文件、目录。 调用仅仅操作目录条目， 而不移动数据，更名既不影响指向该文件的硬链接，也不影响打开文件描述符的任何进程。（这些文件描述符在open调用返回之后，与文件名再无瓜葛）&lt;br /&gt;
规则:
    &lt;ul&gt;
      &lt;li&gt;newpath 存在则将其覆盖&lt;/li&gt;
      &lt;li&gt;newpath与oldpath 指向同一文件， 则不操作&lt;/li&gt;
      &lt;li&gt;系统调用不对参数进行解引用，意味着可以操作符号链接&lt;/li&gt;
      &lt;li&gt;oldpath 是文件的时候，不能更名为目录&lt;/li&gt;
      &lt;li&gt;oldpath是目录的情况下， newpath目录不能存在或者是空目录。且newpath不能包含oldpath的前缀， 如 /home/mtk, -&amp;gt; /home/mtk/bin&lt;/li&gt;
      &lt;li&gt;oldpath、newpath 需要为同一文件系统，因为目录的内容为硬链接列表组成。硬链接的i-node节点指向必须是同一文件系统。（区别于 mv系统命令， mv能够跨越文件系统， 其操作 复制内容， 其在同文件系统上的表现还需要验证）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;symlink(const char * filepath, const char * linkpath): 创建filepath（路径名）文件、目录的一个新的符号链接。filepath 可是相对路径或者绝对路径，相对路径会经常显现一些超乎意外的情况，所以建议是绝对路径。filepath 可以存在或者不存在，因为即便存在依然可能会被删除，造成linkpath的空连接。&lt;/li&gt;
  &lt;li&gt;readlink(const chart *pathname, char * buffer, size_t bufsiz): 获取符号链接本身的内容，系统调用将符号链接的内容放到buffer中。&lt;/li&gt;
  &lt;li&gt;mkdir(const char * pathname, mode_t mode): pathname可以使相对路径或绝对路径，目录的set-user-id 总是关闭（因为没有作用）， mode 中的 set-group-id 设定会被忽略。系统调用所创建的只是路径名中最后的部分，如果中间部分不存在则调用失败。 SUSv3 并未要求目录中包含.、.., 只是要求存在时候能够正确解释，所以，可移植性的程序不能假定总是存在这些条目。&lt;/li&gt;
  &lt;li&gt;rmdir(const char * pathname):要求被删除目录内容为空，才能调用成功。&lt;/li&gt;
  &lt;li&gt;remove(const char *pathname):c标准库中的函数， 并不是系统调用。 不会解引用。移除一个文件或一个空目录。pathname 为文件，remove 会调用unlink， 是目录时，remove 调用rmdir.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="进程都有两个目录相关属性-1根目录-2工作目录没想到过还可以修改根目录"&gt;进程都有两个目录相关属性: 1）根目录， 2）工作目录。没想到过还可以修改根目录&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;进程的当前工作目录:定义了该进程解析相对路径的起点， 继承自父进程。
    &lt;ul&gt;
      &lt;li&gt;getcwd(char * wdbuf, size_t size): 拥有获取当前进程的工作目录， 当前工作目录的最大字符串长度应小于4096 的字节限制。超出将不再可靠。&lt;/li&gt;
      &lt;li&gt;chdir(const char *pathname): 更改调用进程的当前工作目录，可以为符号链接。&lt;/li&gt;
      &lt;li&gt;/proc/PID/cwd 为进程当前工作目录的映射&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;进程的根目录: 该目录是解释绝对路径的起点，继承自父进程。
    &lt;ul&gt;
      &lt;li&gt;chroot(const char *pathname): 系统调用改变进程的根目录，目的为监理一个chroot监禁区。将所有对绝对路径的解释设定为一个目录的起点。将应用程序设定为文件系统的特定区域。&lt;/li&gt;
      &lt;li&gt;需要将 根目录的 .与.. 设定为自身， 防止根据相对路径，逃出监禁区&lt;/li&gt;
      &lt;li&gt;并不是所有的程序都可以运行在监禁区，因为大多数程序与共享库之间采用动态链接的方式。因为需要复制一套标准的共享库来实现运行动态链接的程序（通过绑定挂载可以实现共享库共享）&lt;/li&gt;
      &lt;li&gt;不能在监禁区中方式set-user-id-root 程序，方式获取root的权限&lt;/li&gt;
      &lt;li&gt;需要chdir， 防止通过相对路径逃出监禁区&lt;/li&gt;
      &lt;li&gt;如果进程之前持有监禁区之外的文件描述符，可以逃出监禁区&lt;/li&gt;
      &lt;li&gt;可以通过套接字传递监禁区之外的文件描述符，所以需要避免&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;总结: chroot调用并不能真正的成为安全的控制机制，因为逃出监禁区的方式有很多，还不如实现更加现代的docker容器技术来避免。&lt;br /&gt;
realpath(const char * pathname, char * resolved_path): 对路径解析为绝对路径。&lt;br /&gt;
dirname, basename: 将路径名解析成， 目录和文件名两部分。&lt;/li&gt;
&lt;/ol&gt;

</content>
  </entry>
  <entry>
    <title>daily-learn</title>
    <link rel="alternate" href="http://geniousbar.github.io/2019/05/23/daily-learn/"/>
    <id>http://geniousbar.github.io/2019/05/23/daily-learn/</id>
    <published>2019-05-23T08:00:00+08:00</published>
    <updated>2019-06-17T13:59:45+08:00</updated>
    <summary type="html">&lt;p&gt;mysql_conn doam_217_realm1 -e “show tables” &amp;gt; ~/tables.txt&lt;br&gt;
cat ~/tables.txt | grep 2019 &amp;gt; ~/i_tables.txt&lt;br&gt;
mysqldump $(echo ~/i_tables.txt) -h 10.9.88.246 -pdragonsmobile doam_217_realm1 -u dragonsmobile -d –add-drop-database&lt;/p&gt;

&lt;p&gt;邓小平时代&lt;/p&gt;

&lt;p&gt;作者：哈佛大学傅高义，以中外的...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;mysql_conn doam_217_realm1 -e “show tables” &amp;gt; ~/tables.txt&lt;br /&gt;
cat ~/tables.txt | grep 2019 &amp;gt; ~/i_tables.txt&lt;br /&gt;
mysqldump $(echo ~/i_tables.txt) -h 10.9.88.246 -pdragonsmobile doam_217_realm1 -u dragonsmobile -d –add-drop-database&lt;/p&gt;

&lt;p&gt;邓小平时代&lt;/p&gt;

&lt;p&gt;作者：哈佛大学傅高义，以中外的不同视角描绘了，解读邓小平的政治生涯及其行为逻辑，。对中美建交、华国锋历史评估、改革开放的幕后曲折、邓小平和诸多当时关键人物之关系、香港问题、邓小平南巡等重大议题均有详述及剖析。《邓小平时代》既具学院研究的严谨专精，又对中国现实政治与事理人情有透彻把握，被誉为邓小平研究“纪念碑式”的著作。&lt;/p&gt;

&lt;p&gt;以下是一个简单的概览。&lt;/p&gt;

&lt;p&gt;为什么是邓？&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;首先邓是一个军人，因为其生平路线多以军事为主，所以其有着极高的军事威望。能够得到军队的拥护。&lt;/li&gt;
  &lt;li&gt;毛的选择：与毛的关系密切，曾因为坚持用户毛的政策而被撤职下放。但因为毛担心邓不会坚持自己的路线而失落。&lt;/li&gt;
  &lt;li&gt;邓的思想、执政方式： 邓在决策时特别注重把握整体氛围，不勉强，力求实现“水到渠成”。这是邓能够得到拥戴、政策能够得到稳步推进，改革开放、思想转变 得以顺利进行的一个重要支撑。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;华的作用？&lt;/p&gt;

&lt;p&gt;毛在临终前，确实是指定华为接班人，也得到了叶的支持。（邓因为可能并不能坚持毛的路线而被放弃，也有猜想是因为苏联、美国的共同压力导致，毛发动了文革，从而延缓了美苏对中国的下手，度过了危机，而将衣钵留给了邓（听着有点瞎扯）），华在拨乱反正，清灭四人帮的过程中起到了重要的作用。并启用邓，让邓出来主持工作。华因为害怕得不到支持而错误的提出了『两个凡是』，但其基本思想、政策方针 是值得肯定的。其在 毛 邓的过度时期 起到了重要的作用。&lt;/p&gt;

&lt;p&gt;主持大局&lt;/p&gt;

&lt;p&gt;华因为根基浅显，是导致邓起的重要原因。邓首先巧妙的重新解释了毛的思想的现实意义，使其能够帮助、促进、为现代化发展提供了理论根基。邓通过军中根基，进行了精兵简政，削减了政策开支，转而发展民生。邓通过鼓励、包容 以 万里、赵紫阳 等实干派、智囊团。来进行小范围的尝试。开辟新的思路、思想方法。让事实来推动整体思想氛围的转变。典型的是 『家庭联产承包责任制』 得推进，改革开放的深圳，则更是标志性的胜利。&lt;/p&gt;

&lt;p&gt;对外标志性的事件有： 与美日建交，推动了与美日的关系，日本的企业对中国的现代化发展提供了非常大的技术支持与帮助。一国两制 收复香港、澳门、稳定了西藏局势。并通过对 越南 的自卫战，阻止了苏联的进一步扩展，稳定了东南亚局势。为经济发展创造了一个稳定的外部环境。（然而在越难自卫战中，是否如传闻的一样，势如破竹，直捣黄龙的说法，书中给出了另外的一种视角，大多数的视角认为，战虽然赢了，但是打的异常艰难，中方损失过大，暴露了许多问题）， 关于现在形态，在邓造访美国时候，已经做出了评论，邓认为美方的三权分立形式太过内耗，浪费精力，更不能有效的集中力量办大事，而且对于我们来说一个多民族多融合的国家来说，容易造成分裂。关于组织， 邓在期间并没有改进，依然沿用 由上层任命、罢免下层的方式来控制地方，只是选人方式改成了择优录用而不再是参杂政治阶级，其考核目标则有经济发展代替了阶级斗争。&lt;/p&gt;

&lt;p&gt;关于舆论： 邓放弃了阶级斗争，允许百花齐放，但是是建立在坚持统一、团结的基础上。&lt;/p&gt;

&lt;p&gt;作用、功过是非？&lt;br /&gt;
推荐 邓小平时代&lt;/p&gt;

</content>
  </entry>
  <entry>
    <title>rails-time-zone</title>
    <link rel="alternate" href="http://geniousbar.github.io/2019/05/21/rails-time-zone/"/>
    <id>http://geniousbar.github.io/2019/05/21/rails-time-zone/</id>
    <published>2019-05-21T08:00:00+08:00</published>
    <updated>2019-05-21T20:37:52+08:00</updated>
    <summary type="html">&lt;h1 id="rails-timezone"&gt;Rails Timezone&lt;/h1&gt;

&lt;p&gt;TimeZone 是 rails 为ruby扩展的一个 有用工具。&lt;/p&gt;

&lt;p&gt;application.rb&lt;br&gt;
config.time_zone = “Beijing”&lt;br&gt;
可以指定整个应用的timezone。 然而， 使用timezone依然需要一个特定的方法调用，才能够使用rails 提供的扩展。&lt;/p&gt;

&lt;p&gt;相关代码如下:&lt;/p&gt;

&lt;p&gt;activesupport/lib/active_support/core_ext/time/zones.rb&lt;/p&gt;

&lt;p&gt;为 ruby 的TIme class 提...&lt;/p&gt;</summary>
    <content type="html">&lt;h1 id="rails-timezone"&gt;Rails Timezone&lt;/h1&gt;

&lt;p&gt;TimeZone 是 rails 为ruby扩展的一个 有用工具。&lt;/p&gt;

&lt;p&gt;application.rb&lt;br /&gt;
config.time_zone = “Beijing”&lt;br /&gt;
可以指定整个应用的timezone。 然而， 使用timezone依然需要一个特定的方法调用，才能够使用rails 提供的扩展。&lt;/p&gt;

&lt;p&gt;相关代码如下:&lt;/p&gt;

&lt;p&gt;activesupport/lib/active_support/core_ext/time/zones.rb&lt;/p&gt;

&lt;p&gt;为 ruby 的TIme class 提供了， zone, zone=, use_zone（在临时设定timezone，并yield之后，重置 timezone）, fine_zone！， in_time_zone(转到换 一个timezone的时间表示) 扩展，&lt;/p&gt;

&lt;p&gt;zone 为一个ActiveSupport::TimeZone instance, 提供now, today, at, utc_to_local 等， 配置， timezones简单别名映射&lt;br /&gt;
ActiveSupport::TimeWithZone, 则是简单的一个包含timezone， utc time， 的封装， 包含了一些对界面的映射， to_s, to_yml, httpdate, strftime （其中包含了 ::Timezone 表示） 等&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>book-advise</title>
    <link rel="alternate" href="http://geniousbar.github.io/2019/05/20/book-advise/"/>
    <id>http://geniousbar.github.io/2019/05/20/book-advise/</id>
    <published>2019-05-20T08:00:00+08:00</published>
    <updated>2019-05-21T15:44:40+08:00</updated>
    <summary type="html">&lt;h1 id="书籍推荐"&gt;书籍推荐&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;深入理解计算机系统&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;神书， 其令人惊艳的地方在于，真正的做到了漫游了计算机系统，名副其实， 从硬件到软件、从 逻辑硬件到 流水线cpu设计架构，从 指令集 到 高级语言， 从顺序执行到并发执行。。。。 其包罗万象、贯穿了整个计算机，而又不失深度。&lt;br&gt;
这本书大概可以作为计算机各个领域的一个敲门砖，因为计算机发展到今天已经足够深， 所以在单独的领域中依然需要专门的数据来深入探讨。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;程序的构造和解释&lt;br&gt;
神书， 现在市面上的大部分书籍教的都是框架，如何在xxx框...&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    <content type="html">&lt;h1 id="书籍推荐"&gt;书籍推荐&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;深入理解计算机系统&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;神书， 其令人惊艳的地方在于，真正的做到了漫游了计算机系统，名副其实， 从硬件到软件、从 逻辑硬件到 流水线cpu设计架构，从 指令集 到 高级语言， 从顺序执行到并发执行。。。。 其包罗万象、贯穿了整个计算机，而又不失深度。&lt;br /&gt;
这本书大概可以作为计算机各个领域的一个敲门砖，因为计算机发展到今天已经足够深， 所以在单独的领域中依然需要专门的数据来深入探讨。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;程序的构造和解释&lt;br /&gt;
神书， 现在市面上的大部分书籍教的都是框架，如何在xxx框架上写代码。很少有涉猎教如何写代码，更少有教如何有思考的写代码。这本书大概会教会你这些。虽然不仅仅如此而已。 自上而下 将问题拆分，层层求解，亦或 自下而上 搭积木一般层级而上 大概是 最舒适的构建代码方式了， 然而 现实是复杂的，依然需要我们 从两种方法出发的求证来完成构建。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UNIX编程艺术&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;有关计算机的书已经汗牛充栋，然而，却很少涉及对 复杂度的讨论。作者不仅简单的介绍了UNIX 的编程哲学，还继续深入的讨论了 这些哲学在现代编程中遇到的问题，通过对比vim emacs 的讨论， 从而深层次的 引导出了 『复杂度』的本质概念。作者 将UNiX 编程哲学的简单 进行了更广泛的推广， 认为 任何规模的程序都应该是简单的但是不能简单的过了头，因为 项目解决问题 决定了项目的复杂度， 一个复杂的问题，无论是何种语言 也注定是无法简单的。只能是足够简单。&lt;/p&gt;

&lt;p&gt;作者还详细的对复杂度进行了归类划分，以及对应的解决办法。作者对复杂度的讨论，笔者第一次听到过，简直醍醐灌顶，原来我大概一直在错误的尽力的保持代码的整洁和简单，然而，有一些依然是我解决不了的，因为代码解决的问题本身就决定了代码一定是复杂的&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Linux/UNIX系统编程手册&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;笔者是一个应用的开发工程师，所以难免在 进行多年枯燥的 应用级别编程之后，对底层有些好奇，因为 反复的写下来，都有一个Linux系统在其进行支撑，屏蔽了一些诸如文件、进程、调度、通讯上的细节。进而了解linux系统大概是不可避免的。本书名叫编程手册，所以其内容难免枯燥，反锁。然而 魔鬼隐藏在细节中，而Linux值得这些细节。&lt;/p&gt;

</content>
  </entry>
</feed>
