<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>日常学习</title>
  <id>http://geniousbar.github.io</id>
  <link href="http://geniousbar.github.io"/>
  <link href="http://geniousbar.github.io/feed.xml" rel="self"/>
  <updated>2019-03-24T08:00:00+08:00</updated>
  <author>
    <name>geniousbar</name>
  </author>
  <entry>
    <title>charles-munger</title>
    <link rel="alternate" href="http://geniousbar.github.io/2019/03/24/charles-munger/"/>
    <id>http://geniousbar.github.io/2019/03/24/charles-munger/</id>
    <published>2019-03-24T08:00:00+08:00</published>
    <updated>2019-04-22T09:29:31+08:00</updated>
    <summary type="html">&lt;h2 id="charles-munger---查理芒格"&gt;Charles munger —- 查理芒格&lt;/h2&gt;

&lt;p&gt;芒格 思考问题总是从逆向开始。在其漫长的一生中， 持续不断的研究、收集关于 各种各样的人物、各行各业的企业、以及政府管制、学术研究 等各个领域中 的人类失败的案例。并将那些失败的案例原因 列为 &lt;strong&gt;正确决策的检查清单&lt;/strong&gt;，使自己 在决策中少犯错误。&lt;strong&gt;如果要明白人生如何得到幸福， 查理首先研究的是人生如何才能够变得痛苦&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;很多一流的专家学者， 能够在自己的狭小的研究领域内 做到相对客观，但是一旦离开自己的领域不远。就开始变得主观、教条、僵化，甚至失去了自...&lt;/p&gt;</summary>
    <content type="html">&lt;h2 id="charles-munger---查理芒格"&gt;Charles munger —- 查理芒格&lt;/h2&gt;

&lt;p&gt;芒格 思考问题总是从逆向开始。在其漫长的一生中， 持续不断的研究、收集关于 各种各样的人物、各行各业的企业、以及政府管制、学术研究 等各个领域中 的人类失败的案例。并将那些失败的案例原因 列为 &lt;strong&gt;正确决策的检查清单&lt;/strong&gt;，使自己 在决策中少犯错误。&lt;strong&gt;如果要明白人生如何得到幸福， 查理首先研究的是人生如何才能够变得痛苦&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;很多一流的专家学者， 能够在自己的狭小的研究领域内 做到相对客观，但是一旦离开自己的领域不远。就开始变得主观、教条、僵化，甚至失去了自我学习能力。大都避免不了瞎子摸象的局限。如何避免这种思维上的陷阱， 则需要『&lt;strong&gt;普世智慧&lt;/strong&gt;』(所以即便是 非常聪明有能力的人，依然不能够避免狭隘的知识圈，避免一些 思维上的缺陷，导致一些错误的决定的发生)&lt;/p&gt;

&lt;p&gt;芒格认为，这个世界是复杂多变的，人类的认知永远存在着缺陷， 所以需要使用所有的工具， 同时注意收集各种新的可以证否的证据，并随时修正，基本上所有人都存在着思维上的盲点，对于自己的专业、旁人、或者一件事情能够做到客观，但是对于其他的万事万物 能够秉持客观的态度则是很难的、有违本性的。普世智慧 能够 使人保持客观的精神态度，并导致可以 理解别人理解不了的事务、看不不一样的未来，从而过长幸福、自由的生活。&lt;/p&gt;

&lt;p&gt;巴菲特说，芒格 能够比世界上任何人能够在最短的时间内把一个复杂的商业的本质讲清楚&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如何才能够找到一个优秀的配偶，最好的方式就是让自己配得上他，因为优秀的配偶都不是傻瓜，&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;查理芒格 在中国文化体系 中的 位置：『商才士魂』 士大夫的价值观 提现的是 是一个如何提高自我修养、自我超越的过程。 『正心、修身、齐家、治国、平天下』为中国文明最核心的灵魂价值所在。在市场经济和科学技术逐渐成为 政府之外 最影响人类生活的两股重要力量。在今天商业高度发达的社会，士大夫奇怪坏的中古读书人，对于自身的存在以及其价值理想往往更加困惑，&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;主要做好准备，在人生中  抓住几个机会， 迅速的采取适当的行动， 去做简单而合乎逻辑的事情 这辈子的财富就会得到极大的增长。上面提到的机会很少， 通常会落在 不断寻找和等待、充满求知欲望又热衷于对各种不同的可能性做出分析的人士头上。&lt;br /&gt;
这样的机会来临后， 重重的下注就行了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;将自由的市场经济， 或者部分自由的市场经济， 当多某种生态系统是很有用的思维，因为 动物在合适的 地方能够繁衍 同样的 人只要在社会上找到 专属于自己的位置。也能够取得成功。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id="多元思维模型-避免-铁锤-思维"&gt;多元思维模型： 避免 &lt;strong&gt;铁锤&lt;/strong&gt; 思维&lt;/h2&gt;
&lt;p&gt;必须知道重要学科的重要理论，并经常使用他们–要全部用上，而不是几种，大多数 人都只使用学过的一个学科的思维模型，比如 经济学 试图使用一种方法解决所有问题—–&lt;strong&gt;典型的铁锤思维&lt;/strong&gt;&lt;br /&gt;
查理芒格的模型有： 工程学的冗余备份模型、数学的复利模型、物理学和化学的连接点、倾覆力矩、自我催化模型、生物学的现代达尔文综合模型、心理学的认知误判模型&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;未雨绸缪、富有耐心、律己严厉、不偏不倚 最基本的指导原则&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;假如有20种相互影响的因素，那么你必须学会处理这种复杂的关系—–接受现实，因为世界就是这个样子的。如果你想达尔文那样，带着好奇的毅力，循序渐进的去做，那么就不会觉得是艰巨的任务，你将会惊讶的发现自己能够胜任&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;『耐心，不厌倦等待的等待』艺术，赚大钱的诀窍不在于买进卖出 而在于等待。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;科学理论应该尽可能简单，但不能过于简单。这是最佳的点。因为我们需要应付的是  高度复杂的 系统，在追求理性和简单的时候，应该避免  『物理学妒忌』 即将 复杂的系统 简化为 几道牛顿公式 的倾向&lt;/p&gt;

&lt;p&gt;心理学在投资中的应用： 格雷汉姆 的 聪明的投资者 中的 『市场先生』 ： 市场先生 是一个 脾气温和、头脑理智的 家伙，但有时候 也会受到 非理性的恐惧或 贪婪的驱使，他提醒投资者， 对于股票的价值，需要亲自做出可观的判断， 不能依赖 金融市场常见的狂躁抑郁的行为。&lt;strong&gt;查理认为即便哪些最有能力、最有干劲的人，也依然会有不理性的决定，所以 把 人类误判心理因素 当做 判断投资机会的 思维模型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;双规分析法&lt;/strong&gt;： 1）理性的看： 哪些因素 真正的控制了涉及的利益， 2）有哪些潜意识因素会使大脑 自动的 形成虽然有用但是 失灵的结论， 第一种主要为理性分析，认准真正的利益， 找对真正的机会。第二种， 评估那些造成错误的  心理因素。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;总结为： 迅速歼灭不应该做的事情， 接着对该做的事情发起熟练的，跨学科的攻击， 然后 当适当的机会来临—–就采取果断的行动。 如果你把自己训练的更加客观， 拥有更多学科的知识，那么你在考虑事情的时候，就能够超越哪些比你聪明很多的人，我觉得这是很好玩的， 再说了，那样还能赚到很多的钱， 我本人就是个活生生的例子。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id="能力圈"&gt;能力圈&lt;/h2&gt;

&lt;p&gt;我不是天才，我有几点聪明，我只不过就留在这几点里面  —– 托马斯—沃森 (IBM创始人)&lt;br /&gt;
芒格 关于投资 有三个选项； 可以投资，不能投资，太难理解， 他会从 可以投资中 筛选 来获得自己的投资项目&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果说我们有什么本事的话， 那就是我们能够清楚我们什么时候 在能力圈的中心运作，什么时候正在向 边缘靠近 —– 沃伦巴菲特&lt;br /&gt;
如果你确有能力， 你就会非常清楚能力圈的边界在哪里， 如果你问自己（是否超出了能力圈）那就意味着你已经在圈子之外了。 —— 查理芒格&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;你必须有浓厚的寻去取弄明白正在发生的事情背后的原因， 如果你能够长期保持这种心态， &lt;strong&gt;你关注现实的能力就会逐渐得到提高&lt;/strong&gt;， 如果你没有 这种心态，那么即使你有很高的智商，也注定会失败。   &lt;br /&gt;
你若想在任何领域用有竞争力，就必须熟练的掌握该领域的方方面面，不管你是否喜欢这么做。&lt;/p&gt;

&lt;p&gt;需要牢牢记住的： 这100中模型，往往能够带来特别大的力量， 当几个模型联合起来，你就能够得到&lt;strong&gt;lollapalooza 效应&lt;/strong&gt;， 两种三种力量 共同作用同一个方向时候， 你得到的通常不是几种力量之和，就像物理学的临界质量，当你达到一定程序的质量，你就能够引发核爆炸，如果没有你什么也得不到， 有时候各种力量只是简单的相加， 有时候他们会在临界点上联合起来。&lt;br /&gt;
更为常见的情形是： 这100中模型带来的各种力量只是简单在某种程度上是相互冲突的，所以你将会面临 鱼和熊掌 不可兼得的境况。如果你不明白有舍才有得的道理就太傻了，对于需要高级思维的活动，你这种头脑不清对于旁人而言就变成了一种风险。你必须辨别清楚 这些事情之间的关系，&lt;strong&gt;『生活无非就是一个接一个的联系』 所以你需要拥有各种模型，并且弄清各个模型的相互关系以及他们的效应&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id="多元思维模型"&gt;多元思维模型：&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;有性格的人才能拿着现金坐在那里什么事情杨喝不醉虚哦，我能有今天，靠的是不去追逐平庸的机会  ——- 查理芒格&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id="投资原则检查清单"&gt;投资原则检查清单&lt;/h2&gt;

&lt;h4 id="风险--所有投资评估应该从测量风险开始"&gt;风险 — 所有投资评估应该从测量风险开始&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;测算合适的&lt;strong&gt;安全边际&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;避免和 道德品质有问题 的人交易&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;坚持为预定的风险要求合适的补偿&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;永远记住通货膨胀 和利率的风险&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;避免犯下大错&lt;/strong&gt;：避免资本金持续亏损&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="独立--只有在童话中皇帝才会被告知自己没穿衣服"&gt;独立 — 只有在童话中，皇帝才会被告知自己没穿衣服&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;客观和理性的态度需要独立思考&lt;/li&gt;
  &lt;li&gt;记住: 你的对错取决于你的分析和判断是否正确，而不是别人同意你还是反对你&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="知道如何避免-只要得到严格的遵守光是避免犯傻的芒格体系-就能帮助你超越许多在你之上的人-无论他们有多聪明"&gt;&lt;strong&gt;知道如何避免： 只要得到严格的遵守，光是『避免犯傻的芒格体系』 就能帮助你超越许多在你之上的人， 无论他们有多聪明&lt;/strong&gt;&lt;/h4&gt;
&lt;h4 id="随大流-只能让你往平准值上靠近"&gt;随大流 只能让你往平准值上靠近&lt;/h4&gt;
&lt;h4 id="准备-唯一的获胜的方法就是工作工作工作工作工作并希望拥有一点洞察力"&gt;准备—– 唯一的获胜的方法就是工作、工作、工作、工作、工作、并希望拥有一点洞察力&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;通过广泛的阅读把自己培养成一个终生自学者， 培养好奇心，每天努力使自己聪明一点点&lt;/li&gt;
  &lt;li&gt;比求胜的意愿更重要的是  做好准备的意愿&lt;/li&gt;
  &lt;li&gt;熟练的掌握各大学科的思维模型&lt;/li&gt;
  &lt;li&gt;如果你想要变得聪明，你必须不停的 追问的问题是： 『为什么、为什么、为什么』&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="谦虚--承认自己的无知是智慧的开端"&gt;谦虚—- 承认自己的无知是智慧的开端&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;只在自己明确界定的能力圈内行事&lt;/li&gt;
  &lt;li&gt;辨认和检查否定性的证据&lt;/li&gt;
  &lt;li&gt;抵制追求虚假的精确 和 错误的确定性欲望&lt;/li&gt;
  &lt;li&gt;最重要的是，别愚弄你自己， 并且要记住， 你是最容易被自己愚弄的人&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="理解复利的魔力和-获得他的困难是-理解许多事情的核心和灵魂"&gt;理解复利的魔力和 获得他的困难是 理解许多事情的核心和灵魂&lt;/h4&gt;

&lt;h4 id="严格分析-使用科学方法和有效得检查清单能够最大限度的减少错误和疏忽"&gt;严格分析— 使用科学方法和有效得检查清单能够最大限度的减少错误和疏忽&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;区分价值和价格、过程和行动、财富和规模&lt;/li&gt;
  &lt;li&gt;记住浅显的好过掌握深奥的&lt;/li&gt;
  &lt;li&gt;成为一名商业分析家而不是市场宏观经济或者证券分析家&lt;/li&gt;
  &lt;li&gt;考虑总体的风险和效益，永远关注潜在的二阶效应和更高层次的影响&lt;/li&gt;
  &lt;li&gt;要朝前想、往后想——反过来想，总是反过来想&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="配置--正确的配置资本-是投资者的最重要的工作"&gt;配置—- 正确的配置资本 是投资者的最重要的工作&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;记住:最好的用途总是由第二好的用户衡量出来的（机会成本）&lt;/li&gt;
  &lt;li&gt;好主意特别少—–当时机对你有利时候，狠狠的下赌注&lt;/li&gt;
  &lt;li&gt;别 爱上投资项目—– 要依情况而定，照机会而行&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="耐心克制人类天生爱行动的偏好"&gt;耐心—–克制人类天生爱行动的偏好&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;复利是世界第八大奇迹  不到必要的时候，别去打断他&lt;/li&gt;
  &lt;li&gt;避免多余的交易税和摩擦成本，永远别为了行动而行动&lt;/li&gt;
  &lt;li&gt;幸运来临时 要保持头脑清醒&lt;/li&gt;
  &lt;li&gt;享受结果、也享受过程，因为你活在过程中&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="决心-当合适的时机出现时候-要坚决的采取行动"&gt;决心—– 当合适的时机出现时候， 要坚决的采取行动&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;当别人贪婪时，要害拍，当别人害怕时，要贪婪&lt;/li&gt;
  &lt;li&gt;机会来临的次数不多， 所以当他来临时， 抓住他&lt;/li&gt;
  &lt;li&gt;机会只眷顾有准备的人，投资就是这样的游戏&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="改变在生活中要学会改变和接受无法消除的复杂性"&gt;改变—–在生活中要学会改变和接受无法消除的复杂性&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;认识和适应你身边的世界的真实本质，别指望i昂他来适应你&lt;/li&gt;
  &lt;li&gt;不断的挑战和主动的修正你最爱的观念&lt;/li&gt;
  &lt;li&gt;正视现实，即使你并不喜欢他—-尤其是你不喜欢她的时候&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="专注-别把事情搞复杂记住你原来要做的事"&gt;专注—– 别把事情搞复杂，记住你原来要做的事&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;记住：声誉和正直是你最有价值的财产—而且能够在瞬间化为乌有&lt;/li&gt;
  &lt;li&gt;避免妄自尊大和厌倦无聊的情绪&lt;/li&gt;
  &lt;li&gt;别因为过度关心细节  而忽略了显而易见的东西&lt;/li&gt;
  &lt;li&gt;千万要排除不需要的信息，『千里之堤溃于蚁穴』&lt;/li&gt;
  &lt;li&gt;直面你的大问题别把他们隐藏起来&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="查理的总结"&gt;查理的总结：&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;为什么有些人会比其他人聪明呢(投资上)？这跟与生俱来的性格有部分的关系，有些人的性格并不适合投资，他们总是按耐不住，或者总是忧心忡忡。但如果你用有好的性格，在这里主要指的是非常有耐心，又能够在你知道该采取行动时主动出击，那么你就能够通过实践和学习逐渐的了解这种游戏，很明显，你吸取教训的来源越广泛，而不仅仅从你自己的糟糕经验中吸取教训，你就能变得越好。&lt;br /&gt;
我还没发现有谁能够很快的做到这一点，作为投资者， 巴菲特比我第一次遇到他时候好太多了， 所以诀窍在于不断的学习，而且我不认为不享受学习过程的人能够不断的学习&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;诚实是最好的策略&lt;br /&gt;
  在持续终生的商业赛跑中， 查理和沃伦不但处于领先地位，而且沿途从来不抄近路&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们认为 有些事情就算你能做，而且做了不会受到法律的制裁，或者不会造成损失，你也不应该去做。你应该有一条底线。你心里应该有个指南针。所以很多事情你不会去做，即使他们完全是合法的，这就是我们试图做到的经营方式。&lt;/p&gt;

&lt;h2 id="我们成功的关键"&gt;我们成功的关键&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;如果乌龟能够吸取哪些最棒前辈的已经  被实践所证明的 洞见，有时候他也能跑赢那些追求独创性 的兔子或者跑赢宁愿跻身那些忽略 前人最优秀的工作的蠢货之列的兔子， 或者表面犯下常见 的错误。这种情况就会发生   『我们从来不去试图变为非常聪明的人， 而是持续的试图别变成蠢货，久而久之，我们这种人变能够获得非常大的优势。』&lt;br /&gt;
人们能够更好的理解人类的本性、世界的现状、如何理性的思考、以及最重要的，如何更好的过上一种正直、幸福、善良的生活。三中要素相辅相成，&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;说真话，你讲无需记住你的谎言，就是这么简单的一个概念&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;大数定理： &lt;a href="https://baike.baidu.com/item/%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B"&gt;wiki&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="性格耐心和求知欲的重要性"&gt;性格、耐心、和求知欲的重要性&lt;/h2&gt;

&lt;p&gt;投资的关键因素之一就是拥有 良好的—–性格，大多数人总是按耐不住，或者总是担心过度。成功意味着 你要非常有耐心，然而又能够在你知道该采取行动时主动出击，你吸收的教训越多，就能变得更好。  培养那种毫不焦躁 的持有股票的性情，光靠 性格是不行的。还需要 求知欲望。 你必须有浓厚的寻去取弄明白正在发生的事情背后的原因， 如果你能够长期保持这种心态， &lt;strong&gt;你关注现实的能力就会逐渐得到提高&lt;/strong&gt;， 如果你没有 这种心态，那么即使你有很高的智商，也注定会失败。&lt;/p&gt;

&lt;p&gt;集中投资： 我们的游戏是： 当好项目出现时，我们必须能够认出来。 2）我们的投资规矩是等待好球出现&lt;/p&gt;

&lt;p&gt;优秀的企业： 1）每年赚12%， 你到年底就可以把利润拿走，2）每年赚 12%， 但所有的多余的现金必须在投资—-他总是没有分红 （我们讨厌这种企业）&lt;/p&gt;

&lt;p&gt;能力圈 以及边界： 可以、不行、太难。除非我们对某个项目特别看好，否则就他把归位太难，你需要做的，只是寻找一块特殊的能力领域，并把精力 放在那里面就可以了。&lt;br /&gt;
护城河和持续的竞争优势： 旧的护城河正在被填平、而新的护城河比以前更难预测、所有事情变得越来越难&lt;br /&gt;
错误： 1）什么也不做，沃伦称之为 『吸允我的大拇指』 2）有些股票应该买很多、但是只买了一点&lt;/p&gt;

&lt;p&gt;股票、伦勃朗和泡沫：&lt;br /&gt;
股票有点像债券： 对其价值的评估， 大略以 合理的预测未来产生的现金为基础。&lt;br /&gt;
股票像伦勃朗的画作： 人们购买它， 是因为他的价格一直都在上涨， 这种情况，再加上股票涨跌所产生 的巨大 财富效应。这回造成很多祸害&lt;/p&gt;

&lt;h2 id="思维模型"&gt;思维模型：&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;多元思维模型的重要性： 你需要知道重要学科的 重要理论， 并经常运用他们— 全部用上，而不是几种。大多数人 都只养成一个学科 ——比如经济学–的思维模型。试图用一种方法解决所有问题铁锤人 (似乎在黑 经济学？)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;不自欺的精神&lt;/strong&gt;： 大量的人很荒唐的死抱着错误的观念不防，凯恩斯说『介绍新观念不是很难，男的是清楚那些旧观念』不自欺的精神是你能拥有的最好的精神， 这样的精神 十分强大， 因为它太少见了&lt;/p&gt;

&lt;p&gt;常识：&lt;br /&gt;
非常基础的知识–是一种威力巨大的工具。拥有常识不但意味着 有能力辨识智慧，还有能力 拒绝愚蠢， 如果排除了很多事情，你就不会把自己搞得一团糟。&lt;br /&gt;
我们看很多书，我认识的聪明的人没有不看很多书的。但光看书还不够： 你必须拥有一种能够 1)掌握思想 和 2）做合理事情的性格， 大多数人 无法掌握正确的思维，或者不知道如何应用他们。&lt;/p&gt;

&lt;h2 id="怎样变得幸福富裕以及其他建议"&gt;怎样变得幸福、富裕、以及其他建议：&lt;/h2&gt;
&lt;p&gt;获得幸福和成功：&lt;br /&gt;
生活和生意上的大多数成功来自于  你知道如何避免哪些事情： 过早死亡 、糟糕的婚姻 等等&lt;br /&gt;
避免染上艾滋病、在路口和和火车抢道、吸毒。培养良好的心理习惯&lt;br /&gt;
避免邪恶之人，尤其是那些性感诱人的异性&lt;br /&gt;
满足于你已经拥有的：&lt;/p&gt;

&lt;p&gt;提防妒忌： 妒忌 真的是一种愚蠢的罪行， 因为他是仅有的一种你不可能得到任何乐趣的罪行。 他只会让你痛苦不堪，不会给你带来任何乐趣。关注别人赚钱比你更快的想法是一种致命的罪行。&lt;br /&gt;
如何致富： 每天起床的时候，争取变得比你以前更聪明一点。认真的、出色的完成你的任务。慢慢的你会有所进步，但这种进步不一定很快。但你这样能够为快速的进步大侠挤出机—–媒体呐慢慢向前挪一点。到最后，如果你足够长寿的话—-大多数人能够得到他们应得的东西。&lt;br /&gt;
如何找到好的配偶：&lt;/p&gt;

&lt;p&gt;减少物质需求：  由于通货膨胀 大多数人姜会发送回报率下降了。如果你担心通货膨胀，最好的预防手段之一就是在你的生活中别用有大量的愚蠢的需求—-你不需要很多物质的商品。&lt;br /&gt;
避免欠债： 你一旦陷入负债的怪圈。就很难走出来。千万别欠信用卡的钱，你无法在支付18%的利息的情况下取得进展。&lt;/p&gt;

&lt;p&gt;公立学校的衰落： 你完全可以说 公里学校的衰落是我们时代的主要灾难之一： 我们讲地球史上最大的成功之一 变成了 地球史上 最大的灾难之一。&lt;br /&gt;
日本经济的衰落： 日本的经济衰退  令 每个人大惊失色 他持续了十年， 尽管利率低与1%， 政府把所有的货币政策游戏都玩过了。但是毫无用处， 然而与此同时， 香港却出现了资产泡沫， 为什么？因为日本和中国拥有不同的文化， 中国人喜欢赌博。现有的经济学工具是无法解释现实的状况的。&lt;/p&gt;

&lt;h2 id="查理芒格--十一讲"&gt;查理芒格  十一讲&lt;/h2&gt;

&lt;p&gt;失败的药方：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;为了改变心情或者感觉而是用化学物质&lt;/li&gt;
  &lt;li&gt;妒忌，以及怨恨&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;芒格的药方：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;要反复无常， 为人不可靠。 克罗伊斯   梭伦， 在生命没有结束之前， 没有人的一生能够被称为 幸福的。&lt;/li&gt;
  &lt;li&gt;尽可能的 从你们自身的经验获得知识：尽量别从其他人的成功或者失败的经验中 广泛的吸收教训。不管他们是 古人还是今人， 这味药方 肯定能保证你们过上痛苦的生活，取得二流的成绩。&lt;/li&gt;
  &lt;li&gt;在你们的人生战场上， 遇到 几次严重的失败时，就请意志消沉吧。因为即便是最幸运、最聪明的人。也会遇到许多的失败，这味药方必定能保证你们永远的深陷痛苦的泥沼里。&lt;/li&gt;
  &lt;li&gt;『要是我知道我会死在哪里就好了，那我将永远不去那个地方』 大多数人和你们一样，嘲笑这个乡下人的物质， 忽略那朴素的智慧。若想获得失败， 你们应该讲这种乡下人的方法，贬低的愚蠢至极&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;达尔文的生平 展示了 乌龟如何可以再极端客观态度的帮助下 跑到兔子前面去， 这种态度能够帮助客观的人最后变成 『蒙眼拼驴尾』游戏中唯一那个没有被遮住眼睛的玩家&lt;/p&gt;

&lt;h2 id="论基本的普世的智慧以及-与投资管理和商业的关系"&gt;论基本的、普世的智慧、以及 与投资管理和商业的关系&lt;/h2&gt;

&lt;p&gt;选股的艺术：&lt;/p&gt;

&lt;p&gt;基本的普世智慧 是什么： 1）如果你们指示剂的一些鼓励的事物，试图把他们硬拼凑起来。那么你们无法真正的理解任何东西，如果这些事物 不在一个理论框架中互相联系，你们就无法派上用场。&lt;br /&gt;
需要在头脑中拥有一些思维模型，依靠这些思维模型组成的框架来安排你们的经验。 这些模型必须来自各个不同的学科—因为不可能在一个小小院系里面发现人世间全部的智慧。&lt;/p&gt;

&lt;p&gt;你们也许会说 『天哪， 这太难做到啦』但是幸运的是，这没哟那么难， 因为掌握八九十个模型（？）就差不多能让你成为拥有普世智慧的人， 而在这八九十个模型中，非常重要的只有几个。&lt;/p&gt;

&lt;p&gt;首先就是数学： 你必须能够处理下数字，和数量问题， 也就是基本的数学问题， 1）复利， 2）基本的排列组合原理， 掌握排列组合原理并不难， 真正困的难的是， 日常生活中 习惯于每天使用他们。飞马–帕斯卡的系统与世界��运转的方式惊人的一只，他是基本的公理，所以你需要拥有这些技巧。&lt;br /&gt;
总的来讲，事实已经证明 人们不能 自然的 做到这一点。 心理学解释： 大脑系统是经过�长期的基因和进化而来的。 他是用的是非常粗略而便捷的估算。&lt;br /&gt;
如果你没有将这个基本的但是没有那么自然的 基础数学概率方法变为你生活中的一部分， 那么在漫长的人生中。就等于将巨大的优势让给了别人。&lt;/p&gt;

&lt;p&gt;巴菲特的优势之一就是： 他能够自动的 根据决策树理论和基本的排列组合原来来思考问题。&lt;/p&gt;

&lt;p&gt;会计学： 会计是从事商业活动的语言，对人类文明的一大贡献。&lt;/p&gt;

&lt;p&gt;如果你告诉人们事情的时候， 总是告诉他们原因， 他们就能够深刻的理解，你说的话。就会更加重视你说的话。也会倾向于听从你的说的话，即便是他们不怎么理解你的理由。&lt;/p&gt;

&lt;p&gt;靠谱的思维模型； 那些来自硬科学和工程学的思维模型是地球上最可靠的思维模型。 而工程学的质量控制理论 也是非常重要的核心部分。&lt;br /&gt;
统计学： 不必要精通统计学， 虽然我能准确的知道高斯分布的细节， 不过他的分布形态，也能够做出一个大致的计算。&lt;br /&gt;
工程学的后备系统， 断裂点理论， 临界质量 , 所有这些理论都可以在日常生活中 排上很大的永昌，有全部都是基本的高中只是，只不过是 被一些吓唬人的术语打扮的漂亮而已。&lt;/p&gt;

&lt;p&gt;我认为第二种可靠的思维模型来自生物学、生理学。因为大家毕竟在基因构造方面都是相同的。&lt;br /&gt;
接下来就是心理学：他更加复杂，但是 在普世的智慧中 心理学是不可或缺的。 原因在于， 人类的干支气管有时候会短路， 大脑的神经线路并非总是畅通无阻的， 那些懂得如何利用这些缺点、让大脑一某种错误方式运转的人 能够使你看到根本不存在的东西。所以当外部因素以某些方式结合起来—-让你发生认知错乱—–你就成了任人摆布的蠢货啦。 一个使用工具的人，应该了解他的局限，同样的道理，一个使用认知工具的人，应该了解他的局限。这种知识可以用来操控和激励别人。&lt;/p&gt;

&lt;p&gt;所以心理学最有用、最具实践的部分—–&lt;/p&gt;

&lt;p&gt;心理学最基础的部分 —–误判心理学， 包含了20个小原则：他们还互相影响， 所有有点复杂， 但是核心内容 重要的无以复加。&lt;br /&gt;
双规分析法： 1） 理性的看， 哪些因素控制了涉及的利益？ 2） 潜意识状态时， 会自动形成 那些潜意识因素—-这些总体来讲很有用，但却又常常失灵。&lt;br /&gt;
第一中： 为， 理性分析法， 认准真正的利益， 找对真正的机会， 第二种： 评估哪些因素造成潜意识的结论—-大多数情况下是错误的结论。&lt;br /&gt;
微观经济学：将自由的市场经济， 或者部分自由的市场经济， 当多某种生态系统是很有用的思维，因为 动物在合适的 地方能够繁衍 同样的 人只要在社会上找到 专属于自己的位置。也能够取得成功。&lt;br /&gt;
规模优势： 在微观经济学中 不可绕过的概念， 因为规模优势在商业的成败中扮演者至关重要的角色。一个巨大的规模优势是 成本沿着 所谓的经验曲线下降，只要加大产量，就能够让复杂的生产编的更有效率。本质是： 你生产的商品越多，你就能更好的生产这种产品。 （一个简单的几何学就可以说明，你打算建造一个油罐， 随着油罐的增加，表面积所需要的钢材 会以平方的速度增长。而其容积会以立方的速率增加。所以当你扩建时候，可以以更少的钢材获得更多的容积）， 2）信息优势，早起的宝洁公司能够承担起昂贵的  电视广告（在早起电视刚刚兴起的时候），这对规模很大收益很好的公司起到了巨大的推动力量。3）心理学的『社会认同』： 我们会潜意识的受到  其他人的认同的影响。因此 如果大家都在买一样东西，我也会认为这东西很好。4） 规模优势的劣势： 在更加细分的领域内，被竞争对手打败，因为他们更加专业&lt;/p&gt;

&lt;p&gt;问题？： 许多市场最终会变成两三个–或者五六个–大型竞争对手的天下，在一些那样的市场里面， 没有那家公司能够赚到钱，但是其他市场中，每家公司都能做的很好。&lt;br /&gt;
为什么某些市场的竞争在投资者看来是比较理性，能够给古董带来很多收益。而有些市场 的竞争却总是破坏性的。摧毁了股东的财富。我不是完全能够理解�&lt;br /&gt;
很明显， 麦片行业存在着品牌认同的因素， 而航空业则非常缺乏， 这肯定是 主要原因（上下文为 麦片行业的竞争不不会产生摧毁效应， 而航空行业的竞争则导致大家赚取更少钱）&lt;/p&gt;

&lt;p&gt;微观经济学的伟大意义在于： 让人能够辨别什么时候 技术将会帮助到你， 什么时候会摧毁你， 然而大多数人并没有想过这个问题。&lt;/p&gt;

&lt;p&gt;冲浪模型： 当新的行业  出现时， 先行者会获得巨大的优势，如果你是先行者，会遇到我说的冲浪模型， 当冲浪者冲到浪尖，并停留在那里， 他能够冲很长时间， 但是如果没有， 他会被海浪淹没。（类似， 数学之美作者，阐述IBM， 英特尔 的理论）&lt;/p&gt;

&lt;p&gt;沃伦和我， 都不觉得我们在高科技行业拥有任何大的优势， 实际上，我们认为我们很难理解软件， 等科技行业的发展实质。所以我们尽量避开这些东西，正视我们个人的知识缺陷。每个人都有其自己的能力圈，要扩大他们是很难的事情，所以你需要弄清楚自己的本领， 如果要玩哪些别人玩的很好而自己一窍不通的游戏。 那么你注定要一败涂地。无疑的事情，你需要在自己的能力全之内竞争（同上面的  生态系统类似）&lt;/p&gt;

&lt;p&gt;如果你们想要成为世界上最好的网球球员，你们可以开始努力，然后没多久就发现这是痴人说梦——其他人的球技是你们望尘莫及的。然而，如果你们想要变成伯米吉地区最好的管道工程承包商，你们之中大概有三分之二的人能够做到。这需要下定决心，也需要智慧。但不久之后，你们将会逐渐了解有关伯米吉管道生意的一切，掌握这门艺术。只要有足够的训练，那是个可以达到的目标。有些人虽然无法在国际象棋大赛上获胜，也无缘站在网球大赛的球场上与对手比试高低，但却可以通过慢慢培养一个能力圈而在生活中取得很高的成就——个人成就既取决于天资，也取决于后天的努力。有些优势是可以通过努力获取的。我们大多数人在生活中所能做到的无非就是成为一个伯米吉的优秀管道工程承包商之类的人物。毕竟能够赢得国际象棋世界大赛的人是很少的。&lt;/p&gt;

&lt;p&gt;挑选股票：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;股市的本质是什么：  生活的铁律就是， 只有20% 的人能够去的比其他80% 的人优秀的成绩， 市场是部分有效的， 也是部分低效的。 信奉极端的有效市场理论的人—神经病。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;聪明人在发现这样的机会之后会狠狠地下注。他们碰到好机会就下重注，其他时间则按兵不动。就是这么简单。成为赢家的方法是工作，工作，工作，再工作，并期待能够看准几次机会。这个道理非常简单。而且根据我对彩池投注系统的观察和从其他地方得来的经验，这么做明显是正确的。&lt;/p&gt;

&lt;p&gt;我认为你们一生中不需要看准很多次。只要看看伯克希尔·哈撒韦及其累积起来的数千亿美元就知道了，那些钱大部分是由十个最好的机会带来的。而那是一个非常聪明的人——沃伦比我能干多了，而且非常自律——毕生努力取得的成绩。我并不是说他只看准了十次，我想说的是大部分的钱是从十个机会来的。&lt;/p&gt;

&lt;p&gt;第二个基本方法是本杰明·格拉汉姆使用的方法——沃伦和我十分欣赏这种方法。作为其中一个元素，格拉汉姆使用了私人拥有价值的概念，也就是说，应该考虑如果整个企业出售（给私人拥有者）的话，能够卖多少钱。在很多情况下，那是可以计算出来的。&lt;/p&gt;

&lt;p&gt;然后，你再把股价乘以股票的份数，如果你得到的结果是整个售价的三分之一或更少，他会说你买这样的股票是捡了大便宜。即使那是一家烂企业，管理者是个酗酒的老糊涂，每股的真实价值比你支付的价格高出那么多，这意味着你能得到各种各样的好处。你如果得到这么多额外的价值，用格拉汉姆的话来说，就拥有很高的安全边界&lt;/p&gt;

&lt;p&gt;你们要怎样买入这些伟大公司的股票呢？有一种方法是及早发现它们——在它们规模很小的时候就买进它们的股票。例如，在山姆·沃尔顿第一次公开募股的时候买进沃尔玛。许多人都努力想要这么做。这种方法非常有诱惑性。如果我是年轻人，我也会这么做的。但这种（投资起步阶段公司的）方法对伯克希尔·哈撒韦来讲已经没有用了，因为我们有了太多的钱。（采用这种方法的话，）我们找不到适合我们的投资规模的企业。此外，我们有我们的投资方法。但我认为，对于那些初出茅庐的人来说，要是配以自律，投资有发展潜力的小公司是一种非常聪明的办法。只不过我没那么做过而已。&lt;/p&gt;

&lt;p&gt;所以风险是存在的。没有什么顺理成章和轻而易举的事。但如果你们能够找到某个价格公道的伟大公司的股票，买进它，然后坐下来，这种方法将会非常非常有效——尤其是对个人投资者而言。&lt;/p&gt;

&lt;p&gt;你会发现一些定价过低的赚钱机会。确有人不会把商品价格定到市场能够轻易接受的高位。你们要是发现这样的情况，那就像在马路上看到钱一样——前提是你们有勇气相信自己的判断。&lt;/p&gt;

&lt;p&gt;许多人问我有没有傻瓜也能懂的办法，可以用来确保有足够的钱花或者不为退休后的生活发愁。我总是设法逃避这些问题。（编者：“但是这次，查理，你逃不掉啦。”）量入为出，养成储蓄的习惯。把存起来的钱放进一个延期纳税账户（taxdeferredaccount）。日积月累之后，它就会变成一大笔&lt;/p&gt;

&lt;p&gt;年轻人在工作中应该追求什么？我有三个基本原则。同时满足这三个原则几乎是不可能的，但你应该努力去尝试：·别兜售你自己不会购买的东西。·别为你不尊敬和钦佩的人工作。·只跟你喜欢的人同事。&lt;/p&gt;

&lt;p&gt;你对年轻人有什么人生建议吗？每天起床的时候，争取变得比你从前更聪明一点。认真地、出色地完成你的任务。慢慢地，你会有所进步，但这种进步不一定很快。但你这样能够为快速进步打好基础……每天慢慢向前挪一点。到最后——如果你足够长寿的话——像大多数人那样，你将会得到你应得的东西。&lt;/p&gt;

&lt;p&gt;人生在不同阶段会遇到不同的难题，非常棘手的难题。我认为有三点有助于应付这些困难：·期望别太高；·拥有幽默感；·让自己置身于朋友和家人的爱之中。最重要的是，要适应生活的变化。如果世界没有改变，我现在身上仍然会有12个缺陷。&lt;/p&gt;

&lt;p&gt;长久以来，我相信有某种方法——它是几乎所有聪明人都能掌握的——比绝大多数人所用的方法都有效。正如我在南加大商学院说过的，你们需要的是在头脑里形成一个由各种思维模型构&lt;/p&gt;

&lt;p&gt;成的框架。然后将你们的实际经验和间接经验（通过阅读等手段得来的经验）悬挂在这个强大的思维模型架上。使用这种方法可以让你们将各种知识融会贯通，加深对现实的认知。&lt;/p&gt;

&lt;p&gt;总之，人类发明了一种东西，以便弥补我们天生不擅长处理数字的缺陷，这种东西叫做图表。奇怪的是，它居然是在中世纪期间出现的。在中世纪的修道士发明的东西里，我认为惟一有价值的就是图表。图表以图形的方式把数字表现出来。它利用了你们的神经系统来帮助你们理解它。所以价值线公司（ValueLi&lt;/p&gt;

&lt;p&gt;严重的意识形态是最能扭曲人类认知的因素之一。看看这些宗教激进分子就知道了，他们用枪扫射一群希腊游客，嘴里还不停地大喊：“真主的杰作！”意识形态会让人做出一些古怪的举动，也能严重扭曲人们的认知。如果你们年轻时深受意识形态影响，然后开始传播这种意识形态，那么你们无异于将你们的大脑禁锢在一种非常不幸的模式之中。你们的普遍认知将会受到扭曲。&lt;br /&gt;
。但如果你们带着强烈的意识形态把自己的观点当作不可动摇的真理，那么我认为你们的想法是很愚蠢的。所以要警惕意识形态造成的思维紊乱。&lt;/p&gt;

&lt;p&gt;道德和涉及心理学的普世智慧考量的关系之密切，是再怎么强调也不为过&lt;/p&gt;

&lt;p&gt;：你如何在投资决策中应用心理学？我认为投资决策肯定没有那么简单，只要挑选每个人都看好的产品——比如可口可乐的股票——就行。毕竟投资界的聪明人很多，他们的思维方法明显跟你今天告诉我们的一样。当你在挑选成功企业的时候，你有考虑其他投资者在其投资思维中的失败吗？&lt;/p&gt;

&lt;p&gt;投资之所以困难，是因为人们很容易看出来有些公司的业务比其他公司要好。但它们股票的价格升得太高了，所以突然之间，到底应该购买哪只股&lt;br /&gt;
票这个问题变得很难回答。我们从来没有解决这个难题。在98%的时间里，我们对待股市的态度是……保持不可知状态。我们不知道。通用汽车的股价跟福特比会怎样？我们不知道。我们总是寻找某些我们看准了的、觉得有利可图的东西。我们看准的依据有时候来自心理学，更多时候来自其他学科。并且我们看准的&lt;br /&gt;
我们总是寻找某些我们看准了的、觉得有利可图的东西。我们看准的依据有时候来自心理学，更多时候来自其他学科。并且我们看准的次数很少——每年可能只有一两次。我们并没有一套万试万灵、可以用来判断所有投资决策的方法。我们使用的是一种与此完全不同的方法&lt;/p&gt;

&lt;p&gt;我们只是寻找那些不用动脑筋也知道能赚钱的机会。正如巴菲特和我经常说的，我们跨不过七英尺高的栏。我们寻找的是那些一英尺高的、对面有丰厚回报的栏。所以我们成功的诀窍是去做一些简单的事情，而不是去解决难题。&lt;/p&gt;

&lt;p&gt;问：你们的投资决策靠的是统计分析和眼光吗？当我们作出一项决策的时候，我们当然认为我们的眼光不错。有时候我们确实是因为统计分析才看好某个投资项目。不过，再说一遍，我们只发现了几个这样的机会。光有好机会是不够的，它们必须处在我们能看明白的领域，所以得在我们能看明白的领域出现定错价的机会。这种机会不会经常出现。但它不需要经常出现，如果你们等待好机会，并有勇气和力量在它出现的时候好好把握，你们需要多少个呢？以伯克希尔·哈撒韦最成功的10个投资项目为例。我们就算不投资其他项目，也会非常富裕——那些钱两辈子都花不完。所以，再说一次，我们并没有一套万试万灵、可以用来判断如果有，那就荒唐了。我只是给你们一种用来审视现实、以便获取少数可以作出理性反应的机会的方法而已。如果你们用这种方法去从事竞争很激烈的活动，比如说挑选股票，那么你们将会遇到许多出色的竞争对手。所以我们即使拥有这种方法，得到的机会也很少。幸运的是，那么少的机会也足够了。&lt;/p&gt;

&lt;p&gt;问：你似乎认为高科技行业更难经营——因为你说经营高科技企业需要特殊才能。但它们难道不是一样的吗？对我们来说，低科技企业的优势在于，我们认为我们对它的理解很充分。对高科技企业则不是这样的。我们宁愿与我们熟悉的企业打交道。我们怎么会放弃一种我们有很大优势的游戏，而去玩一种竞争激烈而我们又毫无优势，甚至可能处于劣势地位的游戏呢？你们每个人都必须搞清楚你们有哪方面的才能。你们必须发挥自己的优势。但如果你们想在较不擅长的领域取得成功，那你们的生活可能会过得一团糟。这一点我可以保证。如果不是这样的话，那你们肯定是中了彩票或者遇到其他非常走运的事情。&lt;/p&gt;

&lt;p&gt;问：沃伦·巴菲特说伯克希尔对一家航空公司的投资是一次典型的失败。你们怎么会作出那个错误的决定呢？&lt;br /&gt;
我可不希望你们误以为我们拥有任何可以使你们不犯很多错误的学习或行事方式。我只是说你们可以通过学习，比其他人少犯一些错误——也能够在犯了错误之后，更快地纠正错误。但既要过上富足的生活又不犯很多错误是不可能的。&lt;br /&gt;
实际上，生活之所以如此，是为了让你们能够处理错误。那些破产的人的通病是无法正确地处理心理否认。你们对某样东西投入了巨大的精力，对它倾注了心血和金钱。你们投入的越多，一贯性原理就越会促使你们想：“现在它必须成功。如果我再投入一点，它就会成功。”&lt;/p&gt;

&lt;p&gt;问：迪士尼收购大都会美国广播公司（CapitalCities）的时候，你们并没有套现，而是把大都会的股票换成了迪士尼的股票，能谈谈你是怎么考虑的吗？媒体上有报道说你曾经考虑收取现金。&lt;br /&gt;
迪士尼是自我催化的完美典范……他们拍摄了许多电影。他们拥有版权。电冰箱的出现极大地促进了可口可乐的发展，同样道理，当录像带被发明出来之后，迪士尼不需要发明任何新东西，它只要把摄制好的电影灌录成录像带就够了。每个父母和祖父母都希望自己的后代坐在家里看这些录像带。所以普通人的家庭生活所以普通人的家庭生活对迪士尼的发展起到了推波助澜的作用。这里面的市场高达数千亿美元。&lt;/p&gt;

&lt;p&gt;本杰明·格拉汉姆的重要著作《证券分析》（1934）《财务报告解读》（1937）《世界商品与世界货币》（1944）《聪明的投资者》（1949）《格雷厄姆：华尔街教父回忆录》&lt;/p&gt;

&lt;p&gt;每个人都必须根据他自己的资金状况和心理素质来玩这个游戏。如果亏损会让你变得很惨——有些亏损是不可避免的，你最好采用一种非常保守的投资模式，多存点钱。所以你必须根据自己的实际状况和才能来调整投资策略。我并不认为我能给你一种万金油式的投资策略。我的策略对我来说是有效的，但这部分是因为是因为我善于接受亏损。我的心理承受得了亏损。此外，我亏的次数并不多。这两种因素加起来，使得我的策略很有效&lt;/p&gt;

&lt;p&gt;是因为我善于接受亏损。我的心理承受得了亏损。此外，我亏的次数并不多。这两种因素加起来，使得我的策略很有效,&lt;br /&gt;
有人问他：“杰克，苹果到底做错了什么？”当时巴菲特也在场。韦尔奇是怎么回答的呢？他说：“我没有足够的能力来回答这个问题。”我想给你相同的答案。在这个领域我没有能力给你任何特殊的见解。&lt;br /&gt;
有些人总是很自信地回答他们其实并不了解的问题，我不喜欢跟他们在一起。在我看来，他们就像那只乱跳舞的蜜蜂，只会把整个蜂窝搞得乱哄哄的。&lt;/p&gt;

&lt;p&gt;从他的利益出发去说服他，很可能比从其他方面出发去说服他更有效。这也是一种有着极深的生物学根源的强大心理学原则。&lt;/p&gt;

&lt;p&gt;人类的大脑需要理由才能更好地理解事情。你们应该把现实悬挂在附带理由的理论结构之上。只有那样，你们才能成为一个有效的思考者。&lt;/p&gt;

&lt;p&gt;第一个有用的观念是，简化任务的最佳方法一般是先解决那些答案显而易见的大问题。第二个有用的观念跟伽利略的论断如出一辙。伽利略说，惟有数学才能揭示科学的真实面貌，因为数学似乎是上帝的语言。伽利略的看法在乱糟糟的日常生活中同样有用。如果缺乏数学运算能力，在我们大多数人所过的生活中，你们，你们将会像一个参加踢屁股比赛的独腿人。&lt;br /&gt;
第三个有用的观念是，光是正面思考问题是不够的，你必须进行反面思考。就像有个乡下人说过的，他要是知道他的死亡地点就好了，那他就永远不去那里。实际上，许多问题是无法通过正面思考来解决的。所以伟大的代数学家卡尔·雅各比经常说：“反过来想，总是反过来想。”毕达哥拉斯学派也同样通过逆向思考毕达哥拉斯学派也同样通过逆向思考证明“2的平方根是一个无理数”。&lt;/p&gt;

&lt;p&gt;第四个有用的观念是，最好的、最具有实践性的智慧是基本的学术智慧。但有一个极其重要的前提：你必须以跨学科的方式思考。你必须经常使用所有可以从各个学科的大一课程中学到的概念。如果能够熟练地掌握这些基本概念，你解决问题的方法将不会受到限制。由于各个学科和亚学科之间的壁垒极其森严，跨出划出划定的界线去研究其他学科被视为冒天下之大不韪的事情，所以学术界和许多商业机构解决问题的方法非常有限。你必须反其道而行，采用跨学科的思维方式，用本杰明·富兰克林的话来说，就是：“如果你想要完成，就自己着手去做。如果不想，就让别人去做。”&lt;/p&gt;

&lt;p&gt;第五个有用的观念是，真正的大效应，也就是lollapalooza效应，通常在几种因素的共同作用下才会出现。例如，多年以来，许多人的肺结核之所以能够治愈，是因为他们同时服用了三种药物。其他的lollapalooza效应，比如说飞机的飞行，也是遵守同样的模式。&lt;/p&gt;

&lt;p&gt;（1）巴甫洛夫条件反射，（2）强大的社会认同效应，（3）一种口感出色、提神醒脑、冰凉爽口、能够引起操作性条件反射的饮料，这三种因素产生的巨大合力将会让我们的销量在很长的时间内节节升高。这跟化学里面的自我催化反应差不多，这恰恰是我们需要的那种由多因素引发的lollapalooza效应，所以我们当然两种方法都会采用。我们也想要巨大的巴甫洛夫和社会认同效应，所以将会一直用大量的钱来做广告和促销活动，以四折的价格把糖浆卖给冷饮销售店。&lt;/p&gt;

&lt;p&gt;我们将会再次像雅各比那样进行反向思考。我们必须避开哪些我们不想遇到的情况呢？有四种情况明显是我们应该避免的：&lt;/p&gt;

&lt;p&gt;第一，我们必须避免消费者喝了饮料之后感到腻烦的情况，因为根据现代达尔文主义的理论，消费者一旦感到腻烦，其生理机制就会对我们的饮料产生抵抗作用，促使消费者不再继续消费它。为了达到我们的目标，我们必须让消费者在大热天一瓶接一瓶地喝我们的产品，完全不会因为觉得腻而不喝。我们将会通过实验找到一种很棒的、不会腻的味道，从而解决这个问题。&lt;/p&gt;

&lt;p&gt;第二，我们必须避免失去我们强大的商标名称的情况，哪怕失去一半也不行。例如，如果由于我们的疏忽，而造成市面上有一种某某可乐在销售，比如说一种“百比可乐”，那么我们将会蒙受惨重的损失。就算出现一种“百比可乐”，我们也应该是这个品牌的持有人。&lt;br /&gt;
第三，由于获得巨大的成功，我们必须避免妒忌产生的恶果。妒忌在十诫中占有显著的位置，因为它是人类的天性。亚里士多德说过，避免妒忌的最佳方法是做到名副其实。我们将会致力于提高产品的质量，制定合理的价格，以及为消费者提供无害的快乐。&lt;br /&gt;
第四，等到我们这个品牌的味道占领新市场之后，我们必须避免突然对产品的味道做出重大的改变。即使在双盲测试中，新的味道尝起来更好，换成那种新味道也是一种愚蠢的做法。因为经过上述努力之后，我们原有的味道将会深入人心，成为消费者的偏好，改变味道对我们根本没有好处。那么做会在消费者中引发标发标准的剥夺性超级反应综合征&lt;/p&gt;

&lt;p&gt;“傻瓜徒有想像力，而缺乏知识；学究空有知识，但缺乏想像力。”“真正的勇气并非庸俗英雄的野蛮暴力，而是美德和理性的坚定决心。”&lt;/p&gt;

&lt;p&gt;由于这个原因和其他原因，我们对飞行员的训练，是依照一个严格的六要素系统进行的。这六种要素包括：&lt;/p&gt;

&lt;p&gt;1.要教给他足够全面的知识，让他能够熟练地掌握飞行中用得到的一切知识。&lt;br /&gt;
2.把这些知识统统教给他，不仅是为了让他能够通过一两次考试，而是为了让他能够熟练地应用这些知识，甚至能够同时处理两三种相互交织的复杂的危险情况。&lt;br /&gt;
3.就像任何一个优秀的代数学家，他要学会有时候采用正向思维，有时候采用逆向思维，这样他就能够明白什么时候应该把主要的注意力放在他想要的那些事情上，而什么时候放在他想要避免的那些情况上。&lt;br /&gt;
4.他必须接受各门学科的训练，力求把他未来因为错误操作而造成损失的可能性降到最低；最重要的操作步骤必须得到最严格的训练，达到最高的掌握水平。&lt;br /&gt;
5.他必须养成核对“检查清单”的习惯。&lt;br /&gt;
6.在接受最初的训练之后，他必须常规性地保持对这些知识的掌握：经常使用飞行模拟器，以免那些应付罕见重要问题的知识因为长期不用而生疏。&lt;br /&gt;
因而下面的道理是不证自明的：在试图把优秀学生培养成优秀人才的精英教育中，如果想要得到最佳的结果，我们必须让学生学习大量的跨学科知识，持久地掌握能够应用自如的所有必要技能，拥有根据实际情况综合熟练使用各种知识的能力，，以及证明代数问题用到的那些正向思考和逆向思考的技巧，再加上核对“检查清单”的终身习惯。若要获取全面的普世智慧，没有别的办法，更没有捷径。这个任务涵盖的知识面特别广，乍看之下令人望而生畏，似乎是不可能完成的。&lt;/p&gt;

&lt;p&gt;学生应该有更多用跨学科的知识解决问题的实践机会，包括一些像驾驶飞行模拟器那样的机会，以免掌握的技能由于长期不用而遗忘。让我来举个例子。我隐约记得，许多年前，哈佛商学院有个教授非常聪明，但是有点离经叛道，他给学生上的课很有意思。&lt;/p&gt;

&lt;p&gt;有一次，这位教授的考试题目是这样的：有两位不问世事的老太太刚刚继承了新英格兰地区一家鞋厂，这家鞋厂专门制造名牌皮鞋，现在生意上遇到一些严重的问题。教授详细地介绍了这些问题，并给学生充足的时间写下给两位老太太的建议 几乎每个学生的答案都被判不及格，但教授给一位聪明的学生很高的分数。那么得到高分的学生的答案是什么样的呢？答案非常短，大概是下面这样：“这家企业所在的行业和所处的地方竞争都很激烈，，再加上当前遇到的问题非常棘手，两位不问世事的老太太通过聘请外人来解决问题不是明智的做法。考虑到问题的难度和无法避免的代理成本，两位老太太应该尽快卖掉这家鞋厂，最好是卖给那家拥有最大边际效应优势的竞争对手, 。”因而，这个高分学生作答的根据并非当年商学院传授的知识，而是一些更为基本的概念，比如说代理成本和边际效应，它们分别来自本科生的心理学和经济学课程&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;大多数软科学专业学院应该更多地使用最好的商业刊物，比如说《华尔街日报》《福布斯》《财富》等等。这些刊物现在都非常好，可以承担飞行模拟器的功能：它们报道的那些事件往往有错综复杂的原因，我们可以让学生试着用各个学科的知识来加以分析&lt;/strong&gt; 在商业界，我认识的那些判断能力非常强的人，他们也都用这些刊物来维持他们的智慧。学术界有什么理由例外呢？&lt;/p&gt;

&lt;p&gt;硬科学的基本治学精神与方法:&lt;br /&gt;
这种治学精神与方法值得效仿。毕竟，硬科学在如下两方面做得更好：（1）避免单一学科造成的错误；（2）使得大量跨学科知识更容易被应用，并时常获得良好的结果，比如物理学家理查德·费曼就能够用一只橡皮环解释挑战者号航天飞机爆炸的原因。而且以前软科学也曾借鉴这种治学精神与方法，取得了很好的效果。&lt;br /&gt;
1.你们必须依照基础性给各个学科排序，并按照顺序使用它们。&lt;br /&gt;
2.不管是否喜欢，你们必须熟练掌握并且经常使用这四门基础学科最重要的内容，而且对于那些比你们自己的学科更加基础的学科，要给予特别的关注。&lt;br /&gt;
3.在吸收不同学科的知识时，要弄清楚那些知识是怎么来的，而且不要背离“经济原则”，只要有可能，首先通过自己或其他学科中更为基本的原理对现象进行解释&lt;br /&gt;
4.但是如果第3步并没有对现象解释提供有用的新观点，你们可以通过提出假设和进行验证确立新的原理，就像旧的原理创建的方式一样。但你们不能使用任何与旧的原理冲突的新原理，除非你们能够证明旧的原理是错误&lt;br /&gt;
你们将会发现，与当前软科学常见的做法相比，硬科学的这种基本治学精神与方法更为严格。这让我们想起了飞行员训练。飞行员训练能够取得极大的成功，绝对不是偶然的。现实是最好的老师。跟飞行员训练的情况一样，硬科学的治学精神与方法不是“拿来主义”，而是“不管是否喜欢都必须熟练地掌握”。跨学科知识的合理组织模式应该是这样的：（1）必须完全弄清楚所有知识的原始出处；（2）必须把更基本的解释放在第一位。&lt;/p&gt;

&lt;p&gt;如果真理和一个人的利益背道而驰，那么这个人就很难接受真理。如果这个问题是高等学校的激励机制引起的，那么解决的方法很简单——因为激励机制是可以被改变的&lt;/p&gt;

&lt;p&gt;聪明人怎么会经常犯错呢？他们并没有做到我让你们做的事情：使用一张检查清单，确保你们掌握了所有的主要模型，并以一种多元的方式使用它们。——芒格&lt;/p&gt;

&lt;p&gt;了四种基本的检查清单&lt;/p&gt;

&lt;p&gt;1.双轨分析&lt;br /&gt;
·理性地看，哪些因素真正主导了牵涉到的利益？（例如，宏观的和微观的经济因素。）&lt;br /&gt;
·当大脑处于潜意识状态时，有哪些潜意识因素会自动以各种方式形成虽然有用但往往失灵的结论？（本能、情绪、贪婪等等的影响）&lt;br /&gt;
2.投资和决策检查清单&lt;br /&gt;
·查理的非正式检查清单，详细地列出了各种值得考虑的因素。&lt;br /&gt;
3.超级简单的普通观念&lt;br /&gt;
·先解决那些答案显而易见的问题。·利用数学运算能力。·逆向思考（反过来考虑问题）。·应用基本的跨学科智慧，永远不要完全依赖他人。·注意多种因素的共同作用——也就是lollapalooza效应&lt;/p&gt;

&lt;p&gt;4.基于心理学的倾向&lt;br /&gt;
·他那著名的人类误判的25个标准原因。&lt;/p&gt;

&lt;p&gt;有效市场”理论恰好相反。你们那些误人子弟的教授太过信奉经济学中的“理性人”假设，对心理学中的“非理性人”理论则所知甚少，也缺乏实际的生活经验。人类跟旅鼠一样，在某些情况下都有“集体非理性”的倾向。这种倾向导致聪明人产生了许多不理智的想法，做了许多不理智的行为&lt;/p&gt;

&lt;p&gt;“让人们去理解那些跟他们的利益冲突的事情是很难的。”&lt;/p&gt;

&lt;p&gt;：“如果你想要说服别人，要诉诸利益，而非诉诸理性。”&lt;br /&gt;
，如果你们想要改变别人的想法，要诉诸利益，而非诉诸理性&lt;/p&gt;

&lt;p&gt;依照这种治学方法，你必须领悟所有比你自己的学科更加基础的学科的所有重要思想。只有掌握了那些最基础的知识和原理，你们才能够清清楚楚地解释问题。而且你们要永远承认你们所用的基础知识来自哪个学科；当你们使用物理学的时候，你们要说你们是在使用物理学。当你们使用生物学的时候，你们要说你们是在使用生物学。诸如此类。我很早就明白这种治学方法能够让我的思想变得有条有理。我强烈怀疑它在软科学领域，也会像在硬科学领域那么有效，所以我就就抓起它，终生把它用于软科学领域和硬科学领域。对我来说，这是个非常幸运的想法。&lt;/p&gt;

&lt;p&gt;经济学总是比其他软科学更加强调跨学科研究: 机会成本是一种超级力量，所有希望获得正确答案的人都可以使用。还有，激励机制也是一种超级力量。&lt;br /&gt;
最后还有“公用品悲剧”的原理，&lt;/p&gt;

&lt;p&gt;经济学有哪些缺陷呢？&lt;br /&gt;
1.致命的自闭，导致“铁锤人综合征”，通常会引起经济学家过度强调某些可以量化的因素。&lt;br /&gt;
你们不能只拥有一把铁锤，你们必须拥有所有的工具。你们拥有的方法必须不止一种。你们在使用这些工具的时候，应该把它们列成一张检查清单，因为如果指望在需要的时候合适的工具会自动冒出来，那么你们将会错过很多好机会。但如果你们掌握了所有的工具，并在头脑中把它们排列成一张检查清单，那么你们将将会错过很多好机会。但如果你们掌握了所有的工具，并在头脑中把它们排列成一张检查清单，那么你们将会得到许多用其他方法得不到的答案。所以弥补这种让阿尔弗雷德·诺斯·怀特海感到十分苦恼的缺陷是非常重要的，有些思维窍门能够帮助你们完成这项工作&lt;br /&gt;
2.没有采用硬科学基本的全归因治学方法。&lt;br /&gt;
曼昆研究经济学的方式的错误之处在于，他吸收了其他学科的知识，却没有指出这些知识的来源。他并没有给他借鉴的知识贴上物理学或者生物学或者心理学或者博弈论或者其他这些知识所属的学科的标签，并没有完全指出这些基础知识的来源。如果你不这么做，那就像经营企业时使用了一种糟糕的文档归类方法。这削弱了你的能力，让你无法做最好的自己。现在呢，曼昆十分聪明，所以虽然他的方法不完善，但还是做得很出色。他取得的进展比其他任何教科书作者都大。但要是采用了向来给我很大帮助的硬科学的治学&lt;br /&gt;
3.物理学妒忌。&lt;br /&gt;
采用有效市场理论教条是物理学妒忌给经济学造成的恶果之一。&lt;br /&gt;
我认为经济学可以避免许多由物理学妒忌引起的这种麻烦。我是希望经济学采用硬科学的基本治学方法，养成指明其借鉴知识的来源的习惯，但我并不希望它由于物理学妒忌而渴望一种无法达到的准确度. 。大体上来说，那种包括波尔茨曼常数在内的准确而可靠的公式是不可能在经济学中出现的。经济学涉及的系统太过复杂。渴望做到物理学那么精确不会给你们带来任何好处，只会让你们陷入麻烦之中，就像麦肯锡那个可怜的傻瓜。&lt;br /&gt;
犯的错误还要糟糕。所以呢，经济学应该模仿物理学的基本治学方法，但是永远不应该追求像物理学公式那么准确的理论&lt;br /&gt;
4.太过强调宏观经济学。&lt;br /&gt;
经济学界太过强调宏观经济学，而对微观经济学的重视程度不够。我认为这是错误的&lt;/p&gt;

&lt;p&gt;5.经济学的综合太少。&lt;br /&gt;
你们懂得在一般情况下，当你们提高商品的价格，这种商品的销量就会下跌；当你们降低价格，销量就会上升。对吧？你们学过这个理论吧？”他们全都点头表示同意。然后我说：“现在向我举几个例子，说明你们要是想提高销量，正确的做法是提高价格。”他们沉默了非常久。在我提出这个问题的两所商学院里，也也许50个人里面只有一个人能够举出一个例子。他们认为，在特定的条件下，人们会认为价格较高的商品质量也较好，所以提高价格能够促进销售。&lt;br /&gt;
1.奢侈品：提高价格能够改善奢侈品的“炫耀”功能&lt;br /&gt;
2.非奢侈品：和上面提到的第二个因素相同，消费者看到价格更高的商品，往往不是认为它卖贵了，而是认为更高的价格意味着更好的质量。这种办法对那些耐用性的工业品而言尤为适用。&lt;br /&gt;
3.提高价格，把额外的利润以合法的方式用于改善产品的性能或者改善销售系统。&lt;br /&gt;
4.提高价格，把额外的利润以非法或者不道德的方式来促进销售，比如说通过贿赂交易经纪人，或者其他对终端消费者有害的做法——例如开放式基金的销售回扣。&lt;/p&gt;

&lt;p&gt;第一个是李嘉图提出的贸易中的比较优势原理，另外那个是亚当·斯密的图钉工厂。当然，这两者都能极大地提高人均经济产出，都能将各种职能分配到那些非常善于执行这些职能的人手里。然而，它们也有很大的差别：前者——图钉工厂——是中央计划的极端典型，它的整个系统是由某个人设计出来的；而后者，也，也就是李嘉图的相对优势，则完全是自发的国际贸易自动产生的后果。&lt;br /&gt;
6.对心理学的极度无知及其造成的负面后果。&lt;br /&gt;
我下面来谈谈某个拉丁美洲国家是如何整顿停滞不前的经济的。那是拉丁美洲的一个小国家，这个国家偷盗成风，所有人都喜欢行窃。他们挪用公司的公款；他们偷走社区里一切能弄到手的东西。经济自然停滞不前。但这个问题被解决了。这个案例我是在哪里看到的呢？我愿意给你们一点提示。它并不在经济学刊物上，我是在心理学刊物上看到这个案例的。那个国家出现了一些聪明人，他们使用了一些心理学方法，然后就解决了这个问题。&lt;br /&gt;
7.对二级或者更高级别的效应关注太少。&lt;br /&gt;
对二级或者更高级别的效应关注太少。这个缺陷是相当容易理解的，因为结果会产生结果，而结果的结果也会产生结果。这变得非常复杂。以前我是一名气象学家，这种现象让我感到非常苦恼。不过和经济学相比，气象学的问题太过简单了。&lt;/p&gt;

&lt;p&gt;现在让我们来看看二级和更高级别的后果。如果美国和中国进行贸易，那么美国人的生活水平会得到改善，对吧？李嘉图证明了这一点。但哪个国家的经济会发展得更快呢？那显然是中国。在自由贸易的推动之下，他们吸收了世界上各种现代科技，而且正如亚洲四小龙已经证明的，他们很快就会走到前面去。看看中国的香港和台湾，看看早年的日本。所以最开始的时候，和你们进行贸易的是一个有十几亿落后农民的弱小国家，但到最后这个国家变得比你们的国家更加强大，甚至可能还拥有更多和更好的原子弹。李嘉图并没有证明原来领先的国家会得到这么美好的下场。他并没有试图去确定二级和更高级别的后果。，&lt;/p&gt;

&lt;p&gt;8.对“捞灰金”的概念关注太少。&lt;br /&gt;
9.对美德效应和恶行效应不够重视。&lt;br /&gt;
：对经济生活中的美德效应和恶行效应不够重视。我很早就清楚地知道，经济生活中有巨大的美德效应，也有巨大的恶行效应。但如果你们跟经济学家谈起美德和恶行，他们会感到浑身不自在。因为美德和恶行无法用大量的数据图标来表示。&lt;br /&gt;
极端的诚信精神能够让经济系统运转得更好。&lt;/p&gt;

&lt;p&gt;对于复杂适应系统以及人类大脑而言，如果采用逆向思考，问题往往会变得更容易解决&lt;/p&gt;

&lt;p&gt;另外一个要避免的是极端强烈的意识形态&lt;br /&gt;
妒忌、怨憎、仇恨和自怜都是灾难性的思想状态, 因为自怜是一种标准的反应。你们可以通过训练来摆脱它。&lt;br /&gt;
你们当然也要在你们的思维习惯中消除自我服务的偏好。别以为对你们有利的就是对整个社会有利,也别根据这种自我中心的潜意识倾向来为你们愚蠢或邪恶的行为辩解，那是一种可怕的思考方式。你们要让自己摆脱这种心理，因为你们想成为智者而不是傻瓜，想做好人而不是坏蛋。你们也必须在你们自己的认知和行动中允许别人拥有自我服务的偏好，因为大多数人将无法非常成功地清除这种心理。人性就是这样。如果你们不能容忍别人在行动中表现出自我服务的偏好，那么你们又是傻瓜。&lt;/p&gt;

&lt;p&gt;：“如果你想要说服别人，要诉诸利益，而非诉诸理性。”人类自我服务的偏好是极其强大的，应该被用来获得正确的结果。&lt;br /&gt;
另外一种应该避免的事情是受到变态的激励机制的驱动: 你们不要处在一个你们表现得越愚蠢或者越糟糕，它就提供越多回报的变态激励系统之中。变态的激励机制具有控制人类认知和人类行为的强大力量，人们应该避免受它影响。&lt;br /&gt;
变态的工作关系也是应该避免的。你们要特别避免在你们不崇敬或者不想像他一样的人手下干活，要不然那是很危险。我们所有人在某种程度上都受到权威人物的控制，尤其是那些为我们提供回报的权威人物。要正确地对付这种危险的&lt;/p&gt;

&lt;p&gt;你们不应该光是掌握广泛的基础知识，而是应该把它们在头脑中列成一张检查清单，然后再加以使用。没有其他方法能够取得相同的效果。&lt;br /&gt;
如果你们真的想要在某个领域做得很出色，那么你们必须对它有强烈的兴趣。我可以强迫自己把许多事情做得相当好，但我无法将我没有强烈兴趣的事情做到非常出色。&lt;br /&gt;
还有就是，你们一定要非常勤奋才行。我非常喜欢勤奋的人&lt;br /&gt;
另外一个你们要应付的问题是，你们在生活中可能会遭到沉重的打击，不公平的打击。有些人能挺过去，有些人不能。&lt;/p&gt;

&lt;p&gt;爱比克泰德的道德观&lt;/p&gt;

&lt;p&gt;控制你的情欲，以免它们报复你。&lt;br /&gt;
别根据你的愿望来要求现实，应该依据现实来确定你的愿望。说话之前，先理解你要说的话。智者不为他缺少的东西悲哀，而为他所拥有的东西高兴。&lt;br /&gt;
如果你想要进步，别在意别人觉得你很愚蠢。自以为什么都懂的人不可能开始学习。你遇到什么事并不重要，重要的是你做出了什么反应。凡事尽力而为，别计较结果。&lt;br /&gt;
人若控制不了自己，自由便无从谈起。唯有受过教育的人是自由的。困扰人们的并非事物，而是他们对事物的看法。要和那些比你优秀的人为伴，他们能促使你做到最好。富裕并非拥有许多财产，而是拥有很少需求。&lt;/p&gt;

&lt;h2 id="人类误判心理学"&gt;人类误判心理学&lt;/h2&gt;
&lt;h3 id="目录"&gt;目录&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;奖励和惩罚超级反应倾向&lt;/li&gt;
  &lt;li&gt;喜欢/热爱倾向&lt;/li&gt;
  &lt;li&gt;讨厌/憎恨倾向&lt;/li&gt;
  &lt;li&gt;避免怀疑倾向&lt;/li&gt;
  &lt;li&gt;避免不一致性倾向&lt;/li&gt;
  &lt;li&gt;好奇心倾向&lt;/li&gt;
  &lt;li&gt;康德式公平倾向&lt;/li&gt;
  &lt;li&gt;艳羡/妒忌倾向&lt;/li&gt;
  &lt;li&gt;回馈倾向&lt;/li&gt;
  &lt;li&gt;受简单联想影响的倾向&lt;/li&gt;
  &lt;li&gt;简单的、避免痛苦的心理否认&lt;/li&gt;
  &lt;li&gt;自视过高的倾向&lt;/li&gt;
  &lt;li&gt;过度乐观倾向&lt;/li&gt;
  &lt;li&gt;被剥夺超级反应倾向&lt;/li&gt;
  &lt;li&gt;社会认同倾向&lt;/li&gt;
  &lt;li&gt;对比错误反应倾向&lt;/li&gt;
  &lt;li&gt;压力影响倾向&lt;/li&gt;
  &lt;li&gt;错误衡量易得性倾向&lt;/li&gt;
  &lt;li&gt;不用就忘倾向&lt;/li&gt;
  &lt;li&gt;化学物质错误影响倾向&lt;/li&gt;
  &lt;li&gt;衰老——错误影响倾向&lt;/li&gt;
  &lt;li&gt;权威——错误影响倾向&lt;/li&gt;
  &lt;li&gt;废话倾向二十四、重视理由倾向&lt;/li&gt;
  &lt;li&gt;lollapalooza倾向——数种心理倾向共同作用造成极端后果的倾向&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="奖励和惩罚激励"&gt;奖励和惩罚激励&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;激励机制引起的偏见:
    &lt;ol&gt;
      &lt;li&gt;有的人因为受过教育而变得道德高尚，然而在激励机制的驱动之下，他可能会有意或者无意地做出一些不道德的行为以便得到他想要的东西，而且他还会为自己的糟糕行为寻找借口&lt;/li&gt;
      &lt;li&gt;人们倾向于钻各种制度的空子: 激励机制引起的偏见的另外一个常见后果是，人们倾向于钻各种制度的空子，他们往往在损人利己方面表现得极有创意。制度设计还需要遵守如下的原则：尽量避免奖励容易作假的事情。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;当然，现在驱使人们行动的主要奖励是金钱。只要一个毫无实质价值的筹码能够固定换到一根香蕉，那么人们就可以对猴子进行训练，让它为了筹码而工作，仿佛筹码就是香蕉一样。同样道理， 虽然在各种奖励中金钱是最主要的，但它并非是惟一有效的奖励。人们也会为了性、友谊、伴侣、更高的地位和其他非金钱因素而改变他们的行为和认知。&lt;/li&gt;
  &lt;li&gt;惩罚也强烈地影响到行为和认知，尽管它的弹性和效果不像奖励那么好。&lt;/li&gt;
  &lt;li&gt;如何避免、应用： 主要是政策制定者 应该避免错误的 奖励惩罚机制。会引导人们错误的行文风气。比如 容易偷窃的环境、过轻的刑法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="喜欢热爱倾向"&gt;喜欢/热爱倾向&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;促使人们：1）忽略其热爱对象的缺点，对其百依百顺；2）偏爱那些能够让自己联想起热爱对象的人、物品和行动（这一点我们将会在“受简单联想影响的倾向”中讨论）；（3）为了爱而扭曲其他事实&lt;/li&gt;
  &lt;li&gt;反馈模式: 喜欢/热爱会引发倾慕，反之亦然。倾慕也会引起并且强化喜欢/热爱倾向。这种“反馈模式”一旦形成，通常会造成极端的后果，有时候会促使人们为了帮助自己心爱的人而不惜故意自我毁灭。&lt;/li&gt;
  &lt;li&gt;喜欢/热爱和倾慕交织在一起并相互作用往往在许多和男女情感无关的领域具有巨大的现实意义。例如，一个天生热爱值得敬仰的人和思想的人在生活中拥有巨大的优势。&lt;/li&gt;
  &lt;li&gt;如何避免、应用： 及早的识别、远离错误影响的人， 亲近正确的影响的人，为 自己崇拜、道德高尚的人工作、学习。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="讨厌憎恨倾向"&gt;讨厌/憎恨倾向&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;陷其中的人们：1) 忽略其讨厌对象的优点；2) 讨厌那些能够让自己联想起讨厌对象的人、物品和行动；3）为了仇恨而扭曲其他事实。
    &lt;blockquote&gt;
      &lt;p&gt;这种扭曲往往很极端，导致人们的认知出现了极大的偏差。当世贸中心被摧毁的时候，许多巴基斯坦人立刻认为是印度人干的，而许多穆斯林则认为是犹太人干的。这种致命的扭曲通常使得相互仇视的双方很难或者不可能握手言和。以色列和巴勒斯坦之间很难和解，因为一方历史中记载的事实与另外一方历史中记载的的事实与另外一方历史中记载的事实大相径庭，很少有相同之处&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;如何避免、应用： 理性的看待问题，反过来想，总是反过来想&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="避免怀疑倾向"&gt;避免怀疑倾向&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;人类的大脑天生就有一种尽快作出决定，以此消除怀疑的倾向。&lt;/li&gt;
  &lt;li&gt;人类通过尽快作出决定来消除怀疑的倾向十分明显，所以法官和陪审团必须采用抵制这种倾向的行为。他们不能立刻作出判决，而是必须经过慎重的考虑&lt;/li&gt;
  &lt;li&gt;如何避免、应用：设立决策的检查清单。 总过检查犯错误的清单&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="避免不一致性倾向保持习惯-跟过往行为一致"&gt;避免不一致性倾向(保持习惯， 跟过往行为一致)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;防止一种习惯的养成要比改变它容易得多: 在生活中维持许多好习惯，避免或者戒除许多坏习惯，这样的生活才是明智的。 富兰克林的《穷理查年鉴》：“一盎司的预防比一磅的治疗更值钱。”由于避免不一致性倾向的存在，防止一种习惯的养成要比改变它容易得多。&lt;/li&gt;
  &lt;li&gt;大脑的抗改变倾向还使得人们倾向于保留如下几种东西的原样：以前的结论、忠诚度、身份、社会认可的角色等等。&lt;/li&gt;
  &lt;li&gt;对社会的良好的影响: 例如，大多数人在生活中不会表现出与他们的公共责任、新的或旧的公共认同等不一致的行动，而是会忠于职守，扮演好牧师、医生、公民、士兵、配偶、教师、职员等角色。&lt;/li&gt;
  &lt;li&gt;避免不一致性倾向造成的结果之一是，人们在获取新身份的过程中作出的重大牺牲将会提高他们对这种新身份的忠诚度。毕竟，如果他们认为某样东西并不好，却又为之作出重大牺牲，那他们的行为将会显得和他们的思想很不一致。所以文明社会发明了许多庄严肃穆的入会仪式，这些仪式通常是公开举行的，能够让新新成员更加忠心。&lt;/li&gt;
  &lt;li&gt;如何避免、应用： 理性的看待问题，过检查清单，如果犯错误，及时纠正&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="好奇心倾向"&gt;好奇心倾向&lt;/h3&gt;
&lt;h3 id="康德式公平倾向对现代文明具有重要的意义譬如排队"&gt;康德式公平倾向（对现代文明具有重要的意义，譬如排队）&lt;/h3&gt;

&lt;p&gt;如果所有人都遵守这些方式，那么就能够保证社会制度对每个人来说都是最好的。应该说，在现代社会，每个有文化的人都表现出并期待从别人那里得到康德所定义的这种公平&lt;br /&gt;
  过去300年来，奴隶制度在世界各地基本上被废除了，这是很有意思的事情，因为在此之前，奴隶制度已经和各大宗教共存了几千年。我认为康德式公平倾向是促成这种结果的主要因素。&lt;br /&gt;
  此外，在现代的文明社会中，陌生人之间有文明排队的习惯，这样所有人都能按照“先来后到”的规矩得到服务。&lt;/p&gt;

&lt;h3 id="羡慕妒忌倾向"&gt;羡慕/妒忌倾向&lt;/h3&gt;

&lt;p&gt;犹太文明认为这种心理倾向是极其邪恶的，摩西诫律一条又一条明令禁止妒忌。这位先知甚至警告人们不要去贪图邻人的驴子。&lt;br /&gt;
  兄弟姐妹之间的妒忌明显是非常强大的，并且儿童往往比成年更容易妒忌自己的兄弟姐妹。这种妒忌通常比因陌生人而发的妒忌更加强烈。这种结果也许是康德式公平倾向造成的。&lt;br /&gt;
  驱动这个世界的不是贪婪，而是妒忌。&lt;/p&gt;

&lt;h3 id="回馈倾向投桃报李-以牙还牙"&gt;回馈倾向(投桃报李， 以牙还牙)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;化解过激的敌意的标准方法是，人们可以延迟自己的反应&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;作为现代社会繁荣的主要推动因素，商业贸易也得到人类投桃报李的天性的很大帮助。利己利人的原则和回馈倾向相结合，会引起许多有建设性的行为。作为现代社会繁荣的主要推动因素，商业贸易也得到人类投桃报李的天性的很大帮助。利己利人的原则和回馈倾向相结合，会引起许多有建设性的行为。&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;和激励机制、避免不一致性倾向共同促成了以下结果：1）人们履行在交易中作出的承诺，包括在婚礼上作出的忠于对方的承诺；2）牧师、鞋匠、医生和其他所有职业人士恪守职责，做出正确的行为。&lt;/li&gt;
  &lt;li&gt;聪明的雇主试图压制从事采购工作的职员的回馈倾向。最简单的对策最有效：别让他们从供应商那里得到任何好处。 最简单的对策最有效：别让他们从供应商那里得到任何好处。山姆·沃尔顿（注：山姆·沃尔顿，1918——1992，美国零售商沃尔玛公司的创办人）赞同这种彻底禁止的思想。他不允许采购员从供应商那里接受任何东西，哪怕是一个热狗也不行。考虑到大多数回馈倾向是在潜意识层面发挥作用，沃尔顿的政策是非常正确的。(类似长城汽车？)
    &lt;blockquote&gt;
      &lt;p&gt;回馈倾向给人类带来的贡献远远比它造成的破坏要多。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="受简单联想影响的倾向"&gt;受简单联想影响的倾向&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;条件反射的另一种(将之前的结论，不加思考的应用于现在的情景中)： 由简单的联想引发的反射行为。例如，许多人会根据从前的生活经验得到这样的结论：如果有几种同类产品同时在出售，价格最高的那种质量最好。有的普通工业品销售商明白这个道理，于是他通常会改变产品的外包装，把价格提得很高，希望那些追求高质量的顾客会因此而上当，纯粹由纯粹由于他的产品及其高价格引起的联想而成为购买者。这种做法通常对促进销量很有帮助，甚至对提高利润也很有作用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;若要避免受到对从前之成功的简单联想误导，请记住下面这段历史。拿破仑和希特勒的军队在其他地方战无不胜，于是他们决定侵略俄罗斯，&lt;/li&gt;
  &lt;li&gt;避免因为过去的成功而做蠢事的正确对策是：
    &lt;ol&gt;
      &lt;li&gt;谨慎地审视以往的每次成功，找出这些成功里面的偶然因素，以免受这些因素误导，从而夸大了计划中的新行动取得成功的概率；&lt;/li&gt;
      &lt;li&gt;看看新的行动将会遇到哪些在以往的成功经验中没有出现的危险因素。的危险因素。
        &lt;blockquote&gt;
          &lt;p&gt;在《穷理查年鉴》中，富兰克林提议：“结婚前要睁大双眼看清楚，结婚后要睁一只眼闭一只眼。”也许这种“睁一只眼闭一只眼”的方法是正确的，但我喜欢一种更难做到的办法：“实事求是地看清现实，可还是去爱。&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;憎恨和讨厌也会造成由简单联想引起的认知错误。在企业界，我常常看到人们贬低他们讨厌的竞争对手的能力和品德。这是一种危险的做法，通常不易察觉，因为它是发生在潜意识层面的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;正确的对策是有意识地，养成欢迎坏消息的习惯。伯克希尔有一条普遍的规矩：“有坏消息要立刻向我们汇报。只有好消息是我们可以等待的。”还有就是要保持明智和消息灵通，那就是让人们知道你有可能从别处听说坏消息，这样他们就不敢不把坏消息告诉你了&lt;/li&gt;
  &lt;li&gt;受简单联想影响的倾向通常在消除以德报德的自然倾向方面有惊人的效果. 由于施惠的举动让受惠者联想起自身的不幸遭遇，受惠者不但会讨厌那个帮助他的人，还会试图去伤害他。。除此之外，受惠者可能会妒忌施惠者优越的处境，从而讨厌施惠者。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="简单的避免痛苦的心理否认"&gt;简单的、避免痛苦的心理否认&lt;/h3&gt;
&lt;p&gt;对化学物质的依赖通常会导致道德沦丧，成瘾的人倾向于认为他们的处境仍然很体面，仍然会有体面的前途。因此，他们在越来越堕落的过程中，会表现得极其不现实，对现实进行极端的否认。。人们应该避免任何有可能养成化学物质依赖性的行为。由于这种依赖性会造成极大的伤害，所以哪怕只有很少的概率会染上，也应该坚决避免。&lt;/p&gt;

&lt;h3 id="自视过高的倾向"&gt;自视过高的倾向&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;自视过高的人比比皆是: 这种人会错误地高估自己，就好像瑞典有90%的司机都认为他们的驾驶技术在平均水平之上。这种误评也适用于人们的主要“私人物品”。人们通常会过度称赞自己的配偶。人们通常不会客观地看待自己的孩子，而是会给出过高的评价。&lt;/li&gt;
  &lt;li&gt;人们一旦拥有某件物品之后，对该物品的价值评估就会比他们尚未拥有该物品之前对其的价值评估要高。这种过度高估自己的私人物品的现象在心理学里面有个名称：“禀赋效应”。人们作出决定之后，就会觉得自己的决定很好，甚至比没作出这种决定之前所认为的还要好。&lt;/li&gt;
  &lt;li&gt;现代生活中有一些非常糟糕的派系群体，它们被一群自视过高的人把持，并只从那些和他们非常相似的人中挑选新成员，现代生活可能就会出现一些非常糟糕的结果。&lt;br /&gt;
 而机构化解这种“托尔斯泰效应”的对策是：（1）建设一种公平的、唯才是用的、要求严格的文化，外加采用能够提升士气的人力资源管理方法；（2）开除最糟糕的不守规矩者。当然啦，如果你不能开除，比如说你不能“开除”你的孩子，你必须尽最大努力去帮助这个孩子解决问题。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;自然了，各种形式的自视过高都会导致错误。怎么能不会呢？&lt;br /&gt;
自视过高往往会导致糟糕的雇佣决定，因为大部分雇主高估了他们根据面试印象所得结论的价值。防止这种蠢事的正确对策是看轻面试的印象，看重求职者以往的业绩。&lt;br /&gt;
人们应该试图面对两个事实：（1）如果一个人能够改正糟糕的表现，却没有去改正，而是给自己找各种各样的借口，那他就是品德有问题，而且将会遭受更多的损失&lt;br /&gt;
（2）在要求严格的地方，比如说田径队或者通用电气，如果一个人不做出应有的表现，而是不停地找借口，那么他迟早肯定会被开除。&lt;/p&gt;

&lt;p&gt;虽然自视过高通常会给认知带来负面的影响，但也能引起某些离奇的成功，因为有时过度自信刚好促成了某项成功。这个因素解释了下面这句格言：“千万别低估那些高估自己的人。&lt;/p&gt;

&lt;h3 id="被剥夺超级反应倾向"&gt;被剥夺超级反应倾向：&lt;/h3&gt;
&lt;p&gt;一个人从10美元中得到的快乐的分量，并不正好等于失去10美元给他带来的痛苦的分量。也就是说，失去造成的伤害比得到带来的快乐多得多。被剥夺超级反应倾向。&lt;br /&gt;
人类和芒格家的狗差不多。人们在失去——或者有可能失去——财产、爱情、友谊、势力范围、机会、身份或者其他任何有价值的东西时，通常会做出不理性的激烈反应，哪怕只失去一点点时也是如此。&lt;br /&gt;
人们在表现出被剥夺超级反应倾向的过程中，经常会因为小题大做而惹来麻烦。他往往会对眼前的损失斤斤计较，而不会想到那损失也许是无关紧要的。例如，一个股票账户里有1000万美元的人，通常会因为他钱包里的300美元不小心损失了100美元而感到极端的不快。&lt;br /&gt;
有一种办法能够化解这种受到刻意维护的团体意识，那就是建设一种极端讲礼貌的文化，哪怕双方的意识形态并不相同，但彼此之间要保持彬彬有礼&lt;br /&gt;
被剥夺超级反应倾向也是导致某些赌徒倾家荡产的重要原因之一。首先，它使得赌徒输钱之后急于扳平，输得越多，这种不服输的心理就越严重。&lt;/p&gt;

&lt;h3 id="社会人同倾向"&gt;社会人同倾向&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;青少年特别容易由于社会认同倾向而出现认知错误。 与其教训子女，毋宁控制他们交往朋友的质量。后者是更明智的做法。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;像青少年一样有从众心理的领导人也并不少见。如果有家石油公司愚蠢地买了一个矿场，其他石油公司通常会很快地加入收购矿场的行列。如果被收购的是一家化肥厂，情况也是如此。实际上，石油公司的这两种收购曾经蔚然成风，而它们收购的结果都很糟糕, （类似可以解释   恒大、碧桂园、以及融创的例子？）&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;人们在感到困惑或者有压力的时候，尤其是在既困惑又有压力的时候，最容易受社会认同倾向影响&lt;/li&gt;
  &lt;li&gt;坏行为 和 好行为 都会通过社会认同倾向而得到传播: 所以对于人类社会而言，下面两种措施是非常重要的：1) 在坏行为散播之前阻止它；2) 倡导和展现所有的好行为。&lt;/li&gt;
  &lt;li&gt;社会认同倾向通常以一种变态的方式和艳羡/妒忌倾向、被剥夺超级反应倾向结合在一起。在这些因素的共同作用之下，许多年前曾发生了一件让我们家里人后来想起来就忍俊不禁的事情。当时我的表弟罗斯三岁，我四岁，我们俩为了一块小木板而争夺和喊叫，而实际上周围有许多同样的小木板。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="对比错误反应倾向"&gt;对比错误反应倾向&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;因为人类的神经系统并不是精密的科学仪器，所以它必须依靠某些更为简单的东西。比如说眼睛，它只能看到在视觉上形成对比的东西。和视觉一样，其他感官也是依靠对比来捕捉信息的息的。更重要的是，不但感知如此，认知也是如此。结果就造成了人类的对比错误反应倾向&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;很少有其他心理倾向能够比这种倾向对正确思维造成更大的破坏。小规模的破坏如下面的例子：一个人花1000美元的高价购买了皮质仪表盘，仅仅是因为这个价格和他用来购买轿车的65000美元相比很低。&lt;br /&gt;
对比错误反应倾向常常被用于从购买商品和服务的顾客身上赚取更多的钱&lt;/li&gt;
  &lt;li&gt;为了让正常的价格显得很低，商家通常会瞎编一个比正常价格高很多的虚假价格，然后在广告中把他的标准价格显示为其伪造价格的折扣价。人们即使对这种操纵消费者的伎俩心知肚明，也往往忍不住会上当. 。这种现象部分地解释了报纸上有那么多广告的原因。它还证明了这个道理：了解心理操纵伎俩并非就是一种完美的防御措施。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当一个人逐步逐步走向灭亡时，如果他每一步都很小，大脑的对比错误反应倾向通常会任由这个人走向万劫不复的境地。这种情况会发生，是因为每一步和他当前位置的对比太小了。&lt;/p&gt;

&lt;h3 id="压力影响倾向"&gt;压力影响倾向&lt;/h3&gt;
&lt;p&gt;轻度的压力能够轻微地改善人们的表现，比如说在考试中；而沉重的压力则会引发彻底失调。&lt;/p&gt;

&lt;h3 id="错误衡量易得性倾向-认为容易的到的东西-重要"&gt;错误衡量易得性倾向 (认为容易的到的东西 重要)&lt;/h3&gt;
&lt;p&gt;人类的大脑是有限和不完美的，它很容易满足于容易得到的东西。大脑无法使用它记不住或者认识不到的东西，因为它会受到一种或几种心理倾向的影响.人类的大脑会高估容易得到的东西的重要性，因而展现出易得性——错误衡量倾向。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;避免受易得性——错误衡量倾向影响的主要对策通常是按程序办事，包括使用几乎总是很有帮助的检查清单。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;应该特别关注的是那些不容易被轻易量化的因素，而不是几乎只考虑可以量化的因素。&lt;/li&gt;
  &lt;li&gt;应付这种倾向时所需要记住的伟大原理很简单：别只是因为一样事实或者一种观念容易得到，就觉得它更为重要。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="不用就忘倾向"&gt;不用就忘倾向&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;所有技能都会因为不用而退化。&lt;/li&gt;
  &lt;li&gt;如何避免?: 使用一些类似于飞行员训练中用到的飞行模拟器那样的东西。这种模拟器让飞行员能够持续地操练所有很少用到但必须保证万无一失的技能。 如果他减少了他操练的技能的种数，进而减少了他掌握的技能的种数，那么他自然会陷入“铁锤人倾向”引起的错误之中。他的学习能力也会下降，&lt;/li&gt;
  &lt;li&gt;明智的人会终身操练他全部有用然而很少用得上的、大多数来自其他学科的技能，&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="权威-错误影响倾向"&gt;权威 —错误影响倾向&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;和其所有祖先相同，人类也生活在等级分明的权力结构中，所以大多数人生下来就要跟随领袖，能够成为领袖的则只有少数人。人类社会被正式组织成等级分明的权力结构，这些结构的文化则增强了人类天生就有的追随领袖的倾向。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;人类的权威——错误影响倾向会造成认知错误。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="废话倾向"&gt;废话倾向：&lt;/h3&gt;

&lt;h3 id="重视理由倾向"&gt;重视理由倾向：&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;这种倾向给人们的启发不言而喻。如果老师在传授知识时讲明正确的原因，而非不给任何原因，只是高高在上地把知识罗列出来，那么学生往往会学得更好。因此，不仅在发布命令之前要想清楚原因，而且还应该把这些原因告诉命令的接受者，没有比这更明智的做法了。&lt;/li&gt;
  &lt;li&gt;重视理由倾向是如此强大，乃至一个人给出的理由哪怕是毫无意义的或者是不准确的，也能使他的命令和要求更容易得到遵从。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="lapalooza倾向-数种心理倾向共同作用造成极端后果的倾向"&gt;lapalooza倾向— 数种心理倾向共同作用造成极端后果的倾向&lt;/h3&gt;
</content>
  </entry>
  <entry>
    <title>linux-progress-group</title>
    <link rel="alternate" href="http://geniousbar.github.io/2019/02/23/linux-progress-group/"/>
    <id>http://geniousbar.github.io/2019/02/23/linux-progress-group/</id>
    <published>2019-02-23T08:00:00+08:00</published>
    <updated>2019-03-11T12:10:01+08:00</updated>
    <summary type="html">&lt;h2 id="the-linux-programming-interface"&gt;The linux programming interface&lt;/h2&gt;

&lt;h3 id="进城组会话和作业控制"&gt;进城组、会话和作业控制&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;进程组和会话在进程之间形成了一种 两层的层次关系。 进程组： 是 相关进程的集合， 会话： 是 相关进程组的集合。其目的是为了支持shell的作业控制，而定义的抽象概念，使用户通过shell能够交互的在前台或后台运行命令&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;进程组： 一个或多个共享同一进程组标识PGID的进程组成。PGID的数值为 进程组首进程的进程ID，该进程为进程组的第一个进程 或创建该进程组的进程，子进程会继承父进程 的PGID...&lt;/li&gt;
&lt;/ol&gt;</summary>
    <content type="html">&lt;h2 id="the-linux-programming-interface"&gt;The linux programming interface&lt;/h2&gt;

&lt;h3 id="进城组会话和作业控制"&gt;进城组、会话和作业控制&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;进程组和会话在进程之间形成了一种 两层的层次关系。 进程组： 是 相关进程的集合， 会话： 是 相关进程组的集合。其目的是为了支持shell的作业控制，而定义的抽象概念，使用户通过shell能够交互的在前台或后台运行命令&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;进程组： 一个或多个共享同一进程组标识PGID的进程组成。PGID的数值为 进程组首进程的进程ID，该进程为进程组的第一个进程 或创建该进程组的进程，子进程会继承父进程 的PGID。进程组的结束时间为，最后一个进程成员退出组的时刻 （进程可能终止或加入另一个进程组而退出进程组）&lt;/li&gt;
  &lt;li&gt;会话： 一组进程组的集合，由 SID 标志 （同进程ID 一样为pid_t类型）其数值为 会话首进程 的进程ID，新进程会继承 父进程的 SID。 一个会话中的所有进程共享单个控制终端，控制终端在回话首进程 首次打开一个终端时候建立，该进程成为 该终端的控制进程，在连接断开时，内核会发送信号给该进程。一个终端最多成为一个会话的控制终端。在一个会话中只有一个 进程组会成为 前台进程组，其他的成为 后台进程组，只有 前台进程组能够从控制终端中读取输入，在控制终端中输入一个信号（即 按键会产生信号， liru c-\ c-z c-c）时，该信号会被发送到 前台 进程组的所有成员。&lt;/li&gt;
  &lt;li&gt;通过linux特有的/proc/PID/stat 文件，能够确定任意的进程组ID和会话ID， 此外还能确定进程的控制终端的设备ID 和对应的控制进程ID&lt;/li&gt;
  &lt;li&gt;一个具体的例子为： 登录shell是 会话首进程和终端的控制进程， 从shell中发出的每个命令 都会导致一个或多个进程的创建（通过管道会创建多个进程）并将所有进程放到共一个进程组中，以&amp;amp;结束的命令 会在后台进程组中运行。所有在shell中创建的子进程都会成为该会话的一部分。
&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt; &lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$$&lt;/span&gt;
 &lt;span class="nv"&gt;$ &lt;/span&gt;find / 2&amp;gt; /dev/null | wc &lt;span class="nt"&gt;-l&lt;/span&gt; &amp;amp;
 | sort &amp;lt; longlist | uniq &lt;span class="nt"&gt;-c&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;p&gt;&lt;img src="../../../../images/process-group.png" alt="process-group" /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id="进程组"&gt;进程组&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;每个进程都有一个 进程组ID， 表示该进程的所属进程组。子进程会继承 父进程的 进程组ID。&lt;/li&gt;
  &lt;li&gt;pid getpgrp(void): 获取进程的进程组ID。进程组首进程 的进程组ID同进程ID相同&lt;/li&gt;
  &lt;li&gt;int setpgid(pid_t pid, pid_t pgid): 将 进程ID为pid的进程 的进程组修改为pgid， pid 0 i表示设定进程自身， pgid为0 表示 设定 pid进程的进程组ID为pid。 使用该调用可以创建新的进程组，或者移动 进程 到另一个进程组, 其中存在如下限制：
    &lt;ul&gt;
      &lt;li&gt;pid 参数 仅可以指定为 调用进程或 其子进程， 违反会导致 ESRCH 错误&lt;/li&gt;
      &lt;li&gt;在进程组之间移动，  调用进程、pid进程， 以及移动目标组必须同属于一个会话，违法导致 EPERM 错误&lt;/li&gt;
      &lt;li&gt;一个进程在其子进程已经执行exec后，就无法修改该子进程的进程组ID了，违法导致EACCES错误, 这个规则导致： 一个 任务， 中的所有进程 必须放置在同一个进程组中， 这一步允许shell通过killpg 来同事想进程组中的所有成员进程发送作业控制信号，2）每个子进程在exec执行程序之前，需要分配到进程组中，因为程序本身是不会修改进程组ID的。 这其中引伸出来的问题， 在于 fork 之后， 并确定 子进程，父进程的执行顺序， 因此需要在  父进程和子进程中都需要调用setpgid()来修改子进程的进程组ID， 父进程需要忽略EACCES错误&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id="会话"&gt;会话&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;会话是一组进程组的集合， 一个进程的会话成员关系是由其会话ID 来确定的恩，新进程会进程其父进程的会话ID。&lt;/li&gt;
  &lt;li&gt;getsid(pid_t pid): pid 为0，那么返回调用进程的会话ID&lt;/li&gt;
  &lt;li&gt;setsid(void): 调用进程不是 进程组 首进程，那么调用会创建一个新会话。 （为什么不能 是  进程组首进程呢？）： 创建新会话的步骤如下：
    &lt;ol&gt;
      &lt;li&gt;调用几次会成为新会话的首进程 和该会话中的新进程组的首进程， 会话ID 为 进程ID， 包会新的进程组ID&lt;/li&gt;
      &lt;li&gt;调用进程没有控制终端，所有之前的控制终端的链接都会断开
        &lt;ul&gt;
          &lt;li&gt;如果是进程组首进程来 调用setsid, 会返回 EPERM错误，避免的方式很简单， 执行fork， 由 子进程来调用即可。 约束 调用者的身份是重要的， 因为：如果进程组 首进程调用就能够将自身迁移到一另一个会话中，而该进程组中的其他成员仍然位于原来的会话中（这里并不会创建新的进程组，因为根据定义， 进程组首进程的 进程组ID 等于 其 进程ID，如果创建的话， 那么存在进程组ID相同的两个进程组） 这回破坏进程组和会话的层级关系， 音带要求一个进程组的所有成员必须属于同一个会话&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id="控制终端-和-控制进程"&gt;控制终端 和 控制进程&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;一个会话中可以拥有一个控制终端， 会话在创建的时候是没有控制终端的， 会话首进程 首次打开一个 没有成为其他会话的控制终端的终端时 会建立 控制终端， 会话首进程 打开 控制终端之后，会成为 该终端的控制进程， 在中断断开之后，内核会发送SIGHUP信号到 控制进程，进程 可以通过打开特殊文件 /dev/tty 来获取 终端的文件描述符 没有控制终端则返回 ENXIO 错误（可以在 进程 的标准输入输出 被重定向之后 确保自己确实在于控制终端进程通信是非常有用的 ）控制终端 会被 由 fork 创建的子进程 进程并且在exec中保持&lt;/li&gt;
  &lt;li&gt;终端  以及 控制终端 的概念到底是怎样的？ 如何对应到现实中的 键盘输入 现实生活中。&lt;br /&gt;
删除 进程与 控制终端之间的关联关系： ioctl(fd, TIOCNOTTY): 能够删除进程与文件描述符fd指定的 控制终端之间的关联关系， 在调用函数之后，再次打开 /dev/tty 文件的话就会失败， 调用者为 终端的控制进程，在控制基础终止时， （？为什么是终止时候，而不是调用函数之后） 会发生如下事情； 1）会话中的所有进程将会失去 与控制终端之间的关联关系， 2） 控制终端失去了与该会话 之间的关联关系， 另一个会话首进程能够获取该终端已成为控制基础， 3） 内核会想前台进程组的所有成员 发送一个SIGHUP信号，来通知他们控制终端的丢失&lt;/li&gt;
  &lt;li&gt;ctermid(char * ttyname): 返回表示控制终端的路径名， 通常返回结果为 /dev/ttyname&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="前台后台进程组"&gt;前台、后台进程组：&lt;/h4&gt;
&lt;p&gt;一个会话中，在同一时刻只有一个进程能够成为前台进程，会话中的其他所有进程都是后台进程组，前台进程组 是唯一能够自由的读取和写入控制终端的进程组， 在控制终端中输入 产生信号的字符时，终端驱动器 会相应的 发送信号给前台进程组的成员&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;tcgetpgrp(int fd): 函数返回文件描述符fd 所指定的中断的前台进程组的进程组ID， fd为 控制终端&lt;/li&gt;
  &lt;li&gt;tcsetpgrp(int fd, pid_t pgid): 修改一个终端的前台进程组&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="sighup信号"&gt;SIGHUP信号：&lt;/h4&gt;
&lt;p&gt;一个控制基础时区与终端链接之后，内核会发送一个SIGHUP信号，还会发送一个SIGCONT 信号，以确保 当该进程之前被一个喜好停止时，重新开始该进程。 出现该场景的情况有：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;中断驱动器检测到连接断开后， 表明 调制解调器（网络ssh？）或终端行上信号的丢失&lt;/li&gt;
  &lt;li&gt;当 工作站上的终端窗口被关闭时，发生这种清库激昂是因为最近打开的与终端窗口哦关联的伪终端主侧 的文件描述符被关闭了 ？？？？？&lt;br /&gt;
控制基础接收到SIGHUP信号，会引起炼石反应， 从而导致将SIGHUP信号发送给其他的进程， 这个过程以如下两种方式发生；&lt;/li&gt;
  &lt;li&gt;控制基础通常是一个shell， shell建立了一个 SIGHUP 信号的处理器， 这样在进程终止之前，能够将SIGHUP 信号 发送给由他 创建的各个任务。默认情况下， 这个信号会终止那些任务， 但是如果他们呢不活了这个信号，就能够知道 shell进程已经终止了&lt;/li&gt;
  &lt;li&gt;控制基础终止时，内核会解除会话中的所有进程与该控制终端之间的关联关系以及控制终端与会话的关联关系，并向前台进程组 发送SIGHUP信号来通知他们控制终端的丢失&lt;/li&gt;
&lt;/ol&gt;
</content>
  </entry>
  <entry>
    <title>fifo-pipe</title>
    <link rel="alternate" href="http://geniousbar.github.io/2019/02/05/fifo-pipe/"/>
    <id>http://geniousbar.github.io/2019/02/05/fifo-pipe/</id>
    <published>2019-02-05T08:00:00+08:00</published>
    <updated>2019-02-23T17:56:30+08:00</updated>
    <summary type="html">&lt;h2 id="the-linux-programming-interface"&gt;The linux programming interface&lt;/h2&gt;

&lt;h3 id="管道-fifo"&gt;管道, FIFO&lt;/h3&gt;
&lt;p&gt;管道是UNIX系统上最古老的一种IPC方法，可以用来在相关进程间传递数据。FIFO 则是 管道 概念的一个变体, 区别在于 FIFO可以用于 任意进程间的通信&lt;/p&gt;

&lt;h4 id="管道"&gt;管道&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;shell命令中使用管道最为常见。比如 ls | wc -l, 示意图如下： 为执行该命令， shell创建了两个进程来分别执行ls、wc&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;管道的几个特征：
    &lt;ol&gt;
      &lt;li&gt;一个管道是一个字节流 （不存在消息...&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    <content type="html">&lt;h2 id="the-linux-programming-interface"&gt;The linux programming interface&lt;/h2&gt;

&lt;h3 id="管道-fifo"&gt;管道, FIFO&lt;/h3&gt;
&lt;p&gt;管道是UNIX系统上最古老的一种IPC方法，可以用来在相关进程间传递数据。FIFO 则是 管道 概念的一个变体, 区别在于 FIFO可以用于 任意进程间的通信&lt;/p&gt;

&lt;h4 id="管道"&gt;管道&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;shell命令中使用管道最为常见。比如 ls | wc -l, 示意图如下： 为执行该命令， shell创建了两个进程来分别执行ls、wc&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;管道的几个特征：
    &lt;ol&gt;
      &lt;li&gt;一个管道是一个字节流 （不存在消息边界的概念，读取进程可以读取任意大小的数据块，数据是顺序的、但是管道中没有离散消息的概念）&lt;/li&gt;
      &lt;li&gt;从管道中读取数据： 试图从一个当前为空的 管道中 读取数据将会被阻塞 直到至少 有一个字节被写入到管道中为止，写入端被关闭后，在读取完 所有数据之后 会读取到 文件结束&lt;/li&gt;
      &lt;li&gt;单向的： 数据传递的方向是单向的，一端为读写 一端为写入 （一些UNIX 的实现上 管道 是双向的，但是应该避免依赖这种语义，使用UNIX domain socket 来代替）&lt;/li&gt;
      &lt;li&gt;可以保证 写入不超过PIPE_BUF 字节的操作是原子的： 单个进程写入管道 无需关心PIPE_BUF的取值，多个进程写入同一个管道在一时刻写入的数据量超过PIPE_BUF字节大小时，那么就可以保证写入的数据不会出现 互相混合的情况。（多个写入进程，那么大的数据块写入可能会被拆分成 任意大小的数据段，导致会出现与其他进程 写入的数据交叉的现象， 因为并没有 原子性的写入）&lt;/li&gt;
      &lt;li&gt;管道的容量是有限的： 管道是内核内存中维护的一个缓冲器，这个缓冲器的存储能力是有限的。管道被填满之后，写入的操作会被阻塞知道读取操作从缓冲器中移除一些数据为止。（一个应用程序无需知道 管道的实际存储能力，使用较大的缓冲器会提升效率，每当缓冲器被充满时，内核需要执行调度来消耗管道中的数据，较大的缓冲器意味着更少的调度、进程上下文切换的需要）&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;创建使用管道：int pipe(int fields[2]), 成功会在数组中 filedes 中返回两个打开的文件描述符，0 为读端， 1 为写端，与所有 文件描述符一样，可以使用read、write 系统调用在管道上执行IO，也可以使用stdio 函数等（但是需要首先fdopen获取一个fileds文件描述符对应的文件流）常见的使用场景如下：&lt;/li&gt;
  &lt;li&gt;父进程同子进程从同一个管道 中读取和写入数据 的这种做法并不常见，因为会产生竞争 （�当然 阻塞IO 的系统调用是一个原子操作，不会产生数据错乱，但是竞争条件是在所难免的，非阻塞IO中 则不容易判断 IO数据到底归属于那个进程）一个更简单的方法 则是： 创建两个管道，在两个进程间发送数据的两个方向上各使用一个，但是这种继续需要避免死锁问题（阻塞IO需要，因为两个端同时等待 IO 读取，而无法写入）&lt;/li&gt;
  &lt;li&gt;允许相关进程间的通信：管道可以在任意两个相关进程之间 通信，在 fork创建新的子进程 之前， 父进程创建管道 在 子进程之间使用。 shell所做的工作就是 父进程创建管道， 然后创建子进程，并在子进程中使用。（这里的相关进程存在一个特殊情况，即允许UNIX doamin 传递 文件描述符给其他的进程）&lt;/li&gt;
  &lt;li&gt;关闭未使用的管道文件描述符： 对于正确使用管道是非常重要的一环。读取进程需要关闭写入描述符，这样当写入进程完成输出并关闭写入描述符时候，�读进程才能够看到读取到文件结尾。（也就是说在 文件结尾 的情况是 文件描述符完全被关闭？验证的逻辑的话： 需要3个进程，两个写入，一个读取， 读取一直读， 写入分别 间隔时间关闭， 然后观察情况，文件并不适合这种情况， 文件没有读写端的概念）写入进程关闭其持有的读取描述符的原因在于： 进程对一个没有 读取描述符 的管道 写入时候，内核会发送SIGPIPE信号，返回EPIPE错误（已损坏的管道），而这些是对进程有用的，为了保证 写入进程 能够收到这些消息、避免错误，所以需要主动关闭。其他的原因在于，只有写入进程持有读取描述符， 导致 没有接收端， 但是依然可以写入，最后管道缓冲区被填满，导致永远阻塞。&lt;/li&gt;
  &lt;li&gt;使用管道连接 过滤器： 管道被创建后， 为 读写端  分配的文件描述符是可用的描述符中数值最小的两个， 过滤器 约束规则是 从stdin 读取，写入到 stdout。所以shell需要保证 执行过滤器的 进程 标准输入、输出为 管道的读写端， 这里需要用到dup、dup2 系统调用&lt;/li&gt;
  &lt;li&gt;popen()/ pclose(): 用于 执行一个shell命令并读取其输出或发送一些输入， 其大概是示意图如下： images&lt;br /&gt;
  &lt;img src="../../../../images/fifo-240871a7.png" alt="fifo" /&gt;&lt;/li&gt;
  &lt;li&gt;stdio 缓冲问题： popen调用返回的文件流指针 没有引用一个终端。 stdio库会对这种文件流应用块缓冲。意味着mode 为w时候 popen的调用，只有当stdio缓冲器被充满或者使用 pclose 关闭管道 之后才会将输出发送到另一端。如果要求子进程能够 从管道中立即收到数据，那么需要手动fflush,或者setbuf(fp, NULL) 禁用stdio缓冲来做到，pipe的创建的管道 同样。popen进程使用r调用时候，那么就需要子进程的编码中调用fflush， setbuf 来保证父进程 及时收到消息。（如果无法修改源代码， 可以使用伪终端来替换管道， 对进程来说是一个终端，stdio库 会逐行输出缓冲器的数据）
    &lt;h4 id="fifo"&gt;FIFO&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;与管道类似， 最大的差别在于， FIFO在文件系统中存在一个名称（也被称为 命名管道 ）， 并且与打开一个普通文件的方式是一样的，这样就可以用于非相关进程之间的通信，&lt;/li&gt;
  &lt;li&gt;FIFO也有一个写入端和读取端， 并且从管道中 读取数据的顺序与写入的顺序是一样的，先入先出，所以被称为FIFO&lt;/li&gt;
  &lt;li&gt;mkfifo [-m mode] pathname (shell命令), int mkfifo(const char * pathnamne, mode_t mode); （系统调用） 其中mode为权限（同chmod） ls -\l FIFO文件的类型为p， ls -F 在路径名后面附加一个 | 符号&lt;/li&gt;
  &lt;li&gt;FIFO 被创建之后， 任何进程都可以打开它，只要符合权限 限制即可&lt;/li&gt;
  &lt;li&gt;推荐FIFO的使用方法： 一个写端，一个读端， 打开一个FIFO会同步读取进程和写入进程，即： 打开FIFO 以读取方式 会阻塞到 一个以写入方式 的打开 的产生， 以写入方式的打开 会阻塞到 一个 以读取方式的产生 （O_RDWR mode 打开会绕开 FIFO 的阻塞行为， 因为其不具有可移植性，开发人员应该避免使用， 而是应该是用O_NONBLOCK的方式进行）&lt;/li&gt;
  &lt;li&gt;使用 FIFO, tee 创建双重管道: shell管道线是线性的，每个进程读取前一个进程的产生的输出数据，然后产生输出数据，成为下一个进程的输入数据。使用FIFO就能创建新的管道线，需要使用到tee， tee 将输入数据复制成两份 分别输出， 将tee的一分输出 输入到FIFO中就可以产生两条管道线。 下面为大概的演示的命令行：具体的 tee的 &lt;a href="https://linux.101hacks.com/unix/tee-command-examples/"&gt;参数参考&lt;/a&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;  mkfifo myfifo
  wc &lt;span class="nt"&gt;-l&lt;/span&gt; &amp;lt; myfifo &amp;amp;
  &lt;span class="nb"&gt;ls&lt;/span&gt; &lt;span class="nt"&gt;-l&lt;/span&gt; | tee myfifo | sort &lt;span class="nt"&gt;-n&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;p&gt;&lt;img src="../../../../images/fifo_tee-12e712cd.png" alt="fifo_tee" /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</content>
  </entry>
  <entry>
    <title>linux-interface-socket</title>
    <link rel="alternate" href="http://geniousbar.github.io/2019/01/14/linux-interface-socket/"/>
    <id>http://geniousbar.github.io/2019/01/14/linux-interface-socket/</id>
    <published>2019-01-14T08:00:00+08:00</published>
    <updated>2019-02-23T18:06:30+08:00</updated>
    <summary type="html">&lt;h2 id="the-linux-programming-interface"&gt;The linux programming interface&lt;/h2&gt;
&lt;!-- 1. 57 介绍UNIX domain socket， 允许同一主机上的系统上的应用程序之间通讯。 58 介绍TCP/IP之间联网协议的关键特性。， 59 描述internet domain socket, 允许位于不同主机上的应用程序通过一个TCP/IP王璐进行通讯， 60 讨论socket的服务设计， 61: 介绍一些高级主题， 包括socket IO的， TCP协议的细节信息，已经socket选项来获取修改socket的各种特性。 --&gt;

&lt;h3 id="socket"&gt;Socket&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;socket是一种IPC方法， 它允许位于同意主机或者网络连接的不同主机 上的应用程序之间交换数据(第一个被广泛接收的socket API 实现于 1983年，现在这组API 已经被移植到了大部分的计算机系统上)&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;socket(domain, type, protocol): 系统调用
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;domain: 1）识别 socket 地址的格式  2） 确定范围: 在同一...&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    <content type="html">&lt;h2 id="the-linux-programming-interface"&gt;The linux programming interface&lt;/h2&gt;
&lt;!-- 1. 57 介绍UNIX domain socket， 允许同一主机上的系统上的应用程序之间通讯。 58 介绍TCP/IP之间联网协议的关键特性。， 59 描述internet domain socket, 允许位于不同主机上的应用程序通过一个TCP/IP王璐进行通讯， 60 讨论socket的服务设计， 61: 介绍一些高级主题， 包括socket IO的， TCP协议的细节信息，已经socket选项来获取修改socket的各种特性。 --&gt;

&lt;h3 id="socket"&gt;Socket&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;socket是一种IPC方法， 它允许位于同意主机或者网络连接的不同主机 上的应用程序之间交换数据(第一个被广泛接收的socket API 实现于 1983年，现在这组API 已经被移植到了大部分的计算机系统上)&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;socket(domain, type, protocol): 系统调用
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;domain: 1）识别 socket 地址的格式  2） 确定范围: 在同一个主机上的不同应用程序还是 在一个网络上的不同主机&lt;/p&gt;

        &lt;table&gt;
          &lt;thead&gt;
            &lt;tr&gt;
              &lt;th style="text-align: left"&gt;DOMAIN&lt;/th&gt;
              &lt;th style="text-align: left"&gt;执行的通讯&lt;/th&gt;
              &lt;th style="text-align: left"&gt;应用程序间的通讯&lt;/th&gt;
              &lt;th style="text-align: left"&gt;地址格式&lt;/th&gt;
              &lt;th style="text-align: left"&gt;地址结构&lt;/th&gt;
            &lt;/tr&gt;
          &lt;/thead&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td style="text-align: left"&gt;AF_UNIX&lt;/td&gt;
              &lt;td style="text-align: left"&gt;内核中&lt;/td&gt;
              &lt;td style="text-align: left"&gt;同一主机&lt;/td&gt;
              &lt;td style="text-align: left"&gt;路径名&lt;/td&gt;
              &lt;td style="text-align: left"&gt;sockaddr_un&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td style="text-align: left"&gt;AF_INET&lt;/td&gt;
              &lt;td style="text-align: left"&gt;通过IPv4&lt;/td&gt;
              &lt;td style="text-align: left"&gt;IPv4 连接起来的网络&lt;/td&gt;
              &lt;td style="text-align: left"&gt;32为IPoe 地址+ 16位端口号&lt;/td&gt;
              &lt;td style="text-align: left"&gt;sockaddr_in&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td style="text-align: left"&gt;AF_INET6&lt;/td&gt;
              &lt;td style="text-align: left"&gt;通过IPv6&lt;/td&gt;
              &lt;td style="text-align: left"&gt;IPv6 连接起来的网络&lt;/td&gt;
              &lt;td style="text-align: left"&gt;128为IP地址+ 16位端口号&lt;/td&gt;
              &lt;td style="text-align: left"&gt;sockaddr_in6&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;type: sock_stream, sock_dgram&lt;/p&gt;

        &lt;table&gt;
          &lt;thead&gt;
            &lt;tr&gt;
              &lt;th style="text-align: left"&gt;属性&lt;/th&gt;
              &lt;th style="text-align: left"&gt;流(SOCK_STREAM)&lt;/th&gt;
              &lt;th style="text-align: left"&gt;数据包 (SOCK_DGRAM)&lt;/th&gt;
            &lt;/tr&gt;
          &lt;/thead&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td style="text-align: left"&gt;可靠的传输?&lt;/td&gt;
              &lt;td style="text-align: left"&gt;是&lt;/td&gt;
              &lt;td style="text-align: left"&gt;否&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td style="text-align: left"&gt;边界消息保留?&lt;/td&gt;
              &lt;td style="text-align: left"&gt;否&lt;/td&gt;
              &lt;td style="text-align: left"&gt;是&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td style="text-align: left"&gt;面向连接？&lt;/td&gt;
              &lt;td style="text-align: left"&gt;是&lt;/td&gt;
              &lt;td style="text-align: left"&gt;否&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
      &lt;li&gt;流: 提供了一个可靠的双向的字节流的通讯通道。 (因为需要一对 相互连接的socket，因为被称为面向连接的socket）其中:
        &lt;ol&gt;
          &lt;li&gt;可靠的: 表示可以保证发送者传输的数据会完整的传递到接收者应用程序 （假设接收者发送者应用程序不会崩溃）&lt;/li&gt;
          &lt;li&gt;双向的: 数据可以在socket 之间的任意方向上传输&lt;/li&gt;
          &lt;li&gt;字节流: 表示与管道一样不存在 消息边界的概念&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;数据报 socket: 允许数据以 数据报的消息形式进行交换， 在数据报socket中， 消息边界得到了保留，但是数据传输是不可靠的，消息的到达顺序 可能是无序的、重复的、或者根本无法到达的。数据包socket是一个更一般的无连接socket概念的一个示例， 与流socket连接，一个数据报 socket 在使用时候，无需与另一个socket 连接，现在internet domain 中， 数据包socket使用了UDP（用户数据报协议）, 而流socket 则使用了TCP（传输控制协议）（是否意味着更多的协议的存在？）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;socket 相关的系统调用:
    &lt;ul&gt;
      &lt;li&gt;socket(int domain, int type, int protocol): 其中domain， type 在上面有所描述。protocol 总是为0， 在一些socket类型中会使用非0数值，socket成功后会返回一个socket的文件描述符&lt;/li&gt;
      &lt;li&gt;bind(int sockfd, struct sockaddr * addr, socklen_t addrlen): sockfd 为 socket调用返回的文件描述符，addr 为socket绑定到的地址结构指针，结构详细取决于 socket domain, addrlen 为结构地址大小。一般来讲服务器会将socket 绑定到一个 约定的地址上。&lt;/li&gt;
      &lt;li&gt;listen(int sockfd, int backlog): 系统调用将会sockfd设定为 『被动』， 接收主动连接的请求。 backlog 用于 设定 服务器端 保持等待连接的数量。（在backlog之内的连接会立即成功，等待accept， 更多的连接会阻塞一直到有等待中的连接被accept并冲等待连接中删除掉）（backlog的限制在sys/socket.h 中的 somaxconn 常量设定， linux中 这个常量设定为128,从内核 2.4.25起 linux允许在运行时通过 特有的/proc/sys/net/core/somaxconn 文件来调整这个限制）&lt;/li&gt;
      &lt;li&gt;accept(int sockfd, struct sockaddr * addr, socklen_t * addrlen): 系统调用在 sockfd 的文件描述符 引用的监听流socket上接收一个接入连接。如果在调用accpet时不存在 未决 的连接，那么调用就会阻塞直到 有连接请求为止。参数 addr, addrlen, 会返回连接socket 的地址信息。理解accept 的关键点在于:
        &lt;ul&gt;
          &lt;li&gt;accept 会创建一个新的scoket， 这个socket与执行connect的客户端scoket进行连接。&lt;/li&gt;
          &lt;li&gt;accpet调用返回的结果是 已连接的 socket文件描述符，监听 socketfd 会保持打开状态。并可以接收后续连接。&lt;/li&gt;
          &lt;li&gt;典型的 服务器应用 会创建一个 监听socketfd， 将其绑定到一个约定的地址上。然后 accept 该socketfd 上 的连接 来处理所有的客户端请求。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;connect(int sockfd, struct sockaddr * addr, scoklen_t addrlen): 系统调用将sockfd 主动连接到 地址addr 指定的监听socket上。如果连接失败，标准的可以移植的方法为: 关闭socket，创建一个新的socket，并重新连接&lt;br /&gt;
&lt;img src="../../../../images/pending_socket-84aa5943.png" alt="udp" /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;流 socket 提供了一个在两个端点之间 一个双向通信的通道，流socket IO 上的操作与 管道 IO的操作类似
    &lt;ul&gt;
      &lt;li&gt;可以使用 read， write，因为socket是双向的，所以两端都可以使用&lt;/li&gt;
      &lt;li&gt;socket可以使用close来关闭，之后对应的另一端的socket 在读取数据时候会收到文件结束的标志，如果继续进行写入 会收到一个SIGPIPE的信号，并且系统调用会返回一个EPIPE的错误。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;数据报 socket(SOCK_DGRAM):
    &lt;ol&gt;
      &lt;li&gt;socket 系统调用创建一个邮箱，&lt;/li&gt;
      &lt;li&gt;bind 到一个约定的地址上， 来允许 一个应用程序发送数据报 到这里，一般来讲， 一个服务器会将其socket 绑定到一个地址上，客户端会向该地址发送一个数据报 来发起通讯 （在一个domain 特别是UNIX domain 中，客服端想接收到服务器发送来的数据报的话，也需要bind到一个地址上）&lt;/li&gt;
      &lt;li&gt;sendto(int sockfd, void * buffer, size_t length, int flags, sockaddr * dest_addr, socklen_t addrlen): 用来发送一个数据报, flags 用来控制一些socket的特性，dest_addr置顶了目标接收者的socket地址,&lt;/li&gt;
      &lt;li&gt;recvfrom(int sockfd, void * buffer, size_t length, int flags, sockaddr * src_addr, socklen_t addrlen): 用来接收数据报，在没有数据报时候会阻塞应用。由于recvfrom允许获取发送者的地址，因为可以发送一个响应（这在 发送者的socket没有绑定到一个地址上是有用的，正如bind中的描述所说，unix domain中也需要 客服端 来bind一个地址，才能接收到服务器的响应）其中 src_addr 用来获取发送数据报的远程socket地址，如果并不关心发送者的地址，可以传递NULL，length 数值 用来限制recvfrom获取的数据大小，如果超过length，则会进行截断。（使用recvmsg 则可以找出被截断的数据报）&lt;/li&gt;
      &lt;li&gt;数据报通讯无法保证 数据报 接收的顺序，甚至无法保证数据是到达的 或者是 多次到达&lt;/li&gt;
      &lt;li&gt;connect: 尽管数据报socket是无连接的，但是依然可以使用connect调用
        &lt;ul&gt;
          &lt;li&gt;发送者 socket connect之后，数据报的发送可以使用write来完成，而无需使用sendto，并每次传递addr地址。&lt;/li&gt;
          &lt;li&gt;接收者 socket connect之后，只能接收由对等的socket 发送的数据报&lt;/li&gt;
          &lt;li&gt;数据报socket connect的明显优势在于 可以使用更简单的IO 系统调用，在一些TCP/IP实践中，将一个数据报的socket连接到一个对等socket（connect）能够带来性能上的提升&lt;br /&gt;
   &lt;img src="../../../../images/udp_socket-cce037cc.png" alt="udp" /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="socket-unix-domain"&gt;Socket: Unix domain&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Unix domain socket address:&lt;br /&gt;
 unix domain socket的地址以路径名来表示，其中sun_path 的大小，早期为 108, 104，现在的一般为 92，可移植的需要小一些，应该使用strncpy 以避免缓冲区溢出问题，使用 路径名 初始化 sun_path 来初始化 socket address&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight c"&gt;&lt;code&gt;   &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;sockaddr_un&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
     &lt;span class="n"&gt;sa_family_t&lt;/span&gt; &lt;span class="n"&gt;sun_family&lt;/span&gt;
     &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;sun_path&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;108&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
   &lt;span class="p"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;ul&gt;
      &lt;li&gt;当绑定 UNIX domain socket 时， bind会在 文件系统中创建一个条目， 文件的所有权会根据文件的创建规则来确定，并标记为一个socket， ls -l 第一列 为s， stat()返回的结构中st_mode字段中的文件类型部分为 S_IFSOCK，&lt;/li&gt;
      &lt;li&gt;无法将一个socket绑定到 现有的路径名上。&lt;/li&gt;
      &lt;li&gt;通常将一个socket绑定到绝对路径上&lt;/li&gt;
      &lt;li&gt;一个socket只能绑定到一个路径名上，相应的一个路径名只能被一个socket绑定&lt;/li&gt;
      &lt;li&gt;无法使用open打开一个socket&lt;/li&gt;
      &lt;li&gt;不在需要socket时，使用unlink 来删除其路径&lt;/li&gt;
      &lt;li&gt;示例中通常将socket绑定到/tmp目录下，这并不是一个好的设计，在现实中不要这么做，因为/tmp 此类公共可写的目录中创建文件会导致安全问题，所以应该将socket绑定到一个有安全措施的绝对路径上&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;socketpair(int domain, int type, int protocol, int sockfd[2]): 该系统调用 用于创建一对 互相连接的socket，
    &lt;ul&gt;
      &lt;li&gt;只能用在UNIX domain中(也就是说 domain 必须指定为 AF_UNIX) type 可以为sock_dgram, sock_stream, protocol必须为0，&lt;/li&gt;
      &lt;li&gt;sockfd 数组返回了 引用这两个相互连接的socket文件描述符。type 为sock_stream 相当于创建了一个双向管道，一般来讲 socket对的使用方式与管道的使用方式类似，在调用完socketpair()之后，可以fork出一个子进程，然后子父进程可以通过这一对socket来进行IPC了。&lt;/li&gt;
      &lt;li&gt;与 手动创建一对相互连接的socket的做法的优势: socketpair 创建的socket不会绑定到任意的地址上（即其他方式的socket创建都需要bind 到一个地址上）这样就能避免安全问题，因为这一对socket对其他进程是不可见的&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;linux 抽象socket 命名空间&lt;br /&gt;
  &lt;strong&gt;所谓的抽象命名空间 是linux特有的特性。他允许将一个UNIX domain socket绑定到一个名字上但不会在文件系统上创建该名字&lt;/strong&gt; 优势有:
    &lt;ul&gt;
      &lt;li&gt;无需担心与文件系统中的既有名字冲突&lt;/li&gt;
      &lt;li&gt;没有必要在使用完一个socket之后，删除socket路径名，当socket被关闭之后会自动删除这个抽象名&lt;/li&gt;
      &lt;li&gt;无需为socket创建一个文件系统路径名了&lt;/li&gt;
      &lt;li&gt;创建一个抽象的绑定，只需要将sun_path字段的第一个字节指定为null，用于区分抽象socket 与传统的UNIX domain socket&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="tcpip-网络基础"&gt;TCP/IP 网络基础&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;一个联网协议是定了如何在一个网络上传输信息的一组规则，网络协议通常会被组织成一系列的层，其中每一层都构建于下一层之上并提供特性以供上层使用。TCP/IP 协议套件 是一个封层联网协议。包括因特网协议（IP）和魏雨琦上层的各个协议层。 TCP 为传输层控制协议&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;封装协议的特点有:
    &lt;ol&gt;
      &lt;li&gt;透明: 每一个协议层都对上层 隐藏下层的操作和复杂性。 入一个使用TCP的应用程序只需要使用标准的socket API并清楚自己在使用 一项可靠的字节流传输服务，而无需理解TCP操作的细节。（严格来说 这个标准并不总是正确，应用程序偶尔也需要弄清楚 底层传输协议的操作细节）&lt;/li&gt;
      &lt;li&gt;封装: 是分层连网协议中的一个重要的原则。关键概念: 底层会将从高层向底层传递的信息 当成不透明的数据进行处理。并不会尝试对高哦曾发送过来的信息进行解释。只会 将这些信息 添加自身这一层所使用的头信息，并传递到下一层。当数据从底层传递到高层时，会进行一个逆向的解包过程。&lt;br /&gt;
 &lt;img src="../../../../images/tcp_ip_protocol-1d996324.png" alt="tcp_ip_protocol" /&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;数据链路层: 传输数据， 数据链路层需要将上层传递过来的数据报封装进 被称为帧的一个一个单元，其中每帧都会包含一个头，包含了目标地址和帧的大小。数据链路层在物理连接上 传输帧并处理来自接收者的确认。这一层可能进行 错误检测、重传、以及流量控制。一些数据链层还会将大的网络报分割成多个帧并在接收者端对这些帧进行重传。应用程序编程的角度通常可以忽略 数据链路层，因为所有的通讯细节都是由 驱动和硬件来处理的。有关IP的讨论中， 数据链路层中比较重要的一个特点是最大传输单元(MTU)MTU是该层 所能传输的帧大小的上限， 不同的数据链路层MTU是不同的(netstat -i )&lt;/li&gt;
  &lt;li&gt;网络层IP&lt;br /&gt;
  网络层的、关注的为 如何将包 从愿主几发送到目标主机， 这一层执行的任务如下:
    &lt;ul&gt;
      &lt;li&gt;将数据分解成足够小的片段一变数据链路层进行传输&lt;/li&gt;
      &lt;li&gt;在因特网上路由数据&lt;/li&gt;
      &lt;li&gt;为传输层提供服务&lt;/li&gt;
      &lt;li&gt;在TCP/IP 协议套件中， 网路层主要的协议是IP， 存在IPv4, IPv6版本。一个IP数据报包含了一个头，起大小范围为20字节到60字节，这个包中包含了的目标主机的地址，以及包的源地址。这样就可以在网络上讲这个数据报路由到目标地址了、以及接收方直到数据报的源头了。&lt;/li&gt;
      &lt;li&gt;IP 是无连接协议、不可靠的协。 尽可能的将数据报从发送者传给接收者。当并不保证数据报到达的顺序以是否重传，甚至是否达到等。IP 也没有提供数据恢复。TCP/IP 的可靠性是通过使用一个可靠的TCP （传输层他协议）来保证的。&lt;/li&gt;
      &lt;li&gt;IP 路径MTU: 原主机到目标主机之间的路径上的所有数据链路层的最小MTU （通常以太网的MTU 最小）当一个数据报的大小大鱼MTU时， IP会将数据报分段（分解成一个大小适合在网络上传输的单元， 这些分段在达到最终目标地址之后会被重组成原始的数据报）， IP分段的发生对高层协议层是透明的，一般来讲并不希望发生这种事情。这里的问题在于IP并不进行重传，所以只有在所有分段到达目标之后才能对数据报进行重组，导致如果其中一些分段丢失可能导致整个数据报的失败，一些情况下会导致极高的丢包率（比如UDP并不会进行重传）或者降低传输速率（进行重传的TCP） 现在TCP实现采用了一些算法（路径MTU发现，这个是不是很简单的获取 IP的路径MTU？）并根据该值对传递给IP 的数据进行分解，来防止IP层对数据报进程分解。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;传输层
    &lt;ol&gt;
      &lt;li&gt;端口号: 传输层协议的任务是向位于不同主机的上的应用程序提供端到端 通讯服务，所以传输层需要才用一种方法来区分一个主机上的应用程序，端口号的工作就是如此。（16位）&lt;/li&gt;
      &lt;li&gt;UDP（用户数据报协议）: 仅仅在IP上增加了: 1） 端口号， 2）进行检测传数据错误的 数据校验和， 因为IP是无连接的，而UCP并没有进行 可靠性的保证，所以UCP 具有同IP一样的特性&lt;/li&gt;
      &lt;li&gt;TCP（传输控制协议）: TCP 在两个端点之间提供了可靠的、面向连接的、双响字节流通信通道。通过如下几个方面来保证:
        &lt;ul&gt;
          &lt;li&gt;建立连接: 在连接期间，即 对交换数据 的通讯参数进行协商&lt;/li&gt;
          &lt;li&gt;将数据打包成分段: 将数据分解成段(使单个IP数据报封装成为可能，从而避免 IP层面 进行拆解）每个段都包含一个校验和，并使用单个IP进行传输，从而能够检出数据报的错误。&lt;/li&gt;
          &lt;li&gt;确认、重传、超时: 一个TCP段无错的到达接收方，接收方会向发送者发送确认请求，如果报发生错误，接收方丢弃即可。发送方 在发送每一个分段时会启用一个定时器，在定时器超时时没有收到确认。那么就重传这个分段 （由于所使用的网络以及当前的流量负载会影响 传输一个分段和接收其确认 所需要的时间，所以 TCP采用了� 一个算法来动态的调整 重传超时时间（RTO） 的大小。接收者可能不会立即发送确认，而是等待几毫秒 来观察是否可以将 确认塞进接收者返回给发送者的响应中（因为相应是接收者发送给接收者的，并不需要传递确认信息）来减少一个TCP段的发送，从而降低网络中的包的数量。这个称为 延迟ACK 技术）&lt;/li&gt;
          &lt;li&gt;排序: TCP连接中的每个分段都会分配到一个逻辑号。这个数字指出了该分段在 该连接 的数据流中的位置（连接中的两个流都有各自的序号计数系统）序号的作用有: 1）这个序号可以保证TCP分段能够以正确的顺序在接收者进行组装， 然后以字节流的形式传送给应用层 2）接收者 发送给发送者 使用序号来标识出收到了那个TCP分段 3）接收者可以去除重复的分段信息。(一个流的初始序列ISN， 不是从0开始的，而是通过一个算法来生成的，该算法会递增分配给后续的TCP链接的ISN（防止前后的多个连接中 序号重复混淆的情况发生）)&lt;/li&gt;
          &lt;li&gt;流量控制: 防止一个快速的发送者压垮一个慢速的接收者: 如何实现: 接收TCP 需要为进入的数据维护一个缓冲区（每个TCP在建立连接时候，都会告知其缓冲区大小）当从发送TCP端收到数据时会将数据放入到缓冲区中。当应用层读取数据时会从缓冲区中删除数据， 在每个确认中，接收者会通知发送者 其缓冲区的可用空间，TCP流量控制算法 采用了 滑动窗口算法，来允许包含N个字节的窗口大小的 未确认段 同时在 发送者与接收者之间传递，接收端的缓冲区被充满，那么窗口就会关闭，发送端就会停止传输数据。&lt;br /&gt;
   &lt;img src="../../../../images/tcp_protocol-08a9fb04.png" alt="tcp_protocol" /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;RFC（请求注解）: 是由 国际互联网学会赞助的RFC编辑组织发布的，描述互联网标准的RFC是由互联网工程任务组资助开发的， 互联网工程任务组 是一个由 网络设计师、操作员、厂商以及研究人员组成的社区，主要关注互联网的发展和平稳运行。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="服务器设计"&gt;服务器设计&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;迭代型: 服务器每次只处理一个客户端，只有当完全处理完一个客户端的请求后，才会去处理下一个客户端&lt;/li&gt;
  &lt;li&gt;并发型: 能够同时处理多个客户端的请求。 本章主要放在并发型服务器的传统设计方法:针对每个新的客户端连接, 创建一个新的子进程来处理，每个服务器子进程执行完所有服务于单个客户端的任务后就终止。因此可以同时处理多个客户端。
    &lt;ul&gt;
      &lt;li&gt;由于 服务器为每个客户端连接创建一个子进程，需要保证不会出现僵尸进程，所以需要为信号SIGCHLD 安装信号处理器。&lt;/li&gt;
      &lt;li&gt;主进程 主要由for 循环组成。在循环中accept 链接，然后fork 创建子进程， 在子进程中 调用hanldeRequest来处理客户端。（现实世界中，需要限制 服务器创建子进程的数量，大量的子进程会使系统变的不可用。）&lt;/li&gt;
      &lt;li&gt;每次fork后，监听套接字和连接套接字都在子进程中得到了复制。父进程 关闭 连接套接字， 子进程关闭 监听套接字。（如果父进程没有关闭 连接套接字的话 那么连接套接字永远不会被关闭，从而导致文件描述符被用完。监听套接字并不会这样，因为子进程 结束之后会释放所有的文件描述符）&lt;/li&gt;
      &lt;li&gt;每个子进程处理完客户端之后，终止&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;并发型服务器的其他设计:
    &lt;ul&gt;
      &lt;li&gt;预先创建进程或线程:
        &lt;ol&gt;
          &lt;li&gt;服务器在启动阶段就立刻 预先创建好一定数量的 子进程， 而不是针对一个新的客户端来创建 一个子进程。这些子进程构成了一个 服务池&lt;/li&gt;
          &lt;li&gt;每个子进程一次只处理一个客户端，在处理完之后，子进程并不终止，而是获取下一个待处理的客户端继续处理。&lt;/li&gt;
          &lt;li&gt;主进程需要仔细的管理子进程，并可以相应的根据负载来调节子进程的数量大小，此外， 子进程需要遵循某些协议，是的他们是以 独占 的方式来处理一个客户端的 连接套接字的。在大多数的UNIX实现中，让子进程 在监听套接字上调用accept即可，（即是: 主进程先创建 监听套接字，子进程在每个fork之后 继续使用套接字 并 accept，因为accept调用是一个原子化的操作，所以当客户端连接 到来时，之后一个子进程能够完成 accept调用。负载则由系统进行调度）&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;单个进程中处理多个客户端: 必须能够允许单个进程同时监听多个文件描述符上 IO事件 （IO多路复用， 信号驱动IO， epoll），单进程服务器需要做一些通常由内核来处理的调度任务。在 进程服务池 的设计中，我们可以依靠内核来确保每个服务器进程 能够公平的访问服务器主机的资源。但是当使用 单个进程处理多个客户端的方案时，服务器进程必须自行确保一个或多个 客户端不会霸占服务器，而使 其他的客户端处于饥饿状态&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;服务器集群:
    &lt;ul&gt;
      &lt;li&gt;DNS 轮询负载共享:一个地区的域名权威服务器将同一个域名映射到多个IP地址上（即 多个服务器共享统一域名）后续对DNS服务器的域名解析请求将以 循环轮转的方式返回这些IP地址，优势是成本低，存在的问题有:客户端 DNS缓存、 没有任何机制来达到良好的负载均衡、高可用 的机制 以及 无法确保同一个客户端的请求都到达同一台服务器（所以存在状态的服务器 需要在多个机器之间共享状态 这个特性成为 服务器亲和力）&lt;/li&gt;
      &lt;li&gt;负载均衡(server load balancing): 由一台负载均衡服务器将客户端的请求路由到服务器集群中的一个，这消除了 远端DNS 缓存所引起的问题。因为服务器集群只对外传递一个IP地址。负载均衡服务器会 结合一些算法来衡量或计算服务器负载 并智能化的 将负载分发到 集群中的各个成员上，可能还会提供对服务器亲和力的支持&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;inted 守护进程:
    &lt;ol&gt;
      &lt;li&gt;守护进程 inetd 被设计为用来消除运行大量非 常用服务器进程的需要，inetd 优势有:
        &lt;ol&gt;
          &lt;li&gt;预期为每个服务运行一个单独的守护进程，现在只用一个进程 inetd 守护进程，就可以监视一组指定的套接字端口，并按照需要启动其服务，因为可以降低系统进程的运行数量&lt;/li&gt;
          &lt;li&gt;inetd 简化了 启动服务的编程工作。&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;inetd 进程:
        &lt;ol&gt;
          &lt;li&gt;读取 /etc/inetd.conf 文件，对于其中的每项服务，创建一个 恰当类型的套接字，然后绑定到指定的端口上，其中每个TCP套接字 都会通过listen 允许客户端请求连接&lt;/li&gt;
          &lt;li&gt;通过select调用， inetd 对前一步中创建的所有的套接字进行监听，看是否有数据报或者连接请求 进来&lt;/li&gt;
          &lt;li&gt;select 进入阻塞状态: 直到一个UDP 数据报到来或 TCP 监听套接字 收到连接请求。TCP 会进行accept&lt;/li&gt;
          &lt;li&gt;启动套接字对应的服务，inetd 调用fork创建 一个新进程，然后调用exec 启动服务器程序，执行exec前，子进程执行如下步骤:这里面 子进程 代表的是 inetd 守护进程的标准执行过程, 所以需要执行步骤2，方便exec启动的服务器程序 使用标准文件描述符来 对客户端进行通讯
            &lt;ol&gt;
              &lt;li&gt;关闭从父进程继承的所有文件描述符，除了 用于监听的套接字&lt;/li&gt;
              &lt;li&gt;在文件描述符0，1，2上复制套接字文件描述符，并关闭套接字文件描述符本身，完成这一步之后，启动服务器进程就能通过 这三个标准 文件描述符 同套接字 通讯了&lt;/li&gt;
              &lt;li&gt;为启动的服务器进程设定用户、组ID （可选，通过/etc/inetd.conf 配置）&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
          &lt;li&gt;如果是TCP套接字，则关闭连接套接字&lt;/li&gt;
          &lt;li&gt;返回到 第 2步骤，继续执行&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;/etc/inetd.conf 配置文件:&lt;/p&gt;

        &lt;table&gt;
          &lt;thead&gt;
            &lt;tr&gt;
              &lt;th style="text-align: left"&gt;service name&lt;/th&gt;
              &lt;th style="text-align: left"&gt;socket type&lt;/th&gt;
              &lt;th style="text-align: left"&gt;protocol&lt;/th&gt;
              &lt;th style="text-align: left"&gt;flags&lt;/th&gt;
              &lt;th style="text-align: left"&gt;login name&lt;/th&gt;
              &lt;th style="text-align: left"&gt;server program&lt;/th&gt;
              &lt;th style="text-align: left"&gt;server program argument&lt;/th&gt;
            &lt;/tr&gt;
          &lt;/thead&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td style="text-align: left"&gt;ftp&lt;/td&gt;
              &lt;td style="text-align: left"&gt;stream&lt;/td&gt;
              &lt;td style="text-align: left"&gt;tcp&lt;/td&gt;
              &lt;td style="text-align: left"&gt;nowait&lt;/td&gt;
              &lt;td style="text-align: left"&gt;root&lt;/td&gt;
              &lt;td style="text-align: left"&gt;/usr/sbin/tcpd&lt;/td&gt;
              &lt;td style="text-align: left"&gt;in.ftpd&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td style="text-align: left"&gt;telnet&lt;/td&gt;
              &lt;td style="text-align: left"&gt;stream&lt;/td&gt;
              &lt;td style="text-align: left"&gt;tcp&lt;/td&gt;
              &lt;td style="text-align: left"&gt;nowait&lt;/td&gt;
              &lt;td style="text-align: left"&gt;root&lt;/td&gt;
              &lt;td style="text-align: left"&gt;/usr/sbin/tcpd&lt;/td&gt;
              &lt;td style="text-align: left"&gt;in.telnetd&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td style="text-align: left"&gt;login&lt;/td&gt;
              &lt;td style="text-align: left"&gt;stream&lt;/td&gt;
              &lt;td style="text-align: left"&gt;tcp&lt;/td&gt;
              &lt;td style="text-align: left"&gt;nowait&lt;/td&gt;
              &lt;td style="text-align: left"&gt;root&lt;/td&gt;
              &lt;td style="text-align: left"&gt;/usr/sbin/tcpd&lt;/td&gt;
              &lt;td style="text-align: left"&gt;in.rlogind&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
    &lt;/ol&gt;

    &lt;ul&gt;
      &lt;li&gt;service name (服务名称): 该字段为服务名称，结合 protocol 就可以通过查找 /etc/services 文件以确定 inted 问该服务监听的 端口号&lt;/li&gt;
      &lt;li&gt;socket type (套接字类型): stream, or dgram&lt;/li&gt;
      &lt;li&gt;protocol(协议): 该字段指定了 这个套接字所使用的协议，这个字段 可以包含文件 /etc/protocols 中所列出的任何的 internet 协议&lt;/li&gt;
      &lt;li&gt;flags:
        &lt;ul&gt;
          &lt;li&gt;wait or nowait 字段表明 由 inetd 启动的服务器 是否会接管 用于该服务的 监听套接字。 wait 表明 启动的服务器 需要管理 该监听套接字，inetd 将该套接字从它所监视的文件描述符列表中移除, 直到这个服务器程序退出为止。&lt;/li&gt;
          &lt;li&gt;inetd 调用的 TCP 服务器通常被设计为 只处理一个单独的客户端连接，处理完后就终止， 把监听其他链接的任务留给inetd, 对于这样的服务器， flags字段应为 nowait, 相反 如果是被执行的服务器进程 来接受连接（accept）的话，那么该字段为wait, 此时inetd 不会去接受连接，而是将监听套接字 作为 文件描述符0 传递给 服务器进程。对于大部分的UDP 服务器， flags字段需要设定为wait， 由 inetd 调用的UDP 服务器设定为 读取并处理所有套接字上未完成的数据报，然后终止（通常需要一些超时机制）wait 可以组织 inetd在套接字上做select，会导致inetd 同 UDP 服务器程序之间，产生竞争条件，如果inetd 赢了，会启动一个新的 UDP 服务器实例&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;login name(登录名) :该字段为 /etc/passwd 中的用户名组成部分，还可以在其后 添加 “:” + /etc/group 中的组名称， 这些确定了运行的服务器程序的用户ID和组ID， 因为inetd为 root 方式运行，所以 子进程同样可以是 特权进程。 因此可以在需要时 通过调用setuid, setgid 来修改进程凭证&lt;/li&gt;
      &lt;li&gt;serever program (服务器程序): 指定了 被执行程序的服务器程序路径&lt;/li&gt;
      &lt;li&gt;server program argument(服务器 程序参数): 该字段指定了 一个或多个参数， 参数之间由 空格符分隔，当执行服务器程序时，这些参数就作为程序的参数列表&lt;/li&gt;
      &lt;li&gt;inetd 作为一个提高效率的机制，本身就实现了一些简单的服务，而无需单独的 服务器程序编码来完成任务， UDP， TCP 的echo 服务就是由inetd 来实现的一个例子。编辑修改 /etc/inetd.conf 之后，需要 killall -HUP inetd 发送SIGHUP信号来重新读取配置文件&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="socket-高级主题"&gt;socket 高级主题&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;流式套接字 上的部分读和部分写
    &lt;ul&gt;
      &lt;li&gt;read, write 系统调用 会产生部分读 和 部分写，在流式套接字上 更容易出现这样的问题。套接字傻姑娘可用的数据比read 读取的数量要少，那么read就会出现部分读 的现象，但是只是简单的返回读取的内容大小。write 调用在没有足够的缓冲区 来传输所有的字节时，并且 被信号处理函数中断 或 在 非阻塞模式下工作 或 TCP连接出现问题 write 会产生部分写的现象。 readn， writen 这两个函数 使用循环来 启用这些系统调用，总能确保 所有的数据都会被写入 或者读取。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;shutdown(int sockfd, int how) 系统调用&lt;br /&gt;
 &lt;strong&gt;套接字 上调用close 将双向通讯通道 的两端都关闭，shutdown 提供了 更精细的控制&lt;/strong&gt; 其中how的选项有；
    &lt;ul&gt;
      &lt;li&gt;SHUT_RD: 关闭连接的 读取端， 之后的读取操作将返回文件结尾，写入套接字操作依然可以进行。在UNIX domain 上进行 SHUT_RD, 对端的应用程序 将接受一个 SIGPIPE 信号，对端程序依然写入的话 将产生 EPIPE 错误， 对于TCP 套接字来说没有什么意义（需要在 61.6.6 中讨论）&lt;/li&gt;
      &lt;li&gt;SHUT_WR: 关闭连接的 写端， 对端 会检测到 文件结尾。后续对套接字的读取操作会产生 SIGPIPE 信号以及 EPIPE 错误，而由对端的写入数据依然可以在套接字上正常读取。这个操作允许我们依然可以读取数据，并且告知对方写入已经完成。该操作在ssh 中rsh中 有用到，并称为 半关闭 套接字&lt;/li&gt;
      &lt;li&gt;SHUT_RDWR: 将连接的读写端都关闭。等同于调用了 shutdown SHUT_RD, SHUT_WR&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;区分于close: shutdown 关闭的是系统级 文件表， 而非 进程文件描述符。 这意味着， 父进程 shutdown之后， fork 的子进程中的文件描述符 同样受到影响。需要注意的是， shutdown 并不会关闭进程文件描述符， 依然需要进程close来关闭文件描述符&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight c"&gt;&lt;code&gt;&lt;span class="n"&gt;fd2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dup&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 之后依然可以在 fd2上进行IO操作
//--------
&lt;/span&gt;&lt;span class="n"&gt;fd2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dup&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;shutdown&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SHUT_RDWR&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 之后无法在fd2 上sockfd 上 进行IO操作
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;recv, send, 专属于  套接字的IO系统调用:
    &lt;ul&gt;
      &lt;li&gt;recv(int sockfd, void * buffer, size_t length, inf flags) flags 的选项有:
        &lt;ul&gt;
          &lt;li&gt;MSG_DONTWAIT:  使recv 以非阻塞方式执行， 没有数据可用 立即返回， 错误码为EAGAIN, 同样可以通过 fcntl 来把套接字设定为非阻塞方式运行， 区别在于，这个可以设定每次的调用的阻塞行为&lt;/li&gt;
          &lt;li&gt;MSG_OOB: 在 套接字上接受带外数据&lt;/li&gt;
          &lt;li&gt;MSG_PEEK: 从套接字数据缓冲区 获取一份请求字节的副本，但不会将数据从缓冲区中移除，这份数据可以在之后的read中重新读取&lt;/li&gt;
          &lt;li&gt;MSG_WAITALL: 指定标记后， 将导致系统调用阻塞到 接收到length字节，但是总会出现返回的字节数少于 length的情况: 1）捕获到一个信号， 2）对端终止了连接 3） 遇到了带外数据字节 d）接收到的数据总长度小于 length， 4）套接字错误&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;send(int sockfd, const void * buffer, size_t length, int flags)
        &lt;ul&gt;
          &lt;li&gt;MSG_DONTWAIT: send 以非阻塞方式运行，如果 数据不能立即传送（发送缓冲区满时）该调用失败，错误码 EAGAIN&lt;/li&gt;
          &lt;li&gt;MSG_MORE: 在TCP 套接字上，这个标记实现的效果同 套接字选项 TCP_CORK 完成的功能相同，区别在于该标记可以在每次调用中 对数据进行 栓塞 处理。&lt;/li&gt;
          &lt;li&gt;MSG_NOSIGNAL: 指定该标记时，在已连接的套接字上发送数据时，如果连接的另一端已经关闭时，send 不会产生SIGPIPE信号，而是返回错误 EPIPE&lt;/li&gt;
          &lt;li&gt;MSG_OOB: 在流式套接字 上 发送带外数据&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;size_t sendfile(int outfd, int in_fd, off_t * offset, size_t count):&lt;br /&gt;
 传输文件的简单写法:
&lt;div class="highlight"&gt;&lt;pre class="highlight c"&gt;&lt;code&gt;   &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;diskfilefd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BUZ_SIZE&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;p&gt;示例代码中 read 简单的将文件内容 从内核缓冲区cache中拷贝到用户空间，write将用户空间缓冲区拷贝到内核空间中的socket缓冲区。 sendfile 被用来减少这种操作的低效性。文件内容会直接传送到套接字上，而不会经过用户空间， 这种技术成为 zero-copy transfer 零拷贝传输&lt;br /&gt;
 sendfile 函数调用的限制: out_fd 必须为套接字， in_fd 必须指向文件，能够进行mmap，这通常只能是一个普通文件。&lt;br /&gt;
 &lt;img src="../../../../images/zero_copy-a3db77b5.png" alt="zero_copy" /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;TCP_CORK 套接字选项: 为了提高TCP使用效率（linux专有的选项），在web服务器传送页面时候，作为请求的响应，通常由两部分组成， HTTP 首部， 页面数据，单独的使用write操作 会传输2个TCP报文段，一个非常小的HTTP报文放在第一个分段中，这对网络是非常浪费的。这时候使用TCP_CORK 来避免其低效性。当在TCP 套接字上启用 TCP_CORK 选项时，之后所有的数据都会穿充到一个单独的TCP 报文段中，直到满足以下条件为止: 以达到报文段的大小上限、取消了 TCP_CORK 选项、套接字被关闭、或者启用 TCP_CORK后，从写入的第一个字节开始已经超过200ms（防止忘记取消 TCP_CORK 选项，超时时间可以保证传输）下面例子 介绍如何使用 TCP_CORK:
&lt;div class="highlight"&gt;&lt;pre class="highlight c"&gt;&lt;code&gt; &lt;span class="n"&gt;optval&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
 &lt;span class="n"&gt;setsockopt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;IPPROTO_TCP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;TCP_CORK&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;optval&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="c1"&gt;// enable TCP_CORK
&lt;/span&gt; &lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...);&lt;/span&gt;
 &lt;span class="n"&gt;sendfile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...);&lt;/span&gt;
 &lt;span class="n"&gt;optval&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
 &lt;span class="n"&gt;setsockopt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;IPPROTO_TCP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;TCP_CORK&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;optval&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="c1"&gt;// disable TCP_CORK, TCP 开始传输
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
  &lt;li&gt;获取套接字地址:
    &lt;ul&gt;
      &lt;li&gt;getsockname(int sockfd, struct sockaddr * addr, socklen_t * addrlen): 获取本地套接字地址， sockfd表示套接字的描述符， addr 为返回的套接字地址存储结构， addrlen 为 addr 结构的大小。在套接字并不是由自己初始化时，如 inet调用的应用程序只能获取 已经存在套接字，则可以通过该函数 获取 对应的绑定地址。&lt;br /&gt;
&lt;!-- 1. 当隐式得绑定到一个 --&gt;&lt;/li&gt;
      &lt;li&gt;getpeername(int sockfd, struct sockaddr * addr, socklen_t * addrlen): 获取对端的套接字地址, sockfd, 为对端的套接字描述符， 其他的同 getsockname 一致。在TCP 连接中，可以在accept时获取对端地址，但是如果服务器进程是由另一个进城调用的，比如inetd，那么这个函数就非常有用&lt;/li&gt;
      &lt;li&gt;内核隐式绑定的情况:
        &lt;ol&gt;
          &lt;li&gt;已经在TCP 套接字上执行了connect， listen调用，但之前并没有bind 调用到一个地址上&lt;/li&gt;
          &lt;li&gt;在UDP套接字上 首次调用sendto，盖套接字之前并没有bind到地址上&lt;/li&gt;
          &lt;li&gt;调用bind 时，将端口号 指定为0， 这种情况下 bind 会为套接字制定一个IP地址，并选择一个临时端口号&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;深入探讨TCP 协议
    &lt;ol&gt;
      &lt;li&gt;TCP 报文格式&lt;br /&gt;
 &lt;img src="../../../../images/tcp_segment-c7d14f9b.png" alt="zero_copy" /&gt;
        &lt;ul&gt;
          &lt;li&gt;Source port number（源端口号）: TCP 发送端的端口号&lt;/li&gt;
          &lt;li&gt;Destination port number(目的端口号): TCP 接收端的端口号&lt;/li&gt;
          &lt;li&gt;Sequence number(序列号): 报文的 序列号&lt;/li&gt;
          &lt;li&gt;Acknowledgement number（确认序列号）: 如果设定了ACK 位，那么这个字段包含了接收方期望从发送方接收到的下一个 报文的序列号&lt;/li&gt;
          &lt;li&gt;Header length: 表示TCP 报文首部的长度，首部长度单位是32位，因为这个字段只有4个byte位，所以首部总长度最大可以达到 60字节， 该字段 是的TCP接收端可以确定变长的选项字段的长度，以及数据域的起始点&lt;/li&gt;
          &lt;li&gt;Reserved（保留位）: 该字段包含4个为啥喜欢i用的byte （必须设置为 0）&lt;/li&gt;
          &lt;li&gt;Control bit（控制位）: 8个byte组成:&lt;br /&gt;
    - CER: 拥塞窗口减小标记&lt;br /&gt;
    - ECE: 现实的拥塞通知回显标记 cwr &amp;amp; ece 标记用在TCP 的显示拥塞通知(ECN)算法中。 linux中 可以通过编辑文件 /proc/sys/net/ipv4/tcp_enc 设定一个非零值 来开启这个功能&lt;br /&gt;
    - URG: 设定了该位， 紧急指针字段包含的信息是有效的&lt;br /&gt;
    - ACK: 如果设定了该位， 那么确认序号字段包含的信息就是有效的 （可以同时包含对对端数据报的确认）&lt;br /&gt;
    - PSH: 将所有收到的数据发给接受的进程 (RFC993)&lt;br /&gt;
    - RST: 重置连接&lt;br /&gt;
    - SYN: 同步序列号，在建立连接时，双方需要交换设定了该位的报文，使得tcp 连接的两段可以指定初始序列好&lt;br /&gt;
    - FIN: 发送端提示已经完成了传送任务，TCP 连接关闭&lt;/li&gt;
          &lt;li&gt;Window size （窗口大小）: 滑动窗口机智有关， 用于 在ACK确认时 提示自己可以接受数据的空间大小&lt;/li&gt;
          &lt;li&gt;Checksum(校验和)&lt;/li&gt;
          &lt;li&gt;Urgent Pointer(紧急指针): 设定了该位置， 表示传送的数据位紧急数据&lt;/li&gt;
          &lt;li&gt;Options(选项): 这是一个变长的字段， 包含了控制TCP连接操作的选项&lt;/li&gt;
          &lt;li&gt;Data （数据）: 包含了该报文中 传输的用户数据&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;TCP 序列号 和 确认机制&lt;br /&gt;
每个通过TCP 连接传送的字节都由TCP 协议分配了一个逻辑序列号，双向数据流都有各自的序列号，当传送一个报文时，该报文的序列号被设为该传送方向上的 报文段数据域的第一个字姐的逻辑偏移。这样接收端 就可以按照正确的顺序对接收到的报文进行重组了。TCP 采用了主动确认，当一个报文段被成功接收后， 接收端会发送一个确认信息 即发送ACK 确认报文 给发送端，该报文的 确认序号字段被设置为 期望接受的下一个数据字节的逻辑序列号 （上一个成功收到的序列号 + 1 ）TCP 发送端发送报文时会启动一个定时器，如果在定时器超时时，仍未收到确认报文，那么就重传该报文 (注意 序列号并非常简单的递增 1，而是 按照 传送报文数据 大小来递增的 如下图)&lt;br /&gt;
&lt;img src="../../../../images/tcp_ack-5abca238.png" alt="tcp_ack" /&gt;&lt;/li&gt;
      &lt;li&gt;TCP 连接的建立: API 层面: 服务器）调用listen 打开套接字，然后accept， 阻塞服务器进程 直到连接建立完成。客户端）调用connect 同服务器打开的套接字 建立连接
        &lt;ol&gt;
          &lt;li&gt;客户端 TCP节点 发送一个SYN 报文到服务器 TCP端，这个报文将告知 服务器有关客户端的TCP节点的初始序列号 （因为序列号不是从0 开始）&lt;/li&gt;
          &lt;li&gt;服务器 TCP端 发送确认 客户端 SYN报文的 ACK报文，并同时携带 SYN 的序列号。 即发送ACK，SYN 报文&lt;/li&gt;
          &lt;li&gt;客户端 TCP 节点发送一个ACK报文 来确认服务器端的TCP SYN 报文&lt;br /&gt;
 &lt;img src="../../../../images/tcp_three_hand_shake-74c83b94.png" alt="tcp_three_hand_shake" /&gt;&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;TCP 连接的终止: 一端的应用程序执行close 调用 （主动关闭）， 之后 连接另一端的应用程序 也执行close调用（被动关闭）下面的报文顺序为假设 客户端 发起主动关闭
        &lt;ol&gt;
          &lt;li&gt;客户端执行主动关闭， 导致客户端TCP节点 发送一个FIN报文到服务器端&lt;/li&gt;
          &lt;li&gt;服务器端收到FIN 报文后，发送 ACK 报文进行响应。（之后服务器端任何对 套接字 read 操作 的尝试都会读取到 文件结尾）&lt;/li&gt;
          &lt;li&gt;稍后， 当服务器关闭 自己端的 连接时，服务器端 TCP 节点发送 FIN报文到客户端&lt;/li&gt;
          &lt;li&gt;客户端TCP 节点发送ACK报文作为响应&lt;br /&gt;
 &lt;img src="../../../../images/tcp_close-a6b10984.png" alt="tcp_close" /&gt;&lt;br /&gt;
 上面讨论的是 close 全双工的关闭(连接虽然是双向的，但是TCP节点的状态是唯一共享的)， 然而系统调用允许 shutdown 调用来关闭其中的一个通道，使TCP 成为 一个半双工。我们使用 shut_rdwr, SHUT_WR 来调用 shutdown 时候，TCP 连接将开始上面的关闭步骤。本地的 TCP节点 迁移到FIN_WAIT1 状态， 然后进入 FIN_WAIT2 状态，对端的进入到 CLOSE_WAIT 状态， 如果参数为 SHUT_WR 那么 套接字依然合法（合法的定义是？ 某种符合条件的状态？ FIN_WAIT1， FIN_WAIT2 正好处于 接受对端的ACK 报文， 而没有收到对方FIN 的状态，即 自己主动关闭成功，对方并未关闭），读端依然是打开的，因为对端的写入操作依然可以进行。这里 SHUT_RD 在TCP套接字上没有实际意义的原因是因为， 大多数TCP协议的实现都没有为 SHUT_RD 提供所期望的行为。导致该参数调用的shutdown 并不具有可移植性&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;TIME_WAIT 状态: 执行主动关闭的TCP 端在该状态下， 等待 2MSL时间，然后迁移到closed 状态。 这样的设计目的有两点:（该状态应该只存在于 主动关闭的 TCP 节点上，主要原因在于， 主动关闭的节点 需要对上一条 别动关闭的节点 的FIN报文响应 ACK报文，并组织新的连接的创建 来 保证TCP 可靠性连接的建立）
        &lt;ul&gt;
          &lt;li&gt;实现可靠的链接终止:等待2被的MSL， 这里的MSL 是TCP报文最大生存时间&lt;/li&gt;
          &lt;li&gt;让老的重复的数据报文段在网络中过期失效:TCP协议采用的重传算法，可能会产生重复的报文，根据路由器选择，这些重复的报文可能会在连接已经终止后到达， 而之后使用同样的IP端口重新建立的连接， 然后接收到的数据报 在这种情况下， 为了保证上一次连接中老的重复报文不会重复的出现在新的连接中被当成合法报文接收。当有TCP节点处于TIME_WAIT 状态时 是无法通过 该节点 创建新的连接的。这样就组织了新链接的建立。（在论坛上会看到相关的 如何关闭 TIME_WAIT 状态，因为重新启动的服务器进程会尝试将套接字绑定到处于 TIME_WAIT 状态的地址上时候，会出现 EADDRINUSE 的错误，尽管有办法关闭 TIME_WAIT状态 但是还是应该避免这样做， 因为会阻碍 TCP 提供可靠性保证）&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;netstat(监视套接字)&lt;br /&gt;
 netstat 程序可以显示系统中Internet 和 UNIX域套接字的状态， 是一个非常好的调试工具, 大多数的Unix 都会提供一个版本的 netstat， 但是各个实现中的命令行参数语法有很大的区别&lt;br /&gt;
 其中展示的信息中的字段含义列表有:更多的细节需要查阅netstat用户手册，  /proc/net中有多个专属Linux 的文件，例如tcp, udp, 的呢个，获取更多细节，参考 proc&lt;/p&gt;

        &lt;table&gt;
          &lt;thead&gt;
            &lt;tr&gt;
              &lt;th style="text-align: left"&gt;字段名称&lt;/th&gt;
              &lt;th style="text-align: left"&gt;含义&lt;/th&gt;
            &lt;/tr&gt;
          &lt;/thead&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td style="text-align: left"&gt;Proto&lt;/td&gt;
              &lt;td style="text-align: left"&gt;套接字所使用的协议&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td style="text-align: left"&gt;Recv-Q&lt;/td&gt;
              &lt;td style="text-align: left"&gt;套接字接收缓冲区中还未被本地应用读取的字节数（UDP 中该字段不仅仅包含数据还包含头部信息等）&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td style="text-align: left"&gt;Send-Q&lt;/td&gt;
              &lt;td style="text-align: left"&gt;套接字发送缓冲区中排队等待发送的字节数（同Recv-Q 一样 UDP）&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td style="text-align: left"&gt;Local Address&lt;/td&gt;
              &lt;td style="text-align: left"&gt;套接字绑定到的地址， 主机IP:端口号 展现形式&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td style="text-align: left"&gt;Foreign Address&lt;/td&gt;
              &lt;td style="text-align: left"&gt;对端套接字锁绑定到的地址， *:* 表示没有对端地址&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td style="text-align: left"&gt;State&lt;/td&gt;
              &lt;td style="text-align: left"&gt;当前套接字所处的状态&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
      &lt;li&gt;tcpdump: 有用的调试工具，可以让超级用户监视网络中的 实时流量，实时生成文本信息， 可以显示所有类型的TCP/IP 数据报流量。显示方式如下(具体的使用细节需要google):&lt;br /&gt;
 src &amp;gt; dst: flags data-seqno ack window urg &lt;options&gt;
&lt;/options&gt;        &lt;ul&gt;
          &lt;li&gt;src, dst: 源 IP 地址和端口， 目的 IP 地址 和端口号&lt;/li&gt;
          &lt;li&gt;flags: TCP 报文控制位 信息， 他们是 S(SYN) , F(FIN), P(PSH), R(RST), E(ECE), C(CWR) 中的标记位组合&lt;/li&gt;
          &lt;li&gt;data-seqno: 数据报中的序列号范围&lt;/li&gt;
          &lt;li&gt;ack: ack num，对端 期望的下一个方法字节的序列号&lt;/li&gt;
          &lt;li&gt;window: 对端缓冲区大小（存在接收、写入缓冲区两种）&lt;/li&gt;
          &lt;li&gt;urg: urg num 该报文 在指定的偏移量上包含紧急数据&lt;/li&gt;
          &lt;li&gt;options: 任意的TCP选项&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;套接字选项:
        &lt;ul&gt;
          &lt;li&gt;int getsockopt(int sockfd, int level, int optname, void * optval, socklen_t optlen); int setsockopt(int sockfd, int level, int optname, const void * optval, socklen_t optlen) 两个系统调用获取 设定 套接字选项&lt;/li&gt;
          &lt;li&gt;SO_REUSEADDR 套接字选项: 该选项主要应用在 服务器bind 地址时候，出现EADDRINUSE 错误（即存在TCP节点处于 TIME_WAIT 状态）出现该现象的情况有:
            &lt;ol&gt;
              &lt;li&gt;之前连接到 客户端的服务器 被close， 或者是 崩溃 而执行了一个主动关闭，这就使得 TCP节点处于 TIME_WAIT状态， 直到 2倍的MSL超时 过期为止&lt;/li&gt;
              &lt;li&gt;服务器创建一个子进程来处理客户端的请求， 稍后，服务器终止， 而子进程继续服务客户端， 因为使得 TCP 节点占用了服务器的 端口号&lt;br /&gt;
  针对以上情况，默认的TCP实现会阻止 新的监听套接字的绑定， （客户端不常出现这样的错误， 因为他们一般使用的是不会处在 TIME_WAIT 的临时端口号(新建的连接会选择新的端口号)，但是如果客户端指定的保定到一个端口上那么还是会遇到这个问题）&lt;/li&gt;
              &lt;li&gt;（类比并不严谨）accept 需要识别出 一个新来的套接字，系统内 记录的大概内容是 [ {local-ip-Address, local-port, Foreign-ip-address, Foreign-port }] 每个 已连接的套接字对应的对端的一个套接字，当有链接对应的接入时，通过对端的 TCP 报文 中对应的 ip port 可以识别出对应的 本地的 已经接套接字，如果没有对应的连接套接字存在 则 accpet 创建新的 连接套接字。 TCP 规范要求这个4 元祖是唯一的，问题在于大多数的 实现 都强制限制了 一个更为严格的约束，如果本地存在 可以匹配到本地端口 TCP连接， 则本地端口不能被重用 （即 不能bind 该 端口号）也不能在接受新的链接（即不能accept） 启用该socket选项可以放开这个限制，即便是 情况 2 我们依然可以绑定到该地址，大多数的TCP 服务器应该启用这个选项。&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;UDP 相对TCP 的优势有: 1）UDP 服务器可以从多个客户端接受数据报，而不必为每个 客户端 创建和终止连接 2） 对于简单的请求: UDP的速度更快， 因为UDP不需要建立 和终止连接. DNS 是一个 应用UDP的绝好例子。&lt;/li&gt;
      &lt;li&gt;传递 文件描述符: 通过sendmsg, recvmsg 系统调用，我们可以在同一台主机 上通过UNIX 域套接字 将文件描述符 辅助数据 从一个进程传递到 另一个进程中。 这种方式可以传递任意类型的文件描述符（open 得到的文件描述符， 套接字）这个可以应用在服务器的并发模型中， 主进程可以在TCP监听套接字上接收客户端连接，然后将返回的文件描述符传递给进程池中的一个，之后子进程就可以响应客户端的请求了（虽然这种技术通常称为 传递文件描述符， 但实际上 进程间 传递的是对同一个打开文件描述符的引用。在接收端进程中使用的文件描述符一般和发送进程中文件描述符不同）&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="其他-的io模型-io多路复用-信号驱动io-linux专有-epoll"&gt;其他 的IO模型: IO多路复用， 信号驱动IO， Linux专有 epoll&lt;/h3&gt;
&lt;p&gt;&lt;em&gt; 大部分的程序使用的IO 模型都是单个进程 在多个文件上执行阻塞IO，例如 在管道上调用read，如果管道 中没有数据，那么read会阻塞到 直到管道中有数据，才会继续执行后续的工作。（磁盘文件是一个特例， 对磁盘的write 会立即返回，而不是等到将数据写入到磁盘文件上之后才返回。对应的read 如果数据不在缓冲区内，内核会休眠该进程 （内核 缓存页 调度）然后再 继续read）&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;问题:  然而 依然存在下面的需求:
    &lt;ol&gt;
      &lt;li&gt;以非阻塞的方式检查文件描述符上是否可以进行IO操作&lt;/li&gt;
      &lt;li&gt;同时检查多个文件描述符，查看其中一个是否可以进行IO 操作&lt;br /&gt;
  &lt;strong&gt;现有的系统调用 部分的可以满足这两种需求: 多线程和IO非阻塞（对打开的文件描述符设定 O_NONBLOCK) 非阻塞 IO 可以使我们周期性的检查 某个文件描述符是否可以进行IO操作， 那么同时操作多个IO文件描述就有下面的几种方式:&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;周期性的对多个文件描述进行检查，即轮询，这种轮询通常是我们不希望看到的，轮询频率不高的话，应用程序对IO延迟可能会非常高， 频率高的话，则非常浪费CPU&lt;/li&gt;
          &lt;li&gt;多线程、多进程 的方式进行多个文件描述符的操作: 即 分离开 一个单独的进程、线程来 操作 单个文件描述符，分离多个即可操纵多个文件描述符。这样的弊端在于，多进程 会占用太多的系统资源，多线程、多进程依然需要进行进程、线程间的沟通，导致编码复杂（多线程尤为复杂繁琐）&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;于是有下面几种备选的 IO方案（其共同解决的问题是: 同时检查多个文件描述符，以检查是否可以进行IO操作。文件描述符的就绪转换是通过一些IO事件来触发的。（比如 输入数据的到达、套接字建立的完成、tcp数据报被传送之后，缓冲区有了更多的剩余空间等）同时检查多个 文件描述符对服务器程序，以及同时检查 终端、管道、套接字等程序 是非常有帮助的）
    &lt;ol&gt;
      &lt;li&gt;IO 多路复用: 允许进程同时检查多个文件描述符 以找出他们中一个可以执行IO操作， 系统调用 select poll 可以用来执行IO多路复用&lt;/li&gt;
      &lt;li&gt;信号驱动IO: 当输入或者数据可以写到指定的文件描述符时候，内核向进程发送一个信号，进程通过接收到信号之后来处理IO任务。当检查大量的文件描述符时 相对于 select， poll 等可以显著的提升性能&lt;/li&gt;
      &lt;li&gt;epoll(Linux专有的特性): 具有多路复用、信号驱动IO 的优点， 允许同时检查多个文件描述符， 当检查大量的描述符时候，依然有很好的性能表现&lt;/li&gt;
      &lt;li&gt;总结来说: epoll 相对于select具有性能优势，对比 信号驱动IO 具有避免了信号处理的复杂性。唯一的缺点在于 其为linux专有，没有很好的可移植性&lt;/li&gt;
      &lt;li&gt;Libevent 提供了一个检查文件描述符IO 事件的抽象，Libevent的底层机制能够以透明的方式 应用select， poll, 信号驱动IO， epoll。&lt;a href="http:://monkey.org/~provos/libevent/"&gt;项目地址&lt;/a&gt; 当然是通过google更简单啦&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;IO 通知模式:
    &lt;ol&gt;
      &lt;li&gt;边缘触发:文件描述符自 上次状态检查以来有了新的IO活动 （比如新的输入）此时需要边缘触发通知。采用边缘触发通知意味着  只有当IO事件发生时 才会收到通知，而且我们并不知道需要处理多少IO字节，所以采用边缘触发通知的程序需要按照如下规则设计:
        &lt;ul&gt;
          &lt;li&gt;再接收到一个IO事件通知后: 程序应该在某个时刻 在相应的文件描述符上尽可能多的执行IO，如果程序没有这么做，则可能失去执行IO 的机会，因为在另一个IO事件到达之前，程序不会再接收到通知了，前面我们说 在某个时刻 的原因在于，接收到通知时候后，可能并不适合立刻执行IO操作，更深层次的原因在于，如果我们仅对一个文件描述符进行IO操作，可能会让其他的 文件描述符处于饥饿状态。&lt;/li&gt;
          &lt;li&gt;文件描述符需要设定为 非阻塞模式， 因为 第一条，每次IO操作需要进行尽可能多的IO操作&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;水平触发: 如果文件描述符上可以非阻塞的执行IO系统调用，此时认为他已经就绪，采用水平通知时: 意味着我们可以随时检查文件描述符的就绪状态，水平触发模式允许我们在任意时刻重复检查文件描述符IO状态，没必要 每次的那个文件描述符就绪后就尽可能的执行IO操作&lt;/p&gt;

        &lt;table&gt;
          &lt;thead&gt;
            &lt;tr&gt;
              &lt;th style="text-align: left"&gt;IØ 模式&lt;/th&gt;
              &lt;th style="text-align: left"&gt;水平触发&lt;/th&gt;
              &lt;th&gt;边缘触发&lt;/th&gt;
            &lt;/tr&gt;
          &lt;/thead&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td style="text-align: left"&gt;select, poll&lt;/td&gt;
              &lt;td style="text-align: left"&gt;支持&lt;/td&gt;
              &lt;td&gt;不支持&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td style="text-align: left"&gt;信号驱动 IO&lt;/td&gt;
              &lt;td style="text-align: left"&gt;不支持&lt;/td&gt;
              &lt;td&gt;支持&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td style="text-align: left"&gt;epoll&lt;/td&gt;
              &lt;td style="text-align: left"&gt;支持&lt;/td&gt;
              &lt;td&gt;支持&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;IO 多路复用:允许我们同时检查多个文件描述符， 查看其中一个是否可以执行IO操作。两个系统调用select， poll
    &lt;ul&gt;
      &lt;li&gt;int select(int nfds, fd_set * readfds, fd_set * writefds, fd_set * exceptfds, struct timeval * timeout):
        &lt;ul&gt;
          &lt;li&gt;readfds: 检测输入是否就绪的文件描述符集合&lt;/li&gt;
          &lt;li&gt;writefds: 检测输出是否就绪的文件描述集合&lt;/li&gt;
          &lt;li&gt;exceptfds: 检测异常情况是否发生的文件描述符集合。 这里的异常情况指的是: 连接到信包模式下的伪终端主设备上的从设备状态发生了变化， 流式套接字上接受到了带外数据&lt;/li&gt;
          &lt;li&gt;fd_set 的操作方式: 四个宏实现: fd_zero(将fdset 初始化为空)， fd_set(将文件描述符fd添加到 fdset中)， fd_clr（将文件描述符fd， 从fdset中移除）fd_isset（检查fd是否是fdset中的一员）fdset又一个最大容量限制， 常量 FD_SETSIZE 决定， 在linux通常为 1024， readfds, writefds, exceptfds 同时也是 保存结果的地方，在调用select之前， 参数需要初始化 为感兴趣的文件描述符集合。select之后 这些结构就是就绪状态的文件描述符集合了。因为参数被修改，所以再次调用select 需要保证每次重新初始化它们。fdset 对应的参数可以指定为NULL， 参数 nfds 需要设定为比所有fdset中文件描述符更大的 + 1， 来供select 过滤掉比这个值更大的文件描述符 （如果是这样的话， 岂不是 select 并没有 直接检查fdset中的 文件描述符）&lt;/li&gt;
          &lt;li&gt;timeout: 参数控制着select 的阻塞行为
            &lt;ul&gt;
              &lt;li&gt;timeout指向的结构体都为 0: select不会阻塞，只是简单的轮询指定的文件描述符集合，是否存在就绪的文件描述就立刻返回&lt;/li&gt;
              &lt;li&gt;NULL:select会一直阻塞 直到下面的事件发生: 1）readfds, writefds， exceptfds 种植定的文件描述符中至少有一个 成为就绪状态， 2） 该调用 被信号处理函数中断， 3） timeout 中指定的时间上线超时&lt;/li&gt;
              &lt;li&gt;Linux 无论 select因为一个或多个文件描述符就绪而返回 或者 被信号中断 返回， timeout非NULL的话，timeout指向结构体都会被修改 表示剩余的超时时间。， SUSv3 规定timeout指向的结构体只有select成功之后才有可能被修改&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;返回值:
            &lt;ul&gt;
              &lt;li&gt;-1: 表示有错误发生，有 EBADF 表示readfds,writefds,exceptfds  中又一个文件描述非法， EINTR 表示被信号处理器中断&lt;/li&gt;
              &lt;li&gt;0: 表示 任何文件描述符成为就绪状态前 select调用已经超时， 其中fdset的参数都会被清空&lt;/li&gt;
              &lt;li&gt;&amp;gt; 0: 表示处于就绪态的文件描述符个数， 如果一个文件描述符 在readfds, writefds, exceptfds中存在多次，则会被多次统计， 即 数值表示的， 3个fdset中的就绪状态的文件描述符之和&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;int poll(struct  pollfd fds[], nfds_t nfds, int timeout): struct pollfd {int fd; short events; short revents; }
        &lt;ul&gt;
          &lt;li&gt;pollfd 结构体中 的events &amp;amp; revents 字段都是 位掩码， 调用者厨师胡嘉爱events来之定需要为描述符fd做检查的事件， poll 返回时， revents 被设定为 该文件描述符实际上发生的事件&lt;/li&gt;
          &lt;li&gt;events 0: 表示对该文件描述符上的事件 不感兴趣，同时 revents字段总是返回0， fd 设定一个负值 会产生同样的效果， 两种方法都可以用来关闭对单个文件描述符的检查&lt;/li&gt;
          &lt;li&gt;timeout 设定了 poll的阻塞行为，如下:
            &lt;ul&gt;
              &lt;li&gt;-1 : poll会一直阻塞知道fds数组中列出的文件描述符有一个达到就绪态 或者 捕获到一信号&lt;/li&gt;
              &lt;li&gt;0: poll 不会一直阻塞，只是检查是否有处于就绪态的 文件描述符&lt;/li&gt;
              &lt;li&gt;&amp;gt; 0: poll 至多阻塞timeout毫秒，直到fds 列表中 的文件描述符有一个达到就绪态， 或者 捕获到一个信号&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;返回值:
            &lt;ul&gt;
              &lt;li&gt;-1 表示有有错发生， 一种可能的错误为 EINTR, 表示该调用被一个信号处理器中断， 并且poll 不会自动恢复&lt;/li&gt;
              &lt;li&gt;0 表示 在文件描述符就绪之前超时了&lt;/li&gt;
              &lt;li&gt;
                &lt;p&gt;&amp;gt; 0: 表示就绪态的 pollfd 结构体数量 （比较于 select， 这里并不会出现重复统计的问题）&lt;/p&gt;

                &lt;table&gt;
                  &lt;thead&gt;
                    &lt;tr&gt;
                      &lt;th style="text-align: left"&gt;位掩码&lt;/th&gt;
                      &lt;th style="text-align: left"&gt;events 中的输入&lt;/th&gt;
                      &lt;th style="text-align: left"&gt;返回 revents&lt;/th&gt;
                      &lt;th style="text-align: left"&gt;描述&lt;/th&gt;
                    &lt;/tr&gt;
                  &lt;/thead&gt;
                  &lt;tbody&gt;
                    &lt;tr&gt;
                      &lt;td style="text-align: left"&gt;POLLIN&lt;/td&gt;
                      &lt;td style="text-align: left"&gt;*&lt;/td&gt;
                      &lt;td style="text-align: left"&gt;*&lt;/td&gt;
                      &lt;td style="text-align: left"&gt;可读取非高优先级的数据&lt;/td&gt;
                    &lt;/tr&gt;
                    &lt;tr&gt;
                      &lt;td style="text-align: left"&gt;POLLRDNORM&lt;/td&gt;
                      &lt;td style="text-align: left"&gt;*&lt;/td&gt;
                      &lt;td style="text-align: left"&gt;*&lt;/td&gt;
                      &lt;td style="text-align: left"&gt;等同于POLLIN&lt;/td&gt;
                    &lt;/tr&gt;
                    &lt;tr&gt;
                      &lt;td style="text-align: left"&gt;POLLRDBAND&lt;/td&gt;
                      &lt;td style="text-align: left"&gt;*&lt;/td&gt;
                      &lt;td style="text-align: left"&gt;*&lt;/td&gt;
                      &lt;td style="text-align: left"&gt;可读取优先级数据 （linux中不使用）&lt;/td&gt;
                    &lt;/tr&gt;
                    &lt;tr&gt;
                      &lt;td style="text-align: left"&gt;POLLPRI&lt;/td&gt;
                      &lt;td style="text-align: left"&gt;*&lt;/td&gt;
                      &lt;td style="text-align: left"&gt;*&lt;/td&gt;
                      &lt;td style="text-align: left"&gt;可读取高优先级数据&lt;/td&gt;
                    &lt;/tr&gt;
                    &lt;tr&gt;
                      &lt;td style="text-align: left"&gt;POLLRDHUP&lt;/td&gt;
                      &lt;td style="text-align: left"&gt;*&lt;/td&gt;
                      &lt;td style="text-align: left"&gt;*&lt;/td&gt;
                      &lt;td style="text-align: left"&gt;对端套接字关闭&lt;/td&gt;
                    &lt;/tr&gt;
                    &lt;tr&gt;
                      &lt;td style="text-align: left"&gt;POLLOUT&lt;/td&gt;
                      &lt;td style="text-align: left"&gt;*&lt;/td&gt;
                      &lt;td style="text-align: left"&gt;*&lt;/td&gt;
                      &lt;td style="text-align: left"&gt;普通数据可写&lt;/td&gt;
                    &lt;/tr&gt;
                    &lt;tr&gt;
                      &lt;td style="text-align: left"&gt;POLLWARNORM&lt;/td&gt;
                      &lt;td style="text-align: left"&gt;*&lt;/td&gt;
                      &lt;td style="text-align: left"&gt;*&lt;/td&gt;
                      &lt;td style="text-align: left"&gt;等同于 pollout&lt;/td&gt;
                    &lt;/tr&gt;
                    &lt;tr&gt;
                      &lt;td style="text-align: left"&gt;POLLWRBAND&lt;/td&gt;
                      &lt;td style="text-align: left"&gt;*&lt;/td&gt;
                      &lt;td style="text-align: left"&gt;*&lt;/td&gt;
                      &lt;td style="text-align: left"&gt;优先级数据可写入&lt;/td&gt;
                    &lt;/tr&gt;
                    &lt;tr&gt;
                      &lt;td style="text-align: left"&gt;POLLERR&lt;/td&gt;
                      &lt;td style="text-align: left"&gt;*&lt;/td&gt;
                      &lt;td style="text-align: left"&gt;*&lt;/td&gt;
                      &lt;td style="text-align: left"&gt;有错误发生&lt;/td&gt;
                    &lt;/tr&gt;
                    &lt;tr&gt;
                      &lt;td style="text-align: left"&gt;POLLHUP&lt;/td&gt;
                      &lt;td style="text-align: left"&gt;*&lt;/td&gt;
                      &lt;td style="text-align: left"&gt;*&lt;/td&gt;
                      &lt;td style="text-align: left"&gt;出现挂断&lt;/td&gt;
                    &lt;/tr&gt;
                    &lt;tr&gt;
                      &lt;td style="text-align: left"&gt;POLLNVAL&lt;/td&gt;
                      &lt;td style="text-align: left"&gt;*&lt;/td&gt;
                      &lt;td style="text-align: left"&gt;*&lt;/td&gt;
                      &lt;td style="text-align: left"&gt;文件描述符未打开&lt;/td&gt;
                    &lt;/tr&gt;
                    &lt;tr&gt;
                      &lt;td style="text-align: left"&gt;POLLMSG&lt;/td&gt;
                      &lt;td style="text-align: left"&gt;*&lt;/td&gt;
                      &lt;td style="text-align: left"&gt;*&lt;/td&gt;
                      &lt;td style="text-align: left"&gt;Linux中不使用&lt;/td&gt;
                    &lt;/tr&gt;
                  &lt;/tbody&gt;
                &lt;/table&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;文件描述符何时就绪？: select 使用简单的 w（可写）， r（可读）， x （异常）poll， 使用revents 的位掩码
        &lt;ul&gt;
          &lt;li&gt;普通文件 select总是标记为可读可写， 对于poll来说 则在revents中返回 POLLIN | POLLOUT （因为read总是立即返回数据， write 总是立刻传送数据）&lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;管道和FIFO:&lt;/p&gt;

            &lt;table&gt;
              &lt;thead&gt;
                &lt;tr&gt;
                  &lt;th style="text-align: left"&gt;管道中有数据？&lt;/th&gt;
                  &lt;th style="text-align: left"&gt;写端打开了吗？&lt;/th&gt;
                  &lt;th style="text-align: left"&gt;select&lt;/th&gt;
                  &lt;th style="text-align: left"&gt;Poll&lt;/th&gt;
                  &lt;th&gt; &lt;/th&gt;
                &lt;/tr&gt;
              &lt;/thead&gt;
              &lt;tbody&gt;
                &lt;tr&gt;
                  &lt;td style="text-align: left"&gt;否&lt;/td&gt;
                  &lt;td style="text-align: left"&gt;否&lt;/td&gt;
                  &lt;td style="text-align: left"&gt;r&lt;/td&gt;
                  &lt;td style="text-align: left"&gt;pollhup&lt;/td&gt;
                  &lt;td&gt; &lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                  &lt;td style="text-align: left"&gt;是&lt;/td&gt;
                  &lt;td style="text-align: left"&gt;是&lt;/td&gt;
                  &lt;td style="text-align: left"&gt;r&lt;/td&gt;
                  &lt;td style="text-align: left"&gt;pollin&lt;/td&gt;
                  &lt;td&gt; &lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                  &lt;td style="text-align: left"&gt;是&lt;/td&gt;
                  &lt;td style="text-align: left"&gt;否&lt;/td&gt;
                  &lt;td style="text-align: left"&gt;r&lt;/td&gt;
                  &lt;td style="text-align: left"&gt;pollin&lt;/td&gt;
                  &lt;td&gt;pollhup&lt;/td&gt;
                &lt;/tr&gt;
              &lt;/tbody&gt;
            &lt;/table&gt;

            &lt;p&gt;一些UNIX 实现中，如果管道写端是关闭状态，那么poll 返回POLLIN （因为read遇到的结尾） 可移植性的程序应该同时检查 两个标志 来知道read 是否阻塞了&lt;/p&gt;

            &lt;table&gt;
              &lt;thead&gt;
                &lt;tr&gt;
                  &lt;th style="text-align: left"&gt;有 PIPE_BUF 个字节空间吗？&lt;/th&gt;
                  &lt;th style="text-align: left"&gt;读端打开了吗？&lt;/th&gt;
                  &lt;th style="text-align: left"&gt;select&lt;/th&gt;
                  &lt;th style="text-align: left"&gt;Poll&lt;/th&gt;
                  &lt;th&gt; &lt;/th&gt;
                &lt;/tr&gt;
              &lt;/thead&gt;
              &lt;tbody&gt;
                &lt;tr&gt;
                  &lt;td style="text-align: left"&gt;否&lt;/td&gt;
                  &lt;td style="text-align: left"&gt;否&lt;/td&gt;
                  &lt;td style="text-align: left"&gt;W&lt;/td&gt;
                  &lt;td style="text-align: left"&gt;pollerr&lt;/td&gt;
                  &lt;td&gt; &lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                  &lt;td style="text-align: left"&gt;是&lt;/td&gt;
                  &lt;td style="text-align: left"&gt;是&lt;/td&gt;
                  &lt;td style="text-align: left"&gt;W&lt;/td&gt;
                  &lt;td style="text-align: left"&gt;pollout&lt;/td&gt;
                  &lt;td&gt; &lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                  &lt;td style="text-align: left"&gt;是&lt;/td&gt;
                  &lt;td style="text-align: left"&gt;否&lt;/td&gt;
                  &lt;td style="text-align: left"&gt;W&lt;/td&gt;
                  &lt;td style="text-align: left"&gt;pollout&lt;/td&gt;
                  &lt;td&gt;pollerr&lt;/td&gt;
                &lt;/tr&gt;
              &lt;/tbody&gt;
            &lt;/table&gt;

            &lt;p&gt;一些UNIX 实现中，如果管道读端是关闭状态，那么poll 返回POLLOUT、POLLHUP 可移植性的程序应该同时检查 三个标志 来知道read 是否阻塞了&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;套接字上面的表现&lt;/p&gt;

            &lt;table&gt;
              &lt;thead&gt;
                &lt;tr&gt;
                  &lt;th style="text-align: left"&gt;有 PIPE_BUF 个字节空间吗？&lt;/th&gt;
                  &lt;th style="text-align: left"&gt;select&lt;/th&gt;
                  &lt;th style="text-align: left"&gt;Poll&lt;/th&gt;
                &lt;/tr&gt;
              &lt;/thead&gt;
              &lt;tbody&gt;
                &lt;tr&gt;
                  &lt;td style="text-align: left"&gt;有输入&lt;/td&gt;
                  &lt;td style="text-align: left"&gt;r&lt;/td&gt;
                  &lt;td style="text-align: left"&gt;pollin&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                  &lt;td style="text-align: left"&gt;有输出&lt;/td&gt;
                  &lt;td style="text-align: left"&gt;w&lt;/td&gt;
                  &lt;td style="text-align: left"&gt;pollout&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                  &lt;td style="text-align: left"&gt;监听套接字上建立连接&lt;/td&gt;
                  &lt;td style="text-align: left"&gt;r&lt;/td&gt;
                  &lt;td style="text-align: left"&gt;pollin&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                  &lt;td style="text-align: left"&gt;接收到带外数据&lt;/td&gt;
                  &lt;td style="text-align: left"&gt;x&lt;/td&gt;
                  &lt;td style="text-align: left"&gt;pollpri&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                  &lt;td style="text-align: left"&gt;流套接字的对端关闭连接 或执行了shutdown(SHUT_WR)&lt;/td&gt;
                  &lt;td style="text-align: left"&gt;rw&lt;/td&gt;
                  &lt;td style="text-align: left"&gt;pollin | pollout | pollrdhup&lt;/td&gt;
                &lt;/tr&gt;
              &lt;/tbody&gt;
            &lt;/table&gt;

            &lt;p&gt;Linux专有的pollrdhup标志， 实际上是epollrdhup，主要设计用于epoll api 的边缘触发模式下， 当流式套接字连接远端关闭了写连接时候会返回该标志，能够让采用了epoll 边缘触发模式的应用程序 更简单的判断远端是否已经关闭&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;select vs poll
        &lt;ul&gt;
          &lt;li&gt;实现: 都使用了相同的内核poll例程集合， 这些poll例程有别于系统调用poll本身，每个例程 都返回 有关单个文件描述符就绪的信息， 这个就绪信息以位掩码的形式返回，其数值类似于 poll 系统调用中的 revents字段。系统调用的实现包括为每个文件描述符 调用内核poll 例程， 并将结果处理成 系统调用 的返回结果&lt;/li&gt;
          &lt;li&gt;区别:
            &lt;ol&gt;
              &lt;li&gt;被检查文件描述符的数量限制: select 对于被检查的文件描述符有一个上限 限制， 在Linux上，这个上限默认为1024， 修改上限需要重新编译程序，poll 在数量上没有限制&lt;/li&gt;
              &lt;li&gt;select 参数宏 fdset 同时也是 返回调用结果的地方， 如果需要在循环中 重复调用select， 那么我们每次都需要 重新初始化 fdset， 而poll 则不需要，因为 其通过两个独立的字段，events， revents&lt;/li&gt;
              &lt;li&gt;select 提供的超时精度 （微秒） 比 poll 提供的超时精度（毫秒）要高 （当然都受到  软件时钟粒度的限制）&lt;/li&gt;
              &lt;li&gt;被检查的一个文件描述符关闭了， poll会准确的告知 哪一个文件描述符， select只会返回 -1， 设定错误码为EBADF （只能通过轮询调用错误码来识别是哪个文件关闭了）&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
          &lt;li&gt;问题: 两个系统调用 是可移植的、长期存在 并被广泛使用的。但是在检查大量的文件描述符时，都会存在性能问题, 问题的原因如下:
            &lt;ul&gt;
              &lt;li&gt;每次调用 select， poll，内核都必须检查所有被指定的文件描述符&lt;/li&gt;
              &lt;li&gt;系统调用中参数的传递； select poll 每次都必须 传递所有需要被检查的文件描述符 信息到内核中，内核检查之后，修改这些结构返回给调用者，当需要检查大量的文件描述时，从用户空间到内核空间的数据拷贝 寄哪个占用大量的CPU时间。对于select 来说，还必须在每次调用前，对数据结构进行初始化。&lt;/li&gt;
              &lt;li&gt;系统调用返回后，需要 遍历结构中的每个元素，来确定就绪的文件描述符&lt;/li&gt;
              &lt;li&gt;根本原因在于 API的局限性: 通常程序会重复调用这些系统调用，并且其检查的文件描述符都是相同的，可是内核并不会记录这些&lt;/li&gt;
              &lt;li&gt;每次请求跟主动通知，的对象、消息 构造的依赖关系、编程模式，造就了 性能上的根本表现&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;信号驱动IO: 在信号驱动中，进程请求内核 在 文件描述符可执行IO 操作时为进程发送一个信号，之后 进程 就可以通过信号处理器 来 得知 文件描述符的变化
        &lt;ul&gt;
          &lt;li&gt;使用信号驱动的程序 应该按照如下方式 来编程:
            &lt;ol&gt;
              &lt;li&gt;为内核发送的通知信号安装一个信号处理器， 默认情况下， 该信号为 SIGIO&lt;/li&gt;
              &lt;li&gt;设定进程成为文件描述符的属主(通过fcntl 来完成). 文件描述符的属主: 当文件描述符上可执行IO 时 会接收到信号通知的进程 或进程组&lt;/li&gt;
              &lt;li&gt;设定 O_NONBLOCK 是文件描述符成为非阻塞IO&lt;/li&gt;
              &lt;li&gt;设定 O_ASYNC 标志 使能 信号驱动 (同上 使用fcntl 来进行操作)&lt;/li&gt;
              &lt;li&gt;进程可以执行其他任务， 当IO操作就绪，内核为进程发送一个信号后执行安装好的信号处理器&lt;/li&gt;
              &lt;li&gt;信号驱动IO为边缘触发通知， 意味着 当进程接收到IO就绪通知，需要尽可能多的执行IO操作（读写更多的字节）直到 IO 返回的错误码 为EAGAIN, EWOULDBLOCK为止&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
          &lt;li&gt;何时发送 IO就绪 信号:
            &lt;ol&gt;
              &lt;li&gt;管道， FIFO 读端， 在以下情况会产生信号:
                &lt;ul&gt;
                  &lt;li&gt;数据写入到管道中&lt;/li&gt;
                  &lt;li&gt;管道的写端关闭&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;管道， FIFO 写端， 在以下情况会产生信号:
                &lt;ul&gt;
                  &lt;li&gt;对管道的、读操作增加了管道中的空余空间大小， 因此可以写入PIPE_BUF 个字节，而不会被阻塞&lt;/li&gt;
                  &lt;li&gt;管道的读端关闭&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;套接字:
                &lt;ul&gt;
                  &lt;li&gt;数据报
                    &lt;ul&gt;
                      &lt;li&gt;一个数据数报文 到达 套接字 （即使已经存在未读取的数据报文）&lt;/li&gt;
                      &lt;li&gt;套接字上发生了异步错误&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;流式套接字
                    &lt;ul&gt;
                      &lt;li&gt;监听套接字上 接收到了新的连接&lt;/li&gt;
                      &lt;li&gt;TCP connect 请求完成，对于UNIX domain 不会产生信号&lt;/li&gt;
                      &lt;li&gt;套接字上接收到了新的输入 （即便已经有未读取的数据存在）&lt;/li&gt;
                      &lt;li&gt;套接字对端使用了shutdown关闭了写连接（半关闭），或者close 完全关闭&lt;/li&gt;
                      &lt;li&gt;套接字上输出就绪&lt;/li&gt;
                      &lt;li&gt;套接字上发生了异步错误
                        &lt;ul&gt;
                          &lt;li&gt;优化信号驱动IO: 对比 select， 检查大量的 文件描述符时，具有显著的性能优势， 之所以能够达到这么高的性能是因为内核  记录 了需要检查的文件描述符， 且当IO事件实际发生时 才会向程序 发送信号， 结果就是 采用 信号驱动IO的程序性能呢个可以根据饿发生IO事件的数量来扩展， 而与被检查文件描述的数量无关. 优化使用IO的 操作:&lt;br /&gt;
     1. 专属LInux的fcntl(F_SETFIG) 来之定一个实时信号， 当文件描述符上的IO就绪时， 这个信号 被取代 SIGIO 发送&lt;br /&gt;
     2. 使用sigaction 为上一步指定的 SA_SIGINFO 信号 安装信号处理器 使用siginfo 来代替 sigio 是必须的， 原因有 : 1）signio是标准的非排队信号之一， 如果有多个IO事件通知，sigio被阻塞了（比如 第一个信号处理器执行中）导致后续的通知会丢失，如果指定一个 SIGINFO 实时信号，那么多个通知就能够排队处理， 2）使用sigaction 来安装信号处理器， 且在sa.sa_flags = SA_SIGINFO 时候，内马尔结构体siginfo_t 会作为第二个参数传递给信号处理器，这个结构体包含了 哪个文件描述符发生的事件 以及事件类型 (对于IO就绪事件，传递给信号处理器的结构相关字段如下: si_signno: 引发信号处理器得到调用的信号值， si_fd: 发生IIO事件的文件描述符， si_code: 发生事件类型 的 代码，si_band: 一个位掩码同系统调用poll中revents相同， 与si_code 一一对应)&lt;br /&gt;
     3. 在一个纯粹的 输入驱动的应用程序中， 我们可以阻塞 IO就绪 信号，通过sigwaitinfo,sigtimedwait 来接收 排队中的信号，返回的 signinfo_t 结构体一样。以这种方式接受喜好，实际上是在同步处理IO事件， 对比与 select poll, 这种方式依然可以有效的获取IO事件&lt;br /&gt;
     4. 信号驱动IO中 有排队信号溢出的风险，导致我们会失去一些IO的信号消息，一个好的设计应该是， 同时对 SIGIO 设定信号处理器，在处理器中 通过sigwaitinfo 将队列中的实时信号全部获取，然后临时切换到 select, poll，来处理剩余的IO事件的文件描述符 （？这里为什么这么做？ 需要了解信号相关的处理机制以及 系统调用 sigwaitinfo）&lt;br /&gt;
     5. 多线程中使用信号驱动IO: fcntl 可以指定一个线程 来作为IO就绪信号的接受者&lt;/li&gt;
                        &lt;/ul&gt;
                      &lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
          &lt;li&gt;epoll 编程接口
            &lt;ul&gt;
              &lt;li&gt;优点有: 1） 当检查大量的文件描述符时，epoll的性能延展性比select和poll高很多， 2） epoll API 同时支持 水平触发、边缘触发， 3）比较于信号驱动IO: 可以避免复杂的信号处理流程、更高的灵活性，可以指定我们希望检查的事件类型&lt;/li&gt;
              &lt;li&gt;epoll 的核心数据结构为 epoll实例， 他和一个打开的文件描述符相关联，但是该文件描述并不是用来做IO使用的。踏实内核数据结构的句柄，该内核数据结构 记录了: 1）在进程中声明过 感兴趣的 文件描述符列表(interest list) 2) 维护了处于IO就绪态的 文件描述符列表 (ready list)&lt;/li&gt;
              &lt;li&gt;使用方法:
                &lt;ol&gt;
                  &lt;li&gt;int epoll_create(int size): 系统调用 创建了一个epoll 实例，其中感兴趣的列表初始化为空。调用返回 新创建 的epoll 实例的文件描述符（后续的几个函数调用都操作该文件描述符，无用时，应该close该文件描述符， 当所有与epoll实例相关的文件描述符都被关闭时，实例销毁 （当使用fork， dup等导致epoll的文件描述符存在多个时））。其中size有些鸡肋，指定了我们想要使用epoll 感兴趣文件描述的个数，但是该参数并不是上线，而是可以动态增加的，size的作用在于告知内核为内部数据结构初始化内存大小。&lt;/li&gt;
                  &lt;li&gt;int epoll_ctl(int epfd, int op, int fd, struct epoll_event * ev): 修改epoll的兴趣列表，epfd 为上个调用产生的 文件描述符， fd 为感兴趣的文件描述符，该文件描述符甚至可以是另一个epoll的实例的文件描述符（因为可以构建一个层级的 关系）�但是不能是普通文件的描述符。 op的可选项如下:
                    &lt;ul&gt;
                      &lt;li&gt;EPOLL_CTL_ADD: 添加 fd到， epoll实例的感兴趣列表中，其感兴趣的事件，都指定在了ev的结构体中 （添加一个已经存在的感兴趣文件描述符 出现eexist 错误）&lt;/li&gt;
                      &lt;li&gt;EPOLL_CTL_MOD: 修改 文件描述符 fd上的事件结构，（不存在于感兴趣文件描述符中 出现enoent错误）&lt;/li&gt;
                      &lt;li&gt;EPOLL_CTL_DEL: 将fd从epoll实例的感兴趣列表中移除， 操作忽略ev参数&lt;/li&gt;
                      &lt;li&gt;ev的结构如下:
&lt;div class="highlight"&gt;&lt;pre class="highlight c"&gt;&lt;code&gt;  &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;epoll_event&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;events&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// epoll的位掩码，指定了我们感兴趣的事件集合，
&lt;/span&gt;    &lt;span class="n"&gt;epoll_data_t&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// data 是一个联合体(union) ， 当fd成为就绪态，该联合体被传递给调用进程
&lt;/span&gt;  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
                      &lt;li&gt;max_user_watches: 每个epoll实例感兴趣的文件描述符 都需要占用内核空间（一小段不能被交换的内核内存空间？）内核提供了一个接口用来定义可以注册到 epoll实例上的文件描述符总数（每个用户or每个进程？）可以通过 max_user_watches 来修改和查看。Linux系统的 /proc/sys/fd/epoll 目录下的一个文件（是否可以修改？）&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;int epoll_wait(int epdf, struct epoll_evnet * evlist, int maxevents, int timout): 返回epoll实例中处于就绪态的文件描述符。evlist 是一个包含 有关就绪态文件描述符的数组([epoll_event]) 其内存空间由 调用者 负责申请，maxevents 为 evlist中包含的元素大小。返回的ep_events中的 events 为已经发生的事件掩码，data字段为 添加到epoll 实例感兴趣列表中时候 的ev 结构中的data，data 结构体用来获取 就绪文件描述，所以在 添加到感兴趣列表中 应该 指定ev.data.fd 为文件描述符或者 ev.data.ptr 来获取到文件描述符。参数 timetout， -1 调用一直阻塞到直到有就绪态文件描述符时，返回， 0: 执行一次非阻塞检查，查看感兴趣列表中是否有有就绪态的文件描述符， &amp;gt; 0: 阻塞调用最多等待 timeout 毫秒，否则超时。 因为epoll实例为文件描述符，所以可以实时更新 感兴趣列表， 无论是在多线程、多进程中&lt;/li&gt;
                  &lt;li&gt;
                    &lt;p&gt;epoll事件:&lt;/p&gt;

                    &lt;table&gt;
                      &lt;thead&gt;
                        &lt;tr&gt;
                          &lt;th style="text-align: left"&gt;bit mask&lt;/th&gt;
                          &lt;th style="text-align: left"&gt;epoll_ctl 输入？&lt;/th&gt;
                          &lt;th style="text-align: left"&gt;epoll_wait返回?&lt;/th&gt;
                          &lt;th style="text-align: left"&gt;desc&lt;/th&gt;
                        &lt;/tr&gt;
                      &lt;/thead&gt;
                      &lt;tbody&gt;
                        &lt;tr&gt;
                          &lt;td style="text-align: left"&gt;epollin&lt;/td&gt;
                          &lt;td style="text-align: left"&gt;-&lt;/td&gt;
                          &lt;td style="text-align: left"&gt;-&lt;/td&gt;
                          &lt;td style="text-align: left"&gt;可读取非高优先级的数据&lt;/td&gt;
                        &lt;/tr&gt;
                        &lt;tr&gt;
                          &lt;td style="text-align: left"&gt;epollPRI&lt;/td&gt;
                          &lt;td style="text-align: left"&gt;-&lt;/td&gt;
                          &lt;td style="text-align: left"&gt;-&lt;/td&gt;
                          &lt;td style="text-align: left"&gt;可读取高优先级数据&lt;/td&gt;
                        &lt;/tr&gt;
                        &lt;tr&gt;
                          &lt;td style="text-align: left"&gt;epollRDHUP&lt;/td&gt;
                          &lt;td style="text-align: left"&gt;-&lt;/td&gt;
                          &lt;td style="text-align: left"&gt;-&lt;/td&gt;
                          &lt;td style="text-align: left"&gt;套接字对端关闭&lt;/td&gt;
                        &lt;/tr&gt;
                        &lt;tr&gt;
                          &lt;td style="text-align: left"&gt;epollOUT&lt;/td&gt;
                          &lt;td style="text-align: left"&gt;-&lt;/td&gt;
                          &lt;td style="text-align: left"&gt;-&lt;/td&gt;
                          &lt;td style="text-align: left"&gt;普通数据可写&lt;/td&gt;
                        &lt;/tr&gt;
                        &lt;tr&gt;
                          &lt;td style="text-align: left"&gt;epolllet&lt;/td&gt;
                          &lt;td style="text-align: left"&gt;-&lt;/td&gt;
                          &lt;td style="text-align: left"&gt; &lt;/td&gt;
                          &lt;td style="text-align: left"&gt;边缘触发事件通知&lt;/td&gt;
                        &lt;/tr&gt;
                        &lt;tr&gt;
                          &lt;td style="text-align: left"&gt;epolloneshot&lt;/td&gt;
                          &lt;td style="text-align: left"&gt;-&lt;/td&gt;
                          &lt;td style="text-align: left"&gt; &lt;/td&gt;
                          &lt;td style="text-align: left"&gt;在完成事件通知之后禁用检查&lt;/td&gt;
                        &lt;/tr&gt;
                        &lt;tr&gt;
                          &lt;td style="text-align: left"&gt;epollerr&lt;/td&gt;
                          &lt;td style="text-align: left"&gt; &lt;/td&gt;
                          &lt;td style="text-align: left"&gt;-&lt;/td&gt;
                          &lt;td style="text-align: left"&gt;有错误发生&lt;/td&gt;
                        &lt;/tr&gt;
                        &lt;tr&gt;
                          &lt;td style="text-align: left"&gt;epollhup&lt;/td&gt;
                          &lt;td style="text-align: left"&gt; &lt;/td&gt;
                          &lt;td style="text-align: left"&gt;-&lt;/td&gt;
                          &lt;td style="text-align: left"&gt;出现挂断&lt;/td&gt;
                        &lt;/tr&gt;
                      &lt;/tbody&gt;
                    &lt;/table&gt;
                  &lt;/li&gt;
                &lt;/ol&gt;

                &lt;p&gt;epolloneshot 比较奇怪: 指定之后 只会收到一次 该文件描述符的通知， 之后该文件描述符被标记为非激活状态，意味着之后的epoll_wait 再也不会收到该文件描述符的通知，需要 EPOLL_CTL_MOD 在此激活才可以恢复 (不能使用 EPOLL_CTL_ADD 因为 该文件描述符依然在epoll 中的感兴趣列表中)&lt;/p&gt;
                &lt;ol&gt;
                  &lt;li&gt;epoll 文件描述符: 通过 epoll_create 创建一个epoll实例， 内核会创建相应的i-node 以及对应的 系统级别的 文件描述符，随后在 调用进程中 创建新的文件描述符， 同epoll实例的兴趣列表相关联的 是系统级的文件描述，而不是 epoll文件描述符， 这将产生如下的现象:
                    &lt;ul&gt;
                      &lt;li&gt;dup 或 fork 复制一个epoll文件描述，那么复制后的文件描述符所指代的epoll兴趣列表 同 epoll的文件描述符一样，一端的epoll操作同步到另一端&lt;/li&gt;
                      &lt;li&gt;epoll 兴趣列表中的成员 同样在只有完全关闭（所有的进程级别的文件描述符都关闭）之后才会从 epoll的兴趣列表中自动移除&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;
                    &lt;p&gt;与select， poll 的性能对比 (随着 被监控（感兴趣）的文件描述符数量的上升， select poll的性能 表现越来越差，而epoll的性能表现表现几乎没有降低)&lt;/p&gt;

                    &lt;table&gt;
                      &lt;thead&gt;
                        &lt;tr&gt;
                          &lt;th style="text-align: left"&gt;感兴趣的文件描述符数量&lt;/th&gt;
                          &lt;th style="text-align: left"&gt;poll CPU 时间(s)&lt;/th&gt;
                          &lt;th style="text-align: left"&gt;select CPU 时间(s)&lt;/th&gt;
                          &lt;th style="text-align: left"&gt;epoll CPU 时间(s)&lt;/th&gt;
                        &lt;/tr&gt;
                      &lt;/thead&gt;
                      &lt;tbody&gt;
                        &lt;tr&gt;
                          &lt;td style="text-align: left"&gt;10&lt;/td&gt;
                          &lt;td style="text-align: left"&gt;0.61&lt;/td&gt;
                          &lt;td style="text-align: left"&gt;0.73&lt;/td&gt;
                          &lt;td style="text-align: left"&gt;0.41&lt;/td&gt;
                        &lt;/tr&gt;
                        &lt;tr&gt;
                          &lt;td style="text-align: left"&gt;100&lt;/td&gt;
                          &lt;td style="text-align: left"&gt;2.9&lt;/td&gt;
                          &lt;td style="text-align: left"&gt;3.0&lt;/td&gt;
                          &lt;td style="text-align: left"&gt;0.42&lt;/td&gt;
                        &lt;/tr&gt;
                        &lt;tr&gt;
                          &lt;td style="text-align: left"&gt;1000&lt;/td&gt;
                          &lt;td style="text-align: left"&gt;35&lt;/td&gt;
                          &lt;td style="text-align: left"&gt;35&lt;/td&gt;
                          &lt;td style="text-align: left"&gt;35&lt;/td&gt;
                        &lt;/tr&gt;
                        &lt;tr&gt;
                          &lt;td style="text-align: left"&gt;10000&lt;/td&gt;
                          &lt;td style="text-align: left"&gt;990&lt;/td&gt;
                          &lt;td style="text-align: left"&gt;930&lt;/td&gt;
                          &lt;td style="text-align: left"&gt;0.66&lt;/td&gt;
                        &lt;/tr&gt;
                      &lt;/tbody&gt;
                    &lt;/table&gt;
                  &lt;/li&gt;
                  &lt;li&gt;epoll 性能为什么会更好？:
                    &lt;ul&gt;
                      &lt;li&gt;与select， poll相比 每次需要检查所有 在调用中指定的文件描述符， 通过epoll_ctl 添加文件描述符 到epoll感兴趣的文件描述符列表之后，每当执行IO操作使得 文件描述符成为就绪态时，内核就在epoll描述符的就绪列表中 添加一个元素， 之后epoll_wait 调用从 就绪列表中简单的读取这些数据&lt;/li&gt;
                      &lt;li&gt;每次调用select poll时，我们传递所有需要监视的文件描述符列表 到内核中，内核将所有 标记为就绪态的文件描述符 数据传递过来。epoll 使用epoll_ctl 在内核空间中构建一个数据结构， 该数据结构记录 感兴趣的文件描述符，之后调用epoll_wait 并不需要传递 文件描述符相关的数据&lt;/li&gt;
                      &lt;li&gt;select poll 随着被监视文件描述符的数量 而扩展，epoll则随着 发生IO事件 文件描述符 的数量而扩展。常见的高效的服务器 会同步处理许多的客户端，需要监视大量的文件描述符，但是大部分处于空闲状态，只有少数文件描述符处于就绪态&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;边缘触发通知: 默认情况下， epoll提供的为水平出发通知，意味着 何时 在文件描述 上非阻塞的执行IO操作。epoll还能够采用同信号驱动IO一样的模式即是: 边缘触发通知。只是如果 有多个IO事件发生的话，epoll会合并成一次单独的通知，并通过epoll_wait返回。而信号驱动IO则会产生多个信号, 下面我们来区分一下 epoll使用 边缘触发通知 与 水平触发通知 在同样场景下的 区别:
                    &lt;ol&gt;
                      &lt;li&gt;套接字上有输入到来&lt;/li&gt;
                      &lt;li&gt;我们调用一次epoll_wait, 无论采用水平触发通知，还是边缘触发通知，该调用 都会告诉我们套接字上已经处于就绪态态&lt;/li&gt;
                      &lt;li&gt;再次调用epoll_wait, 水平触发情况下: 套接字处于就绪态， 边缘触发情况下: 调用将阻塞，因为自从上一次之后并没有新的请求输入到来&lt;/li&gt;
                    &lt;/ol&gt;
                  &lt;/li&gt;
                  &lt;li&gt;边缘触发通知 如何避免出现文件描述符饥饿现象: 监视多个文件描述符，其中一个处于就绪态的文件描述符有这大流量的输入存在，然后我们通过非阻塞方式读取所有输入，那么此时就有是其他的文件描述符存在饥饿状态的风险。即:我们再次检查这些文件描述符是否处于就绪态并执行IO操作前，会有很长一段时间， 该问题的解法是:
                    &lt;ol&gt;
                      &lt;li&gt;应用程序维护一个处于就绪态的文件描述符列表，通过一个循环不断处理如下&lt;/li&gt;
                      &lt;li&gt;epoll_wait 监控文件描述符，将 就绪态的 文件描述符 添加到应用程序维护的列表中。如果&lt;br /&gt;
 有文件描述符 已经存在于 应用程序维护的列表中，那么这次监视的超时时间设定的较小或者是0， 这样应用程序就可以快速的进行到下一步，去处理哪些已经处于就绪态的文件描述&lt;/li&gt;
                      &lt;li&gt;在应用程序维护的列表中，轮转调度 进行一定限度的 IO操作。（不是从 上一步 epoll_wait调用中返回的 文件描述列表 遍历处理）当相关的非阻塞IO调用出现EAGAIN 或者 EWOULDBLOCK错误，从应用程序维护的列表中移除&lt;/li&gt;
                    &lt;/ol&gt;
                  &lt;/li&gt;
                  &lt;li&gt;在信号和文件描述符上等待  ？ （不知道为什么会出现有关竞争的问题？）以及出现pselect 调用， self-pipe技巧&lt;/li&gt;
                &lt;/ol&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="问题列表"&gt;问题列表&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;DNS 负载 如何实现？&lt;/li&gt;
  &lt;li&gt;信号 相关的设定 是如何的？ 为什么会出现 如此复杂的设计，race conditoin，&lt;/li&gt;
  &lt;li&gt;epoll 中 一小段不能交换的内存是？新概念吗？&lt;/li&gt;
  &lt;li&gt;epoll 的内部实现&lt;/li&gt;
  &lt;li&gt;消息边界的概念，以及实际意义&lt;/li&gt;
&lt;/ol&gt;
</content>
  </entry>
  <entry>
    <title>linux-interface-04</title>
    <link rel="alternate" href="http://geniousbar.github.io/2018/12/30/linx-interface-04/"/>
    <id>http://geniousbar.github.io/2018/12/30/linx-interface-04/</id>
    <published>2018-12-30T08:00:00+08:00</published>
    <updated>2019-03-11T13:18:13+08:00</updated>
    <summary type="html">&lt;h2 id="the-linux-programming-interface"&gt;The linux programming interface&lt;/h2&gt;

&lt;h3 id="文件io-通用的io模型"&gt;文件IO 通用的IO模型&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;文件描述符： 一个非负整数，来指代打开的文件，其中包括： 管道FIFO socket，终端 设备 普通文件&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;标准文件描述符:&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style="text-align: left"&gt;文件描述符&lt;/th&gt;
          &lt;th style="text-align: left"&gt;用途&lt;/th&gt;
          &lt;th style="text-align: left"&gt;名称&lt;/th&gt;
          &lt;th style="text-align: left"&gt;stdio&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style="text-align: left"&gt;0&lt;/td&gt;
     ...&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    <content type="html">&lt;h2 id="the-linux-programming-interface"&gt;The linux programming interface&lt;/h2&gt;

&lt;h3 id="文件io-通用的io模型"&gt;文件IO 通用的IO模型&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;文件描述符： 一个非负整数，来指代打开的文件，其中包括： 管道FIFO socket，终端 设备 普通文件&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;标准文件描述符:&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style="text-align: left"&gt;文件描述符&lt;/th&gt;
          &lt;th style="text-align: left"&gt;用途&lt;/th&gt;
          &lt;th style="text-align: left"&gt;名称&lt;/th&gt;
          &lt;th style="text-align: left"&gt;stdio&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style="text-align: left"&gt;0&lt;/td&gt;
          &lt;td style="text-align: left"&gt;标准输入&lt;/td&gt;
          &lt;td style="text-align: left"&gt;STDIN_FILENO&lt;/td&gt;
          &lt;td style="text-align: left"&gt;stdin&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style="text-align: left"&gt;1&lt;/td&gt;
          &lt;td style="text-align: left"&gt;标准输出&lt;/td&gt;
          &lt;td style="text-align: left"&gt;STDOUt_FILENO&lt;/td&gt;
          &lt;td style="text-align: left"&gt;stdout&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style="text-align: left"&gt;2&lt;/td&gt;
          &lt;td style="text-align: left"&gt;标准错误&lt;/td&gt;
          &lt;td style="text-align: left"&gt;StDERR_FILENO&lt;/td&gt;
          &lt;td style="text-align: left"&gt;stderr&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;主要的系统调用&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;open(pathname, flags, mode) open创建新文件时候， 即 flags 中包含 O_creat 标志，mode制定了文件的访问权限。flags还有许多的可选参数， 包括O_APPEND, O_ASYNC等等。&lt;/li&gt;
      &lt;li&gt;read(fd, buffere, count), read 调用成功返回 实际读取的字节数， 如果遇到文件结束EOF 则返回0， 出席那错误 -1， 一次read 可能返回的 字节数可能小于count， fd为文件时候， 可能是文件靠近结尾，（所以文件尾部时候是不是小于count还是一个0？），fd为其他类型时候， socket， 终端，例如在终端遇到\n read调用就会结束。在有需要注意， C语言， 如果输入缓冲区， buffere 需要一个表示终止的空字符串，需要自己显示添加&lt;/li&gt;
      &lt;li&gt;write(fd, buffer, count), write 为将buffer中的数据写入fd中，error 返回-1， 其他返回写入的字节数， 写入字节数可能小于count （进程资源对文件大小的限制，磁盘满等， 造成部分写），write成功并不能保证已经写入到文件中，而是高速缓冲区，系统会缓存磁盘IO。&lt;/li&gt;
      &lt;li&gt;close(fd) close error -1，success 0， 文件属于有限资源，文件描述符关闭失败可能导致一个进程将资源消耗殆尽。编写长期运行的程序，比如网络服务器显得尤为重要。所以，总是显式的关闭文件描述符。&lt;/li&gt;
      &lt;li&gt;lseek(fd, offset, whence) 改变文件偏移量。文件偏移量是下一个read， write 等的起始点。文件打开指向文件头，read, write 自动调整偏移量. whence 可选参数为 SEEK_SET, SEEK_CUR, SEEK_END, 分表表示offset的基准坐标 为 文件开始头部， 当前偏移量， 文件末尾。 offset 可以为负数 表示，向前偏移多少。调用成功返回移动之后的偏移量。可以使offset为0 来获取当前偏移量。lseek并不适合所有类型的文件，应用与管道， FIFO, socket或者终端，调用将会失败， errno 被设定为ESPIPE.&lt;/li&gt;
      &lt;li&gt;ioctl(fd, request, ….args) 对为纳入标准IO模型的所有设备和文件操作而言，ioctl系统调用是个万金油&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;/proc/PID/fdinfo 目录下，可以获取系统任一进程中文件描述符的相关信息。针对进程中的每一个已打开的文件描述符，该目录下都有对应的文件， 以对应的文件描述符的数值命名，其中文件中的pos为文件偏移量， flags字段 则为一个八进制数, 其格式形如&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;   pos:  0
   flags: 02
   mnt_id: 9
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;p&gt;&lt;em&gt;文件空洞，在 文件结尾+ offset的位置写入数据，会发生什么情况，文件结尾开始到offset 中会产生空洞。文件空洞的特点在于它并不占用磁盘空间，只有当空洞中有数据写入时候，才会分配磁盘空间。 编程角度看读取空洞返回0。空间的存在，造成 文件名义上的大小可能要比其占用的磁盘存储总量要大，当空洞被写入文件时候，内和为其分配存储空间，磁盘可用空间减少。&lt;/em&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="深入探究文件io"&gt;深入探究文件IO&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;原子操作： 将某一系统调用所要完成的各个动作作为不可中断的操作，一次性加以完成, 是许多系统调用的以正确完成的必要条件&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;竞争状态是这样一种情形：操作共享资源的两个进程或线程，结果取决于 一个无法预期的顺序，即这些进程获取CPU使用权的先后相对顺序&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;open, 保证进程是打开文件的创建者，对文件是否存在的检查和创建文件属于同一原子操作。 flags: O_CREAT&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;fcntl: fcntl(fd, cmd,…) 该调用对一个打开的文件描述符执行一系列控制操作。用途之一: 对一个打开的文件， 获取或修改其访问模式和状态标志。通过open也可以设定，所以fcntl针对已经打开的文件描述符，1）文件不是由调用程序打开的， 2）通过open之外的系统调用获取的， 比如pipe，socket， 等。 示例代码&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight c"&gt;&lt;code&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;flags&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;accessMode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="n"&gt;flags&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fcntl&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;F_GETFL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 获取flags
&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;flags&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="n"&gt;errExit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"fcntl"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
 &lt;span class="n"&gt;flags&lt;/span&gt; &lt;span class="o"&gt;|=&lt;/span&gt; &lt;span class="n"&gt;O_APPEND&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// operate flags
&lt;/span&gt; &lt;span class="n"&gt;fcntl&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;F_SETFL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;flags&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;// set flags   
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;p&gt;因为 O_RDONLY, OWRONLY, O_RDWR, 因为历史原因，数值为0,1,2所以不能简单的使用 &amp;amp; 来判断是否存在对应的标记位， 如下为正确的做法&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight c"&gt;&lt;code&gt;  &lt;span class="n"&gt;accessmode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;flags&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;O_ACCMODE&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;accessmode&lt;/span&gt; &lt;span class="o"&gt;===&lt;/span&gt; &lt;span class="n"&gt;O_WRONLY&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;accessMode&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;O_RDWR&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;accessmode&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;O_RDONLY&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="n"&gt;prinf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"xx"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/li&gt;
  &lt;li&gt;文件描述符与文件的关系&lt;/li&gt;
  &lt;li&gt;结构
    &lt;ul&gt;
      &lt;li&gt;进程级别的文件描述符，记录的标志有 close-on-exec, 并指向到系统级 文件表&lt;/li&gt;
      &lt;li&gt;系统级 文件表： 记录了: 文件偏移量， 打开文件的状态标记（open flags）, 文件访问模式，与信号驱动IO相关的g设地年， 对该文件I-node对象的引用&lt;/li&gt;
      &lt;li&gt;文件系统的i-node表: 文件类型，一个指针，指向该文件所持有的锁列表， 文件的各种属性（包括文件大小， 已经时间戳）。 区分与磁盘中的i-node，这里是内存的i-node， 访问文件时候，会在内存中为i-node创建一个副本，其中记录了引用i-node的打开文句柄的数量，以及所在设备的主从设备等。
        &lt;ul&gt;
          &lt;li&gt;[ ] 添加指向 csapp的图片&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;文件设计的这些特点，可以产生如下的总结：
    &lt;ol&gt;
      &lt;li&gt;两个不同文件描述符， 若指向同一个文件句柄(系统及的文件表)将共享同一个文集偏移量。通过其中一个更改偏移量，另外一个可以观察到该变化，无论两个描述符在不同进程还是统一进程，亦或线程。&lt;/li&gt;
      &lt;li&gt;fcntl 操作的作用域 同 1相同&lt;/li&gt;
      &lt;li&gt;对应的 文件描述符的 close-on-exec 因为存储在进程级别， 所以并不会影响到其他进程。&lt;/li&gt;
      &lt;li&gt;cat log.log &amp;gt; result.log 2&amp;gt;&amp;amp;1 shell通过复制 文件描述符2实现了标准错误的重定向操作。因为描述符2同1指向同一个文件句柄，所以输出不会产生覆盖彼此的问题。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;复制文件描述符
    &lt;ul&gt;
      &lt;li&gt;dup(int oldfd), 复制一个打开的文件描述符oldfd， 并返回一个新的描述符， 两者指向同一个文件句柄，系统保证新描述符一定是编号值最低的未用的文件描述符。意味着dup(1)会产生3&lt;/li&gt;
      &lt;li&gt;dup2(oldfd, newfd)： 系统调用会创建oldfd的副本，编号由newfd决定， 如果newfd已经打开，会先将其关闭，然后返回newfd指定的编号的文件描述符。（所以dup2(调用了那个接口，来产生特定编号的文件描述符。)） 但是dup2关闭newfd时候会忽略错误， 所以 最好手动关闭newfd,&lt;/li&gt;
      &lt;li&gt;pread, pwrite(fd, buf, count, offset)： 区别于 read, write的地方在于， pread, pwrite 会在指定的offset进行操作，并且不会改变文件的偏移量。这些特性是的 使得在多线程应用非常便利，多个进程可以同时操作同一个描述符。而不会互相影响。如果使用lseek， read调用引起竞争状态。使得编写正确的IO代码变得困难。&lt;/li&gt;
      &lt;li&gt;分散输入和集中输出, (scatter-gather IO), readv, writev&lt;/li&gt;
      &lt;li&gt;截断: truncate(char * pathname, length), ftruncate(fd, length): 若文件长度&amp;gt; length 丢弃超出部分， &amp;lt; length, 将在文件尾部添加一系列空字节或者文件空洞(版本实现比一样吗？)其中 truncat 通过字符串指定名字但是依然需要文件的写权限。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;非阻塞IO： 1) open 指定 O_NONBLOCK, 2） socket因为无法通过open来获取文件描述符， 所以需要使用fcntl来启动非阻塞标志。&lt;/li&gt;
  &lt;li&gt;-【】大文件&lt;/li&gt;
  &lt;li&gt;/dev/fd: 是一个连接到 /proc/PID/fd 目录的一个符号连接， 该目录中的每一个目录都连接到 /proc/PID/fd中的目录，一一对应&lt;/li&gt;
  &lt;li&gt;临时文件：mkstemp(char * template), tmpfile(): 打开文件使用了O_EXCL 以保证独占使用文件。两者区别在于 mkstemp()之后需要unlink(char* template), 在close(fd) 之后自动删除， tmpfile 则无需调用unlink, close之后 自动删除（内部自动调用unlink）&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="进程"&gt;进程&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;进程 是可执行程序的实例&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;进程号 和 父进程号： 每个进程都有一个PID， 唯一标识 某个进程，除了少数(init PID 为1) 之外，多数程序与运行该程序的进程PID没有固定关系。 linux内核限制 进程号小于 32767,当进程号达到这个限制时候，内核将重置进程号计数器，重新从最小的整数开始分配。（进程号计数器会重置为 300， 因为 低于此数值的进程号 为系统进程和守护进程 长期占用， 关于最大进程号 默认上限是 32767,, 但是可以通过更改 /proc/sys/kernel/pid_max 来进行更改=最大值+1， 64位最大进程号为2 22次方 为什么？）getppid可以获取进程的父PID， 可以通过pstree， 来查看家族树。&lt;/li&gt;
  &lt;li&gt;命令行参数 argc, argv：argc 表示命令行参数的个数，argv 是一个指向 命令行参数的指针数组，每一个参数指向一个以null结尾的字符串。其中argv[0] 包含了 调用程序的名称。可以为一个程序创建多个连接，然后argv[0]的名字是不同的。&lt;/li&gt;
  &lt;li&gt;环境列表： 每个进程都有与之相关的字符串数组成为环境列表(envoriment list), 每个字符串都以 name=value 的形式定义。常常将name称为环境变量。新创建进程会继承父进程的环境副本，因为获得是副本，随意之后父子环境信息个不相关。
    &lt;ul&gt;
      &lt;li&gt;export NAME=value: 将NAME变量添加到shell环境中, 此后这个shell所创建的进程中都存在变量NAME&lt;/li&gt;
      &lt;li&gt;NAME=value programe: 在应用程序 programe的环境变量中添加一个变量值，但是不影响shell&lt;/li&gt;
      &lt;li&gt;printenv： 显示当前的环境列表&lt;/li&gt;
      &lt;li&gt;/proc/PID/environ: 文件显示编号为PID的进程的环境列表&lt;/li&gt;
      &lt;li&gt;getenv(char *name): 获取环境变量的数值(value), 不存在返回NULL&lt;/li&gt;
      &lt;li&gt;putenv(char *string): 添加一个 name=value 形式字符串的环境变量，失败返回非0值。一位内putenv 添加到environ变量的是一个指针，而不是string 的副本，所以不应该在栈上分配&lt;/li&gt;
      &lt;li&gt;setenv(char * name, char *value, overwrite): 该函数会复制 name, value。函数会自动拼接=号，overwrite ！= 0 总会写入， overwrite = 0时，存在则不写入，不存在写入&lt;/li&gt;
      &lt;li&gt;unsetenv&lt;/li&gt;
      &lt;li&gt;clearenv&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ABI, 应用程序二进制接口，一套规则。 规定了二进制可执行文件在运行时应该如何与某些服务（诸如内核或函数库所提供的服务）交换信息， ABI特别规定了使用那些寄存器和栈地址交换信息以及所交换数值的含义，一旦针对某个特定ABI进行了编译，其二进制可执行文件应该能在ABI相同的任何系统上运行。与之想法，标准化的API仅能通过编译源代码来保证应用程序的可移植性。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="内存分配"&gt;内存分配&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;在堆上分配内存， 进程呢个可以通过增加堆的大小来分配内存， 堆就是一段长度可变的连续的虚拟内存，初始于 进程未初始化的数据段末尾，随着内存的分配和释放而增减。通常将堆当前内存边界成为 program break
    &lt;ul&gt;
      &lt;li&gt;brk(vodi * end_data_segment), sbrk(int increment), 两个系统调用可以改变 program break 的位置， 位置调升以后，程序可以访问新分配区域内的任何内存地址。内核会在进程首次访问新分配的地址时，会自动分配实际的物理内存页。brk 直接改变 program break 的地址， sbrk 增量的改变 break 地址， 在原有的 break 地址上 增加increment 的空间，函数返回之前的break地址，也就是新分配的地址空间的起始处，sbrk(0) 返回现有的 program break 地址。&lt;/li&gt;
      &lt;li&gt;malloc(size_t size), free(void * ptr)： 库函数(建立在系统调用， brk, sbrk的基础上封装而成)，比较与系统调用， 库函数拥有不少的优点， 明显的有 &lt;strong&gt;允许随意的释放内存块，他们被维护于一张空闲的内存列表中，在后续的内存分配调用时候循环使用&lt;/strong&gt;,
        &lt;ol&gt;
          &lt;li&gt;malloc: 分配成功返回void* 类型指针， 因为void类型所以可以随意使用， 调用失败可能是因为program break 已经触顶，（已经没有堆空间可以分配） 则返回NULL， 虽然出错的概率很小，但是依然需要进行错误检查。&lt;/li&gt;
          &lt;li&gt;free： 函数释放ptr所指向的内存块，一般情况下， free并不会降低 program break 的位置， 而是将该内存块放入到空闲的内存列表中，以便供后续的malloc使用。有如下的好处， 1）尽量的减少了 sbrk的系统调用此处&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;调用free还是不呢？: 当进程终止时， 所有的内存都会返回给操作系统，基于内存的这一自动释放机制，对于那些分配内存并持续使用的程序而言，可以忽略free，因为在多次调用free时候不但消耗大量的cpu时间，还是使代码趋向于复杂。&lt;/li&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;malloc, free 的实现: 数据结构为 双向链表， len&lt;/td&gt;
              &lt;td&gt;pre&lt;/td&gt;
              &lt;td&gt;next&lt;/td&gt;
              &lt;td&gt;space&lt;/td&gt;
              &lt;td&gt;其中len 表示该空闲内存块 的大小， pre,next 为双向链表指针，指向上一个下一个空闲内存块， space为空闲内存&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
        &lt;ol&gt;
          &lt;li&gt;malloc(size_t size) 会扫描空闲链表，以找到适合大小的内存块
            &lt;ul&gt;
              &lt;li&gt;空闲链表中的len == size 时，则直接返回给z调用者&lt;/li&gt;
              &lt;li&gt;len &amp;gt; size: 对其切割（将会出现一个合适大小的内存块+一个空闲的内存块）&lt;/li&gt;
              &lt;li&gt;len &amp;lt; size: 没有找到符合要求的内存块时，调用sbrk 重新分配适合的内存块（为了更少的系统调用sbrk, 通常mallock 会以更大的increment 调用sbrk ）&lt;/li&gt;
              &lt;li&gt;更新 空闲块链表&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;free(void * ptr) : free函数通过 ptr 内存块中 len来知道内存块大小，然后加入到 空闲块链表中。&lt;/li&gt;
          &lt;li&gt;因为free， malloc的实现导致， 1）ptr指针需要完全正确，以避免对空闲链表的错误操作。（非malloc返回的指针，绝不能调用free）， 2）不能重复释放同一个指针&lt;/li&gt;
          &lt;li&gt;除了mallock, C函数库还提供了其他的 内存分配算法版本的 内存分配函数实现。 calloc, realloc, memalign, posix_memalign, alloca（该函数从栈上分配内存，因为栈的特殊性使其有两个特点 1）只有当调用函数的位于顶部时候可用 2）不需要free， 因为函数返回时代码会重置栈指针。）&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="用户和组"&gt;用户和组&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;每个用户都存在唯一的UID， 并可以归属于多个GID&lt;/li&gt;
  &lt;li&gt;UID， GID 的主要用途有 1）确定各种系统资源的所有权， 2）对进程的操作资源的权限加以控制&lt;/li&gt;
  &lt;li&gt;/et/passwd, 用于记录用户相关的UID， home, shell etc等。 /etc/shadow 维护对应UID的加密密码。组文件 /etc/group, 维护GID， 以及对应的用户列表，&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="进程凭证"&gt;进程凭证&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;每个进程都有一套数字表示UID和GID 具体如下：
    &lt;ol&gt;
      &lt;li&gt;real user id, real group id, 实际用户id，实际组id， 确定了进程所属的用户和组，作为登陆过程之一，登陆shell 从/etc/passwd中读取相应用户密码记录的3，4字段，设定为其实际用户id &amp;amp; 组id，当创建进程时，将从父进程中继承这些&lt;/li&gt;
      &lt;li&gt;effective user id, effective group id, 有效用户id， 有效组id。 系统通常通过结合有效用户id，组id 连同辅助组id 来授予进程权限。&lt;/li&gt;
      &lt;li&gt;saved user id, saved group id, 保存的用户id， 保存的组id&lt;/li&gt;
      &lt;li&gt;file-system user id, file-system group id, 文件系统用户id， 文件系统组id&lt;/li&gt;
      &lt;li&gt;辅助组id&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;set-user-id, set-group-id 程序， set-user-id 程序会将进程的有效用户id设为可执行文件的用户id， 从而获得不具备的权限。set-group-id 程序有类似的效果。可执行文件拥有两个特别的权限位 set-user-id和set-group-id位，（实际上所有文件都有，只有可执行文件比较有用）ls -l program, x 变成 代表 拥有set-user-id or set-group-id. 当运行set-user-id程序时候，内核会将进程的有效用户id变为可执行文件的用户id， set-group-id 执行类似的操作。 linux系统中常用的passwd, mount, unmount, wall(用户向tty组下所有终端写入消息)等都为set-user-id程序(set-user-id-root 来特指 root用户所拥有的 set-user-id 程序)&lt;/li&gt;
  &lt;li&gt;保存用户id(saved-user-id) 当执行程序时，会发生如下事情：
    &lt;ol&gt;
      &lt;li&gt;可执行文件的set-user-id权限位开启，将进程等的有效用户id 设定为 可执行文件的属主，未设定则进程有效用户id不变&lt;/li&gt;
      &lt;li&gt;复制 有效id 到 set-user-id&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;有不少的系统调用，允许将set-user-id 程序的有效用户id在实际用户id和保存set-user-id之间切换。对于与执行文件用户id相关的任何权限，程序能够随时在两种状态间切换。&lt;/li&gt;
  &lt;li&gt;文件系统用户id： 在进行linux中 打开文件、改变文件属主 、修改文件权限之类的文件操作时，决定其操作权限的是 文件系统用户id， 而非 有效用户id。通常 文件系统用户id和组id都等于相应的有效用户和组id， 并且只要有效用户id发生变化，相应的文件系统用户id也会发生变化，只有linux特有的两个系统调用setfsuid(), setfsgid()才能刻意的制造出 文件系统用户id 不等于 有效用户id。因此   大部分情况下，可以忽视文件系统用户id，等同于检查 有效用户id&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;[ ] 完成对应的系统调用&lt;/li&gt;
  &lt;li&gt;[ ] 如何在进程中调用 特权程序?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="时间"&gt;时间&lt;/h2&gt;
&lt;p&gt;大多数计算机体系结构都内置有硬件始终，是的内核得以计算真实时间和进程时间。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;日历时间: Unix 系统内部对时间的表示，以 Epoch以来的秒数来度量（UTC 时间）。存储于time_t类型的变量中。（time_t是一个有符号整数 理论上当前许多的32位unix系统都面临着一个2038 的理论问题，如果执行的计算工作涉及到未来时间，那么在2038年问题都会出现，事实上在此之前所有的unix系统可能都已经升级到了64位系统，然而32位嵌入式系统的寿命要长的多，依然面临着这个问题）
    &lt;ul&gt;
      &lt;li&gt;gettimeofday(timeval *tv, timezone *tz): struct timeval { time_t tv_sec; suseconds_t tv_usec;} 其中 tv_usec提供了微秒级别的精度，参数tz是一个历史产物，应该总为NULL，&lt;/li&gt;
      &lt;li&gt;time_t time(time_t *timep): 函数有两种方式返回同样的结果， UTC秒数， timep 不为NULL，将秒数放在timep 的指针中， timep NULL返回一个数值&lt;/li&gt;
      &lt;li&gt;时间转换函数： 类型包含如下 time_t， 打印格式， 分解时间(即是： struct tm {int tm_sec; int tm_min; int tm_hour; int tm_mday; int tm_year; int tm_mon; etc})， 转换函数即是 用来在上面的类型中 进行转换的函数，方便使用。其中包括， strftime, mktime, gmtime, localtime 等。&lt;/li&gt;
      &lt;li&gt;时区： 时区信息被系统使用标准格式保存于文件中。 /usr/share/zoneinfo, 该目录中的每个文件都包含了一个特定国家或地区的时区制度，系统的本地时间在 /etc/localtime 中定义，通常链接到 /usr/share/zoneinfo中的一个文件。使用TZ环境变量来为一个程序指定时区，其值为 “:“ + 时区名称组成的字符串。设定时区会自动影响到 ctime, locatime, mktime, strftime 等，&lt;/li&gt;
      &lt;li&gt;setlocale(int category, char * locale) : 设定和查询程序的当前地区, category 可选项为 表中的数值 + LC_ALL, LANG, LANGUAGE, 其中，LC_ALL 为设定所有值而准备， LANG为设定所有为明确指定的变量而准备. setlocale 参数中的locale可以为 “”空字符串，表示可以从环境变量中却的地区的设定， 大部分的程序代码 setlocale(LC_ALL, “”) 来使用程序中的环境变量设定地区，如果调用被省略，这些环境变量将不会对程序的地区设定生效。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;文件名&lt;/td&gt;
          &lt;td&gt;目的&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;LC_TYPE&lt;/td&gt;
          &lt;td&gt;包含字符分类以及大小写转换规则&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;LC_COLLATE&lt;/td&gt;
          &lt;td&gt;包含针对一字符集的排序规则&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;LC_MONETARY&lt;/td&gt;
          &lt;td&gt;对货币格式化规则&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;LC_NUMERIC&lt;/td&gt;
          &lt;td&gt;对货币意外的数字格式化规则&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;LC_TIME&lt;/td&gt;
          &lt;td&gt;对日期和时间的格式化规则&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;LC_MESSAGES&lt;/td&gt;
          &lt;td&gt;针对肯定和否定响应，就格式以及数值做了规定&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;进程时间:&lt;br /&gt;
&lt;strong&gt;软件时钟： 进程时间受限于 系统软件时钟的分辨率，度量单位 为jiffies（定义在内核代码中的常量HZ, jiffies 为1s内 cpu增加的记数，100HZ(jiffies) 时候， 1 jiffies(hz) 的时间为10毫秒）这是内核按照round-robin的分时调度算法分配cpu进程的单位。因为CPU 的速度大大提高，2.6.0的内核时钟速度已经提高了1000hz， 更高的分辨率意味着更高的时间精度，然而并非可以任意的提高时钟频率，因为每个时钟中断都对耗费少量的CPU时间&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;用户CPU时间： 在用户模式下执行所花费的时间数量&lt;/li&gt;
      &lt;li&gt;系统CCPU时间： 在内核模式中执行所花费的时间数量&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="系统和进程信息"&gt;系统和进程信息&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;为了提供简单的方法来访问内核信息， 现在的UNIX实现提供了一个/proc 虚拟文件系统（并非存储于磁盘上，恶热是内核在进程访问信息时候动态生成的），其中包含了各种用于展示内核信息的文件。并允许进程通过常规的IO系统调用来访问，有些还可以对信息进行修改。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;/proc/PID： 内核提供了对应PID进程的目录结构，&lt;/p&gt;

    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;文件&lt;/td&gt;
          &lt;td&gt;描述&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;cmdline&lt;/td&gt;
          &lt;td&gt;以 \0分割的命令行参数&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;cwd&lt;/td&gt;
          &lt;td&gt;指向当前工作目录的符号连接&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;Environ&lt;/td&gt;
          &lt;td&gt;NAME=value 键值对的环境列表&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;exe&lt;/td&gt;
          &lt;td&gt;指向正在执行文件的符号连接&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;fd&lt;/td&gt;
          &lt;td&gt;文件目录包含了指向由进程打开文件的符号连接&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;maps&lt;/td&gt;
          &lt;td&gt;内存映射&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;mem&lt;/td&gt;
          &lt;td&gt;进程虚拟内存&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;mounts&lt;/td&gt;
          &lt;td&gt;进程的安装点&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;root&lt;/td&gt;
          &lt;td&gt;指向根目录的符号链接&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;status&lt;/td&gt;
          &lt;td&gt;各类信息&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;/proc/PID/fd： 目录 为进程打开的每个文件描述符都包含了一个符号连接，每个符号连接的名称都与描述符的数值向匹配（/proc/pid/1 为 标准输出）， 任何进程都可以使用符号连接 /proc/self 来访问自己的/proc/PID 目录&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;/proc 目录下的系统信息:&lt;/p&gt;

    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;目录&lt;/td&gt;
          &lt;td&gt;描述&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;/proc/net&lt;/td&gt;
          &lt;td&gt;网路和套接字的状态信息&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;/proc/sys/fs/&lt;/td&gt;
          &lt;td&gt;文件系统相关的设定&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;/proc/sys/kernel/&lt;/td&gt;
          &lt;td&gt;各种常规的内核设定&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;/proc/sys/net&lt;/td&gt;
          &lt;td&gt;网络和套接字设定&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;/proc/sys/vm/&lt;/td&gt;
          &lt;td&gt;内存管理设定&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;uname(utsname * utsbuf): 系统调用返回主机系统的标识信息&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="文件io缓冲"&gt;文件IO缓冲&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;出于效率的考虑， 系统IO调用，以及 函数库IO函数，都在文件IO操作中对数据进行了缓冲&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;###: 内核缓冲区： 缓冲区 高速缓存： read, write 系统调用： 系统调用并不会直接发起磁盘调用，而仅仅是在 用户空间缓冲区 与 内核缓冲区高速缓存(kernel buffer cache) 中间复制数据。 write(fd, “abc”, 3) 的详细步骤： 1. 将数据从 用户空间内存传递到 内核 缓冲区中， 2. write 返回， 3）后续的某个时刻， 内核会将其 缓冲区的数据写入到 磁盘上。 read系统调用 则会产生 缺页中断， 进程挂起，知道 内核从磁盘中读取数据 并 存储到 内核缓冲区中，进程执行 从内核缓冲区中读取数据。&lt;/p&gt;

&lt;h3 id="stdio库的缓冲-缓冲大块数据以减少系统调用-c语言函数库的io函数-fprintf-fgetsfputs-fputc-等能够使"&gt;stdio库的缓冲： 缓冲大块数据以减少系统调用， C语言函数库的IO函数， fprintf, fgets,fputs, fputc 等能够使&lt;/h3&gt;
</content>
  </entry>
  <entry>
    <title>linux-interface-02</title>
    <link rel="alternate" href="http://geniousbar.github.io/2018/12/06/linux-interface-02/"/>
    <id>http://geniousbar.github.io/2018/12/06/linux-interface-02/</id>
    <published>2018-12-06T08:00:00+08:00</published>
    <updated>2018-12-31T15:41:43+08:00</updated>
    <summary type="html">&lt;h2 id="the-linux-programming-interface"&gt;The linux programming interface&lt;/h2&gt;

&lt;h2 id="系统编程概念"&gt;系统编程概念&lt;/h2&gt;

&lt;p&gt;无论何时，执行了系统调用或者库函数，检查调用的返回状态以确定调用是否成功,是一条编程铁律。(消灭nil就好了)&lt;/p&gt;

&lt;h3 id="系统调用"&gt;系统调用&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;借助这一机制，进程可以请求内核以自己的名义去执行动作，以API 的形式，内核提供一系列服务供程序访问。（创建进程， IIO操作等）可以参考 csapp中的 异常控制流章节。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;系统调用有以下特征：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;系统调用将CPU 从用户态切换到 内核态，以便CPU访问受保护的内存等（越过...&lt;/li&gt;
&lt;/ol&gt;</summary>
    <content type="html">&lt;h2 id="the-linux-programming-interface"&gt;The linux programming interface&lt;/h2&gt;

&lt;h2 id="系统编程概念"&gt;系统编程概念&lt;/h2&gt;

&lt;p&gt;无论何时，执行了系统调用或者库函数，检查调用的返回状态以确定调用是否成功,是一条编程铁律。(消灭nil就好了)&lt;/p&gt;

&lt;h3 id="系统调用"&gt;系统调用&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;借助这一机制，进程可以请求内核以自己的名义去执行动作，以API 的形式，内核提供一系列服务供程序访问。（创建进程， IIO操作等）可以参考 csapp中的 异常控制流章节。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;系统调用有以下特征：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;系统调用将CPU 从用户态切换到 内核态，以便CPU访问受保护的内存等（越过保护机制）&lt;/li&gt;
  &lt;li&gt;系统调用的组成是固定的。每个系统调用都由一个唯一的数字来标识。（程序通过名称标识系统调用，对编号方案无需关心）&lt;/li&gt;
  &lt;li&gt;每个系统调用都有一套对应的参数，对用户态内核态的参数传递有一定规范&lt;br /&gt;
  下面是一个系统调用的示例：&lt;/li&gt;
  &lt;li&gt;应用程序调用C语言的函数库中的外壳（wrapper） 函数，来发起系统调用&lt;/li&gt;
  &lt;li&gt;外壳函数保证所有的系统调用参数可用，并将参数复制到寄存器&lt;/li&gt;
  &lt;li&gt;外壳函数会将系统调用编号复制到%eax中，用于区分不同的系统调用&lt;/li&gt;
  &lt;li&gt;外壳函数执行一条中断机器指令，引发CPU从用户态切换到内核态，并执行 todo&lt;/li&gt;
  &lt;li&gt;内核调用 system_call 来处理中断，&lt;br /&gt;
    1) 在内核栈中保存寄存器数值&lt;br /&gt;
    2）验证 系统调用的 编号有效性&lt;br /&gt;
    3) 通过系统调用编号 发现对应的系统调用服务例程，检查参数的有效性，执行对应的代码逻辑。最后将结果状态返回给system_call&lt;br /&gt;
    4) 从内核栈中回复各个寄存器值，并将系统调用返回值置于栈中&lt;br /&gt;
    5) 返回值外壳函数，通知讲CPU切换到用户态&lt;/li&gt;
  &lt;li&gt;系统调用的服务例程返回值代表调用有误， 外壳函数会使用该值设定全局变量errno。外壳函数会返回到调用程序，并返回一个整数，标志系统调用是否成功。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="库函数"&gt;库函数&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;库函数 的设计 是为了提供比底层系统 调用更为方便的调用接口,例如 printf函数 可提供格式化输出和数据缓存， 而write 系统调用只能输出 字节块， malloc, free 函数包装了 内存的释放和分配工作&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id="处理错误"&gt;处理错误&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;几乎所有的 系统调用都会返回某种类型的错误,用以表明 调用成功与否，要了解是否调用成功则必须坚持对状态进行检查。若调用失败则必须采取相应的行动，至少应该输出错误。 不检查状态，少写几行代码，听起来很诱人。实际上却会浪费掉大把的程序调试时间&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;这段陈述适用于 任何领域的编程工作， 简单的就是 人们常讲的 nil是一个百万的设计错误 一样。nil让他们忽略对他的检查，因为假定 变量不是nil的代码很清爽，可以减少很多的if判断，造成了nil是一个非常常见，频率高的错误。 那么正确的设计应该是什么样子呢？ 答案或许是Option + 强制类型（弱类型语言不必要了，因为没有人可以阻止你不检查错误）&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;系统错误处理&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;通常返回值为-1 表示出错，系统调用失败后， 会将全局变量设定 errno 设定为一个正值来标记具体错误。但是如果系统调用和库函数成功，errno并不会被重置为0，所以单独的检查errno的设定来判断错误是错误的，因为可能是上个调用错误设定的数值。少数系统调用 在调用成功后(getpriority)依然返回-1， 要判断此类错误需要调用前将errno 设定为0， 然后根据errno判断是否错误。&lt;br /&gt;
 打印错误， perror(“string”), char *strerror(int errorcode), strerror返回的字符串 指针是静态分配的，后续的调用会覆盖之前的调用。两个函数都是 locale-sensitive 语言环境敏感型，所以现实的是本地语言。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;库函数的错误处理&lt;br /&gt;
&lt;strong&gt;不同的库函数在调用发生错误时候，返沪的数据类型和数值也各不相同，可以划分为几个类型:&lt;/strong&gt;&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;同系统调用完全相同, (remove 会调用unlink 或者rmdir)&lt;/li&gt;
      &lt;li&gt;出错时会返回-1之外的其他值，然后设定errno表明出错的具体情况 (fopen 出错返回 NULL 指针，同时设定errno)&lt;/li&gt;
      &lt;li&gt;根本不使用errno&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</content>
  </entry>
</feed>
