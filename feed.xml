<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>日常学习</title>
  <id>http://geniousbar.github.io</id>
  <link href="http://geniousbar.github.io"/>
  <link href="http://geniousbar.github.io/feed.xml" rel="self"/>
  <updated>2021-05-09T00:00:00+00:00</updated>
  <author>
    <name>geniousbar</name>
  </author>
  <entry>
    <title>Rust Async</title>
    <link rel="alternate" href="http://geniousbar.github.io/2021/05/09/rust-async/"/>
    <id>http://geniousbar.github.io/2021/05/09/rust-async/</id>
    <published>2021-05-09T00:00:00+00:00</published>
    <updated>2021-05-11T04:12:24+00:00</updated>
    <summary type="html">&lt;h3 id="并发模型"&gt;并发模型&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
&lt;strong&gt;OS threads&lt;/strong&gt;:  1) 不需要改变代码编码模式  2) 线程间 同步困难  3) 性能开销比较大， 线程池 可以一定程度上减少这些开销， 但是并不能够支撑起 庞大的IO 工作&lt;/li&gt;
  &lt;li&gt;
&lt;strong&gt;事件驱动模型(Event-driven)&lt;/strong&gt;： 结合callback, 性能非常好，但是 导致 非线性的控制流， Data flow and error propagation is often hard to follow.&lt;/li&gt;
  &lt;li&gt;
&lt;strong&gt;协程(coroutines)&lt;/strong&gt;： like thread， 不需...&lt;/li&gt;
&lt;/ul&gt;</summary>
    <content type="html">&lt;h3 id="并发模型"&gt;并发模型&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;OS threads&lt;/strong&gt;:  1) 不需要改变代码编码模式  2) 线程间 同步困难  3) 性能开销比较大， 线程池 可以一定程度上减少这些开销， 但是并不能够支撑起 庞大的IO 工作&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;事件驱动模型(Event-driven)&lt;/strong&gt;： 结合callback, 性能非常好，但是 导致 非线性的控制流， Data flow and error propagation is often hard to follow.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;协程(coroutines)&lt;/strong&gt;： like thread， 不需要改变代码编码模式， 共容易使用，提供了包括async 的工具， 支持大量的 任务，但是，其对于 底层的细节抽象 导致 系统编程非常困难&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Actor model&lt;/strong&gt;： 将所有的并行运算抽象为 actor ，其之间的沟通通过 message passing 非常像 分布式系统， 可以实现非常好的性能， 但是留下了许多实际问题 依然没有解决， 比如 flow control and retry logic&lt;/li&gt;
  &lt;li&gt;总结： async 编程 能够让 Rust 此类 &lt;strong&gt;系统编程语言&lt;/strong&gt; 编写出高性能代码，同时具有 thread 与 协程(coroutines) 的优势;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="rust-async-的现状"&gt;Rust Async 的现状&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;Rust Async 的特点：
    &lt;ul&gt;
      &lt;li&gt;Futures是rust 内置的&lt;/li&gt;
      &lt;li&gt;Async是zero-cost 的，即： 并不需要 在堆上 进行内存分配 和动态分发，即高性能（you can use async without heap allocations and dynamic dispatch, which is great for performance!）&lt;/li&gt;
      &lt;li&gt;没有内建的runtime， 由社区提供&lt;/li&gt;
      &lt;li&gt;可以支持 单线程 或者 多线程 的runtime&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Rust Async vs threads 的比较
    &lt;ul&gt;
      &lt;li&gt;threads： 适合少量的工作， 不用改变代码结构， 生成 线程 与线程之间的切换 是非常昂贵的， 线程池可以一定程度上减轻此类开销&lt;/li&gt;
      &lt;li&gt;Async： 可以显著的减少CPU 与 内存的开销， 尤其是在对于 大量IO任务时。 比thread 模式能够处理更多的任务，因为 该模型，使用 较少的 threads 处理大量的 task。 但是其二进制的文件会比传统的非异步编码的代码要大。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;异步编程的支持：
    &lt;ul&gt;
      &lt;li&gt;标准库： 提供 Future trait 抽象&lt;/li&gt;
      &lt;li&gt;Rust Compiler： 提供对  async/await 语法的支持&lt;/li&gt;
      &lt;li&gt;futures crate： 提供 工具类型， macros， 以及 方法&lt;/li&gt;
      &lt;li&gt;async runtime： 提供对 async code, IO, task spawn 的运行。有 TOkio, async-std&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;编译 与  debug：
    &lt;ul&gt;
      &lt;li&gt;为了支持异步代码：  rust 需要使用异常一些更复杂的 语言特性， 比如lifetimes pinning。 你可能将经常遇到此类错误&lt;/li&gt;
      &lt;li&gt;runtime errors： 编译器 遇到 async function，将产生一个 状态机（state machine）， Stack traces 将包含状态机内部的详细信息， 对比 Rust 同步代码, runtime errors debug 要复杂不少&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;New failure modes： 异步Rust中可能会出现一些新颖的故障模式，例如，如果您从异步上下文中调用了阻止函数，或者您错误地实现了Future特性。 这样的错误可以无声地通过编译器，有时甚至可以通过单元测试。 本书旨在为您提供对底层概念的深刻理解，可以帮助您避免这些陷阱。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="rust-异步编程-简单示例"&gt;Rust 异步编程 简单示例：&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;async/.await 语法： rust compiler 为 async 声明的block转换成一个实现了 Future trait 的 state machine。 await 等待Future的完成， 但是将thread yield 出去以允许其他Future执行&lt;/li&gt;
  &lt;li&gt;block_on: 阻塞当前 thread，直到 future 完成， 不允许 thread 运行其他的 Future&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="c"&gt;// Cargo.toml&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;dependencies&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;futures&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"0.3"&lt;/span&gt;

&lt;span class="c"&gt;// main.rs&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;futures&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nn"&gt;executor&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;block_on&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;hello_world&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"hello, world!"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;future&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;hello_world&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c"&gt;// Nothing is printed&lt;/span&gt;
  &lt;span class="nf"&gt;block_on&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;future&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c"&gt;// `future` is run and "hello, world!" is printed&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="c"&gt;// await 示例： &lt;/span&gt;

&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;learn_song&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Song&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* ... */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;sing_song&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;song&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Song&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* ... */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;dance&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* ... */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="c"&gt;// 这里使用 block_on 导致  learn_song  aing_song dance 的 串行执行, 因为block_on 将阻塞thread，直到 Future 执行完成&lt;/span&gt;
&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;song&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;block_on&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;learn_song&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
  &lt;span class="nf"&gt;block_on&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sing_song&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;song&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
  &lt;span class="nf"&gt;block_on&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;dance&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;



&lt;span class="c"&gt;// 这里使用await 可以将 thread 让出，以便  Future f2 执行。 join 能够同时执行 两个 future&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;learn_and_sing&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="c"&gt;// Wait until the song has been learned before singing it.&lt;/span&gt;
  &lt;span class="c"&gt;// We use `.await` here rather than `block_on` to prevent blocking the // thread, which makes it possible to `dance` at the same time.&lt;/span&gt;
  &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;song&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;learn_song&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="nf"&gt;sing_song&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;song&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;async_main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;f1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;learn_and_sing&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; 
  &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;f2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;dance&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
  &lt;span class="c"&gt;// `join!` is like `.await` but can wait for multiple futures concurrently. &lt;/span&gt;
  &lt;span class="c"&gt;// If we're temporarily blocked in the `learn_and_sing` future, the `dance`&lt;/span&gt;
  &lt;span class="c"&gt;// future will take over the current thread. If `dance` becomes blocked, &lt;/span&gt;
  &lt;span class="c"&gt;// `learn_and_sing` can take back over. If both futures are blocked, then &lt;/span&gt;
  &lt;span class="c"&gt;// `async_main` is blocked and will yield to the executor. &lt;/span&gt;
  &lt;span class="nn"&gt;futures&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;join!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;f2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;



&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
  &lt;span class="nf"&gt;block_on&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async_main&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="future-trait-rust-异步编程的-核心点-future-即是一个可以产生-value-的异步计算抽象简单的-future-可以如下"&gt;Future Trait: rust 异步编程的 核心点， Future 即是一个可以产生 value 的异步计算抽象。简单的 Future 可以如下：&lt;/h4&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="k"&gt;trait&lt;/span&gt; &lt;span class="n"&gt;SimpleFuture&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;poll&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;wake&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Poll&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nn"&gt;Self&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;Poll&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nf"&gt;Ready&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="n"&gt;Pending&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;pub&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;SocketRead&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;'a&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nv"&gt;'a&lt;/span&gt; &lt;span class="n"&gt;Socket&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;SimpleFuture&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;SocketRead&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;'_&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="n"&gt;Output&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;Vec&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;u8&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;poll&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;wake&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Poll&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nn"&gt;Self&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="py"&gt;.socket&lt;/span&gt;&lt;span class="nf"&gt;.has_data_to_read&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="c"&gt;// The socket has data-- read it into a buffer and return it.&lt;/span&gt;
            &lt;span class="nn"&gt;Poll&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;Ready&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="py"&gt;.socket&lt;/span&gt;&lt;span class="nf"&gt;.read_buf&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="c"&gt;// The socket does not yet have data. //&lt;/span&gt;
            &lt;span class="c"&gt;// Arrange for `wake` to be called once data is available.&lt;/span&gt;
            &lt;span class="c"&gt;// When data becomes available, `wake` will be called, and the&lt;/span&gt;
            &lt;span class="c"&gt;// user of this `Future` will know to call `poll` again and&lt;/span&gt;
            &lt;span class="c"&gt;// receive data. self.socket.set_readable_callback(wake); Poll::Pending&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;poll func 为Future 接口， 如果future 完成  则返回 Poll::Ready(result), 否则 返回 Poll::Pending, 并在当 Future 可以取得进一步进展时 调用 wake() 函数， 当wake 函数调用， Future 的 executor 将再次 在future 调用poll 以取得进展&lt;/li&gt;
  &lt;li&gt;wake 的作用： 如果没有wake 则 executor 将没有任何知识 能够知道 一个特定的future 可以取得进展， 除非周期性的在 每个future 上进行poll。 wake的存在能够让 executor 知道 那个 future 需要被poll&lt;/li&gt;
  &lt;li&gt;Timer Future 的简单实现：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;
&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::{&lt;/span&gt;
    &lt;span class="nn"&gt;future&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Future&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nn"&gt;pin&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Pin&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nn"&gt;sync&lt;/span&gt;&lt;span class="p"&gt;::{&lt;/span&gt;&lt;span class="nb"&gt;Arc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Mutex&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="nn"&gt;task&lt;/span&gt;&lt;span class="p"&gt;::{&lt;/span&gt;&lt;span class="n"&gt;Context&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Poll&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Waker&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="n"&gt;thread&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nn"&gt;time&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Duration&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;


&lt;span class="k"&gt;pub&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;TimerFuture&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;shared_state&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;Arc&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Mutex&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;SharedState&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c"&gt;// 需要使用锁， 跨 thread 更改变量&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c"&gt;/// Shared state between the future and the waiting thread&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;SharedState&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c"&gt;/// Whether or not the sleep time has elapsed&lt;/span&gt;
    &lt;span class="n"&gt;completed&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;bool&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

    &lt;span class="c"&gt;// The waker for the task that `TimerFuture` is running on.&lt;/span&gt;
    &lt;span class="c"&gt;// The thread can use this after setting `completed = true` to tell&lt;/span&gt;
    &lt;span class="c"&gt;// `TimerFuture`'s task to wake up, see that `completed = true`, and&lt;/span&gt;
    &lt;span class="c"&gt;// move forward.&lt;/span&gt;
    &lt;span class="n"&gt;waker&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;Option&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Waker&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;Future&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;TimerFuture&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="n"&gt;Output&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="c"&gt;// 需要注意 这里面 self参数类型为Pin&amp;lt;&amp;amp;mut Self&amp;gt; 以及cx 为Context&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;poll&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Pin&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;Self&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cx&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;Context&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;'_&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Poll&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nn"&gt;Self&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c"&gt;// Look at the shared state to see if the timer has already completed.&lt;/span&gt;
        &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;shared_state&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="py"&gt;.shared_state&lt;/span&gt;&lt;span class="nf"&gt;.lock&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="nf"&gt;.unwrap&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;shared_state&lt;/span&gt;&lt;span class="py"&gt;.completed&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nn"&gt;Poll&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;Ready&lt;/span&gt;&lt;span class="p"&gt;(())&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="c"&gt;// Set waker so that the thread can wake up the current task&lt;/span&gt;
            &lt;span class="c"&gt;// when the timer has completed, ensuring that the future is polled&lt;/span&gt;
            &lt;span class="c"&gt;// again and sees that `completed = true`.&lt;/span&gt;
            &lt;span class="c"&gt;//&lt;/span&gt;
            &lt;span class="c"&gt;// It's tempting to do this once rather than repeatedly cloning&lt;/span&gt;
            &lt;span class="c"&gt;// the waker each time. However, the `TimerFuture` can move between&lt;/span&gt;
            &lt;span class="c"&gt;// tasks on the executor, which could cause a stale waker pointing&lt;/span&gt;
            &lt;span class="c"&gt;// to the wrong task, preventing `TimerFuture` from waking up&lt;/span&gt;
            &lt;span class="c"&gt;// correctly.&lt;/span&gt;
            &lt;span class="c"&gt;//&lt;/span&gt;
            &lt;span class="c"&gt;// N.B. it's possible to check for this using the `Waker::will_wake`&lt;/span&gt;
            &lt;span class="c"&gt;// function, but we omit that here to keep things simple.&lt;/span&gt;
            &lt;span class="n"&gt;shared_state&lt;/span&gt;&lt;span class="py"&gt;.waker&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;Some&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cx&lt;/span&gt;&lt;span class="nf"&gt;.waker&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="nf"&gt;.clone&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
            &lt;span class="nn"&gt;Poll&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Pending&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;TimerFuture&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c"&gt;// Create a new `TimerFuture` which will complete after the provided&lt;/span&gt;
    &lt;span class="c"&gt;// timeout.&lt;/span&gt;
    &lt;span class="k"&gt;pub&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;duration&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Duration&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Self&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;shared_state&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;Arc&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nn"&gt;Mutex&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SharedState&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;completed&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;false&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;waker&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="p"&gt;}));&lt;/span&gt;

        &lt;span class="c"&gt;// Spawn the new thread&lt;/span&gt;
        &lt;span class="c"&gt;// 这个 Future 实现的 比较奇怪，直接 使用另一个 thread 中sleep 进行 timer 的实现, 所以 在上面 TimerFuture 中的 Sharedstate 需要进行 Mutex 进行保护&lt;/span&gt;
        &lt;span class="c"&gt;// 这也是后面提到 Runtime  需要提供 Timer的 重要原因吧&lt;/span&gt;
        &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;thread_shared_state&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;shared_state&lt;/span&gt;&lt;span class="nf"&gt;.clone&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="nn"&gt;thread&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;spawn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;move&lt;/span&gt; &lt;span class="p"&gt;||&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nn"&gt;thread&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;duration&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;shared_state&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;thread_shared_state&lt;/span&gt;&lt;span class="nf"&gt;.lock&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="nf"&gt;.unwrap&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="c"&gt;// Signal that the timer has completed and wake up the last&lt;/span&gt;
            &lt;span class="c"&gt;// task on which the future was polled, if one exists.&lt;/span&gt;
            &lt;span class="n"&gt;shared_state&lt;/span&gt;&lt;span class="py"&gt;.completed&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="nf"&gt;Some&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;waker&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;shared_state&lt;/span&gt;&lt;span class="py"&gt;.waker&lt;/span&gt;&lt;span class="nf"&gt;.take&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;waker&lt;/span&gt;&lt;span class="nf"&gt;.wake&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;});&lt;/span&gt;

        &lt;span class="n"&gt;TimerFuture&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;shared_state&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="c"&gt;// Executor 的实现：&lt;/span&gt;

&lt;span class="c"&gt;/// Task executor that receives tasks off of a channel and runs them.&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Executor&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;ready_queue&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Receiver&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;Arc&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Task&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c"&gt;/// `Spawner` spawns new futures onto the task channel.&lt;/span&gt;
&lt;span class="nd"&gt;#[derive(Clone)]&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Spawner&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;task_sender&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;SyncSender&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;Arc&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Task&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c"&gt;/// A future that can reschedule itself to be polled by an `Executor`.&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Task&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c"&gt;/// In-progress future that should be pushed to completion.&lt;/span&gt;
    &lt;span class="c"&gt;///&lt;/span&gt;
    &lt;span class="c"&gt;/// The `Mutex` is not necessary for correctness, since we only have&lt;/span&gt;
    &lt;span class="c"&gt;/// one thread executing tasks at once. However, Rust isn't smart&lt;/span&gt;
    &lt;span class="c"&gt;/// enough to know that `future` is only mutated from one thread,&lt;/span&gt;
    &lt;span class="c"&gt;/// so we need to use the `Mutex` to prove thread-safety. A production&lt;/span&gt;
    &lt;span class="c"&gt;/// executor would not need this, and could use `UnsafeCell` instead.&lt;/span&gt;
    &lt;span class="n"&gt;future&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Mutex&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;Option&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;BoxFuture&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;'static&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

    &lt;span class="c"&gt;/// Handle to place the task itself back onto the task queue.&lt;/span&gt;
    &lt;span class="n"&gt;task_sender&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;SyncSender&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;Arc&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Task&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;new_executor_and_spawner&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Executor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Spawner&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c"&gt;// Maximum number of tasks to allow queueing in the channel at once.&lt;/span&gt;
    &lt;span class="c"&gt;// This is just to make `sync_channel` happy, and wouldn't be present in&lt;/span&gt;
    &lt;span class="c"&gt;// a real executor.&lt;/span&gt;
    &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;MAX_QUEUED_TASKS&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;usize&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10_000&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;task_sender&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ready_queue&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;sync_channel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MAX_QUEUED_TASKS&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Executor&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;ready_queue&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="n"&gt;Spawner&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;task_sender&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;Spawner&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;spawn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;future&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;Future&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Output&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nv"&gt;'static&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;Send&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;future&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;future&lt;/span&gt;&lt;span class="nf"&gt;.boxed&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;task&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;Arc&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Task&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;future&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nn"&gt;Mutex&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;Some&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;future&lt;/span&gt;&lt;span class="p"&gt;)),&lt;/span&gt;
            &lt;span class="n"&gt;task_sender&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="py"&gt;.task_sender&lt;/span&gt;&lt;span class="nf"&gt;.clone&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;
        &lt;span class="p"&gt;});&lt;/span&gt;
        &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="py"&gt;.task_sender&lt;/span&gt;&lt;span class="nf"&gt;.send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;.expect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"too many tasks queued"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;ArcWake&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;Task&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;wake_by_ref&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arc_self&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nb"&gt;Arc&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Self&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c"&gt;// Implement `wake` by sending this task back onto the task channel&lt;/span&gt;
        &lt;span class="c"&gt;// so that it will be polled again by the executor.&lt;/span&gt;
        &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;cloned&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arc_self&lt;/span&gt;&lt;span class="nf"&gt;.clone&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;arc_self&lt;/span&gt;
            &lt;span class="py"&gt;.task_sender&lt;/span&gt;
            &lt;span class="nf"&gt;.send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cloned&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="nf"&gt;.expect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"too many tasks queued"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;Executor&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;run&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="nf"&gt;Ok&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="py"&gt;.ready_queue&lt;/span&gt;&lt;span class="nf"&gt;.recv&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="c"&gt;// Take the future, and if it has not yet completed (is still Some),&lt;/span&gt;
            &lt;span class="c"&gt;// poll it in an attempt to complete it.&lt;/span&gt;
            &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;future_slot&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="py"&gt;.future&lt;/span&gt;&lt;span class="nf"&gt;.lock&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="nf"&gt;.unwrap&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="nf"&gt;Some&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;future&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;future_slot&lt;/span&gt;&lt;span class="nf"&gt;.take&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="c"&gt;// Create a `LocalWaker` from the task itself&lt;/span&gt;
                &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;waker&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;waker_ref&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="nn"&gt;Context&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;from_waker&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;*&lt;/span&gt;&lt;span class="n"&gt;waker&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="c"&gt;// `BoxFuture&amp;lt;T&amp;gt;` is a type alias for&lt;/span&gt;
                &lt;span class="c"&gt;// `Pin&amp;lt;Box&amp;lt;dyn Future&amp;lt;Output = T&amp;gt; + Send + 'static&amp;gt;&amp;gt;`.&lt;/span&gt;
                &lt;span class="c"&gt;// We can get a `Pin&amp;lt;&amp;amp;mut dyn Future + Send + 'static&amp;gt;`&lt;/span&gt;
                &lt;span class="c"&gt;// from it by calling the `Pin::as_mut` method.&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="nn"&gt;Poll&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Pending&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;future&lt;/span&gt;&lt;span class="nf"&gt;.as_mut&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="nf"&gt;.poll&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                    &lt;span class="c"&gt;// We're not done processing the future, so put it&lt;/span&gt;
                    &lt;span class="c"&gt;// back in its task to be run again in the future.&lt;/span&gt;
                    &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;future_slot&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;Some&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;future&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;



&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;executor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;spawner&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;new_executor_and_spawner&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="c"&gt;// Spawn a task to print before and after waiting on a timer.&lt;/span&gt;
    &lt;span class="n"&gt;spawner&lt;/span&gt;&lt;span class="nf"&gt;.spawn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"howdy!"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="c"&gt;// Wait for our timer future to complete after two seconds.&lt;/span&gt;
        &lt;span class="nn"&gt;TimerFuture&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nn"&gt;Duration&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"done!"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;});&lt;/span&gt;

    &lt;span class="c"&gt;// Drop the spawner so that our executor knows it is finished and won't&lt;/span&gt;
    &lt;span class="c"&gt;// receive more incoming tasks to run.&lt;/span&gt;
    &lt;span class="k"&gt;drop&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;spawner&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c"&gt;// Run the executor until the task queue is empty.&lt;/span&gt;
    &lt;span class="c"&gt;// This will print "howdy!", pause, and then print "done!".&lt;/span&gt;
    &lt;span class="n"&gt;executor&lt;/span&gt;&lt;span class="nf"&gt;.run&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="executors-and-system-io"&gt;Executors and System IO:&lt;/h3&gt;
&lt;h4 id="executor-谁来调用-future-的poll-方法-答案是-future-executor-executor-调用一大堆-futures-的poll方法-以便让future-取得进展-当-future-能够-取得进一步进展时通过调用wake-方法-以便-executor-再次执行-future"&gt;Executor： 谁来调用 Future 的poll 方法？ 答案是 Future Executor。 executor 调用一大堆 Futures 的poll方法 以便让Future 取得进展， 当 Future 能够 取得进一步进展时，通过调用wake 方法， 以便 executor 再次执行 Future。&lt;/h4&gt;
&lt;h4 id="system-io-在上面的-simplefuture-代码中-谁来执行-wake-方法呢-selfsocketset_readable_callbackwake-又是如何处罚呢-答案是-epoll-的io多路复用可以让我们-使用thread-对-socket文件进行-监听循环检测-io-事件"&gt;System IO: 在上面的 SimpleFuture 代码中， 谁来执行 wake 方法呢？ self.socket.set_readable_callback(wake) 又是如何处罚呢？ 答案是 epoll 的IO多路复用，可以让我们 使用thread 对 socket文件进行 监听，循环检测 IO 事件。&lt;/h4&gt;
&lt;h4 id="executors-单线程-与-多线程"&gt;Executors: 单线程 与 多线程&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;多线程执行程序可同时在多个任务上取得进展。 对于具有许多任务的工作负载，它可以极大地加快执行速度，但是在任务之间同步数据通常会更加昂贵。 在单线程和多线程运行时之间进行选择时，建议测量应用程序的性能。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;任务可以在创建任务的线程上运行，也可以在单独的线程上运行。 异步运行时通常提供将任务生成到单独线程上的功能。 即使任务在单独的线程上执行，它们也应该是非阻塞的。 为了在多线程执行器上安排任务，它们也必须是Send。 一些运行时提供了生成非发送任务的功能，以确保每个任务都在生成它的线程上执行。 它们还可以提供用于将阻塞任务生成到专用线程上的功能，这对于从其他库运行阻塞同步代码很有用。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;async Lifetimes， async move， 因为异步的存在， 导致 async { /../ } 可以 传递给变量 并进行 .await， 导致  block {} 中 的包含的变量，以及 引用 需要与 Future 存在的周期相同。 async move 允许 like normal block 一样， 允许将 block中变量 移入到 block中， 并跟随 Future 一样的生命周期&lt;/li&gt;
  &lt;li&gt;当使用 多线程的 executor时， Future 可能在 threads 中进行移动，所以 在async block中的 any variables 必须同样能够在 threads中进行移动， 意味着  任何没有实现 &lt;a href="https://doc.rust-lang.org/std/marker/trait.Send.html"&gt;Send trait&lt;/a&gt;、reference type 没有 实现 &lt;a href="https://doc.rust-lang.org/std/marker/trait.Sync.html"&gt;Sync trait&lt;/a&gt; 的都不能够 在async block中使用。&lt;/li&gt;
  &lt;li&gt;锁：不能使用 传统的 non-futures-aware lock, 因为Future 可能在threads 中进行移动 从而导致死锁，应该使用  futures::lock 中的Mutex&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="工具以及-trait"&gt;工具以及 trait:&lt;/h3&gt;

&lt;h4 id="pin"&gt;Pin:&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Pin： maker， 保证 对象 implement !Unpin 永远不会被移动。因为比较难以理解， 下面为英文：&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;The Pin type wraps pointer types, guaranteeing that the values behind the pointer won’t be moved. For example, Pin&amp;lt;&amp;amp;mut T&amp;gt; , Pin&amp;lt;&amp;amp;T&amp;gt; , Pin&amp;lt;Box&lt;T&gt;&amp;gt; all guarantee that T won't be moved if T: !Unpin .
Most types don't have a problem being moved. These types implement a trait called Unpin . Pointers to Unpin types can be freely placed into or taken out of Pin . For example, u8 is
Unpin , so Pin&amp;lt;&amp;amp;mut u8&amp;gt; behaves just like a normal &amp;amp;mut u8 .
However, types that can't be moved after they're pinned have a marker called !Unpin .
Futures created by async/await is an example of this.&lt;/T&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Pinning: 大概的以为是 是一个编译器 标记（marker） 用来保证 impl  !Unpin 的对象 在内存中 不被移动，即pin:&lt;/li&gt;
  &lt;li&gt;Pin Summary:
    &lt;ol&gt;
      &lt;li&gt;If T: Unpin (which is the default), then Pin&amp;lt;’a, T&amp;gt; is entirely equivalent to &amp;amp;’a mut T. in other words: Unpin means it’s OK for this type to be moved even when pinned, so Pin will have no effect on such a type.&lt;/li&gt;
      &lt;li&gt;Getting a &amp;amp;mut T to a pinned T requires unsafe if T: !Unpin.&lt;/li&gt;
      &lt;li&gt;Most standard library types implement Unpin. The same goes for most “normal” types you encounter in Rust. A Future generated by async/await is an exception to this rule.&lt;/li&gt;
      &lt;li&gt;You can add a !Unpin bound on a type on nightly with a feature flag, or by adding std::marker::PhantomPinned to your type on stable.&lt;/li&gt;
      &lt;li&gt;You can either pin data to the stack or to the heap.&lt;/li&gt;
      &lt;li&gt;Pinning a !Unpin object to the stack requires unsafe&lt;/li&gt;
      &lt;li&gt;Pinning a !Unpin object to the heap does not require unsafe. There is a shortcut for doing this using Box::pin.&lt;/li&gt;
      &lt;li&gt;For pinned data where T: !Unpin you have to maintain the invariant that its memory will not get invalidated or repurposed from the moment it gets pinned until when drop is called. This is an important part of the pin contract.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="stream-trait-like-future-但是能够-在完成之前-传递多个数值-like-iterator即-返回对象为---polloptionselfitem--stream-可以实现并行函数有-for_each_concurrent-try_for_each_concurrent"&gt;Stream Trait: like Future 但是能够 在完成之前 传递多个数值 like Iterator，即： 返回对象为   Poll&amp;lt;Option&amp;lt;Self::Item&amp;gt; &amp;gt;。 stream 可以实现并行，函数有 for_each_concurrent， try_for_each_concurrent&lt;/h4&gt;
&lt;h4 id="多个future-同时执行"&gt;多个Future 同时执行:&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;工具方法:
    &lt;ol&gt;
      &lt;li&gt;join! : waits for futures to all complete&lt;/li&gt;
      &lt;li&gt;select! : waits for one of several futures to complete&lt;/li&gt;
      &lt;li&gt;Spawning: creates a top-level task which ambiently runs a future to completion&lt;/li&gt;
      &lt;li&gt;FuturesUnordered : a group of futures which yields the result of each subfuture&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;join! 示例代码: try_join!  在其中一个 Future 返回错误的时候，立即返回&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="c"&gt;// book 与 music 串行执行， music 等待book 执行完 才能执行&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;get_book_and_music&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Book&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Music&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;book&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;get_book&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;music&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;get_music&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;book&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;music&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c"&gt;// 错误的尝试，将 book 与 music 并行执行&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;get_book_and_music&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Book&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Music&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;book_future&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;get_book&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;music_future&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;get_music&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;book_future&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;music_future&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c"&gt;// 真正的并行执行&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;get_book_and_music&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Book&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Music&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;book_fut&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;get_book&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;music_fut&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;get_music&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="nd"&gt;join!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;book_fut&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;music_fut&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;select! 示例代码： select macro 的使用风格比较奇怪， 需要在深入理解一下&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;
&lt;span class="nd"&gt;#![allow(unused)]&lt;/span&gt;
&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;futures&lt;/span&gt;&lt;span class="p"&gt;::{&lt;/span&gt;
    &lt;span class="nn"&gt;future&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;FutureExt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c"&gt;// for `.fuse()`&lt;/span&gt;
    &lt;span class="n"&gt;pin_mut&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;select&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;task_one&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* ... */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;task_two&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* ... */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;race_tasks&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;task_one&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="nf"&gt;.fuse&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;t2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;task_two&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="nf"&gt;.fuse&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="nd"&gt;pin_mut!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;t2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="nd"&gt;select!&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"task one completed first"&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;t2&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"task two completed first"&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;Unpin ： Unpin 是必须的， 因为在 select 中 数值是使用mut reference，而非take ownership 的， 没有完成的future 依然可以在后面的select 中使用。&lt;/li&gt;
  &lt;li&gt;FusedFuture: 同样是必须的， 因为 select 中 必须 not poll 已经完成的Future， FusedFuture 实现了 跟踪 Future 是否已经完成，&lt;/li&gt;
  &lt;li&gt;这两个 trait 能够让 select 在 loop block 中使用。 如下代码示例：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="nd"&gt;#![allow(unused)]&lt;/span&gt;
&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;futures&lt;/span&gt;&lt;span class="p"&gt;::{&lt;/span&gt;&lt;span class="n"&gt;future&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;select&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;count&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;a_fut&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;future&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;ready&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;b_fut&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;future&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;ready&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;total&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nd"&gt;select!&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a_fut&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;total&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b_fut&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;total&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;complete&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;default&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;unreachable!&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="c"&gt;// never runs (futures are ready, then complete)&lt;/span&gt;
        &lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nd"&gt;assert_eq!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;total&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="async-blocks-编码存在的一些问题"&gt;Async Blocks 编码存在的一些问题:&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;？: 在 async block 中  使用 ? 需要  额外的 声明 Error type 来帮助 编译器确定 错误类型， 如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="c"&gt;// 产生 编译错误&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;fut&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nf"&gt;Ok&lt;/span&gt;&lt;span class="p"&gt;(())&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="c"&gt;// 正确的解决方法&lt;/span&gt;
&lt;span class="nd"&gt;#![allow(unused)]&lt;/span&gt;
&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;MyError&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Result&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;MyError&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nf"&gt;Ok&lt;/span&gt;&lt;span class="p"&gt;(())&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Result&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;MyError&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nf"&gt;Ok&lt;/span&gt;&lt;span class="p"&gt;(())&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;fut&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nn"&gt;Ok&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;MyError&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(())&lt;/span&gt; &lt;span class="c"&gt;// &amp;lt;- note the explicit type annotation here&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;Future 是否 能够 send： 有些Future state machines 可以安全地被send, 而有些则不能。 是否Future 可以被 send 取决于是否在.await点上保留 non-send type。 当可能在.await点上保留值时，编译器会尽力进行近似，但是编译器的分析在许多地方都过于保守。 如下面代码示例：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="c"&gt;// 通过编译&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nn"&gt;rc&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nb"&gt;Rc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nd"&gt;#[derive(Default)]&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nf"&gt;NotSend&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;Rc&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nn"&gt;NotSend&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;default&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;require_send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;_&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="nb"&gt;Send&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nf"&gt;require_send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c"&gt;// 产生编译错误&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nn"&gt;rc&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nb"&gt;Rc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nd"&gt;#[derive(Default)]&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nf"&gt;NotSend&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;Rc&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;NotSend&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;default&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;require_send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;_&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="nb"&gt;Send&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="nf"&gt;require_send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="c"&gt;// 正确的解决方法&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nn"&gt;rc&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nb"&gt;Rc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nd"&gt;#[derive(Default)]&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nf"&gt;NotSend&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;Rc&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;NotSend&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;default&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;require_send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;_&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="nb"&gt;Send&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="nf"&gt;require_send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;递归问题： 因async fn 内部的状态机 实现导致 递归的使用 需要 额外 解决方案. 如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="c"&gt;// This function:&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nf"&gt;step_one&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nf"&gt;step_two&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c"&gt;// generates a type like this:&lt;/span&gt;
&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;Foo&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nf"&gt;First&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;StepOne&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="nf"&gt;Second&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;StepTwo&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c"&gt;// So this function:&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;recursive&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nf"&gt;recursive&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nf"&gt;recursive&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c"&gt;// generates a type like this:  因为类型对象存在递归，导致 无法通过编译，需要通过 Box 进行封装 来进行规避&lt;/span&gt;
&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;Recursive&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nf"&gt;First&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Recursive&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="nf"&gt;Second&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Recursive&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c"&gt;// --------------------&lt;/span&gt;
&lt;span class="c"&gt;// In order to allow this, we have to introduce an indirection using Box. Unfortunately, compiler limitations mean that just wrapping the calls to recursive() in Box::pin isn't enough. To make this work, we have to make recursive into a non-async function which returns a .boxed() async block:&lt;/span&gt;

&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;futures&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nn"&gt;future&lt;/span&gt;&lt;span class="p"&gt;::{&lt;/span&gt;&lt;span class="n"&gt;BoxFuture&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;FutureExt&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;recursive&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;BoxFuture&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;'static&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;move&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nf"&gt;recursive&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="nf"&gt;recursive&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="nf"&gt;.boxed&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="async-生态"&gt;Async 生态:&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Async Runtimes = reactor + one or more executors&lt;/li&gt;
  &lt;li&gt;Reactors： 提供对于 外部事件 比如: 异步IO 进程内通讯 timer 等 简单的订阅方式 (provide subscription mechanisms for external events, like async I/O, interprocess communication, and timers. In an async runtime, subscribers are typically futures representing low-level I/O operations)&lt;/li&gt;
  &lt;li&gt;Executors: Future 具体的执行者， 因为只有 thread ，process 才能够执行代码，所以Future等 抽象事物，依然需要具体的executor  (handle the scheduling and execution of tasks. They keep track of running and suspended tasks, poll futures to completion, and wake tasks when they can make progress)&lt;/li&gt;
  &lt;li&gt;Futures Crate： 包含 async code 有用的trait 与 函数， 包含trait有： Stream, Sink, AsyncRead, AsyncWrite  , 工具有： join! select! etc （这些可能将成为 标准库 的一部分） future 实现了自己的 executor， 但是并没有 reactor。 所以一个常见的组合是： Future 的工具 + 其他crate 的executor&lt;/li&gt;
  &lt;li&gt;常见的 Async runtime:
    &lt;ul&gt;
      &lt;li&gt;Tokio: A popular async ecosystem with HTTP, gRPC, and tracing frameworks. async-std: A crate that provides asynchronous counterparts to standard library components.&lt;/li&gt;
      &lt;li&gt;smol: A small, simplified async runtime. Provides the Async trait that can be used to wrap structs like*  UnixStream or TcpListener&lt;/li&gt;
      &lt;li&gt;fuchsia-async: An executor for use in the Fuchsia OS.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>Mysql</title>
    <link rel="alternate" href="http://geniousbar.github.io/2021/04/11/mysql-relearn/"/>
    <id>http://geniousbar.github.io/2021/04/11/mysql-relearn/</id>
    <published>2021-04-11T00:00:00+00:00</published>
    <updated>2021-04-22T02:50:09+00:00</updated>
    <summary type="html">&lt;h2 id="mysql-relearn"&gt;Mysql Relearn&lt;/h2&gt;
&lt;h3 id="内存模型"&gt;内存模型：&lt;/h3&gt;
&lt;p&gt;&lt;img src="../../../../images/innodb-change-buffer-5fbd1a84.png" alt="memory-cache"&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Change BUffer： 缓存 不在Buffer pool 中的 索引页的变动， 变动 可能由 insert update， delete 等操作 导致， 将在以后 页面 被加载到 Buffer pool时 被合并
    &lt;ul&gt;
      &lt;li&gt;[image]&lt;/li&gt;
      &lt;li&gt;不同于 聚簇索引， 普通的索引 通常是不唯一的，索引 的插入 删除 更新 通常是 random 的， 随后 将 change Buffer 的合并到 Buffer pool（当...&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    <content type="html">&lt;h2 id="mysql-relearn"&gt;Mysql Relearn&lt;/h2&gt;
&lt;h3 id="内存模型"&gt;内存模型：&lt;/h3&gt;
&lt;p&gt;&lt;img src="../../../../images/innodb-change-buffer-5fbd1a84.png" alt="memory-cache" /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Change BUffer： 缓存 不在Buffer pool 中的 索引页的变动， 变动 可能由 insert update， delete 等操作 导致， 将在以后 页面 被加载到 Buffer pool时 被合并
    &lt;ul&gt;
      &lt;li&gt;[image]&lt;/li&gt;
      &lt;li&gt;不同于 聚簇索引， 普通的索引 通常是不唯一的，索引 的插入 删除 更新 通常是 random 的， 随后 将 change Buffer 的合并到 Buffer pool（当索引页被load 到 buffer pool时） 将减少 随机 的IO 操作。&lt;/li&gt;
      &lt;li&gt;当系统 空闲时，或者缓慢关闭时 会定时的进行清理操作（将cache 写回到 硬盘中） 清理操作 将 一系列的 索引更新 写入到磁盘中 的速度 远高于 每个更新立即写入&lt;/li&gt;
      &lt;li&gt;当存在大量的 受影响的row 和 众多的 索引时， change Buffer 的合并（这里的合并 应该不是简单的与 Buffer pool的合并，而是 合并之后，需要写回到 硬盘中吧） 可能 需要数个小时， 在这期间， IO将显著增加， 导致 磁盘绑定查询（意思是 需要 访问硬盘？） 的速度显著变慢，&lt;/li&gt;
      &lt;li&gt;在Memory中， change buff 是Buffer pool 的一部分， 在disk上， change buff 是 system tablespace 的一部分（当服务器关闭是， 索引的更改change buff 可能保存其中）&lt;/li&gt;
      &lt;li&gt;配置：
        &lt;ol&gt;
          &lt;li&gt;innodb_change_buffering 因为 change buffer 虽然能够 减少IO操作，但 依然占用了 部分的 Buffer pool, 所以提供了此变量 来精确的控制 insert， delete， purge（physical deletion happen in background）， changes(insert + delete) 操作 是否使用  change buffer&lt;/li&gt;
          &lt;li&gt;innodb_change_buffer_max_size 可以控制 buffer的大小，数值为 其所占 Buffer pool 的百分比， 默认为 25，最高 为 50&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;Monitor：
        &lt;ul&gt;
          &lt;li&gt;show engine Innodb status 中的 INSERT BUFFER AND ADAPTIVE HASH INDEX 段&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;  -------------------------------------
  INSERT BUFFER AND ADAPTIVE HASH INDEX
  -------------------------------------
  Ibuf: size 1, free list len 0, seg size 2, 0 merges
  merged operations:
   insert 0, delete mark 0, delete 0
  discarded operations:
   insert 0, delete mark 0, delete 0
  Hash table size 4425293, used cells 32, node heap has 1 buffer(s)
  13577.57 hash searches/s, 202.47 non-hash searches/s

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;ul&gt;
      &lt;li&gt;数据库方式： information_schema 中 相关的table 可以查询到相关信息 &lt;a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-change-buffer.html#innodb-change-buffer-maximum-size"&gt;url&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="自适应hash-索引"&gt;自适应Hash 索引：&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Hash 索引： 通过 索引 的前缀 构建 hash 的 key， 通过监控到的搜索， 如果InnoDB 认为可以 让查询从 简历Hash索引中 收益， 他会自动构建。&lt;/li&gt;
  &lt;li&gt;在一些负载比较繁重的情况下， 导致 监控 争用 Hash索引 的开销 并不能够 使其 受益，则可以选择关闭 该选项， 以为很难判定 这种情况的出现， 则 应该使用 准确的基准测试 之后来决定&lt;/li&gt;
  &lt;li&gt;自适应 Hash索引： 已经实现了 分区(partition)， 每个索引都绑定到特定的分区（并不知道有啥用,这里要讲啥?） 分区数量由 innodb_adaptive_hash_index_parts  控制，在 8…512 范围内&lt;/li&gt;
  &lt;li&gt;可以 在 show engine innodb  status 中的  SEMAPHORES 段 来查看 btr0sea.c 的rw 锁 争用情况， 可以考虑增加 Hash索引的分区数值，或者关闭 该功能&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="log-buffer"&gt;Log Buffer:&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Log buffer 用来缓存 将要写入 disk 的 log file的数据，&lt;/li&gt;
  &lt;li&gt;配置：
    &lt;ol&gt;
      &lt;li&gt;innodb_log_buffer_size  用来控制Buffer 的大小， default is 16MB, 定期 刷新到 disk, 一个大 的 log buffer 可以让一个 da的 transaction 在commit 提交前 不需要将 redo log 刷新到disk 中。&lt;/li&gt;
      &lt;li&gt;innodb_flush_log_at_trx_commit  控制 log buffer 而如何 同步到disk中&lt;/li&gt;
      &lt;li&gt;innodb_flush_log_at_timeout： 控制log buffer 同步的频率&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="innodb-磁盘数据结构"&gt;InnoDB 磁盘数据结构：&lt;/h3&gt;

&lt;h4 id="table"&gt;Table&lt;/h4&gt;
&lt;h4 id="创建表-create-table"&gt;创建表： create table,&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt;   &lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;TABLE&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="nb"&gt;INT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="nb"&gt;CHAR&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="k"&gt;PRIMARY&lt;/span&gt; &lt;span class="k"&gt;KEY&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="n"&gt;ENGINE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;Innodb 默认 table 的存储方式 为一个 文件 一个table， 配置 innodb_file_per_table 用来打开、关闭 此行为
    &lt;h4 id="row-format"&gt;Row format：&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;row 的格式，决定了 InnoDB 行 在物理上的disk 的存储，支持 4中format， 每个格式 都有对应的存储特性。格式有：
    &lt;ul&gt;
      &lt;li&gt;redundant： 冗余&lt;/li&gt;
      &lt;li&gt;compact： 紧凑&lt;/li&gt;
      &lt;li&gt;dynamic： 动态&lt;/li&gt;
      &lt;li&gt;compressed： 压缩&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;row 格式控制： 默认为 dynamic， 变量 innodb_default_row_format 可以控制 默认的row 存储格式， create table, alter table 也同样可以控制 row 格式&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="primary-key"&gt;Primary key&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;建议 为每个table 创建自己的 primary key, 选取 primary key 的column 规则为：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;重要查询所使用&lt;/li&gt;
      &lt;li&gt;永远不会存储空&lt;/li&gt;
      &lt;li&gt;永远不会存储重复数值&lt;/li&gt;
      &lt;li&gt;插入之后 很少更新的数值&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;如果没有 明显的选择的话， 则 可以创建一个 type 为number auto-increment 的column 作为主建&lt;/li&gt;
  &lt;li&gt;尽管在没有定义主键的情况下表可以正常工作，但是主键涉及性能的许多方面，并且对于任何大型或经常使用的表都是至关重要的设计方面。 建议始终在CREATE TABLE语句中指定主键&lt;/li&gt;
  &lt;li&gt;查看table的相关的属性：
    &lt;ol&gt;
      &lt;li&gt;SHOW TABLE STATUS&lt;/li&gt;
    &lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt;   &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;SHOW&lt;/span&gt; &lt;span class="k"&gt;TABLE&lt;/span&gt; &lt;span class="n"&gt;STATUS&lt;/span&gt; &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt; &lt;span class="k"&gt;LIKE&lt;/span&gt; &lt;span class="s1"&gt;'t%'&lt;/span&gt; &lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="k"&gt;G&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="o"&gt;***************************&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="k"&gt;row&lt;/span&gt; &lt;span class="o"&gt;***************************&lt;/span&gt;
              &lt;span class="n"&gt;Name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt;
            &lt;span class="n"&gt;Engine&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt;
           &lt;span class="k"&gt;Version&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
        &lt;span class="n"&gt;Row_format&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;Dynamic&lt;/span&gt;
              &lt;span class="k"&gt;Rows&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="n"&gt;Avg_row_length&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
       &lt;span class="n"&gt;Data_length&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;16384&lt;/span&gt;
   &lt;span class="n"&gt;Max_data_length&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
      &lt;span class="n"&gt;Index_length&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
         &lt;span class="n"&gt;Data_free&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="n"&gt;Auto_increment&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;NULL&lt;/span&gt;
       &lt;span class="n"&gt;Create_time&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2021&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;02&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;18&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;18&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;28&lt;/span&gt;
       &lt;span class="n"&gt;Update_time&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;NULL&lt;/span&gt;
        &lt;span class="n"&gt;Check_time&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;NULL&lt;/span&gt;
         &lt;span class="k"&gt;Collation&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;utf8mb4_0900_ai_ci&lt;/span&gt;
          &lt;span class="n"&gt;Checksum&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;NULL&lt;/span&gt;
    &lt;span class="n"&gt;Create_options&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; 
           &lt;span class="k"&gt;Comment&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;从 INFORMATION_SCHEMA.INNODB_TABLES 中获取信息:&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt;
  &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;INFORMATION_SCHEMA&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;INNODB_TABLES&lt;/span&gt; &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;NAME&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'test/t1'&lt;/span&gt; &lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="k"&gt;G&lt;/span&gt;
 &lt;span class="o"&gt;***************************&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="k"&gt;row&lt;/span&gt; &lt;span class="o"&gt;***************************&lt;/span&gt;
      &lt;span class="n"&gt;TABLE_ID&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1144&lt;/span&gt;
          &lt;span class="n"&gt;NAME&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;t1&lt;/span&gt;
          &lt;span class="n"&gt;FLAG&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;33&lt;/span&gt;
        &lt;span class="n"&gt;N_COLS&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;
         &lt;span class="k"&gt;SPACE&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;
    &lt;span class="n"&gt;ROW_FORMAT&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;Dynamic&lt;/span&gt;
 &lt;span class="n"&gt;ZIP_PAGE_SIZE&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="n"&gt;SPACE_TYPE&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Single&lt;/span&gt;
  &lt;span class="n"&gt;INSTANT_COLS&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="在其他目录中存储-数据即-外部创建表"&gt;在其他目录中存储 数据：（即 外部创建表）&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Using the DATA DIRECTORY Clause： 在 create table syntax 中 可以 添加  DATA DIRECTORY 来制定数据的存储目录&lt;/li&gt;
  &lt;li&gt;Using TABLESPACE Clause: 在create table syntax 中添加 TABLESPACE = innodb_file_per_table 配合 data dictory 使用&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;示例：&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt;&lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;USE&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;Database&lt;/span&gt; &lt;span class="n"&gt;changed&lt;/span&gt;

&lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;TABLE&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c1&lt;/span&gt; &lt;span class="nb"&gt;INT&lt;/span&gt; &lt;span class="k"&gt;PRIMARY&lt;/span&gt; &lt;span class="k"&gt;KEY&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;DATA&lt;/span&gt; &lt;span class="n"&gt;DIRECTORY&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'/external/directory'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="n"&gt;MySQL&lt;/span&gt; &lt;span class="n"&gt;creates&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="k"&gt;table&lt;/span&gt;&lt;span class="s1"&gt;'s data file in a schema directory
# under the external directory

shell&amp;gt; cd /external/directory/test
shell&amp;gt; ls
t1.ibd
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="导入-innodb-表"&gt;导入 InnoDB 表：&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;可能应用的场景有：
    &lt;ol&gt;
      &lt;li&gt;利用 线上 的数据做报表，而不像 增加额外的负担 在线上 2） 复制数据给 replica server 3） 从backup 上恢复 表 4）&lt;/li&gt;
      &lt;li&gt;比import a dump file 更快的 移动数据 的方法&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;先决条件
    &lt;ol&gt;
      &lt;li&gt;innodb_file_per_table  变量 必须是打开的&lt;/li&gt;
      &lt;li&gt;source server &amp;amp; desitnation server  的 page size of tablespace 配置必须相同，  innodb_page_size  变量控制&lt;/li&gt;
      &lt;li&gt;foreign key 的关系， 如果 导出表 有 foreign key，  在 执行 discard talbespace 之前， 则 需要 foreign_key_checks 需要关闭， 还需要导出所有外键 关联的表，因为ALTER TABLE … IMPORT TABLESPACE不会对导入的数据实施外键约束。 为此 需要 停止更新 相关的表， 提交所有 transaction， 获取表 的 S锁，然后执行 export 操作&lt;/li&gt;
      &lt;li&gt;导出导入 的mysql version  必须兼容&lt;/li&gt;
      &lt;li&gt;导出导入server 的 data directory 必须 相同, 导致 schema mismatch error&lt;/li&gt;
      &lt;li&gt;导出导入server 的 ROW_FORMAT 需要相同, 导致 schema mismatch errorgg&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;示例
    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;在 destination server 上 创建表， schema 需要与 source server 表的 syntax 相同&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt; &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;USE&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;TABLE&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c1&lt;/span&gt; &lt;span class="nb"&gt;INT&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;ENGINE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;INNODB&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;      &lt;/li&gt;
      &lt;li&gt;在destination server 上， 执行 discard tablespace 命令
        &lt;ul&gt;
          &lt;li&gt;table 将会 上 X 锁&lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;tablespace 与table 分离&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt; &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;ALTER&lt;/span&gt; &lt;span class="k"&gt;TABLE&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="n"&gt;DISCARD&lt;/span&gt; &lt;span class="n"&gt;TABLESPACE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;在source server 上 执行 flush tables … for export， 执行之后 只能允许 读表请求， 将产生 .cfg, .ibd文件
        &lt;ul&gt;
          &lt;li&gt;导出的table 将会上S锁， 并将更新 flush 到disk&lt;/li&gt;
          &lt;li&gt;停止 purge thread&lt;/li&gt;
          &lt;li&gt;Dirty page sync to disk&lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;table metadata write to .cfg file&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt; &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;USE&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;FLUSH&lt;/span&gt; &lt;span class="n"&gt;TABLES&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="k"&gt;FOR&lt;/span&gt; &lt;span class="n"&gt;EXPORT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

 &lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="err"&gt;可能看到的&lt;/span&gt; &lt;span class="err"&gt;输出为&lt;/span&gt;
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Note&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Sync&lt;/span&gt; &lt;span class="k"&gt;to&lt;/span&gt; &lt;span class="n"&gt;disk&lt;/span&gt; &lt;span class="k"&gt;of&lt;/span&gt; &lt;span class="s1"&gt;'"test"."t1"'&lt;/span&gt; &lt;span class="n"&gt;started&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Note&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Stopping&lt;/span&gt; &lt;span class="n"&gt;purge&lt;/span&gt;
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Note&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Writing&lt;/span&gt; &lt;span class="k"&gt;table&lt;/span&gt; &lt;span class="n"&gt;metadata&lt;/span&gt; &lt;span class="k"&gt;to&lt;/span&gt; &lt;span class="s1"&gt;'./test/t1.cfg'&lt;/span&gt;
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Note&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;Table&lt;/span&gt; &lt;span class="s1"&gt;'"test"."t1"'&lt;/span&gt; &lt;span class="n"&gt;flushed&lt;/span&gt; &lt;span class="k"&gt;to&lt;/span&gt; &lt;span class="n"&gt;disk&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;复制数据：&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt; &lt;span class="n"&gt;shell&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;scp&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="k"&gt;to&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;datadir&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="n"&gt;ibd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;cfg&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt; &lt;span class="n"&gt;destination&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="k"&gt;to&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;datadir&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;      &lt;/li&gt;
      &lt;li&gt;在 source server 上执行 unlock tables
        &lt;ul&gt;
          &lt;li&gt;删除 .cfg 文件&lt;/li&gt;
          &lt;li&gt;table上的S锁 被释放&lt;/li&gt;
          &lt;li&gt;purge thread 被重启&lt;/li&gt;
        &lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt;  &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;USE&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;UNLOCK&lt;/span&gt; &lt;span class="n"&gt;TABLES&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="err"&gt;可能的输出&lt;/span&gt;&lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="err"&gt;为&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Note&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Deleting&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;meta&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;data&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="s1"&gt;'./test/t1.cfg'&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Note&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Resuming&lt;/span&gt; &lt;span class="n"&gt;purge&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
      &lt;li&gt;在 destination server 上import tablespace
        &lt;ul&gt;
          &lt;li&gt;每个 tablespace page 会被 校验是否正确&lt;/li&gt;
          &lt;li&gt;The space ID and log sequence numbers (LSNs) on each page are updated.&lt;/li&gt;
          &lt;li&gt;Flags are validated and LSN updated for the header page.&lt;/li&gt;
          &lt;li&gt;Btree pages are updated.&lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;The page state is set to dirty so that it is written to disk.&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt; &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;USE&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;ALTER&lt;/span&gt; &lt;span class="k"&gt;TABLE&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="n"&gt;IMPORT&lt;/span&gt; &lt;span class="n"&gt;TABLESPACE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

 &lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="err"&gt;可能输出&lt;/span&gt; &lt;span class="n"&gt;log&lt;/span&gt; &lt;span class="err"&gt;为：&lt;/span&gt;

 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Note&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Importing&lt;/span&gt; &lt;span class="n"&gt;tablespace&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="k"&gt;table&lt;/span&gt; &lt;span class="s1"&gt;'test/t1'&lt;/span&gt; &lt;span class="n"&gt;that&lt;/span&gt; &lt;span class="n"&gt;was&lt;/span&gt; &lt;span class="n"&gt;exported&lt;/span&gt;
 &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="k"&gt;host&lt;/span&gt; &lt;span class="s1"&gt;'host_name'&lt;/span&gt;
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Note&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Phase&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="k"&gt;Update&lt;/span&gt; &lt;span class="k"&gt;all&lt;/span&gt; &lt;span class="n"&gt;pages&lt;/span&gt;
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Note&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Sync&lt;/span&gt; &lt;span class="k"&gt;to&lt;/span&gt; &lt;span class="n"&gt;disk&lt;/span&gt;
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Note&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Sync&lt;/span&gt; &lt;span class="k"&gt;to&lt;/span&gt; &lt;span class="n"&gt;disk&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;done&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Note&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Phase&lt;/span&gt; &lt;span class="n"&gt;III&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;Flush&lt;/span&gt; &lt;span class="n"&gt;changes&lt;/span&gt; &lt;span class="k"&gt;to&lt;/span&gt; &lt;span class="n"&gt;disk&lt;/span&gt;
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Note&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Phase&lt;/span&gt; &lt;span class="n"&gt;IV&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;Flush&lt;/span&gt; &lt;span class="n"&gt;complete&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="auto_increment-在innodb-中的处理方式"&gt;AUTO_INCREMENT 在InnoDB 中的处理方式&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在表中 添加 AUTO_INCREMENT 字段， 是InnoDB 提高性能 与 稳定性的一种方式， 为了有效利用 AUTO_INCREMENT ， 必须将 AUTO_INCREMENT 字段设为索引， 以便 执行 select max(col) 以获得 最大值，&lt;/li&gt;
  &lt;li&gt;AUTO_INCREMENT 锁的 集中方式，其中的区别 以及 每种对 replic 的影响&lt;/li&gt;
  &lt;li&gt;数据插入的集中方式： 所有生成 新row的 语句， 包括 insert, insert .. select, replace, replace .. select, load data 包含
    &lt;ol&gt;
      &lt;li&gt;simple-insert: 可以预先知道 插入 行数 的 insert 语句，比如简单的单行， 多行 insert&lt;/li&gt;
      &lt;li&gt;bulk-insert: 插入行数未知  的语句，比如： insert .. select ,replace .. select, load data 语句&lt;/li&gt;
      &lt;li&gt;mixed-mode insert: 指定 auto_increment 数值的 insert 语句 或者  INSERT … ON DUPLICATE KEY UPDATE 等复杂的 语句，这些语句可能不会使用 auto_increment 分配的数值 比如：&lt;/li&gt;
    &lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt;   &lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'a'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'b'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'c'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'d'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
  &lt;li&gt;innodb_autoinc_lock_mode 可能的模式有： 0 (traditional), 1(consecutive), 2(interleaved) Mysql 8.0 默认为 interleaved 模式， 8.0 之前 默认为 consecutive 模式
    &lt;h5 id="lock-mode-的变化-反映了-mysql-从--基于语句-replica-转变到-基于-row-replica-的转变-基于语句复制-需要-一个-consecutive-的lock-mode--来确保-auto-increment-数值的-可以预测-可重复-性-因为-在replic时候-同步的是-sql-执行语句只有这样才能够保证-replic与-master-server-的数据一致性-而基于-row-replica-对于-语句的执行顺序并不敏感"&gt;lock mode 的变化 反映了 Mysql 从  基于语句 replica 转变到 基于 row replica 的转变。 基于语句复制 需要 一个 consecutive 的lock mode  来确保 auto-increment 数值的 可以预测 可重复 性 （因为 在replic时候， 同步的是 sql 执行语句，只有这样才能够保证 replic与 master server 的数据一致性）， 而基于 row replica 对于 语句的执行顺序并不敏感&lt;/h5&gt;
    &lt;ol&gt;
      &lt;li&gt;traditional: 该种模式下， 所有的inert like 语句 斗殴需要获取 一个特殊的 table-level  auto-inc lock， 该锁 需要把持到 语句的结束（非 transaction 结束） 来 保证 auto-increment 数值 的可重复性 与 可预见性， 同时保证了  auto-increment 字段数值的 连续性。 假设在 基于 语句 的复制模式中， 这意味着 sql语句 replic 到 replica server上的时候，将产生 与 source server上 完全相同的数值。 如果 让 多个 insert 语句 交替执行，则将导致 结果 不可重现， 即 replica server 与 source server数据 并不相同。 下面示例：&lt;/li&gt;
    &lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt;  &lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;TABLE&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;c1&lt;/span&gt; &lt;span class="nb"&gt;INT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;11&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;NOT&lt;/span&gt; &lt;span class="k"&gt;NULL&lt;/span&gt; &lt;span class="n"&gt;AUTO_INCREMENT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;c2&lt;/span&gt; &lt;span class="nb"&gt;VARCHAR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;DEFAULT&lt;/span&gt; &lt;span class="k"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="k"&gt;PRIMARY&lt;/span&gt; &lt;span class="k"&gt;KEY&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;ENGINE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="c1"&gt;----------&lt;/span&gt;
  &lt;span class="n"&gt;Tx1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt; &lt;span class="k"&gt;rows&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;another&lt;/span&gt; &lt;span class="k"&gt;table&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;
  &lt;span class="n"&gt;Tx2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'xxx'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;


  &lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt; &lt;span class="err"&gt;并不能知道&lt;/span&gt; &lt;span class="n"&gt;Tx1&lt;/span&gt; &lt;span class="err"&gt;中到底有多少数据&lt;/span&gt; &lt;span class="err"&gt;需要插入，&lt;/span&gt; &lt;span class="err"&gt;使用&lt;/span&gt; &lt;span class="err"&gt;一个&lt;/span&gt; &lt;span class="k"&gt;table&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;level&lt;/span&gt; &lt;span class="err"&gt;的&lt;/span&gt;&lt;span class="k"&gt;lock&lt;/span&gt; &lt;span class="err"&gt;，可以&lt;/span&gt; &lt;span class="err"&gt;使&lt;/span&gt; &lt;span class="err"&gt;在同一时间&lt;/span&gt; &lt;span class="err"&gt;只执行&lt;/span&gt; &lt;span class="err"&gt;一个&lt;/span&gt; &lt;span class="k"&gt;sql&lt;/span&gt; &lt;span class="err"&gt;语句。&lt;/span&gt; &lt;span class="err"&gt;所以&lt;/span&gt; &lt;span class="err"&gt;当在&lt;/span&gt; &lt;span class="n"&gt;replica&lt;/span&gt; &lt;span class="n"&gt;server&lt;/span&gt; &lt;span class="err"&gt;上&lt;/span&gt; &lt;span class="err"&gt;使用&lt;/span&gt; &lt;span class="err"&gt;基于&lt;/span&gt;  &lt;span class="nb"&gt;binary&lt;/span&gt; &lt;span class="n"&gt;log&lt;/span&gt; &lt;span class="err"&gt;重放&lt;/span&gt; &lt;span class="k"&gt;sql&lt;/span&gt; &lt;span class="err"&gt;语句时候，无论是&lt;/span&gt;&lt;span class="n"&gt;Tx1&lt;/span&gt; &lt;span class="err"&gt;与&lt;/span&gt; &lt;span class="n"&gt;Tx2&lt;/span&gt; &lt;span class="err"&gt;谁先执行，&lt;/span&gt; &lt;span class="err"&gt;都会产生相同的结果。当然&lt;/span&gt; &lt;span class="err"&gt;一个&lt;/span&gt;&lt;span class="k"&gt;table&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;level&lt;/span&gt;&lt;span class="err"&gt;的&lt;/span&gt;&lt;span class="k"&gt;lock&lt;/span&gt; &lt;span class="err"&gt;必然会限制&lt;/span&gt; &lt;span class="err"&gt;并发&lt;/span&gt; &lt;span class="err"&gt;与&lt;/span&gt; &lt;span class="err"&gt;可伸缩性&lt;/span&gt; &lt;span class="err"&gt;的发挥&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;consecutive mode: 在该种模式下，
    &lt;ul&gt;
      &lt;li&gt;“bulk inserts” 使用特殊的 AUTO-INC table level lock 并一直把持到 语句的最后。该类规则将 应用到 所有 的 insert ..select, replace .. select, load data 的语句中，同一时间 只有 一个把持 AUTO-INC 的语句 能够执行，&lt;/li&gt;
      &lt;li&gt;“simple inserts”: 因为可以预先知道插入的数量， 可以使用 特殊的 轻量级 X锁（只在auto-increment 分配阶段 保持），来避免  table-level AUTO-INC 锁。如果存在 其他的 transaction 持有 table-level 的 AUTO-INC lock 则 需要等待 该 transaction 完成&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;”mixed-mode inserts“: 分配的数值增量 要大于 插入的行数， 自动分配的数值 也是连续的。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;简单的说， consecutive lock mode 下， 在 保证 基于语句的 replic 正确下，提高了 并发与可伸缩性， 完美兼容 tranditional mode&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;interleaved mode: 不使用 table-level auto-inc lock， 而且可以同时执行多个insert 语句， 是最快的，可伸缩 的 lock 模式， 但是对于 基于语句 复制的 server来说 并不安全。 在这种锁定模式下，保证auto-increment column 是唯一的，并且在所有同时执行的“类似INSERT”语句中单调递增。 但是，由于多个语句可以同时生成数字（也就是说，在语句之间交错分配数字），因此为任何给定语句插入的行生成的值可能不是连续的。即： 在 simple insert 语句中， auto-increment 中的column是连续的， mixed-mode insert 与 bulk insert 中 可能存在 gap&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;auto-increment gap: 自动增量间隙
    &lt;ul&gt;
      &lt;li&gt;在所有的lock mode下： 如果事务发生回滚，则分配给该 transaction 的数值 就丢失了，该值 将不会被重用，因为表中的 auto-increment column 数值 可能存在 gap&lt;/li&gt;
      &lt;li&gt;批量插入： 在 traditional 或者 consecutive 模式下 任何插入 都不会产生 gap，因为批量插入 都需要获得 table-level 的 auto-inr lock 并保持到 活动结束。 在 interleaved 下，”bulk-insert” 可能产生gap。在 consecutive 或者 interleaved 模式下， 在连续的语句之间可能会出现gap，因为对于批量插入，可能不知道每个语句所需的自动递增值的确切数量，并且可能会高估。( 这里面 是不是描述有问题？ 因为已经在前面说了， tranditional or consecutive 模式下 批量插入并不会产生gap， 这里又说会有， 为什么？ &lt;a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html"&gt;文档在此&lt;/a&gt;)&lt;/li&gt;
      &lt;li&gt;mixed mode insert 在各种不同mode下产生的结果： 最近产生的sequence number  is 100：&lt;/li&gt;
    &lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt;    &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;TABLE&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;c1&lt;/span&gt; &lt;span class="nb"&gt;INT&lt;/span&gt; &lt;span class="nb"&gt;UNSIGNED&lt;/span&gt; &lt;span class="k"&gt;NOT&lt;/span&gt; &lt;span class="k"&gt;NULL&lt;/span&gt; &lt;span class="n"&gt;AUTO_INCREMENT&lt;/span&gt; &lt;span class="k"&gt;PRIMARY&lt;/span&gt; &lt;span class="k"&gt;KEY&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
    &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt; &lt;span class="nb"&gt;CHAR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;ENGINE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;INNODB&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

    &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'a'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'b'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'c'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'d'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="k"&gt;lock&lt;/span&gt; &lt;span class="k"&gt;mode&lt;/span&gt; &lt;span class="err"&gt;为&lt;/span&gt; &lt;span class="n"&gt;traditional&lt;/span&gt; &lt;span class="err"&gt;时候，&lt;/span&gt; &lt;span class="err"&gt;执行插入操作&lt;/span&gt;
    &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt; &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="k"&gt;ORDER&lt;/span&gt; &lt;span class="k"&gt;BY&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
     &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="c1"&gt;-----+------+&lt;/span&gt;
     &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;c1&lt;/span&gt;  &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt;   &lt;span class="o"&gt;|&lt;/span&gt;
     &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="c1"&gt;-----+------+&lt;/span&gt;
     &lt;span class="o"&gt;|&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
     &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;101&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
     &lt;span class="o"&gt;|&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="k"&gt;c&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
     &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;102&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
     &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="c1"&gt;-----+------+&lt;/span&gt;

    &lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="k"&gt;lock&lt;/span&gt; &lt;span class="k"&gt;mode&lt;/span&gt; &lt;span class="err"&gt;为&lt;/span&gt; &lt;span class="n"&gt;consecutive&lt;/span&gt; &lt;span class="err"&gt;时候，&lt;/span&gt; &lt;span class="err"&gt;执行插入操作&lt;/span&gt;   

        &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt; &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="k"&gt;ORDER&lt;/span&gt; &lt;span class="k"&gt;BY&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="c1"&gt;-----+------+&lt;/span&gt;
    &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;c1&lt;/span&gt;  &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt;   &lt;span class="o"&gt;|&lt;/span&gt;
    &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="c1"&gt;-----+------+&lt;/span&gt;
    &lt;span class="o"&gt;|&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
    &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;101&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
    &lt;span class="o"&gt;|&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="k"&gt;c&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
    &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;102&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
    &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="c1"&gt;-----+------+&lt;/span&gt;


    &lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="k"&gt;lock&lt;/span&gt; &lt;span class="k"&gt;mode&lt;/span&gt; &lt;span class="err"&gt;为&lt;/span&gt; &lt;span class="n"&gt;interleaved&lt;/span&gt; &lt;span class="err"&gt;时候，&lt;/span&gt; &lt;span class="err"&gt;执行插入操作&lt;/span&gt; 

     &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt; &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="k"&gt;ORDER&lt;/span&gt; &lt;span class="k"&gt;BY&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
     &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="c1"&gt;-----+------+&lt;/span&gt;
     &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;c1&lt;/span&gt;  &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt;   &lt;span class="o"&gt;|&lt;/span&gt;
     &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="c1"&gt;-----+------+&lt;/span&gt;
     &lt;span class="o"&gt;|&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
     &lt;span class="o"&gt;|&lt;/span&gt;   &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
     &lt;span class="o"&gt;|&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="k"&gt;c&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
     &lt;span class="o"&gt;|&lt;/span&gt;   &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
     &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="c1"&gt;-----+------+    &lt;/span&gt;

     &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="err"&gt;代表&lt;/span&gt; &lt;span class="err"&gt;唯一，但是并不能够确定的数值&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;InnoDB AUTO_INCREMENT Counter 的初始化：&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;mysql 5.7 auto-increment 的counter 存储在 main memory not disk， 所以 当server 重启，将执行  类似  SELECT MAX(ai_col) FROM table_name FOR UPDATE; 来 进行 counter 的初始化&lt;/li&gt;
  &lt;li&gt;MySQL 8.0 之后，行为发生了改变， 目前最大的 auto-increment counter 数值 被写入到了 redo log， server 重启直接从 disk 进行初始化counter&lt;/li&gt;
  &lt;li&gt;所以， 5.7 之后，如果transaction 发生rollback之后，重启server， 会出现rollback的 auto-increment id 被重复使用的问题，而 8.0 的server，则不会 重用 id， 因为 其将 counter 写入到了 disk中&lt;/li&gt;
  &lt;li&gt;auto_increment_increment 设定 auto-increment 的起始点， 默认为1， auto_increment_increment 设置 增量 默认为 1&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="index-没个-innodb-表-都有一个-特殊的index-称为-聚簇索引-用来保存-row-data-通常-聚簇索引-与-primary-key主键-同意-为了-请求获得-更好的性能-理解-innodb-如何使用-聚簇索引-来-进行优化-查询和-dml-操作-是非常重要-的"&gt;index: 没个 InnoDB 表， 都有一个 特殊的index 称为 聚簇索引， 用来保存 row data， 通常 聚簇索引 与 primary key(主键) 同意， 为了 请求获得 更好的性能， 理解 InnoDB 如何使用 聚簇索引 来 进行优化 查询，和 DML 操作 是非常重要 的&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;当你定义table 的Primary key时， InnoDB 用它作为聚簇索引， 如果没有 逻辑上的 唯一 非空 作为主键的情况下， 可以添加一个 auto-increment column 作为 主键&lt;/li&gt;
  &lt;li&gt;如果没有为 table 设定 Primary key（ 主键） 时， InnoDB 使用第一个 Unique &amp;amp; 所有column not null 的index 作为聚簇索引&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果table 没有 Primary key 和 合适的Unique index， 则 InnoDB 生成一个隐藏的名称为 GEN_CLUST_INDEX 的聚簇索引， 该字段为 6-byte 的单调递增&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;聚簇索引 如何 加快查询：
    &lt;blockquote&gt;
      &lt;p&gt;Accessing a row through the clustered index is fast because the index search leads directly to the page that contains the row data. If a table is large, the clustered index architecture often saves a disk I/O operation when compared to storage organizations that store row data using a different page from the index record.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;二级索引 是如何关联到 聚簇索引的： 二级索引定义为： 除 聚簇索引之外的索引&lt;/li&gt;
  &lt;li&gt;二级索引的每个条目（记录） 中 都包含 主键 + 二级索引 包含的column，InnoDB 使用 包含的主键 来 在聚簇索引中进行查找&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;所以 如果聚簇索引 很大的话，将加大 二级索引 的空间占用&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;InnoDB index 的物理结构：&lt;/li&gt;
  &lt;li&gt;InnoDB 所以为B-tree， 索引记录 存储在 B-tree 的 页子 page 中， 默认的 index page 大小为 16KB， 可以通过   innodb_page_size  进行设定&lt;/li&gt;
  &lt;li&gt;当插入 新纪录 到 聚簇索引时， InnoDB 尝试留下  1/16 的 空间 来满足 未来的insert update。 如果数据时按照 顺序插入的，则 index page 将占用 15/16 空间， 如果数据按照 random 顺序插入的，则可能 占用 1/2 - 15/16， innodb_fill_factor  用来控制 空间占用百分比&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果InnoDB 索引页的占用率下降到 MERGE_THRESHOLD(默认为50%) 时， InnoDB 将尝试 收缩索引 以 释放页面&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href="https://dev.mysql.com/doc/refman/8.0/en/sorted-index-builds.html"&gt;Sorted index builde&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="the-system-tablespace"&gt;The System Tablespace:&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;change buffer 在 disk 上存储到 system tablespace, 如果在system tablespace 而非 file-per-table 或者 general tablespace 则 其中还包含 table 和 index data的数据。 8.0之前 还存储 doublewrite buffer， innodb data dictionary， 8.0之后 则分开存储&lt;/li&gt;
  &lt;li&gt;system tablespace 可以有多个 data 文件， 默认的 一个 ibddata1 在 data directory中，&lt;/li&gt;
  &lt;li&gt;tablespace 的数量 与 大小 在 启动项 innodb_data_file_path  进行设定&lt;/li&gt;
  &lt;li&gt;可以进行调整，&lt;a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-system-tablespace.html"&gt;文档在此&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="file-per-table-tablespace-包含-table中的-data-和-index存储在系统中-单个文件中"&gt;File-Per-Table Tablespace: 包含 table中的 data 和 index，存储在系统中 单个文件中&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;innodb_file_per_table 控制开关， 默认为 打开状态。关闭将导致 InnoDB 存储table 数据到 system tablespace 中&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;file-per-table tablespace 在mysql 的 data directory(DATA DIRECTORY 可以在create table syntax 中指定) 目录下 存储 table_name.idb ，下面为示例：&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt;&lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;USE&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;TABLE&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
   &lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="nb"&gt;INT&lt;/span&gt; &lt;span class="k"&gt;PRIMARY&lt;/span&gt; &lt;span class="k"&gt;KEY&lt;/span&gt; &lt;span class="n"&gt;AUTO_INCREMENT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
   &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="nb"&gt;VARCHAR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;ENGINE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;shell&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="k"&gt;to&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="k"&gt;data&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;
&lt;span class="n"&gt;shell&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;ls&lt;/span&gt;
&lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ibd&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/li&gt;
  &lt;li&gt;File-per-table 的优势：
    &lt;ol&gt;
      &lt;li&gt;当 发生drop file， table_name.idb 直接被删掉， 存储空间 可以快速的归还给操作系统&lt;/li&gt;
      &lt;li&gt;Truncate table 表现的比较好&lt;/li&gt;
      &lt;li&gt;可以将 data directory 指定到 单独的设备上&lt;/li&gt;
      &lt;li&gt;创建在 改 tablespace 的table， 支持 dynamic compressed 存储格式(System tablespace 不支持)&lt;/li&gt;
      &lt;li&gt;比较容易恢复和 备份&lt;/li&gt;
      &lt;li&gt;允许单独监控 操作系统的 文件系统&lt;/li&gt;
      &lt;li&gt;减少空间限制&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="general-tablespace-通用-tablespace"&gt;General Tablespace： 通用 Tablespace&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;使用create  tablespace 创建的 共享的 tablespace, 其属性 是 file-per-tablespace 与 system tablespace 的结合。 可以 像 file-per-table tablespace 一样 指定目录存储 general tablespace， 想system tablespace 一样 存储多个 table 在一个文件中， 并可以支持 所有的存储类型。&lt;/li&gt;
  &lt;li&gt;下面是 使用 General Tablespace 的方法：&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;创建&lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt;&lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="n"&gt;TABLESPACE&lt;/span&gt; &lt;span class="n"&gt;tablespace_name&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;ADD&lt;/span&gt; &lt;span class="n"&gt;DATAFILE&lt;/span&gt; &lt;span class="s1"&gt;'file_name'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;FILE_BLOCK_SIZE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ENGINE&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;engine_name&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  

&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="err"&gt;可以&lt;/span&gt; &lt;span class="err"&gt;使用&lt;/span&gt; &lt;span class="err"&gt;变量&lt;/span&gt; &lt;span class="n"&gt;innodb_directories&lt;/span&gt;  &lt;span class="err"&gt;控制&lt;/span&gt; &lt;span class="k"&gt;general&lt;/span&gt; &lt;span class="n"&gt;tablespace&lt;/span&gt; &lt;span class="err"&gt;的存储目录，&lt;/span&gt; 
&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="n"&gt;ts1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;idb&lt;/span&gt; &lt;span class="err"&gt;为相对&lt;/span&gt; &lt;span class="n"&gt;innodb_directories&lt;/span&gt; &lt;span class="err"&gt;目录&lt;/span&gt;
&lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="n"&gt;TABLESPACE&lt;/span&gt; &lt;span class="nv"&gt;`ts1`&lt;/span&gt; &lt;span class="k"&gt;ADD&lt;/span&gt; &lt;span class="n"&gt;DATAFILE&lt;/span&gt; &lt;span class="s1"&gt;'ts1.ibd'&lt;/span&gt; &lt;span class="n"&gt;Engine&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="err"&gt;也可以执行全路径&lt;/span&gt;
&lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="n"&gt;TABLESPACE&lt;/span&gt; &lt;span class="nv"&gt;`ts1`&lt;/span&gt; &lt;span class="k"&gt;ADD&lt;/span&gt; &lt;span class="n"&gt;DATAFILE&lt;/span&gt; &lt;span class="s1"&gt;'/my/tablespace/directory/ts1.ibd'&lt;/span&gt; &lt;span class="n"&gt;Engine&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;使用： 添加table 到 general tablespace:&lt;br /&gt;
  ```sql&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;mysql&amp;gt; CREATE TABLE t1 (c1 INT PRIMARY KEY) TABLESPACE ts1;&lt;br /&gt;
  mysql&amp;gt; ALTER TABLE t2 TABLESPACE ts1;&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;  
   * 使用alter table 可以将table 的tablespace 在各个 tablespace 中进行转换： general tablespace为具体的create tablespace 的名字， file-per-table名称为 innodb_file_per_table， system tablespace 为innodb_system； 如下： 
   
   ```sql
   
   
   ALTER TABLE tbl_name TABLESPACE [=] tablespace_name;
   
   ALTER TABLE tbl_name TABLESPACE [=] innodb_system;
   
   ALTER TABLE tbl_name TABLESPACE [=] innodb_file_per_table;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;重命名tablespace： ALTER TABLESPACE s1 RENAME TO s2;， 重命名操作不能发生在 lock tables， flush tables 作用期间&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;删掉 tablespace： 在tablespace中的所有table 都必须删除掉，才能够成功的 drop tablespace&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt;   
    &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="n"&gt;Use&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;query&lt;/span&gt; &lt;span class="k"&gt;similar&lt;/span&gt; &lt;span class="k"&gt;to&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;following&lt;/span&gt; &lt;span class="k"&gt;to&lt;/span&gt; &lt;span class="n"&gt;identify&lt;/span&gt; &lt;span class="n"&gt;tables&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;general&lt;/span&gt; &lt;span class="n"&gt;tablespace&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; 
     &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NAME&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="n"&gt;space_name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NAME&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="k"&gt;table_name&lt;/span&gt; &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;INFORMATION_SCHEMA&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;INNODB_TABLESPACES&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
          &lt;span class="n"&gt;INFORMATION_SCHEMA&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;INNODB_TABLES&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;SPACE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;SPACE&lt;/span&gt; &lt;span class="k"&gt;AND&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NAME&lt;/span&gt; &lt;span class="k"&gt;LIKE&lt;/span&gt; &lt;span class="s1"&gt;'ts1'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="c1"&gt;------------+------------+&lt;/span&gt;
   &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;space_name&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="k"&gt;table_name&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
   &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="c1"&gt;------------+------------+&lt;/span&gt;
   &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ts1&lt;/span&gt;        &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;t1&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
   &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ts1&lt;/span&gt;        &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;t2&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
   &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ts1&lt;/span&gt;        &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;t3&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
   &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="c1"&gt;------------+------------+&lt;/span&gt;

   &lt;span class="k"&gt;DROP&lt;/span&gt; &lt;span class="n"&gt;TABLESPACE&lt;/span&gt; &lt;span class="n"&gt;ts1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href="https://dev.mysql.com/doc/refman/8.0/en/general-tablespaces.html"&gt;文档在此&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Undo tablespace: 用于保存undo log 的地方， undo log 产生于 insert, update, delete, 等DML 操作， 用于 事务回滚， consistent reading 等&lt;/li&gt;
  &lt;li&gt;默认的undo tablespace 存储在 mysql data dir 中， 可以使用 innodb_undo_directory  进行控制， 默认的 tablespace 文件为  undo_001 , undo_002， 对应的 tablespace名称 为 innodb_undo_001, innodb_undo_002&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-undo-tablespaces.html"&gt;文档在此&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;undo tablespace 作为一个系统使用的tablespace 一样可以允许创建，删除， 但是与 应系统性能表现相关， 比较重要&lt;/li&gt;
&lt;/ul&gt;

</content>
  </entry>
  <entry>
    <title>Redis Client conection</title>
    <link rel="alternate" href="http://geniousbar.github.io/2021/02/21/redis/"/>
    <id>http://geniousbar.github.io/2021/02/21/redis/</id>
    <published>2021-02-21T00:00:00+00:00</published>
    <updated>2021-04-20T08:07:49+00:00</updated>
    <summary type="html">&lt;h2 id="redis-建立链接过程"&gt;Redis 建立链接过程&lt;/h2&gt;
&lt;p&gt;&lt;img src="../../../../images/redis-a3bef2b1.png" alt="redis" /&gt;&lt;/p&gt;
</summary>
    <content type="html">&lt;h2 id="redis-建立链接过程"&gt;Redis 建立链接过程&lt;/h2&gt;
&lt;p&gt;&lt;img src="../../../../images/redis-a3bef2b1.png" alt="redis" /&gt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Rust little book</title>
    <link rel="alternate" href="http://geniousbar.github.io/2021/02/20/rust-little-book/"/>
    <id>http://geniousbar.github.io/2021/02/20/rust-little-book/</id>
    <published>2021-02-20T00:00:00+00:00</published>
    <updated>2021-04-20T04:02:05+00:00</updated>
    <summary type="html">&lt;h2 id="rust-little-book"&gt;Rust little book&lt;/h2&gt;

&lt;h3 id="rustup--rust-complier-的管理工具-可以方便的切换-stable-beta-and-nightly"&gt;rustup:  rust complier 的管理工具， 可以方便的切换 stable, beta, and nightly&lt;/h3&gt;
&lt;h3 id="cargo-是rust的包管理工具-用来-下载-rust的依赖-编译-以及-分发-到-cratesio"&gt;cargo 是rust的包管理工具， 用来 下载 rust的依赖， 编译， 以及 分发 到 crates.io&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;在安装 rust 之后， cargo 也会被自动安装上&lt;/li&gt;
  &lt;li&gt;cargo 提供了一些有用的工具有:
    &lt;ol&gt;
      &lt;li&gt;cargo new package # default –bin 生成 可执行 program...&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    <content type="html">&lt;h2 id="rust-little-book"&gt;Rust little book&lt;/h2&gt;

&lt;h3 id="rustup--rust-complier-的管理工具-可以方便的切换-stable-beta-and-nightly"&gt;rustup:  rust complier 的管理工具， 可以方便的切换 stable, beta, and nightly&lt;/h3&gt;
&lt;h3 id="cargo-是rust的包管理工具-用来-下载-rust的依赖-编译-以及-分发-到-cratesio"&gt;cargo 是rust的包管理工具， 用来 下载 rust的依赖， 编译， 以及 分发 到 crates.io&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;在安装 rust 之后， cargo 也会被自动安装上&lt;/li&gt;
  &lt;li&gt;cargo 提供了一些有用的工具有:
    &lt;ol&gt;
      &lt;li&gt;cargo new package # default –bin 生成 可执行 program, 可以传递 –lib 来产生库程序&lt;/li&gt;
      &lt;li&gt;cargo build&lt;/li&gt;
      &lt;li&gt;cargo 存在的意义：
        &lt;ul&gt;
          &lt;li&gt;剥离 rustc 的复杂度， 类似 make 与 c 一样&lt;/li&gt;
          &lt;li&gt;cargo 最终调用rustc 来编译 项目， 当然可以 直接使用 rustc 来编译项目，但是 需要出入 复杂的参数 来 添加项目 依赖关系， 编译文件， 依赖关系 等，并精心安排顺序 来进行调用。&lt;/li&gt;
          &lt;li&gt;所以使用cargo： make工具， cargo 的功能
            &lt;ol&gt;
              &lt;li&gt;使用两个文件 来 包含 package的信息&lt;/li&gt;
              &lt;li&gt;拉取，构建  package 依赖&lt;/li&gt;
              &lt;li&gt;使用正确的参数 来调用rustc 或者其他 tool， 来构建项目&lt;/li&gt;
              &lt;li&gt;引用约定，方便package 构建&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="cargo-使用笔记"&gt;cargo 使用笔记：&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;cargo new hello_world –bin&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;cd &lt;/span&gt;hello_world
&lt;span class="nv"&gt;$ &lt;/span&gt;tree &lt;span class="nb"&gt;.&lt;/span&gt;
&lt;span class="nb"&gt;.&lt;/span&gt;
├── Cargo.toml
└── src
    └── main.rs

1 directory, 2 files
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;其中 Cargo.toml 被称为 manifest,包含package的元数据&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;fn main&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    println!&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Hello, world!"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;


&lt;span class="nv"&gt;$ &lt;/span&gt;cargo build
   Compiling hello_world v0.1.0 &lt;span class="o"&gt;(&lt;/span&gt;file:///path/to/package/hello_world&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="nv"&gt;$ &lt;/span&gt;./target/debug/hello_world
Hello, world!


&lt;span class="nv"&gt;$ &lt;/span&gt;cargo run
   Compiling hello_world v0.1.0 &lt;span class="o"&gt;(&lt;/span&gt;file:///path/to/package/hello_world&lt;span class="o"&gt;)&lt;/span&gt;
     Running &lt;span class="sb"&gt;`&lt;/span&gt;target/debug/hello_world&lt;span class="sb"&gt;`&lt;/span&gt;
Hello, world!



&lt;span class="nv"&gt;$ &lt;/span&gt;cargo build &lt;span class="nt"&gt;--release&lt;/span&gt;
   Compiling hello_world v0.1.0 &lt;span class="o"&gt;(&lt;/span&gt;file:///path/to/package/hello_world&lt;span class="o"&gt;)&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;cargo build  将会 构建 package&lt;/li&gt;
  &lt;li&gt;cargo run 则 构建并运行它&lt;/li&gt;
  &lt;li&gt;cargo build –release 将 构建 优化的代码&lt;/li&gt;
  &lt;li&gt;cargo 默认的构建 代码优化级别 为 debug, 存在的目录为 target/debug, 构建 优化后的代码需要 显式传递 参数 –release 生成的文件目录为 target/release&lt;/li&gt;
  &lt;li&gt;Dependencies：
    &lt;ul&gt;
      &lt;li&gt;crate.io 为 rust 中间的 package 机构， 用于发现 下载 更新package&lt;/li&gt;
      &lt;li&gt;添加依赖关系： 在 Cargo.toml 中 的dependencies 下，添加项目&lt;/li&gt;
    &lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="o"&gt;[&lt;/span&gt;package]
name &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"hello_world"&lt;/span&gt;
version &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"0.1.0"&lt;/span&gt;
authors &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"Your Name &amp;lt;you@example.com&amp;gt;"&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
edition &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"2018"&lt;/span&gt;

&lt;span class="o"&gt;[&lt;/span&gt;dependencies]
&lt;span class="nb"&gt;time&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"0.1.12"&lt;/span&gt;
regex &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"0.1.41"&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;之后的 cargo build 过程&lt;/li&gt;
    &lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;cargo build
      Updating crates.io index
   Downloading memchr v0.1.5
   Downloading libc v0.1.10
   Downloading regex-syntax v0.2.1
   Downloading memchr v0.1.5
   Downloading aho-corasick v0.3.0
   Downloading regex v0.1.41
     Compiling memchr v0.1.5
     Compiling libc v0.1.10
     Compiling regex-syntax v0.2.1
     Compiling memchr v0.1.5
     Compiling aho-corasick v0.3.0
     Compiling regex v0.1.41
     Compiling hello_world v0.1.0 &lt;span class="o"&gt;(&lt;/span&gt;file:///path/to/package/hello_world&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="package-构成"&gt;package 构成：&lt;/h4&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;  &lt;span class="nb"&gt;.&lt;/span&gt;
  ├── Cargo.lock
  ├── Cargo.toml
  ├── src/
  │   ├── lib.rs
  │   ├── main.rs
  │   └── bin/
  │       ├── named-executable.rs
  │       ├── another-executable.rs
  │       └── multi-file-executable/
  │           ├── main.rs
  │           └── some_module.rs
  ├── benches/
  │   ├── large-input.rs
  │   └── multi-file-bench/
  │       ├── main.rs
  │       └── bench_module.rs
  ├── examples/
  │   ├── simple.rs
  │   └── multi-file-example/
  │       ├── main.rs
  │       └── ex_module.rs
  └── tests/
      ├── some-integration-tests.rs
      └── multi-file-test/
          ├── main.rs
          └── test_module.rs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;Cargo.toml and Cargo.lock 在项目的根目录&lt;/li&gt;
  &lt;li&gt;src 下 为源代码&lt;/li&gt;
  &lt;li&gt;默认的 library file 为 src/lib.rs&lt;/li&gt;
  &lt;li&gt;默认的 executable file 是 src/main.rc, 其他的 放在 src/bin/&lt;/li&gt;
  &lt;li&gt;基准测试 放在benches 目录下&lt;/li&gt;
  &lt;li&gt;示例代码放在examples 目录下&lt;/li&gt;
  &lt;li&gt;集成测试 放在 tests 目录下&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;其他详细的需要参看 [[https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html]]&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Cargo.toml 与 Cargo.lock: 两种目的，
    &lt;ul&gt;
      &lt;li&gt;cargo.toml 描述 大概的依赖关系 并不准确，是由 人来确定的&lt;/li&gt;
      &lt;li&gt;Cargo.lock 包含准确的依赖关系， 由cargo 来维护&lt;/li&gt;
      &lt;li&gt;[[https://doc.rust-lang.org/cargo/faq.html#why-do-binaries-have-cargolock-in-version-control-but-not-libraries]]&lt;/li&gt;
      &lt;li&gt;示例:&lt;/li&gt;
    &lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;Cargo.toml

&lt;span class="o"&gt;[&lt;/span&gt;package]
name &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"hello_world"&lt;/span&gt;
version &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"0.1.0"&lt;/span&gt;
authors &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"Your Name &amp;lt;you@example.com&amp;gt;"&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;

&lt;span class="o"&gt;[&lt;/span&gt;dependencies]
rand &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; git &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"https://github.com/rust-lang-nursery/rand.git"&lt;/span&gt;, rev &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"9f35b8e"&lt;/span&gt; &lt;span class="o"&gt;}&lt;/span&gt;


Cargo.lock


&lt;span class="o"&gt;[[&lt;/span&gt;package]]
name &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"hello_world"&lt;/span&gt;
version &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"0.1.0"&lt;/span&gt;
dependencies &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;
 &lt;span class="s2"&gt;"rand 0.1.0 (git+https://github.com/rust-lang-nursery/rand.git#9f35b8e439eeedd60b9414c58f389bdc6a3284f9)"&lt;/span&gt;,
&lt;span class="o"&gt;]&lt;/span&gt;

&lt;span class="o"&gt;[[&lt;/span&gt;package]]
name &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"rand"&lt;/span&gt;
version &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"0.1.0"&lt;/span&gt;
&lt;span class="nb"&gt;source&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"git+https://github.com/rust-lang-nursery/rand.git#9f35b8e439eeedd60b9414c58f389bdc6a3284f9"&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
  &lt;li&gt;Cargo.lock 中包含 依赖的确定的 version， 当其他人使用的时候， 他们将使用相同的 sha，即便我们并没有在Cargo.toml 中使用&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;cargo update 更新全部的依赖， cargo update -p rand 只更新依赖 rand&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Test:
    &lt;ul&gt;
      &lt;li&gt;cargo test 执行 package中的所有test， test主要有两种： 1) 在每个 src 目录中的文件， 2） tests/ 目录下的所有文件。 1）中的为单元测试， 2）则为 集成测试，&lt;/li&gt;
    &lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;cargo &lt;span class="nb"&gt;test
   &lt;/span&gt;Compiling rand v0.1.0 &lt;span class="o"&gt;(&lt;/span&gt;https://github.com/rust-lang-nursery/rand.git#9f35b8e&lt;span class="o"&gt;)&lt;/span&gt;
   Compiling hello_world v0.1.0 &lt;span class="o"&gt;(&lt;/span&gt;file:///path/to/package/hello_world&lt;span class="o"&gt;)&lt;/span&gt;
     Running target/test/hello_world-9c2b65bbb79eabce

running 0 tests

&lt;span class="nb"&gt;test &lt;/span&gt;result: ok. 0 passed&lt;span class="p"&gt;;&lt;/span&gt; 0 failed&lt;span class="p"&gt;;&lt;/span&gt; 0 ignored&lt;span class="p"&gt;;&lt;/span&gt; 0 measured&lt;span class="p"&gt;;&lt;/span&gt; 0 filtered out
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;ul&gt;
      &lt;li&gt;cargo test foo  可以单独执行 名字为foo的测试，&lt;/li&gt;
      &lt;li&gt;cargo test 其实还会执行 额外的测试，包含在 src中的部分 文档中的测试（并不重要，为补充部分）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Cargo Home： 当build package的时候， cargo 将下载的依赖package 存储到 Cargo home 下。当做cache 使用。
    &lt;ul&gt;
      &lt;li&gt;可以通过 改变 环境变量 CARGO_HOME 来改变 cargo home的值， 默认 为 $HOME/.cargo/&lt;/li&gt;
      &lt;li&gt;Cargo Home 目录下的 数据：
        &lt;ul&gt;
          &lt;li&gt;bin 目录： 可执行crate， 包括cargo install 或者 rustup 安装的&lt;/li&gt;
          &lt;li&gt;git/db: crate 依赖git 项目时， cargo clone 项目到 该目录下&lt;/li&gt;
          &lt;li&gt;git/checkouts： git/db 项目中的检出到该文件， 比如 依赖于特定的commit&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;registry： 项目依赖于 crate.io 中的crate 存放在该目录下
    &lt;ul&gt;
      &lt;li&gt;registry/index： crate 的原数据， 包括： version， dependencies 等&lt;/li&gt;
      &lt;li&gt;registry/cache： 下载的crate 储存到该目录下， 存储形式为 .crate 的gzip压缩文件&lt;/li&gt;
      &lt;li&gt;registry/src： cache 的解压形式 存放在 该文件中&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="指定-dependencies"&gt;指定 Dependencies：&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;依赖版本： 版本号各个位置数字的含义： [[https://semver.org/][SemVer compatible]] 与 link 中讲的同样， major.minor.patch&lt;/li&gt;
  &lt;li&gt;Caret requirements： 指定 可以使用 一个 major 版本号 不变的更新， 但是 0 是 一个特殊的数字，标识不与 任何 数字兼容。即是： 0.0.1， 与 0.1.x 不兼容&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;下面为兼容样例：&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;^1.2.3  :&lt;span class="o"&gt;=&lt;/span&gt;  &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;1.2.3, &amp;lt;2.0.0
^1.2    :&lt;span class="o"&gt;=&lt;/span&gt;  &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;1.2.0, &amp;lt;2.0.0
^1      :&lt;span class="o"&gt;=&lt;/span&gt;  &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;1.0.0, &amp;lt;2.0.0
^0.2.3  :&lt;span class="o"&gt;=&lt;/span&gt;  &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;0.2.3, &amp;lt;0.3.0
^0.2    :&lt;span class="o"&gt;=&lt;/span&gt;  &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;0.2.0, &amp;lt;0.3.0
^0.0.3  :&lt;span class="o"&gt;=&lt;/span&gt;  &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;0.0.3, &amp;lt;0.0.4
^0.0    :&lt;span class="o"&gt;=&lt;/span&gt;  &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;0.0.0, &amp;lt;0.1.0
^0      :&lt;span class="o"&gt;=&lt;/span&gt;  &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;0.0.0, &amp;lt;1.0.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/li&gt;
  &lt;li&gt;Tilde requirements:  分为以下情况:
    &lt;ul&gt;
      &lt;li&gt;有 major.minor.patch 或者  major.minor 只有patch version 的升级是允许的&lt;/li&gt;
      &lt;li&gt;有major情况下, minor patch verison的升级 是允许的&lt;/li&gt;
      &lt;li&gt;for example&lt;/li&gt;
    &lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;~1.2.3  :&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;1.2.3, &amp;lt;1.3.0
~1.2    :&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;1.2.0, &amp;lt;1.3.0
~1      :&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;1.0.0, &amp;lt;2.0.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
  &lt;li&gt;Wildcard requirements:
    &lt;ul&gt;
      &lt;li&gt;允许所在位置上的 任何版本&lt;/li&gt;
      &lt;li&gt;for example&lt;/li&gt;
    &lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="se"&gt;\*&lt;/span&gt;     :&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;0.0.0
1.&lt;span class="k"&gt;*&lt;/span&gt;   :&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;1.0.0, &amp;lt;2.0.0
1.2.&lt;span class="k"&gt;*&lt;/span&gt; :&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;1.2.0, &amp;lt;1.3.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="workspaces-workspace-下的一系列package-共享同样的cargolock-output-dir-等配置比如profile-workspace下的packages-被称为-workspace-members"&gt;Workspaces: workspace 下的一系列package 共享同样的Cargo.lock， output dir 等配置（比如profile）， workspace下的packages 被称为 workspace members&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;存在两种形式： 1） [package] 与 [workspace] 共存在 Cargo.toml 中 2） 只有 [workspace] 存在Cargo.toml 中， 被称作 Virtual manifest&lt;/li&gt;
  &lt;li&gt;主要作用：
    &lt;ol&gt;
      &lt;li&gt;共享Cargo.lock&lt;/li&gt;
      &lt;li&gt;共享output dir， Cargo.toml 中 [target]&lt;/li&gt;
      &lt;li&gt;[patch], [replace] and [profile.*] 等 在Cargo.toml 中的 段  只能识别在 workspace 中的 manifest，member package 中的被忽略&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;workspace section 中的配置&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="o"&gt;[&lt;/span&gt;workspace]
members &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"member1"&lt;/span&gt;, &lt;span class="s2"&gt;"path/to/member2"&lt;/span&gt;, &lt;span class="s2"&gt;"crates/*"&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
exclude &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"crates/foo"&lt;/span&gt;, &lt;span class="s2"&gt;"path/to/other"&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/li&gt;
  &lt;li&gt;members 为 成员package 列表， exclude 排除 member
    &lt;ul&gt;
      &lt;li&gt;workspace 寻找： Cargo 自动的 向上目录 寻找 含有 [workspace] 的Cargo.toml， 在 member中可以指定 package.workspace 来 直接指定 workspace 的位置， 来防止自动查找， 这个对于 没有在 workspace 目录下的member package 非常有用&lt;/li&gt;
      &lt;li&gt;member package： cargo command -p package 可以指定 package 来 执行命令， 如果没有指定 package， 则 选择当前所在目录的package， default-members = [“path/to/member2”, “path/to/member3/”] 可以指定默认的 操作的member package&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="rustup-从官方下载rustc-使能够随意的在-stable-beta-nightly-中切换-让-cross-compiling-编译变的简单"&gt;rustup： 从官方下载rustc， 使能够随意的在 stable, beta, nightly 中切换。 让 cross-compiling 编译变的简单&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;工作原理：  rustup 通过 ~/.cargo/bin 下的工具 来实现其功能， 比如 安装在~/.cargo/bin   下的  rustc cargo 等 只是一个 到真正执行工具的 代理，&lt;/li&gt;
  &lt;li&gt;rustup 提供了一个方便的机制来 控制 这些代理的行为， 比如 通过执行rustup default nightly 来切换 nightly 下的工具&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="概念"&gt;概念:&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;channel: rustc 按照 beta, night, stable 三个 channel 进行发布， channel 并没有什么用， 只是个概念而已。&lt;/li&gt;
  &lt;li&gt;toolchain： rustc and cargo 等相关工具。 因为能够控制rustc (即是channel概念下的实际应用)&lt;/li&gt;
  &lt;li&gt;target： rustc 可以为多个平台生成代码。 默认的 rustc 使用host(即本机) 作为target， 为了生成不同target的代码，我们需要 使用rustup target 来安装目标target&lt;/li&gt;
  &lt;li&gt;component: 每个rust版本的发布，都会包含一些 组件， 包括rustc， clippy 等&lt;/li&gt;
  &lt;li&gt;profile： 为了更好的与component 工作， profile 定义了 一组component，&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;toolchain：  rustup 不仅可以 安装stable, beta, nightly 三个channel， 还可以安装 其他的 官方 历史版本&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;channel 的命令规则:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&amp;lt;channel&amp;gt;[-&amp;lt;&lt;span class="nb"&gt;date&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;][&lt;/span&gt;-&amp;lt;host&amp;gt;]

&amp;lt;channel&amp;gt;       &lt;span class="o"&gt;=&lt;/span&gt; stable|beta|nightly|&amp;lt;major.minor&amp;gt;|&amp;lt;major.minor.patch&amp;gt;
&amp;lt;&lt;span class="nb"&gt;date&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;          &lt;span class="o"&gt;=&lt;/span&gt; YYYY-MM-DD
&amp;lt;host&amp;gt;          &lt;span class="o"&gt;=&lt;/span&gt; &amp;lt;target-triple&amp;gt;

&lt;span class="c"&gt;#+end_src&lt;/span&gt;
&lt;span class="k"&gt;**&lt;/span&gt; 其他命令： 保持 rust 更新： 
&lt;span class="c"&gt;#+begin_src &lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;rustup update
info: syncing channel updates &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="s1"&gt;'stable'&lt;/span&gt;
info: downloading component &lt;span class="s1"&gt;'rustc'&lt;/span&gt;
info: downloading component &lt;span class="s1"&gt;'rust-std'&lt;/span&gt;
info: downloading component &lt;span class="s1"&gt;'rust-docs'&lt;/span&gt;
info: downloading component &lt;span class="s1"&gt;'cargo'&lt;/span&gt;
info: installing component &lt;span class="s1"&gt;'rustc'&lt;/span&gt;
info: installing component &lt;span class="s1"&gt;'rust-std'&lt;/span&gt;
info: installing component &lt;span class="s1"&gt;'rust-docs'&lt;/span&gt;
info: installing component &lt;span class="s1"&gt;'cargo'&lt;/span&gt;
info: checking &lt;span class="k"&gt;for &lt;/span&gt;self-updates
info: downloading self-updates

  stable updated: rustc 1.7.0 &lt;span class="o"&gt;(&lt;/span&gt;a5d1e7a59 2016-02-29&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
  &lt;p&gt;如上， rustup update 会更新 stable， component， 以及 rustup self， 可以使用 rustup self update 来手动更新rustup&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id="rust-知识"&gt;Rust 知识：&lt;/h3&gt;
&lt;h4 id="stdfmt"&gt;std::fmt:&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;format! 的使用 方法：  positional params：， named params： ， formating params：&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;示例&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="nd"&gt;format!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Hello, {}!"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"world"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   &lt;span class="c"&gt;// =&amp;gt; "Hello, world!"&lt;/span&gt;
&lt;span class="nd"&gt;format!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"{1} {} {0} {}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c"&gt;// =&amp;gt; "2 1 1 2"&lt;/span&gt;
&lt;span class="nd"&gt;format!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"{argument}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;argument&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"test"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Hello {:1$}!"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"x"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/li&gt;
  &lt;li&gt;formating trait: 实践显式 对于外部的Type  {}确实需要impl Display， 而{:?} 需要 impl Debug
    &lt;ol&gt;
      &lt;li&gt;{} =&amp;gt; Display&lt;/li&gt;
      &lt;li&gt;{:?} =&amp;gt; Debug&lt;/li&gt;
      &lt;li&gt;{:o} =&amp;gt; Octal&lt;/li&gt;
      &lt;li&gt;{:p} =&amp;gt; Pointer&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;fmt::Display vs fmt::Debug
    &lt;ol&gt;
      &lt;li&gt;Display: 断言 实现者 总是返回 UTF-8 的字符串， 并非所有的 都实现了 Display&lt;/li&gt;
      &lt;li&gt;Debug：  应该为所有pub type 实现， 输出为 内部状态， 该Trait 的目的是为了方便Rust Debug， 可以 使用#[derive(Debug)] 来使用默认的内部实现&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="array--slice"&gt;array &amp;amp; Slice&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;array的类型为： [T: len], let mut array: [i32; 3] = [0; 3];&lt;/li&gt;
  &lt;li&gt;Slice: [T]&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="structures-有三种类型-1-tuple-struct-2-classic-struct-3-unit-structs"&gt;structures： 有三种类型： 1） Tuple struct, 2) classic struct 3) Unit structs&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;struct Pair(i32, f32);&lt;/li&gt;
  &lt;li&gt;struct Person {  name: String,    age: u8}&lt;/li&gt;
  &lt;li&gt;struct Unit; unit Struct 没有任何的 field&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="enums-包含多个-变体-的-组合项-任何一个变体-都是一个-正确的-enum-类型"&gt;Enums： 包含多个 变体 的 组合项， 任何一个变体 都是一个 正确的 enum 类型&lt;/h4&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;  &lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;WebEvent&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="c"&gt;// An `enum` may either be `unit-like`,&lt;/span&gt;
      &lt;span class="n"&gt;PageLoad&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="n"&gt;PageUnload&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="c"&gt;// like tuple structs,&lt;/span&gt;
      &lt;span class="nf"&gt;KeyPress&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;char&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
      &lt;span class="nf"&gt;Paste&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;String&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
      &lt;span class="c"&gt;// or c-like structures.&lt;/span&gt;
      &lt;span class="n"&gt;Click&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;i64&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;i64&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="c"&gt;// A function which takes a `WebEvent` enum as an argument and&lt;/span&gt;
  &lt;span class="c"&gt;// returns nothing.&lt;/span&gt;
  &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;inspect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;WebEvent&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
          &lt;span class="nn"&gt;WebEvent&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;PageLoad&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"page loaded"&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
          &lt;span class="nn"&gt;WebEvent&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;PageUnload&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"page unloaded"&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
          &lt;span class="c"&gt;// Destructure `c` from inside the `enum`.&lt;/span&gt;
          &lt;span class="nn"&gt;WebEvent&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;KeyPress&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"pressed '{}'."&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
          &lt;span class="nn"&gt;WebEvent&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;Paste&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"pasted &lt;/span&gt;&lt;span class="se"&gt;\"&lt;/span&gt;&lt;span class="s"&gt;{}&lt;/span&gt;&lt;span class="se"&gt;\"&lt;/span&gt;&lt;span class="s"&gt;."&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
          &lt;span class="c"&gt;// Destructure `Click` into `x` and `y`.&lt;/span&gt;
          &lt;span class="nn"&gt;WebEvent&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Click&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
              &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"clicked at x={}, y={}."&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
          &lt;span class="p"&gt;},&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="type-aliastype-关键字能够-使用-type-name--existingtype-语法来-使用-name-代替-existingtype-使用-self-是一种type-alias"&gt;Type Alias：type 关键字能够 使用 type Name = ExistingType； 语法来 使用 Name 代替 ExistingType 使用。 Self 是一种Type Alias&lt;/h4&gt;

&lt;h4 id="const-static"&gt;const， static&lt;/h4&gt;

&lt;h4 id="variable-bindings-1变量默认-是不可修改的-使用mut-改变-2-可以在内部的scope中-其同样的名字来shadow即使不可见-外部的变量-3可以使用-先声明-后设定数值的形式-使用变量但是rust-会检查-使用-未定义变量的错误-来预防因此产生的问题"&gt;Variable Bindings： 1）变量默认 是不可修改的， 使用mut 改变 2） 可以在内部的scope中 其同样的名字来shadow(即使不可见) 外部的变量 3）可以使用 先声明 后设定数值的形式 使用变量，但是rust 会检查 使用 未定义变量的错误， 来预防因此产生的问题&lt;/h4&gt;

&lt;h4 id="types-1转换-as关键字--2-type-alias-type-nanosecond--u64-3-数值的类型可以添加到--后面最为后缀使用-例如-42i32"&gt;Types: 1）转换 as关键字  2） type alias： type NanoSecond = u64; 3） 数值的类型，可以添加到  后面最为后缀使用， 例如： 42i32&lt;/h4&gt;

&lt;h4 id="conversion-rust-的struct-以及-enum-等自定义类型的-type转换"&gt;Conversion： rust 的struct 以及 enum 等自定义类型的 type转换&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;From &amp;amp; Into:
    &lt;ul&gt;
      &lt;li&gt;From 为一个类型定义， 如何create self 从 另一个type中转变&lt;/li&gt;
      &lt;li&gt;Into 则是From 的 调用者， From&lt;T&gt; for U 自动实现了 Into&lt;u&gt; for T ( blank implement)&lt;/u&gt;&lt;/T&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;TryFrom &amp;amp; TryInto: 类似于 From &amp;amp; Into 不同的是， 转换可能失败，返回Result
    &lt;ul&gt;
      &lt;li&gt;ToString &amp;amp; FromStr:&lt;/li&gt;
      &lt;li&gt;ToString： 单独为 String 类型 定义了一个 ToString Trait，但是并不需要直接实现 ToString，而是实现了 fmt::Display 之后 就自动了提供了 ToString 中的to_string 方法&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;    &lt;span class="nd"&gt;#[stable(feature&lt;/span&gt; &lt;span class="nd"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"rust1"&lt;/span&gt;&lt;span class="nd"&gt;,&lt;/span&gt; &lt;span class="nd"&gt;since&lt;/span&gt; &lt;span class="nd"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"1.0.0"&lt;/span&gt;&lt;span class="nd"&gt;)]&lt;/span&gt;
&lt;span class="k"&gt;impl&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nn"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Display&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="n"&gt;Sized&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;ToString&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c"&gt;// A common guideline is to not inline generic functions. However,&lt;/span&gt;
    &lt;span class="c"&gt;// removing `#[inline]` from this method causes non-negligible regressions.&lt;/span&gt;
    &lt;span class="c"&gt;// See &amp;lt;https://github.com/rust-lang/rust/pull/74852&amp;gt;, the last attempt&lt;/span&gt;
    &lt;span class="c"&gt;// to try to remove it.&lt;/span&gt;
    &lt;span class="nd"&gt;#[inline]&lt;/span&gt;
    &lt;span class="n"&gt;default&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;to_string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;String&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;String&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="nf"&gt;.write_fmt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nd"&gt;format_args!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"{}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="nf"&gt;.expect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"a Display implementation returned an error unexpectedly"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;buf&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="fromstr--parse-将string-转换为其他类型-只需要实现了-fromstr-for-struct-而string-中的parse-方法-只是-对fromstrfrom_strstring-的调用"&gt;FromStr &amp;amp; parse: 将String 转换为其他类型， 只需要实现了 FromStr for struct, 而String 中的parse 方法 只是 对FromStr::from_str(&amp;amp;string) 的调用&lt;/h4&gt;

&lt;h4 id="expression-程序是由一系列表达式组成的-1-赋值表达式-用-结尾-2--也是表达式-如果最后一个表达式-以-结尾则返回---否则为最后一个表达式的-结果"&gt;Expression： 程序是由一系列表达式组成的， 1） 赋值表达式 用; 结尾， 2） {} 也是表达式， 如果最后一个表达式 以; 结尾，则返回  (), 否则为最后一个表达式的 结果&lt;/h4&gt;

&lt;h4 id="flow-of-control"&gt;Flow of control：&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;if-else  也是表达式， 所有的分支必须返回同样的类型&lt;/li&gt;
  &lt;li&gt;loop： loop break continue。 break 用来随时中断退出loop， continue 则用于 用于 跳过剩下的 代码，重新开始一个 循环&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;loop 是可以嵌套的，并起名字, break ，以及continue 可以使用名字来进行 break， 或者continue&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="nd"&gt;#![allow(unreachable_code)]&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nv"&gt;'outer&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Entered the outer loop"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="nv"&gt;'inner&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Entered the inner loop"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

            &lt;span class="c"&gt;// This would break only the inner loop&lt;/span&gt;
            &lt;span class="c"&gt;//break;&lt;/span&gt;

            &lt;span class="c"&gt;// This breaks the outer loop&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt; &lt;span class="nv"&gt;'outer&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"This point will never be reached"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Exited the outer loop"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;counter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;counter&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;counter&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt; &lt;span class="n"&gt;counter&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;

    &lt;span class="nd"&gt;assert_eq!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/li&gt;
  &lt;li&gt;loop 也是可以 返回数值的， 放到break 后面&lt;/li&gt;
  &lt;li&gt;while&lt;/li&gt;
  &lt;li&gt;for: for in 结构用来 遍历 所有实现了 IntoIterator 的对象， 比如简单 range形式： a..b, a..=b
    &lt;ul&gt;
      &lt;li&gt;for loop 会自动调用 into_iter 在参数上，我们可以主动产生下面几类实现IntoIterator 的 Iterator：&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;iter: 产生 引用的 Iterator, 对 ownership不产生影响
    &lt;ul&gt;
      &lt;li&gt;into_iter: 将ownership 交给 Iterator， 调用过之后的对象，将不再可用。产生&lt;/li&gt;
      &lt;li&gt;iter_mut: 产生mut 引用的Iterator， 可以进行修改&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;match:
    &lt;ul&gt;
      &lt;li&gt;c like 方式： 即 match  number&lt;/li&gt;
      &lt;li&gt;解构对象：
        &lt;ul&gt;
          &lt;li&gt;Tuples：  使用.. 来 忽略剩余所有的 tuple&lt;/li&gt;
          &lt;li&gt;Enums:&lt;/li&gt;
          &lt;li&gt;Pointers: *  &amp;amp; ref ref mut 见下面示例&lt;/li&gt;
          &lt;li&gt;Structs: struct 同样可以被match&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Guards: 在match 对象的arm中，同样可以 使用 if 条件判断 即是 guards&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Bindings： match 在 arm中，除了解构对象的同时 可以将变量整体绑定 到一个变量上&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;triple&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="c"&gt;// TODO ^ Try different values for `triple`&lt;/span&gt;

    &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Tell me about {:?}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;triple&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="c"&gt;// Match can be used to destructure a tuple&lt;/span&gt;
    &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="n"&gt;triple&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c"&gt;// Destructure the second and third elements&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"First is `0`, `y` is {:?}, and `z` is {:?}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;..&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"First is `1` and the rest doesn't matter"&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="c"&gt;// `..` can be the used ignore the rest of the tuple&lt;/span&gt;
        &lt;span class="mi"&gt;_&lt;/span&gt;      &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"It doesn't matter what they are"&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="c"&gt;// `_` means don't bind the value to a variable&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c"&gt;//point s &lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c"&gt;// Assign a reference of type `i32`. The `&amp;amp;` signifies there&lt;/span&gt;
    &lt;span class="c"&gt;// is a reference being assigned.&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;reference&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="n"&gt;reference&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c"&gt;// If `reference` is pattern matched against `&amp;amp;val`, it results&lt;/span&gt;
        &lt;span class="c"&gt;// in a comparison like:&lt;/span&gt;
        &lt;span class="c"&gt;// `&amp;amp;i32`&lt;/span&gt;
        &lt;span class="c"&gt;// `&amp;amp;val`&lt;/span&gt;
        &lt;span class="c"&gt;// ^ We see that if the matching `&amp;amp;`s are dropped, then the `i32`&lt;/span&gt;
        &lt;span class="c"&gt;// should be assigned to `val`.&lt;/span&gt;
        &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Got a value via destructuring: {:?}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c"&gt;// To avoid the `&amp;amp;`, you dereference before matching.&lt;/span&gt;
    &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;reference&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Got a value via dereferencing: {:?}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c"&gt;// What if you don't start with a reference? `reference` was a `&amp;amp;`&lt;/span&gt;
    &lt;span class="c"&gt;// because the right side was already a reference. This is not&lt;/span&gt;
    &lt;span class="c"&gt;// a reference because the right side is not one.&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="mi"&gt;_&lt;/span&gt;&lt;span class="n"&gt;not_a_reference&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c"&gt;// Rust provides `ref` for exactly this purpose. It modifies the&lt;/span&gt;
    &lt;span class="c"&gt;// assignment so that a reference is created for the element; this&lt;/span&gt;
    &lt;span class="c"&gt;// reference is assigned.&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;ref&lt;/span&gt; &lt;span class="mi"&gt;_&lt;/span&gt;&lt;span class="n"&gt;is_a_reference&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c"&gt;// Accordingly, by defining 2 values without references, references&lt;/span&gt;
    &lt;span class="c"&gt;// can be retrieved via `ref` and `ref mut`.&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;mut_value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c"&gt;// Use `ref` keyword to create a reference.&lt;/span&gt;
    &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;ref&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Got a reference to a value: {:?}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c"&gt;// Use `ref mut` similarly.&lt;/span&gt;
    &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="n"&gt;mut_value&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;ref&lt;/span&gt; &lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="c"&gt;// Got a reference. Gotta dereference it before we can&lt;/span&gt;
            &lt;span class="c"&gt;// add anything to it.&lt;/span&gt;
            &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"We added 10. `mut_value`: {:?}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Foo&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;u32&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;u32&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;u32&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c"&gt;// Try changing the values in the struct to see what happens&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Foo&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

    &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Foo&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"First of x is 1, b = {},  y = {} "&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;

        &lt;span class="c"&gt;// you can destructure structs and rename the variables,&lt;/span&gt;
        &lt;span class="c"&gt;// the order is not important&lt;/span&gt;
        &lt;span class="n"&gt;Foo&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"y is 2, i = {:?}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;

        &lt;span class="c"&gt;// and you can also ignore some variables:&lt;/span&gt;
        &lt;span class="n"&gt;Foo&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;..&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"y = {}, we don't care about x"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="c"&gt;// this will give an error: pattern does not mention field `x`&lt;/span&gt;
        &lt;span class="c"&gt;//Foo { y } =&amp;gt; println!("y = {}", y),&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;pair&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="c"&gt;// TODO ^ Try different values for `pair`&lt;/span&gt;

    &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Tell me about {:?}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pair&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="n"&gt;pair&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"These are twins"&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="c"&gt;// The ^ `if condition` part is a guard&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Antimatter, kaboom!"&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;_&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"The first one is odd"&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="mi"&gt;_&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"No correlation..."&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="c"&gt;// A function `age` which returns a `u32`.&lt;/span&gt;
&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;age&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;u32&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="mi"&gt;15&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Tell me what type of person you are"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="nf"&gt;age&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="mi"&gt;0&lt;/span&gt;             &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"I haven't celebrated my first birthday yet"&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="c"&gt;// Could `match` 1 ..= 12 directly but then what age&lt;/span&gt;
        &lt;span class="c"&gt;// would the child be? Instead, bind to `n` for the&lt;/span&gt;
        &lt;span class="c"&gt;// sequence of 1 ..= 12. Now the age can be reported.&lt;/span&gt;
        &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="o"&gt;..=&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"I'm a child of age {:?}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt; &lt;span class="mi"&gt;13&lt;/span&gt; &lt;span class="o"&gt;..=&lt;/span&gt; &lt;span class="mi"&gt;19&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"I'm a teen of age {:?}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="c"&gt;// Nothing bound. Return the result.&lt;/span&gt;
        &lt;span class="n"&gt;n&lt;/span&gt;             &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"I'm an old person of age {:?}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;if let: 在判断的同时 进行match&lt;/li&gt;
  &lt;li&gt;while let&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="functions"&gt;Functions:&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;methods: 依附于 对象的函数， 在methods 的block中，能够 通过self使用 对象的 数据&lt;/li&gt;
  &lt;li&gt;closures:  |val| {val + x}
    &lt;ul&gt;
      &lt;li&gt;Capturing： 捕获， 其可以 捕获环境中的 变量， 可以是： &amp;amp;T, &amp;amp;mut T , T（by value）&lt;/li&gt;
      &lt;li&gt;作为参数： 分为三类： Fn, FnMut, FnOnce， 对应ownership  的 &amp;amp;T, &amp;amp;mut T, T. Fn 可以无限次执行， FnMut 则要求 capture 变量的 mut 引用， FnOnce 则 只能执行一次&lt;/li&gt;
      &lt;li&gt;疑问：
        &lt;ol&gt;
          &lt;li&gt;如何 区分  Fn(i64, i64) -&amp;gt; i64 与Fn(&amp;amp;String) -&amp;gt; i64&lt;/li&gt;
          &lt;li&gt;FnOnce 是如何确定的， 有些函数，即便将变量 move 到了block中， 然而依然可以调用多次， 这些优势如何判断的？ 根据内部函数调用的 Fn 属性吗？ 比如mem::drop(p) 则 包含其调用的函数 则为 FnOnce?&lt;/li&gt;
          &lt;li&gt;如何断定 Cloosure 为 Fn or FnMut ?&lt;/li&gt;
        &lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;  &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;f64&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;f64&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="c"&gt;// Implementation block, all `Point` methods go in here&lt;/span&gt;
  &lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="c"&gt;// This is a static method&lt;/span&gt;
      &lt;span class="c"&gt;// Static methods don't need to be called by an instance&lt;/span&gt;
      &lt;span class="c"&gt;// These methods are generally used as constructors&lt;/span&gt;
      &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;origin&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
          &lt;span class="n"&gt;Point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;

      &lt;span class="c"&gt;// Another static method, taking two arguments:&lt;/span&gt;
      &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;f64&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;f64&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
          &lt;span class="n"&gt;Point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="modules"&gt;Modules:&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;mod visibility: mod 的可见性， mod 默认只能在本mod 可见， 需要使用 pub 来对外可见， 定义其中的fn， struct 使用同样的规则， 因为mod 可以nest， 所以 存在pub(self) (等同于private) pub(super) 即让super mod 可见,  而pub(crate)则让crate 可见&lt;/li&gt;
  &lt;li&gt;struct visibility: struct 中包含fn 以及 field，默认都为 对 所在 定义的mod可见， pub 则开放为对外部的 mod可见&lt;/li&gt;
  &lt;li&gt;mod vs struct: struct 的控制比较弱， mod的控制则相对复杂， struct 可能并不需要如此复杂的规则吧&lt;/li&gt;
  &lt;li&gt;关键字 use： 我们可以使用 use mod::struct as another_struct 来 减少路径的拼写， 使用as 更可以 启用别名&lt;/li&gt;
  &lt;li&gt;mod 的 使用类似于 Unix下的 目录 安排， super 代表 .. self 则代表 本mod&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="attributes-可以用来作什么-1-条件编译-2设定crate-属性-3关闭-warning-4启用编译器特性maros-etc-5-link-to-a-foreign-library-6-设定unit-test"&gt;Attributes: 可以用来作什么？ 1） 条件编译， 2）设定crate 属性， 3）关闭 warning 4)启用编译器特性(maros etc) 5） link to a foreign library 6) 设定unit test&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;形式： 当应用到 整个crate： #![crate_attribute], 应用到module 或者 item ： #[item_attribute]&lt;/li&gt;
  &lt;li&gt;还可以接受参数： 1) #[attribute = “value”] 2) #[attribute(key = “value”)] 3) #[attribute(value)]&lt;/li&gt;
  &lt;li&gt;示例：
    &lt;ul&gt;
      &lt;li&gt;#[allow(dead_code)]： 关闭rust 关于没有调用函数的提示&lt;/li&gt;
      &lt;li&gt;#![crate_name = “rary”]&lt;/li&gt;
      &lt;li&gt;cfg(Configuration):  1） #[cfg(…)] 条件编译  2） cfg!(…) 在运行阶段的条件判断， 返回bool值&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;   &lt;span class="c"&gt;// This function only gets compiled if the target OS is linux&lt;/span&gt;
   &lt;span class="nd"&gt;#[cfg(target_os&lt;/span&gt; &lt;span class="nd"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"linux"&lt;/span&gt;&lt;span class="nd"&gt;)]&lt;/span&gt;
   &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;are_you_on_linux&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
       &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"You are running linux!"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
   &lt;span class="p"&gt;}&lt;/span&gt;

   &lt;span class="c"&gt;// And this function only gets compiled if the target OS is *not* linux&lt;/span&gt;
   &lt;span class="nd"&gt;#[cfg(not(target_os&lt;/span&gt; &lt;span class="nd"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"linux"&lt;/span&gt;&lt;span class="nd"&gt;))]&lt;/span&gt;
   &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;are_you_on_linux&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
       &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"You are *not* running linux!"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
   &lt;span class="p"&gt;}&lt;/span&gt;

   &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
       &lt;span class="nf"&gt;are_you_on_linux&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

       &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Are you sure?"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
       &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nd"&gt;cfg!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;target_os&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"linux"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
           &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Yes. It's definitely linux!"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
       &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
           &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Yes. It's definitely *not* linux!"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
       &lt;span class="p"&gt;}&lt;/span&gt;
   &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
</content>
  </entry>
  <entry>
    <title>link compile</title>
    <link rel="alternate" href="http://geniousbar.github.io/2021/02/19/link-compile/"/>
    <id>http://geniousbar.github.io/2021/02/19/link-compile/</id>
    <published>2021-02-19T00:00:00+00:00</published>
    <updated>2021-04-19T08:29:22+00:00</updated>
    <summary type="html">&lt;h2 id="link--compile"&gt;link &amp;amp; compile&lt;/h2&gt;

&lt;h3 id="为什么c语言中的-header-file-h-一定需要-防止重复被include-呢-而为什么一定需要-header-file的存在呢"&gt;为什么c语言中的 header file *.h 一定需要 防止重复被include 呢？ 而为什么一定需要 header file的存在呢？&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;header file 需要存在原因有： 1） .c 文件 变为可执行文件，需要 编译、链接 两个阶段， 而链接中 是可以将 不同的 类型编译过的文件进行 链接的。 随着程序的复杂， 比如 函数参数的 传递顺序等 原因导致，需要 程序调用者 知道 函数调用的结构， 所以 [[https://www.zhihu.com...&lt;/li&gt;
&lt;/ul&gt;</summary>
    <content type="html">&lt;h2 id="link--compile"&gt;link &amp;amp; compile&lt;/h2&gt;

&lt;h3 id="为什么c语言中的-header-file-h-一定需要-防止重复被include-呢-而为什么一定需要-header-file的存在呢"&gt;为什么c语言中的 header file *.h 一定需要 防止重复被include 呢？ 而为什么一定需要 header file的存在呢？&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;header file 需要存在原因有： 1） .c 文件 变为可执行文件，需要 编译、链接 两个阶段， 而链接中 是可以将 不同的 类型编译过的文件进行 链接的。 随着程序的复杂， 比如 函数参数的 传递顺序等 原因导致，需要 程序调用者 知道 函数调用的结构， 所以 [[https://www.zhihu.com/question/280665935][链接]] 2) 如果依赖于系统中的系统库，比如标准库中的系统调用，则只能使用inluce header file 来进行使用，即：被调用方 是已经编译好的文件格式&lt;/li&gt;
  &lt;li&gt;为什么 header file一定需要 预防被重复加载呢？： 经过测试发现，在 header file 中不存在 struct 定义的时候，只是简单的 func 定义的时候， 重复包含并没有问题， 然而在 定义 struct的时候 则出现了 重复定义问题。 而问题也只是出现了 gcc -c 的阶段， 在gcc -E gcc -S 阶段 依然没有任何问题，所以 关于 为什么一定需要 #ifndef #define code …  #endif 的格式，则需要 在gcc 中寻找&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="c-语言-到可执行文件的过程"&gt;C 语言 到可执行文件的过程&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;预处理(Preprocessing)&lt;/li&gt;
  &lt;li&gt;编译(Compilation)&lt;/li&gt;
  &lt;li&gt;汇编(Assembly)&lt;/li&gt;
  &lt;li&gt;链接(Linking): 链接过程主要包括了：
    &lt;ul&gt;
      &lt;li&gt;地址和空间分配&lt;/li&gt;
      &lt;li&gt;符号决议&lt;/li&gt;
      &lt;li&gt;重定位： 当存在a.c 依赖 b.c 的函数时候， 文件是单独编译的，并非 将b.c 的中内容 插入到 a.c 中，然后进行整体编译。所以导致 a.c 中并不知道 b.c 中函数 变量的存在， 所以 在编译 a.c时候， 函数调用 都会 call 0， 函数地址 需要 在链接时候 进行确定，并修改 （即是重定位）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="elf-文件的类型"&gt;elf 文件的类型：&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;type&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
      &lt;th&gt;实例&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;可重定位文件(Relocatable File)&lt;/td&gt;
      &lt;td&gt;可以被可执行文件或 共享目标文件 链接&lt;/td&gt;
      &lt;td&gt;Linux: .o&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;可执行文件(Executable File)&lt;/td&gt;
      &lt;td&gt;可执行程序, 一般没有 扩展名&lt;/td&gt;
      &lt;td&gt;Linux: /bin/bash Windows .exe&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;共享目标文件(Shared Object File )&lt;/td&gt;
      &lt;td&gt;1） 可被 其他 可重定位文件 、共享文件 连接成 目标文件 2） 动态链接器 将其与可执行文件结合，映射为 进程的一部分&lt;/td&gt;
      &lt;td&gt;Linux: .so, Windows: DLL&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;核心转储文件(Core Dump File)&lt;/td&gt;
      &lt;td&gt;进程意外终止时候， 系统可以 将进程的地址空间内容 等信息 转储到  该文件中&lt;/td&gt;
      &lt;td&gt;Linux: core dump&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;vagrant@precise64:/vagrant_data/link_test&lt;span class="nv"&gt;$ &lt;/span&gt;file a.out
a.out: ELF 64-bit LSB executable, x86-64, version 1 &lt;span class="o"&gt;(&lt;/span&gt;SYSV&lt;span class="o"&gt;)&lt;/span&gt;, dynamically linked &lt;span class="o"&gt;(&lt;/span&gt;uses shared libs&lt;span class="o"&gt;)&lt;/span&gt;, &lt;span class="k"&gt;for &lt;/span&gt;GNU/Linux 2.6.24, BuildID[sha1]&lt;span class="o"&gt;=&lt;/span&gt;0x91de252bc2c3703aa5c324e5176b05e6b36a5bfa, not stripped

vagrant@precise64:/vagrant_data/link_test&lt;span class="nv"&gt;$ &lt;/span&gt;file main.o
main.o: ELF 64-bit LSB relocatable, x86-64, version 1 &lt;span class="o"&gt;(&lt;/span&gt;SYSV&lt;span class="o"&gt;)&lt;/span&gt;, not stripped
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="深入-o-文件"&gt;深入 .o 文件&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;可用工具有： 1) objdump, 2) readelf, 3) nm&lt;/li&gt;
  &lt;li&gt;elf 因为 存在段(section) ，而段 是变长的，导致 没有固定的映射方法，所以 Header 为固定长度 异常重要， Header 中存在 多少个段（Number of section headers），  段表偏移(Start of section headers:) 的关键信息， 来使 c代码能够将 段表（section table） 映射到代码中&lt;/li&gt;
  &lt;li&gt;objdump -h main.o&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;
int main&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  int a &lt;span class="o"&gt;=&lt;/span&gt; 10&lt;span class="p"&gt;;&lt;/span&gt;
  name&lt;span class="o"&gt;(&lt;/span&gt;a&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

vagrant@precise64:/vagrant_data/link_test&lt;span class="nv"&gt;$ &lt;/span&gt;objdump &lt;span class="nt"&gt;-h&lt;/span&gt; main.o

main.o:     file format elf64-x86-64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000020  0000000000000000  0000000000000000  00000040  2&lt;span class="k"&gt;**&lt;/span&gt;2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  0000000000000000  0000000000000000  00000060  2&lt;span class="k"&gt;**&lt;/span&gt;2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  0000000000000000  0000000000000000  00000060  2&lt;span class="k"&gt;**&lt;/span&gt;2
                  ALLOC
  3 .comment      0000002b  0000000000000000  0000000000000000  00000060  2&lt;span class="k"&gt;**&lt;/span&gt;0
                  CONTENTS, READONLY
  4 .note.GNU-stack 00000000  0000000000000000  0000000000000000  0000008b  2&lt;span class="k"&gt;**&lt;/span&gt;0
                  CONTENTS, READONLY
  5 .eh_frame     00000038  0000000000000000  0000000000000000  00000090  2&lt;span class="k"&gt;**&lt;/span&gt;3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
vagrant@precise64:/vagrant_data/link_test&lt;span class="nv"&gt;$ &lt;/span&gt;readelf &lt;span class="nt"&gt;-h&lt;/span&gt; main.o
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF64
  Data:                              2&lt;span class="s1"&gt;'s complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              REL (Relocatable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x0
  Start of program headers:          0 (bytes into file)
  Start of section headers:          296 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           0 (bytes)
  Number of program headers:         0
  Size of section headers:           64 (bytes)
  Number of section headers:         12
  Section header string table index: 9

//  注意 在 文件中添加 了 全局变量之后 .data 文件 的size 变大了。
int b = 10;
int main() {
  int a = 10;
  name(a);
}


vagrant@precise64:/vagrant_data/link_test$ objdump -h main.o

main.o:     file format elf64-x86-64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000020  0000000000000000  0000000000000000  00000040  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000004  0000000000000000  0000000000000000  00000060  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  0000000000000000  0000000000000000  00000064  2**2
                  ALLOC
  3 .comment      0000002b  0000000000000000  0000000000000000  00000064  2**0
                  CONTENTS, READONLY
  4 .note.GNU-stack 00000000  0000000000000000  0000000000000000  0000008f  2**0
                  CONTENTS, READONLY
  5 .eh_frame     00000038  0000000000000000  0000000000000000  00000090  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA

vagrant@precise64:/vagrant_data/link_test$ size main.o
   text	   data	    bss	    dec	    hex	filename
     88	      4	      0	     92	     5c	main.o

&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="objdump--s--d-maino-其中---s--将各个段-都打印出来--d-则将-代码段反汇编"&gt;objdump -s -d main.o 其中  -s  将各个段 都打印出来， -d 则将 代码段反汇编&lt;/h4&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;vagrant@precise64:/vagrant_data/link_test&lt;span class="nv"&gt;$ &lt;/span&gt;objdump &lt;span class="nt"&gt;-s&lt;/span&gt; &lt;span class="nt"&gt;-d&lt;/span&gt; main.o

main.o:     file format elf64-x86-64

Contents of section .text:
 0000 554889e5 4883ec10 c745fc0a 0000008b  UH..H....E......
 0010 45fc89c7 b8000000 00e80000 0000c9c3  E...............
Contents of section .data:
 0000 0a000000                             ....
Contents of section .comment:
 0000 00474343 3a202855 62756e74 752f4c69  .GCC: &lt;span class="o"&gt;(&lt;/span&gt;Ubuntu/Li
 0010 6e61726f 20342e36 2e332d31 7562756e  naro 4.6.3-1ubun
 0020 74753529 20342e36 2e3300             tu5&lt;span class="o"&gt;)&lt;/span&gt; 4.6.3.
Contents of section .eh_frame:
 0000 14000000 00000000 017a5200 01781001  .........zR..x..
 0010 1b0c0708 90010000 1c000000 1c000000  ................
 0020 00000000 20000000 00410e10 8602430d  .... ....A....C.
 0030 065b0c07 08000000                    .[......

Disassembly of section .text:

0000000000000000 &amp;lt;main&amp;gt;:
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    &lt;span class="nv"&gt;$0x10&lt;/span&gt;,%rsp
   8:	c7 45 &lt;span class="nb"&gt;fc &lt;/span&gt;0a 00 00 00 	movl   &lt;span class="nv"&gt;$0xa&lt;/span&gt;,-0x4&lt;span class="o"&gt;(&lt;/span&gt;%rbp&lt;span class="o"&gt;)&lt;/span&gt;
   f:	8b 45 &lt;span class="nb"&gt;fc             	&lt;/span&gt;mov    &lt;span class="nt"&gt;-0x4&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;%rbp&lt;span class="o"&gt;)&lt;/span&gt;,%eax
  12:	89 c7                	mov    %eax,%edi
  14:	b8 00 00 00 00       	mov    &lt;span class="nv"&gt;$0x0&lt;/span&gt;,%eax
  19:	e8 00 00 00 00       	callq  1e &amp;lt;main+0x1e&amp;gt;
  1e:	c9                   	leaveq
  1f:	c3                   	retq
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;重定位表：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;  vagrant@precise64:/vagrant_data/link_test&lt;span class="nv"&gt;$ &lt;/span&gt;readelf &lt;span class="nt"&gt;-S&lt;/span&gt; main.o
There are 12 section headers, starting at offset 0x128:

Section Headers:
  &lt;span class="o"&gt;[&lt;/span&gt;Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  &lt;span class="o"&gt;[&lt;/span&gt; 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  &lt;span class="o"&gt;[&lt;/span&gt; 1] .text             PROGBITS         0000000000000000  00000040
       0000000000000020  0000000000000000  AX       0     0     4
  &lt;span class="o"&gt;[&lt;/span&gt; 2] .rela.text        RELA             0000000000000000  00000548
       0000000000000018  0000000000000018          10     1     8
  &lt;span class="o"&gt;[&lt;/span&gt; 3] .data             PROGBITS         0000000000000000  00000060
       0000000000000004  0000000000000000  WA       0     0     4
  &lt;span class="o"&gt;[&lt;/span&gt; 4] .bss              NOBITS           0000000000000000  00000064
       0000000000000000  0000000000000000  WA       0     0     4
  &lt;span class="o"&gt;[&lt;/span&gt; 5] .comment          PROGBITS         0000000000000000  00000064
       000000000000002b  0000000000000001  MS       0     0     1
  &lt;span class="o"&gt;[&lt;/span&gt; 6] .note.GNU-stack   PROGBITS         0000000000000000  0000008f
       0000000000000000  0000000000000000           0     0     1
  &lt;span class="o"&gt;[&lt;/span&gt; 7] .eh_frame         PROGBITS         0000000000000000  00000090
       0000000000000038  0000000000000000   A       0     0     8
  &lt;span class="o"&gt;[&lt;/span&gt; 8] .rela.eh_frame    RELA             0000000000000000  00000560
       0000000000000018  0000000000000018          10     7     8
  &lt;span class="o"&gt;[&lt;/span&gt; 9] .shstrtab         STRTAB           0000000000000000  000000c8
       0000000000000059  0000000000000000           0     0     1
  &lt;span class="o"&gt;[&lt;/span&gt;10] .symtab           SYMTAB           0000000000000000  00000428
       0000000000000108  0000000000000018          11     8     8
  &lt;span class="o"&gt;[&lt;/span&gt;11] .strtab           STRTAB           0000000000000000  00000530
       0000000000000014  0000000000000000           0     0     1
Key to Flags:
  W &lt;span class="o"&gt;(&lt;/span&gt;write&lt;span class="o"&gt;)&lt;/span&gt;, A &lt;span class="o"&gt;(&lt;/span&gt;alloc&lt;span class="o"&gt;)&lt;/span&gt;, X &lt;span class="o"&gt;(&lt;/span&gt;execute&lt;span class="o"&gt;)&lt;/span&gt;, M &lt;span class="o"&gt;(&lt;/span&gt;merge&lt;span class="o"&gt;)&lt;/span&gt;, S &lt;span class="o"&gt;(&lt;/span&gt;strings&lt;span class="o"&gt;)&lt;/span&gt;, l &lt;span class="o"&gt;(&lt;/span&gt;large&lt;span class="o"&gt;)&lt;/span&gt;
  I &lt;span class="o"&gt;(&lt;/span&gt;info&lt;span class="o"&gt;)&lt;/span&gt;, L &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;link &lt;/span&gt;order&lt;span class="o"&gt;)&lt;/span&gt;, G &lt;span class="o"&gt;(&lt;/span&gt;group&lt;span class="o"&gt;)&lt;/span&gt;, T &lt;span class="o"&gt;(&lt;/span&gt;TLS&lt;span class="o"&gt;)&lt;/span&gt;, E &lt;span class="o"&gt;(&lt;/span&gt;exclude&lt;span class="o"&gt;)&lt;/span&gt;, x &lt;span class="o"&gt;(&lt;/span&gt;unknown&lt;span class="o"&gt;)&lt;/span&gt;
  O &lt;span class="o"&gt;(&lt;/span&gt;extra OS processing required&lt;span class="o"&gt;)&lt;/span&gt; o &lt;span class="o"&gt;(&lt;/span&gt;OS specific&lt;span class="o"&gt;)&lt;/span&gt;, p &lt;span class="o"&gt;(&lt;/span&gt;processor specific&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;在列表中，有 type 为RELA  或者 REL  的 rela.text, 为重定位表， main.c 中 调用了一个name 函数， name 存在于name.c 文件中， 链接器在 连接时候，需要 将main.o 中的函数调用 处理为 name.o 中的地址， 其中info 为指向需要重定位的 section index&lt;/li&gt;
  &lt;li&gt;每个需要重定位的段，都需要 一个相应的重定位表， 比如 .text 则为 .rela.text, .eh_frmae .rela.eh_frame,&lt;/li&gt;
  &lt;li&gt;字符串表：因为字符串为变长，比较难映射 所以单独存放一个 段。 .strtab .shstrtab, 类型为 strtab (String table )， .strtab  为 字符串表 用来存储 普通的字符串， 比如符号的名字， .shstrtab 则为 （section header string table） 段表字符串表， 用来保存段表 中 用到的字符串 比如段名&lt;/li&gt;
  &lt;li&gt;对比 header 中的 Section header string table index: 9 项， 正好 为 .shstrtab 在section table中的下标
    &lt;h3 id="符号"&gt;符号&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;符号是， 链接过程中重要的信息数据， 链接过程中  目标文件的相互拼接： 实际上 就是目标文件之间对地址的引用， 即对函数 变量地址的引用。比如 B 需要用到 A中的函数foo， 则是： A中定义了 函数foo， B 引用了 A中的函数foo, 概念同样适用变量，&lt;/li&gt;
  &lt;li&gt;链接中，我们称  函数和变量为符号，函数名 变量名则是 符号名。&lt;/li&gt;
  &lt;li&gt;每个文件中 都包含 函数表， 记录了 文件中使用的所有符号，每个定义的符号都有对应的条目，其中包含符号值， 对于变量和函数来说，符号值 则为 其地址。&lt;/li&gt;
  &lt;li&gt;符号 可能包含的有 以下类型：
    &lt;ol&gt;
      &lt;li&gt;定义在本文件中的全局符号，函数 等，可以被其他文件 引用。 比如: 函数 main, name,&lt;/li&gt;
      &lt;li&gt;外部符号： 再本文件中引用的全局符号，并未在本文件中定义&lt;/li&gt;
      &lt;li&gt;段名： 其数值为 该段的其实地址， 编译器所加。&lt;/li&gt;
      &lt;li&gt;局部符号： 只在该文件中可见，比如static 变量&lt;/li&gt;
      &lt;li&gt;行号信息： 目标文件指令 与 源代码 的对应关系. debug 模式下 会创建 不少的 该类信息 在 符号表中&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;vagrant@precise64:/vagrant_data/link_test&lt;span class="nv"&gt;$ &lt;/span&gt;readelf &lt;span class="nt"&gt;-s&lt;/span&gt; main.o

Symbol table &lt;span class="s1"&gt;'.symtab'&lt;/span&gt; contains 11 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND
     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS main.c
     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1
     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3
     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4
     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    6
     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    7
     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    5
     8: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    3 b
     9: 0000000000000000    32 FUNC    GLOBAL DEFAULT    1 main
    10: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND name  


vagrant@precise64:/vagrant_data/link_test&lt;span class="nv"&gt;$ &lt;/span&gt;objdump &lt;span class="nt"&gt;-t&lt;/span&gt; main.o

main.o:     file format elf64-x86-64

SYMBOL TABLE:
0000000000000000 l    &lt;span class="nb"&gt;df&lt;/span&gt; &lt;span class="k"&gt;*&lt;/span&gt;ABS&lt;span class="k"&gt;*&lt;/span&gt;	0000000000000000 main.c
0000000000000000 l    d  .text	0000000000000000 .text
0000000000000000 l    d  .data	0000000000000000 .data
0000000000000000 l    d  .bss	0000000000000000 .bss
0000000000000000 l    d  .note.GNU-stack	0000000000000000 .note.GNU-stack
0000000000000000 l    d  .eh_frame	0000000000000000 .eh_frame
0000000000000000 l    d  .comment	0000000000000000 .comment
0000000000000000 g     O .data	0000000000000004 b
0000000000000000 g     F .text	0000000000000020 main
0000000000000000         &lt;span class="k"&gt;*&lt;/span&gt;UND&lt;span class="k"&gt;*&lt;/span&gt;	0000000000000000 name
&lt;span class="c"&gt;#+end_src&lt;/span&gt;

&lt;span class="c"&gt;#### 相似段合并：&lt;/span&gt;

&lt;span class="sb"&gt;```&lt;/span&gt;shell
vagrant@precise64:/vagrant_data/link_test&lt;span class="nv"&gt;$ &lt;/span&gt;objdump &lt;span class="nt"&gt;-h&lt;/span&gt; main.o

main.o:     file format elf64-x86-64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000020  0000000000000000  0000000000000000  00000040  2&lt;span class="k"&gt;**&lt;/span&gt;2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000004  0000000000000000  0000000000000000  00000060  2&lt;span class="k"&gt;**&lt;/span&gt;2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  0000000000000000  0000000000000000  00000064  2&lt;span class="k"&gt;**&lt;/span&gt;2
                  ALLOC
  3 .comment      0000002b  0000000000000000  0000000000000000  00000064  2&lt;span class="k"&gt;**&lt;/span&gt;0
                  CONTENTS, READONLY
  4 .note.GNU-stack 00000000  0000000000000000  0000000000000000  0000008f  2&lt;span class="k"&gt;**&lt;/span&gt;0
                  CONTENTS, READONLY
  5 .eh_frame     00000038  0000000000000000  0000000000000000  00000090  2&lt;span class="k"&gt;**&lt;/span&gt;3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
vagrant@precise64:/vagrant_data/link_test&lt;span class="nv"&gt;$ &lt;/span&gt;objdump &lt;span class="nt"&gt;-h&lt;/span&gt; name.o

name.o:     file format elf64-x86-64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         0000000f  0000000000000000  0000000000000000  00000040  2&lt;span class="k"&gt;**&lt;/span&gt;2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  0000000000000000  0000000000000000  00000050  2&lt;span class="k"&gt;**&lt;/span&gt;2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  0000000000000000  0000000000000000  00000050  2&lt;span class="k"&gt;**&lt;/span&gt;2
                  ALLOC
  3 .comment      0000002b  0000000000000000  0000000000000000  00000050  2&lt;span class="k"&gt;**&lt;/span&gt;0
                  CONTENTS, READONLY
  4 .note.GNU-stack 00000000  0000000000000000  0000000000000000  0000007b  2&lt;span class="k"&gt;**&lt;/span&gt;0
                  CONTENTS, READONLY
  5 .eh_frame     00000038  0000000000000000  0000000000000000  00000080  2&lt;span class="k"&gt;**&lt;/span&gt;3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA

ld main.o  name.o &lt;span class="nt"&gt;-e&lt;/span&gt; main &lt;span class="nt"&gt;-o&lt;/span&gt; ab                  
vagrant@precise64:/vagrant_data/link_test&lt;span class="nv"&gt;$ &lt;/span&gt;objdump &lt;span class="nt"&gt;-h&lt;/span&gt; ab

ab:     file format elf64-x86-64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         0000002f  00000000004000e8  00000000004000e8  000000e8  2&lt;span class="k"&gt;**&lt;/span&gt;2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .eh_frame     00000058  0000000000400118  0000000000400118  00000118  2&lt;span class="k"&gt;**&lt;/span&gt;3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .data         00000004  0000000000600170  0000000000600170  00000170  2&lt;span class="k"&gt;**&lt;/span&gt;2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .comment      0000002a  0000000000000000  0000000000000000  00000174  2&lt;span class="k"&gt;**&lt;/span&gt;0
                  CONTENTS, READONLY

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;ld main.o  name.o -e main -o ab&lt;/li&gt;
  &lt;li&gt;注意 VMA LMA:  VMA (Virtual Memory Address) 为 虚拟地址， LMA( Load Memory Address) 即 加载地址， 一般情况下两个数值 都是一样的，有些切入式系统中 两个数值不同。&lt;/li&gt;
  &lt;li&gt;链接器为 目标文件 分配 地址和空间 的理解： 其中地址和空间 含义有两个： 1）输出的可执行文件的空间， 2） 装载后的虚拟地址中的虚拟地址空间， 对于 .text .data 来说， 他们在 文件中 和 虚拟地址 中都有分配空间， .bss 则 仅在 虚拟地址空间中存在。其中 虚拟地址 关系到 链接器对于 地址的重新计算
    &lt;h4 id="链接-步骤-两部链接"&gt;链接 步骤: 两部链接&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;空间和地址分配：
        &lt;ul&gt;
          &lt;li&gt;扫描所有的输入文件，获得各个段的长度、属性、位置。&lt;/li&gt;
          &lt;li&gt;将输入文件中的符号 定义 和符号引用 收集起来，统一为一个 全局符号表&lt;/li&gt;
          &lt;li&gt;合并所有的输入文件的相似段，计算各个合并后的段的长度和位置，并建立映射关系&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;符号解析 与重定位： 链接过程的核心 过程
        &lt;ul&gt;
          &lt;li&gt;读取输入文件中的段的数据、重定位信息、进行符号解析与重定位 调整代码中的地址等&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="重定位表-用来提供-给链接器-关于重定位-的相关信息-比如那些需要被调整怎样调整-重定位表-即用来专门提供这些信息"&gt;重定位表： 用来提供 给链接器 关于重定位 的相关信息， 比如那些需要被调整，怎样调整？ 重定位表 即用来专门提供这些信息&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;每个 需要 包含需要被重定位符号的 段，都有一个对应的 重定位表。 比如 .text 则赌赢 .rel.text&lt;/li&gt;
  &lt;li&gt;重定位表结构：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;   vagrant@precise64:/vagrant_data/link_test&lt;span class="nv"&gt;$ &lt;/span&gt;objdump &lt;span class="nt"&gt;-r&lt;/span&gt; main.o

main.o:     file format elf64-x86-64

RELOCATION RECORDS FOR &lt;span class="o"&gt;[&lt;/span&gt;.text]:
OFFSET           TYPE              VALUE
000000000000001a R_X86_64_PC32     name-0x0000000000000004


RELOCATION RECORDS FOR &lt;span class="o"&gt;[&lt;/span&gt;.eh_frame]:
OFFSET           TYPE              VALUE
0000000000000020 R_X86_64_PC32     .text



vagrant@precise64:/vagrant_data/link_test&lt;span class="nv"&gt;$ &lt;/span&gt;objdump &lt;span class="nt"&gt;-d&lt;/span&gt; main.o

main.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &amp;lt;main&amp;gt;:
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    &lt;span class="nv"&gt;$0x10&lt;/span&gt;,%rsp
   8:	c7 45 &lt;span class="nb"&gt;fc &lt;/span&gt;0a 00 00 00 	movl   &lt;span class="nv"&gt;$0xa&lt;/span&gt;,-0x4&lt;span class="o"&gt;(&lt;/span&gt;%rbp&lt;span class="o"&gt;)&lt;/span&gt;
   f:	8b 45 &lt;span class="nb"&gt;fc             	&lt;/span&gt;mov    &lt;span class="nt"&gt;-0x4&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;%rbp&lt;span class="o"&gt;)&lt;/span&gt;,%eax
  12:	89 c7                	mov    %eax,%edi
  14:	b8 00 00 00 00       	mov    &lt;span class="nv"&gt;$0x0&lt;/span&gt;,%eax
  19:	e8 00 00 00 00       	callq  1e &amp;lt;main+0x1e&amp;gt;
  1e:	c9                   	leaveq
  1f:	c3                   	retq

因为  main中 存在对 外部函数&lt;span class="o"&gt;(&lt;/span&gt;name.c 中name &lt;span class="o"&gt;)&lt;/span&gt; 的调用，所以 call name 命令 的地址 需要被 ld 调整修改，即是 .rel.text 段中需要记录的信息. 在  重定位表 中， offset 代表 改需要被重定位的符号，在段中的偏移，
main.o 中的 rel.text name中的offset 为1a， 即是 main.o 中的代码段 callq 的地址部分。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h5 id="common--块"&gt;common  块&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;符号抉择： 如果链接的输入文件中， 存在多个相同的符号类型，该如何选择？  因为链接器本身并不支持符号类型， 变量，函数定义对于编译器 是透明的。&lt;/li&gt;
  &lt;li&gt;符号类型 不一致的情况 主要由如下三点：
    &lt;ul&gt;
      &lt;li&gt;
        &lt;ol&gt;
          &lt;li&gt;两个或者两个以上的 强符号类型不一致&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;ol&gt;
          &lt;li&gt;有一个强符号，其他都是 弱符号， 出现类型不一致&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;ol&gt;
          &lt;li&gt;两个或两个以上 弱符号类型不一致&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;对于1  无额外处理，即： 链接器直接抛出错误。 2， 3 情况 则需要 common块（common block）机制 来进行处理， common块 很简单， 当不同的 目标文件需要的common块 空间大小不一致时， 以最大的那块为准&lt;/li&gt;
      &lt;li&gt;弱符号： 即是非强符号， 强符号有： 函数定义， 全局变量， 初始化的内部变量，&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ABI： ld 能不能 链接 两个不同编译器 编译出来的目标文件呢？ 能够 满足的条件的目标文件 需要满足如下条件：
    &lt;ul&gt;
      &lt;li&gt;采用相同的文件格式&lt;/li&gt;
      &lt;li&gt;同样的符号修饰标准&lt;/li&gt;
      &lt;li&gt;变量的内存分布方式相同(大端、小端)&lt;/li&gt;
      &lt;li&gt;函数的调用方式相同 （参数push stack的顺序， 是否 使用 寄存器代替stack ）&lt;/li&gt;
      &lt;li&gt;etc…&lt;/li&gt;
      &lt;li&gt;规范这些的即是 二进制兼容性 ABI  (Application Binary Interface)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="静态链接-一种语言的开发环境-往往带有语言库这些苦-就是对操作系统的api-封装其实一个静态库可以简单的堪称一组目标文件的集合很多目标文件经过压缩打包后-形成的一个文件-比如linux-下-usrliblibca"&gt;静态链接: 一种语言的开发环境 往往带有语言库，这些苦 就是对操作系统的api 封装，其实一个静态库可以简单的堪称一组目标文件的集合，很多目标文件经过压缩打包后 形成的一个文件， 比如linux 下 /usr/lib/libc.a&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;glic 本身是c语言开发的， 他有上千个 C语言源代码文件组成， 编译完成后 有相同数量的 目标文件（上千个） 比如 printf.o scanf.o fread.o&lt;/li&gt;
  &lt;li&gt;把这些零散的目标文件直接提供给 开发者，造成组织上的不便， 人们采用 ar 压缩程序将目标文件组合到一起，并对其进行编号索引，以便于查找和检索，形成了lib.a 静态库文件.&lt;/li&gt;
  &lt;li&gt;可以使用ar -t libc.a 来查看文件&lt;/li&gt;
  &lt;li&gt;gcc -static –verbose main.c 可以打印详细的 编译过程&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="链接脚本控制-即是-控制ld-参数的方式"&gt;链接脚本控制： 即是 控制ld 参数的方式：&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;使用命令行指定参数， 比如ld -e -o&lt;/li&gt;
  &lt;li&gt;将连接指令存放在目标文件中， 编译器 会通过此类方法 向链接器 传递指令，比如visual c++ 将参数 放在 PE目标文件的 .drectve 段&lt;/li&gt;
  &lt;li&gt;链接控制脚本， 单独将连接配置放到一个 .lds 文件中， 详细的内容 需要查看参考资料&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="动态连接-页映射"&gt;动态连接: 页映射，&lt;/h3&gt;
&lt;h4 id="装载的方式-程序执行时所需要的指令和数据-都必须在内存中-才能够正常运行将程序的指令和数据-装载到内存中-就称为-装载覆盖装入overlay-和页面映射-paging-是典型的两种装载方法"&gt;装载的方式： 程序执行时所需要的指令和数据 都必须在内存中 才能够正常运行。将程序的指令和数据 装载到内存中 就称为 装载。覆盖装入（overlay） 和页面映射 (Paging) 是典型的两种装载方法。&lt;/h4&gt;
&lt;h5 id="页映射"&gt;页映射：&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;将内存和磁盘中的 数据和指令 按照 页（page） 为单位划分为若干个页，即 装载和操作的单位是页。&lt;/li&gt;
  &lt;li&gt;操作系统角度看 可执行文件的装载：&lt;/li&gt;
  &lt;li&gt;在 程序中使用物理地址直接进行操作时，都需要硬件的MMU 进行 虚拟地址 到 page 的地址转换功能，&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="进程的建立"&gt;进程的建立：&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;创建一个独立的虚拟地址空间
        &lt;ul&gt;
          &lt;li&gt;只需要分配一个页目录 即可， 甚至不需要设定页面映射关系，可以等到后面程序发生页错误的时候 在进行设置&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;读取可执行文件头， 并建立 虚拟空间到 可执行文件的映射关系
        &lt;ul&gt;
          &lt;li&gt;虚拟空间 与 可执行文件的映射关系。 当 发生缺页错误时，操作系统 应该知道 当前所需页 在可执行文件中的哪一个位置，这就是这步骤的目的&lt;/li&gt;
          &lt;li&gt;该数据结构 只保存在 操作系统内部，Linux 将 进程虚拟空间中的一个段 叫做 虚拟内存区域(virtual Memory Area)  操作系统创建进程后&lt;/li&gt;
          &lt;li&gt;会在进程相应的数据结构中设定一个 .text 段的VMA&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;将CPU 的PIC 寄存器 设定为 可执行文件的文件入口地址， 启动运行
        &lt;ul&gt;
          &lt;li&gt;操作系统通过设定CPU的执行寄存器将控制权交给 进程，由此进程开始执行。 看似简单，操作系统层面比较复杂， 涉及到内核堆栈到用户堆栈的切换，CPU运行权限的切换， 等&lt;/li&gt;
          &lt;li&gt;进程角度则 认为操作系统执行了一个跳转指令 到 可执行文件的入口地址， ELF 文件头中的 入口地址&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="进程虚拟空间分布"&gt;进程虚拟空间分布：&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;elf 文件 链接视图 与 执行视图&lt;/li&gt;
  &lt;li&gt;elf 映射到 内存时， 当段的数量增多，就会 产生空间浪费问题， 因为 是以系统的页大小问映射单位，段 映射的长度都是系统页的整数倍。如果不是，那么段 多余的部分也将映射 一个页，那么如何减少空间浪费呢？&lt;/li&gt;
  &lt;li&gt;操作系统视角看 可执行文件，我并不关心 文件的 各个段的内容，我们只关心与装载相关的 权限问题 （即 段是否可以被修改，共享等）， 对于相同权限的段，我们将他们合并到一起当做 一个段进行映射，比如.text .init。 段的权限组合有以下几种：&lt;/li&gt;
  &lt;li&gt;以代码段 为代表的权限为 可读可执行的段&lt;/li&gt;
  &lt;li&gt;以数据段和bss段为代表的权限为 可读可写的段&lt;/li&gt;
  &lt;li&gt;以只读数据段为代表的权限为 只读的段&lt;/li&gt;
  &lt;li&gt;Segment: elf 引入segment，一个segment 包含一个或多个属性类型的section，将.text 与 .init 段合并在一起看做一个 segment&lt;/li&gt;
  &lt;li&gt;装载时候就可以 一起映射。也就说 映射以后 在进程的虚拟空间中 只有一个对应的VMA， 这样的好处就是 明显的减少了 页面的内部碎片&lt;/li&gt;
  &lt;li&gt;Segment 概念实际上上从 装载的角度 重新划分elf 的各个段， 将目标文件连接成可执行文件的时候，链接器会尽量将相同权限属性的各个段 分配在同一Sgemtn中&lt;/li&gt;
  &lt;li&gt;而系统正式按照Segment 而不是section进行映射的&lt;/li&gt;
  &lt;li&gt;再看了通篇 概念之后，我们可能会问， 为什么 最后要按照 segment 把文件组合呢？ 在前面的 重定位 章节中，我们以为 地址的计算是按照 合并各个段 然后进行计算的，&lt;/li&gt;
  &lt;li&gt;其实不是的， &lt;em&gt; VMA 即是最后的 虚拟地址， 重定位的 地址计算也是按照 VMA 得来的。也即是说 链接最后的结果 就是 装载视图。链接视图只是其中的过程而已。&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;描述 segment 的 结构叫做程序头 (Program Header ) 描述了 elf文件该如何被操作系统 映射到进程的 虚拟空间。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id="堆栈在进程的虚拟空间中同样是以-vma-存在的-很多情况下一个进程的堆和栈-都有一个对应的vma-linux可以通过proc-来查看进程的-虚拟空间分布"&gt;堆栈：在进程的虚拟空间中，同样是以 VMA 存在的， 很多情况下，一个进程的堆和栈 都有一个对应的VMA， Linux可以通过/proc 来查看进程的 虚拟空间分布&lt;/h5&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;vagrant@precise64:/vagrant_data/link_test&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;sleep &lt;/span&gt;100 &amp;amp;
&lt;span class="o"&gt;[&lt;/span&gt;1] 3834
vagrant@precise64:/vagrant_data/link_test&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;cat&lt;/span&gt; /proc/3834/maps
00400000-00406000 r-xp 00000000 &lt;span class="nb"&gt;fc&lt;/span&gt;:00 2359461                            /bin/sleep
00605000-00606000 r--p 00005000 &lt;span class="nb"&gt;fc&lt;/span&gt;:00 2359461                            /bin/sleep
00606000-00607000 rw-p 00006000 &lt;span class="nb"&gt;fc&lt;/span&gt;:00 2359461                            /bin/sleep
01ee5000-01f06000 rw-p 00000000 00:00 0                                  &lt;span class="o"&gt;[&lt;/span&gt;heap]
7fba0d791000-7fba0da96000 r--p 00000000 &lt;span class="nb"&gt;fc&lt;/span&gt;:00 3413573                    /usr/lib/locale/locale-archive
7fba0da96000-7fba0dc4d000 r-xp 00000000 &lt;span class="nb"&gt;fc&lt;/span&gt;:00 2752737                    /lib/x86_64-linux-gnu/libc-2.15.so
7fba0dc4d000-7fba0de4c000 &lt;span class="nt"&gt;---p&lt;/span&gt; 001b7000 &lt;span class="nb"&gt;fc&lt;/span&gt;:00 2752737                    /lib/x86_64-linux-gnu/libc-2.15.so
7fba0de4c000-7fba0de50000 r--p 001b6000 &lt;span class="nb"&gt;fc&lt;/span&gt;:00 2752737                    /lib/x86_64-linux-gnu/libc-2.15.so
7fba0de50000-7fba0de52000 rw-p 001ba000 &lt;span class="nb"&gt;fc&lt;/span&gt;:00 2752737                    /lib/x86_64-linux-gnu/libc-2.15.so
7fba0de52000-7fba0de57000 rw-p 00000000 00:00 0
7fba0de57000-7fba0de79000 r-xp 00000000 &lt;span class="nb"&gt;fc&lt;/span&gt;:00 2756455                    /lib/x86_64-linux-gnu/ld-2.15.so
7fba0e06c000-7fba0e06f000 rw-p 00000000 00:00 0
7fba0e077000-7fba0e079000 rw-p 00000000 00:00 0
7fba0e079000-7fba0e07a000 r--p 00022000 &lt;span class="nb"&gt;fc&lt;/span&gt;:00 2756455                    /lib/x86_64-linux-gnu/ld-2.15.so
7fba0e07a000-7fba0e07c000 rw-p 00023000 &lt;span class="nb"&gt;fc&lt;/span&gt;:00 2756455                    /lib/x86_64-linux-gnu/ld-2.15.so
7fff892a4000-7fff892c5000 rw-p 00000000 00:00 0                          &lt;span class="o"&gt;[&lt;/span&gt;stack]
7fff89388000-7fff89389000 r-xp 00000000 00:00 0                          &lt;span class="o"&gt;[&lt;/span&gt;vdso]
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  &lt;span class="o"&gt;[&lt;/span&gt;vsyscall]       
对于 输出结构 的描述：

第一列为 VMA 的地址范围， 第二列 为 权限， 第三列 为偏移，标识VMA对应的Segment 在映射文件中的偏移， 
第四列为 映射文件 所在设备的主、次设备号 （可以为0 即没有映射文件 比如stack heap）， 第五列： 映射文件的节点号， 最后为 映射文件路径
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="进程栈初始化-进程运行存在一些环境变量以及-运行参数-常见的做法-是-操作系统-在进程启动时-将这些基本信息-提前保存到-进程的虚拟空间栈中"&gt;进程栈初始化： 进程运行存在一些环境变量以及 运行参数， 常见的做法 是 操作系统 在进程启动时 将这些基本信息 提前保存到 进程的虚拟空间栈中&lt;/h4&gt;

&lt;h3 id="动态链接"&gt;动态链接：&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;为什么需要动态链接： 1） 静态链接 对于计算机内存和磁盘的空间浪费非常严重， 特别是多进程的时候，极大的浪费了内存空间，  2） 更新、部署 困难， 基础库的更新 导致 所有的依赖程序 需要重新编译&lt;/li&gt;
  &lt;li&gt;解决方法即是： 把程序的模块相互分隔开来，形成独立的文件，而不再将他们静态的链接在一起。即是： 不对那些组成程序的目标文件进行连接，等到程序要运行时 才进行连接。&lt;/li&gt;
  &lt;li&gt;把链接过程推迟到了运行时再进行，这就是动态链接的基本思想
    &lt;h4 id="动态链接过程的优势-动态链接简单过程"&gt;动态链接过程的优势； 动态链接简单过程&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;Programe1 依赖  Lib.o&lt;/li&gt;
  &lt;li&gt;Programe2 依赖  Lib.o&lt;/li&gt;
  &lt;li&gt;运行 Programe1 时，系统加载 Programe1.o 然后加载依赖 Lib.o 如果Lib.o 依赖其他文件，则依次递归加载所有依赖。&lt;/li&gt;
  &lt;li&gt;当所有依赖关系加载完成之后， 开始链接工作，链接工作 与静态链接非常相似， 包括 符号解析，地址重定位等。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;完成上述工作之后，将控制权交给Programe1.o 的程序入口处。程序开始运行，&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;当运行Program2时，系统加载Program2.o，但是不在加载 Lib.o 因为系统已经在运行Program1时，加载了 Lib.o
    &lt;ul&gt;
      &lt;li&gt;
        &lt;ol&gt;
          &lt;li&gt;通过以上过程，可以发现 动态链接 节省了一次Lib.o 的依赖 加载。&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;ol&gt;
          &lt;li&gt;在其中如果更新Lib.o 时，不需要 重新编译 Programe1, 与 Programe2 仅仅 更新Lib.o 在下一次重新运行Program1，2时，即可使用最新的依赖
            &lt;h5 id="程序可扩展性和兼容性"&gt;程序可扩展性和兼容性：&lt;/h5&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;动态链接 可以在 程序运行时 动态的选择加载各种程序模块，这个特点被人们用来开发 插件功能&lt;/li&gt;
      &lt;li&gt;动态链接可以加强程序的兼容性，  一个程序可以再不同的平台运行时 可以动态的链接到右操作系统 提供的动态链接库，比如 程序依赖printf 函数， 操作系统 A与 B 只需要提供 一样的printf 接口，即可实现 程序在操作系统AB上的运行
        &lt;h5 id="动态链接-的基本实现"&gt;动态链接 的基本实现：&lt;/h5&gt;
      &lt;/li&gt;
      &lt;li&gt;动态链接涉及到 各个文件的装载， 需要操作系统的支持， 因为在动态链接的情况下，进程的虚拟地址空间分布 会比 静态链接 情况下更加复杂，&lt;/li&gt;
      &lt;li&gt;内存管理、内存共享、进程线程等机制，在 动态链接下也会有一些变化，Linux 中动态链接文件 称为 动态共享对象(DSO Dynamic Shared Objects) 以.so 为扩展名， Windows中 动态链接文件称为 动态链接库(Dynamical Linking Library) .dll 为扩展名&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="动态链接-导致的问题-因为动态链接-将在程序编译阶段的工作推迟到了-运行时间段导致-程序每次被装载时-都要进行-重新进行连接导致一些程序性能上的损失性能损失-大约在5以下这些损失-换来-程序在空间上的-节省和程序构建升级上的便利性是相当值得的"&gt;动态链接 导致的问题： 因为动态链接 将在程序编译阶段的工作推迟到了 运行时间段，导致 程序每次被装载时 都要进行 重新进行连接。导致一些程序性能上的损失，性能损失 大约在5%以下。这些损失 换来 程序在空间上的 节省和程序构建升级上的便利性，是相当值得的。&lt;/h4&gt;

&lt;h3 id="地址无关代码"&gt;地址无关代码：&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;装载时重定位： 为了能够共享对象在任意地址被装载， 第一个方法为： 装载时重定位， 在链接时，对所有 绝对地址的应用不做重定位，而把这一步推迟到装载时在完成，即：一旦模块装载地址确定 即目标地址确定，name系统就对模块中的所有绝对地址 引用进行重定位，即， 系统需要遍历所有的重定位表，对所有 符号的地址引用进行修改。&lt;/li&gt;
  &lt;li&gt;静态链接中提到的重定位： 链接时重定位， 现在为 装载时重定位。&lt;/li&gt;
  &lt;li&gt;存在问题： 指令中对绝对地址函数的应用，被修改好，不能很好的在多个进程中共享。&lt;br /&gt;
** 地址无关代码 的基本思想： 将指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分可以保持不变，而数据部分可以在每个进程中拥有一个副本。 即是地址无关代码技术(PIC position-indenpendent Code)&lt;/li&gt;
  &lt;li&gt;具体解决方法：共享对象模块中的地址应用 分为两类： 模块内部引用、模块外部应用 按照应用类型不同 又分为 函数引用和数据引用， 可分为4类：
    &lt;ul&gt;
      &lt;li&gt;
        &lt;ol&gt;
          &lt;li&gt;模块内部的函数调用、跳转&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;ol&gt;
          &lt;li&gt;模块内部的数据访问， 如模块中定义的全局变量、静态变量&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;ol&gt;
          &lt;li&gt;模块外部的函数调用、跳转&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;ol&gt;
          &lt;li&gt;模块外部的数据访问， 如 其他模块中定义的全局变量&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;条件对应的 解决方法为：
    &lt;ul&gt;
      &lt;li&gt;
        &lt;ol&gt;
          &lt;li&gt;即是：相对 位置调用， 因为同在模块内，函数间 的地址相对位置是确定的&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;ol&gt;
          &lt;li&gt;相对寻址，我们知道， 一个模块前面一般是若干页的代码 后面跟 若干页 的数据，这些页 的相对位置是固定的， 所以 可以使用 指定+ 相对位置 间隔 来访问模块内部的数据 （这里是否存在其他问题呢？ 确定 系统装载时候， 代码与数据段的相对位置是固定的吗？）&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;ol&gt;
          &lt;li&gt;模块间的 地址访问 （数据访问、函数地址访问） 比较麻烦， 因为 模块间的地址访问 需要等到装载时候才能决定， 要使该类 代码地址无关，基本思想： 把地址相关的部分放到数据段里面，具体 ELF 的做法就是在数据段里面建立一个指向这些变量的数组指针， 称为 全局偏移表(Global offset Table GOT) 当代吗需要引用该全局变量时候，可以通过GOT中的相对应的项间接引用, 图示如下：&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;当指令中：需要访问变量b时，程序会找到GOT， 然后根据GOT中的变量所对应的项找到变量的目标地址， 链接器 在装载模块时，会查找每个变量所在的地址，然后填充GOT中的各个项， 以保证 项目地址指向正确。因为GOT 在数据段中，所以他可以在装载时候被修改，并且每个进程都有独立的副本存在。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;gcc -fPIC -shared -o name.so name.c&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;
      &lt;ol&gt;
        &lt;li&gt;同4中一样， 使用 GOT 来保存 函数地址&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;指令跳转、调用&lt;/th&gt;
      &lt;th&gt;数据访问&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;模块内部&lt;/td&gt;
      &lt;td&gt;相对跳转和调用&lt;/td&gt;
      &lt;td&gt;相对地址访问&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;模块外部&lt;/td&gt;
      &lt;td&gt;间接跳转和调用(GOT)&lt;/td&gt;
      &lt;td&gt;间接访问(GOT)&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;-fpic 与 -fPIC 参数的区别: -fPIC 产生的代码要更大， 更跨平台， 而-fpic 产生的代码更小， 也更快，但是存在一些限制，更与硬件相关&lt;/p&gt;

&lt;h4 id="由上可见-动态链接-会使程序变慢的-原因有-1-动态装载重定位计算-2-共享代码段中-通过got来访问数据调用函数"&gt;由上可见： 动态链接 会使程序变慢的 原因有： 1） 动态装载，重定位计算， 2） 共享代码段中 通过GOT来访问数据，调用函数&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;延迟绑定（Procedure Linkage Table）:  共享模块加载时候，程序需要浪费不少时间来 用于解决模块之间的函数应用的符号查找 以及重定位。 而在实际中 大量的函数很少被使用到， 所以 ELF采用了一种叫做延迟绑定的做法， 基本的思想就是 当函数第一次被用到时候 才进行绑定（符号查找，重定位等）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id="动态链接-文件启动-顺序-与静态链接情况基本一致-首先操作系统-读取可执行文件-的头部检查合法性-并从-header中读取各个segment-映射到进程虚拟空间的对应文职-这时候差异开始显现-静态链接情况下-操作系统将-控制权直接交给-可执行文件的入口地址然后程序开始执行-动态链接情况下-操作系统并不能将控制权交给可执行文件-因为其-依赖的-很多共享对象还没有加载起来所以操作系统-先启动一个动态链接器由动态链接器-来进行一系列的初始化工作并进行动态链接工作当所有-链接工作完成以后-动态联机器将-控制权-交给可执行文件-的入口地址程序开始正式执行"&gt;动态链接 文件启动 顺序： 与静态链接情况基本一致， 首先操作系统 读取可执行文件 的头部，检查合法性， 并从 header中读取各个Segment 映射到进程虚拟空间的对应文职。 这时候差异开始显现， 静态链接情况下， 操作系统将 控制权直接交给 可执行文件的入口地址，然后程序开始执行。 动态链接情况下： 操作系统并不能将控制权交给可执行文件， 因为其 依赖的 很多共享对象，还没有加载起来，所以操作系统 先启动一个动态链接器，由动态链接器 来进行一系列的初始化工作，并进行动态链接工作，当所有 链接工作完成以后， 动态联机器将 控制权 交给可执行文件 的入口地址，程序开始正式执行&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;动态链接器的路径配置：  .interp 段 中 为 ld 的具体路径&lt;/li&gt;
  &lt;li&gt;动态符号表： 为了完成链接， 需要 所依赖的符号和相关文件的信息， 在静态链接中 有 段为 .symtab (Symbol Table) 动态链接中 则为 Dynmic Symbol Table .dynsym 其中只保存 动态链接相关的符号。很多动态链接库中同时存在.dynsym 以及 .symtab 两个表， .symtab 中 保存了所有的符号。其中的符号 字符串 则保存在 .dynstr (Dynamic String Table) 其中往往还有 符号哈希表 用于加快符号查找速度&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;readelf -sD  lib.so&lt;/p&gt;

&lt;p&gt;动态链接 需要在装载时候 进行重定位， 对于 使用 PIC 模式编译的（地址无关代码） 则只需要对GOT进行 重定位， 非PIC编译的，则在装载时候 重定位（即 代码段 也被 修改，而无法与其他程序共享） &lt;br /&gt;
重定位结构： 动态链接中 重定位表 为.rel.dyn, .rel.plt  对应于静态链接中的 .rel.text, .rel.data 分别对应  .got （数据段）, 以及 .got.plt （代码段，函数调用地址的修正）&lt;/p&gt;

&lt;p&gt;root@precise64:/vagrant_data/link_test# readelf -r main.so&lt;/p&gt;

&lt;p&gt;Relocation section ‘.rela.dyn’ at offset 0x420 contains 4 entries:&lt;br /&gt;
  Offset          Info           Type           Sym. Value    Sym. Name + Addend&lt;br /&gt;
000000201010  000000000008 R_X86_64_RELATIVE                    0000000000201010&lt;br /&gt;
000000200fd0  000300000006 R_X86_64_GLOB_DAT 0000000000000000 &lt;strong&gt;gmon_start&lt;/strong&gt; + 0&lt;br /&gt;
000000200fd8  000400000006 R_X86_64_GLOB_DAT 0000000000000000 _Jv_RegisterClasses + 0&lt;br /&gt;
000000200fe0  000500000006 R_X86_64_GLOB_DAT 0000000000000000 __cxa_finalize + 0&lt;/p&gt;

&lt;p&gt;Relocation section ‘.rela.plt’ at offset 0x480 contains 2 entries:&lt;br /&gt;
  Offset          Info           Type           Sym. Value    Sym. Name + Addend&lt;br /&gt;
000000201000  000200000007 R_X86_64_JUMP_SLO 0000000000000000 name + 0&lt;br /&gt;
000000201008  000500000007 R_X86_64_JUMP_SLO 0000000000000000 __cxa_finalize + 0&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;动态链接时候，进程堆栈的初始化信息： 当操作系统将控制权交给 动态链接器的时候， 除了 进程初始化时候的，堆栈里面关于进程执行环境和命令行参数等， 还包含 不少的 动态链接器所需要的辅助信息，比如 可执行文件的入口地址等，&lt;/li&gt;
  &lt;li&gt;这些信息往往由操作系统传递给动态链接器&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="动态链接器自举-因为动态链接器-也是一个共享库而动态链接器是操作系统的程序入口-所以动态链接器如何递归的解决自己的依赖关系完成启动是一个-非常有意思的事情"&gt;动态链接器自举： 因为动态链接器 也是一个共享库，而动态链接器是操作系统的程序入口， 所以动态链接器如何递归的解决自己的依赖关系，完成启动，是一个 非常有意思的事情。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;动态链接器完成自举之后，链接器将 可执行文件和链接器本身的符号表合并到一个符号表中， 称为 全局符号表&lt;/li&gt;
  &lt;li&gt;之后 开始寻找可执行文件所依赖的共享对象， 在.dynamic 段中， 类型为NEEDED 为 可执行文件所依赖的 共享对象，由此 链接器可以获得 可执行文件的所需要的所有的共享对象，其组成的一个集合&lt;/li&gt;
  &lt;li&gt;称为 装载集合， 从装载集合中取出来一个文件，打开 并读取对应的ELF header 和.dynamic 段，将其所依赖的其他的共享对象 加入到家在集合中，如此递归的加载所有依赖的共享对象&lt;/li&gt;
  &lt;li&gt;常见的加载算法为 广度优先&lt;/li&gt;
  &lt;li&gt;当新的共享对象被加载进来的时候，他的符号表会被合并到全局符号表中， 所以 当所有的共享对象 被装载进来的时候，全局符号表里面将函数进程中所有的动态链接所需要的符号&lt;/li&gt;
  &lt;li&gt;所以动态链接器的加载顺序决定了符号的优先级&lt;/li&gt;
  &lt;li&gt;链接器开始变量可执行文件和每个共享对象的重定位表，将他们的 .got.plt 中的每个需要重定位的位置进行修正， 因为此时动态链接器已经拥有了进程的全局符号表，所以这个修正过程会比较容易&lt;/li&gt;
  &lt;li&gt;重定位完成后，如果某个共享对象 存在.init 段， 则动态链接器 会执行.init 段中的代码， 泳衣实现共享对象特有的初始化代过程， 比如 c++中 全局对象的构造过程， 共享对象中的 .finit 段，则在进程退出时执行 实现共享对象 的析构类型操作&lt;/li&gt;
  &lt;li&gt;与 链接器执行的.init 对比，则为 可执行文件的 .init, .finit段的执行者， 需要在后面补充
    &lt;h5 id="符号优先级"&gt;符号优先级：&lt;/h5&gt;
  &lt;/li&gt;
  &lt;li&gt;动态链接器 按照 各个模块之间依赖关系，对他们进行装载并将他们的符号 并入到 全局符号表。 那么就有可能 两个不同的模块定义了 同一个符号，导致符号歧义，&lt;/li&gt;
  &lt;li&gt;该现象称为 共享对象全局符号介入 问题，  那么链接器 如何 解决此类问题呢？ 其规则为： 当一个符号需要加入全局符号表时，如果相同的符号名已经存在，对于&lt;/li&gt;
  &lt;li&gt;则后加的符号 被忽略。由于存在该类问题， 所以 当程序中存在大量的 共享对象 时候，应该非常小心符号的重名问题， 如果 两个符号重名  又执行不同的功能&lt;/li&gt;
  &lt;li&gt;name程序运行时 可能会将所有的该符号的应用解析到 第一个被加入全局符号表的符号，从而导致 莫名其妙的错误&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id="如何-避免全局符号介入问题-对于-导出-符号全局符号-是不可能解决的然而-内部函数调用-可以使用-static-关键字-来避免其成为-全局符号-而被-其他模块覆盖则在内部-程序直接使用-内部-相对地址调用也加快了-程序的调用速度-即-不适用-gotplt-来-进行-间接跳转"&gt;如何 避免全局符号介入问题： 对于 导出 符号（全局符号） 是不可能解决的，然而 内部函数调用， 可以使用 static 关键字 来避免其成为 全局符号 而被 其他模块覆盖，则在内部 程序直接使用 内部 相对地址调用，也加快了 程序的调用速度。 即 不适用 .got.plt 来 进行 间接跳转。&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;则 更一般的规律为： 文件内部函数调用 都采用的 .got.plt 进行跳转调用，除非 被调用函数为static 则不会成为符号，而是用 内部相对地址调用&lt;/li&gt;
  &lt;li&gt;
    &lt;h5 id="动态链接器-的接个问题"&gt;动态链接器 的接个问题：&lt;/h5&gt;
  &lt;/li&gt;
  &lt;li&gt;动态链接器 本身是 动态链接的还是 静态链接的？： 静态链接的， 因为 他不能依赖 与其他共享对象， 其存在的目的 即为 解决 其他elf 动态链接文件 的依赖关系的，所以不能存在依赖&lt;/li&gt;
  &lt;li&gt;动态链接器 本身必须是PIC 的吗？ 并不是， 动态链接器 的目的是帮助其他elf解决依赖关系，本身是否PIC  的 决定 其代码是否 能够共享。如果 PIC 则会更加简单一些，因为 非PIC的话，链接器在自举的时候 往往 还需要重定位自己的代码段&lt;/li&gt;
  &lt;li&gt;动态链接器 是否可以被当做可执行文件运行？ 可运行的话，其装载地址是多少？： 可以当做可执行文件来运行， 其装载地址 没有什么区别 几位 0x00000000 这是一个无效地址 ，作为共享库，内核在装载时， 会为期选择一个合适的装载地址
    &lt;h5 id="显式-运行时链接explicit-run-time-linking-即是程序在运行期间-可以主动的加载指定的-动态链接库-而共享对象-不需要任何的修改-即可-被-运行时装载"&gt;显式 运行时链接(Explicit Run-time Linking) 即是：程序在运行期间 可以主动的加载指定的 动态链接库， 而共享对象 不需要任何的修改 即可 被 运行时装载&lt;/h5&gt;
  &lt;/li&gt;
  &lt;li&gt;这种共享对象往往被叫做 动态装载库 (Dynamic Loading Library) 本质 上与 一般的共享对象 没有任何区别，只是 使用的角度不同而已&lt;/li&gt;
  &lt;li&gt;其理论上 与 可执行文件 依赖 共享对象 一样的执行方式&lt;/li&gt;
  &lt;li&gt;主要API有： dlopen  dlsym, dlerror, dlclose&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id="共享库的-组织方式"&gt;共享库的 组织方式：&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;因为共享对象的优点，导致 大量的程序开始使用共享对象，导致系统中存在数量极为庞大的共享对象， 所以操作系统一般会对共享对象的目录组织和使用方式 有一定的规定，即为 共享库，&lt;/li&gt;
  &lt;li&gt;共享库与共享对象没有任何区别，只是 共享库为共享对象的 组织方式 的另一个称呼 而已
    &lt;h6 id="共享库的兼容性"&gt;共享库的兼容性：&lt;/h6&gt;
  &lt;/li&gt;
  &lt;li&gt;兼容更新：所有的更新只是在原有的共享库基础上添加一些内容， 原接口保持不变&lt;/li&gt;
  &lt;li&gt;不兼容更新： 共享库改变了原有接口， 使用该共享库的原有接口的程序 无法运行&lt;/li&gt;
  &lt;li&gt;这里面讨论的接口为 ABI， 而非其他的接口， 导致ABI发生变化的有以下几种情况：&lt;/li&gt;
  &lt;li&gt;共享库的版本命名： 用于解决 兼容性问题。 使用命名规范来 明确兼容性。共享库的文件命名如下： libname.so.x.y.z&lt;/li&gt;
  &lt;li&gt;x 为主要版本号(Major version number)， y 为子版本号(Minor version number)， z为发布版本号(Release version number)&lt;/li&gt;
  &lt;li&gt;主版本号： 库的重大升级， 不同主版本号之间 是不兼容的，依赖旧版本共享库的程序 需要 重新编译 才能 使用最新的共享库版本， 或者 系统保留 旧的版本，旧程序才能正常运行&lt;/li&gt;
  &lt;li&gt;次版本号： 增量升级， 增加一些新的接口符号，保持原有的符号不变， 高的次要版本号 要 向后兼容低次要版本号的 共享库。 一个依赖 低次要版本号的程序 可以再 高次要版本号的共享库 下运行。&lt;/li&gt;
  &lt;li&gt;发布版本号： 对一些错误的修正、性能的改进等。  不添加新的接口 也不对 接口进行更改， 相同主版本号，次版本号，不同发布版本号 之间完全兼容&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
  </entry>
  <entry>
    <title>java shell docker</title>
    <link rel="alternate" href="http://geniousbar.github.io/2020/09/15/java-shell-docker/"/>
    <id>http://geniousbar.github.io/2020/09/15/java-shell-docker/</id>
    <published>2020-09-15T00:00:00+00:00</published>
    <updated>2021-05-06T02:40:44+00:00</updated>
    <summary type="html">&lt;h2 id="a-little-book-on-java-的总结"&gt;A Little Book on Java 的总结&lt;/h2&gt;
&lt;h4 id="basic"&gt;Basic&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;编译 与 运行&lt;br&gt;
编译: javac First.java 产生一个 First.class 文件&lt;br&gt;
运行：java First 将运行 编译之后 First.class
    &lt;ul&gt;
      &lt;li&gt;java  编译器 将 源代码 中的每个 class 转变为 对应的 class file 并存储 其 字节码&lt;/li&gt;
      &lt;li&gt;有 main 函数的 class才能够运行，一个项目中存在多个class 有 main 函数 是为了 将 项...&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    <content type="html">&lt;h2 id="a-little-book-on-java-的总结"&gt;A Little Book on Java 的总结&lt;/h2&gt;
&lt;h4 id="basic"&gt;Basic&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;编译 与 运行&lt;br /&gt;
编译: javac First.java 产生一个 First.class 文件&lt;br /&gt;
运行：java First 将运行 编译之后 First.class
    &lt;ul&gt;
      &lt;li&gt;java  编译器 将 源代码 中的每个 class 转变为 对应的 class file 并存储 其 字节码&lt;/li&gt;
      &lt;li&gt;有 main 函数的 class才能够运行，一个项目中存在多个class 有 main 函数 是为了 将 项目分为不同的 可以运行的单元 方便测试&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;基本类型
    &lt;ul&gt;
      &lt;li&gt;Number, float, double, int&lt;/li&gt;
      &lt;li&gt;Character: char a = ’a’;&lt;/li&gt;
      &lt;li&gt;Boolean: boolean true and false&lt;/li&gt;
      &lt;li&gt;Strings: String title = “A Little Book on Java”;&lt;/li&gt;
      &lt;li&gt;Array: datatype[] ArrayName = new datatype[ArraySize]; 当 使用 index 超过 数组边界 时 会发生 ArrayIndexOutOfBoundsException 错误&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;流程控制语句
    &lt;ul&gt;
      &lt;li&gt;while loop&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight java"&gt;&lt;code&gt;  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;boolean&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="n"&gt;statement&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;for loop&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight java"&gt;&lt;code&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;initial&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;boolean&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;increment&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;st&lt;/span&gt;  &lt;span class="n"&gt;atement&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;if&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight java"&gt;&lt;code&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;boolean&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;statement&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="nf"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;boolean&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; 
  &lt;span class="n"&gt;statement&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;
  &lt;span class="n"&gt;statement&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;break;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;抽象机制&lt;/li&gt;
  &lt;li&gt;Procedures
    &lt;ul&gt;
      &lt;li&gt;its name,&lt;/li&gt;
      &lt;li&gt;what kinds of parameters it expects (if any),&lt;/li&gt;
      &lt;li&gt;what kind of result it might return.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;class
    &lt;ul&gt;
      &lt;li&gt;Syntax of Class Declarations&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight java"&gt;&lt;code&gt;  &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Hello&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;main method; java foo a b c, params as args array&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight java"&gt;&lt;code&gt;  &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Foo&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;String&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;[]){&lt;/span&gt;
        &lt;span class="cm"&gt;/* Body of main */&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;static variable &amp;amp; function and usage&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight java"&gt;&lt;code&gt;  &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Foo&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;showFoo&lt;/span&gt;&lt;span class="o"&gt;(){&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;

  &lt;span class="n"&gt;classname&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;methodname&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parameters&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// static method usage&lt;/span&gt;
  &lt;span class="n"&gt;classname&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;variablename&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// static variable usage&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;Visibility Issues （可见控制）: Public data and code is visible to all classes, while private data and code is visible only inside the class that contains it.&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;The Object Concept&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;The State of an Object (Instance variables)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight java"&gt;&lt;code&gt;  &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;PointIn3D&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;//Instance Variables&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;Constructors&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight java"&gt;&lt;code&gt;  &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;PointIn3D&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

     &lt;span class="c1"&gt;//Constructors&lt;/span&gt;
    &lt;span class="c1"&gt;//This constructor does not take parameters&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;PointIn3D&lt;/span&gt;&lt;span class="o"&gt;(){&lt;/span&gt;
      &lt;span class="cm"&gt;/* Initializing the fields of this object to the origin,
         a default point */&lt;/span&gt;
      &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
      &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
      &lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;//This constructor takes parameters&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;PointIn3D&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="no"&gt;X&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="no"&gt;Y&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="no"&gt;Z&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
      &lt;span class="cm"&gt;/* Initializing fields of this object to values specified by
         the parameters */&lt;/span&gt;
      &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;X&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
      &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;Y&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
      &lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;Z&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;Creating an Object&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight java"&gt;&lt;code&gt;  &lt;span class="c1"&gt;//Creates a PointIn3D object with coordinates (0, 0, 0)&lt;/span&gt;
  &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nf"&gt;PointIn3D&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
  &lt;span class="c1"&gt;//Creates a PointIn3D object with coordinates (10.2, 78, 1) new PointIn3D(10.2, 78, 1);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;Object References&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight java"&gt;&lt;code&gt;   &lt;span class="nc"&gt;ReferenceType&lt;/span&gt; &lt;span class="nc"&gt;ReferenceName&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

   &lt;span class="nc"&gt;PointIn3D&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;PointIn3D&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;Accessing the Fields of an Object&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight java"&gt;&lt;code&gt;   &lt;span class="nc"&gt;ReferenceName&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;FieldName&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;The Behavior of an Object
&lt;div class="highlight"&gt;&lt;pre class="highlight java"&gt;&lt;code&gt;    &lt;span class="nc"&gt;ObjectReference&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;InstanceMethodName&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;Parameter&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nc"&gt;List&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
  &lt;li&gt;The this reference: Inside an instance method, this is a reference to the object on which the instance method is invoked. Inside a constructor, this refers to the object that the constructor just created.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight java"&gt;&lt;code&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;PointIn3D&lt;/span&gt;&lt;span class="o"&gt;(){&lt;/span&gt;
    &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;z&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="nf"&gt;getX&lt;/span&gt;&lt;span class="o"&gt;(){&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;x&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;Inheritance: extends, super can use in subtype to call supertype methods&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;Rules for Method Lookup and Type Checking.
    &lt;ul&gt;
      &lt;li&gt;First the rules. Remember that there are two phases: compile time, which is when type checking is done and run time, which is when method lookup happens. Compile time is before run time.&lt;/li&gt;
      &lt;li&gt;The type checker has to say that a method call is OK at compile time.&lt;/li&gt;
      &lt;li&gt;All type checking is done based on what the declared type of a reference to an object is.&lt;/li&gt;
      &lt;li&gt;Subtyping is an integral part of type checking. This means if B is a subtype of A and there is a context that gets a B where A was expected there will not be a type error.&lt;/li&gt;
      &lt;li&gt;Method lookup is based on actual type of the object and not the declared type of the reference.&lt;/li&gt;
      &lt;li&gt;When there is overloading (as opposed to overriding) this is resolved by type-checking.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight java"&gt;&lt;code&gt;  &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;myInt&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
      &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;myInt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
          &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
      &lt;span class="o"&gt;}&lt;/span&gt;
      &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;getval&lt;/span&gt;&lt;span class="o"&gt;(){&lt;/span&gt;
          &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
      &lt;span class="o"&gt;}&lt;/span&gt;
      &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;increment&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
          &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;n&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
      &lt;span class="o"&gt;}&lt;/span&gt;
      &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;myInt&lt;/span&gt; &lt;span class="nf"&gt;add&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;myInt&lt;/span&gt; &lt;span class="no"&gt;N&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
          &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nf"&gt;myInt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;n&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="no"&gt;N&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getval&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
      &lt;span class="o"&gt;}&lt;/span&gt;
      &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;show&lt;/span&gt;&lt;span class="o"&gt;(){&lt;/span&gt;
          &lt;span class="nc"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
      &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;

  &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;gaussInt&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;myInt&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;//represents the imaginary part&lt;/span&gt;
      &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;gaussInt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
          &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
          &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;m&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
      &lt;span class="o"&gt;}&lt;/span&gt;
      &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;show&lt;/span&gt;&lt;span class="o"&gt;(){&lt;/span&gt;
          &lt;span class="nc"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"realpart is: "&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getval&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;" imagpart is: "&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
      &lt;span class="o"&gt;}&lt;/span&gt;
      &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;realpart&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
          &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nf"&gt;getval&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
              &lt;span class="o"&gt;;}&lt;/span&gt;
      &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;imagpart&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
          &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
      &lt;span class="o"&gt;}&lt;/span&gt;
      &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;gaussInt&lt;/span&gt; &lt;span class="nf"&gt;add&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gaussInt&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
          &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nf"&gt;gaussInt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;realpart&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;realpart&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt;
                              &lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;imagpart&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;imagpart&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
      &lt;span class="o"&gt;}&lt;/span&gt;
      &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
          &lt;span class="n"&gt;gaussInt&lt;/span&gt; &lt;span class="n"&gt;kreimhilde&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;gaussInt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
          &lt;span class="n"&gt;kreimhilde&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;show&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
          &lt;span class="n"&gt;kreimhilde&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;increment&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
          &lt;span class="n"&gt;kreimhilde&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;show&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
          &lt;span class="nc"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Now we watch the subtleties of overloading."&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
          &lt;span class="n"&gt;myInt&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;myInt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
          &lt;span class="n"&gt;gaussInt&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;gaussInt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
          &lt;span class="n"&gt;gaussInt&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
          &lt;span class="n"&gt;myInt&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
          &lt;span class="n"&gt;myInt&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;add&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//this does type System.out.print("the value of d is:&lt;/span&gt;

          &lt;span class="c1"&gt;// 这里面并没有错误， add 方法为 重载，而非重写，因为 方法签名不同。 同样会通过type check&lt;/span&gt;
          &lt;span class="c1"&gt;// w = z.add(b);&lt;/span&gt;
          &lt;span class="c1"&gt;// w = b.add(z);&lt;/span&gt;
          &lt;span class="n"&gt;w&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gaussInt&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="na"&gt;add&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//this does type check System.out.print("the value of w is: ");&lt;/span&gt;
          &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;show&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
          &lt;span class="n"&gt;myInt&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;add&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//will this typecheck? System.out.print("the value of c is: ");&lt;/span&gt;
          &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;show&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
      &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;
  &lt;li&gt;The Exception Object
    &lt;ul&gt;
      &lt;li&gt;分为两类： unchecked exceptions and checked exceptions.&lt;/li&gt;
      &lt;li&gt;所有的exception 都发生在 runtime， 因为不是的话，要啥编译检查？&lt;/li&gt;
      &lt;li&gt;Unchecked exceptions 与  checked exception 的区别主要在于： Unchecked exceptions happen because of the programmer’s carelessness，也就是说  unchecked exception 是可以预防的，可以避免的。两个主要的 unchecked exception 主要有： rrayIndexOutofBoundsException and NullPointerException&lt;/li&gt;
      &lt;li&gt;所有其他的非 unchecked exception 则是：checked exceptions， 两个主要的exception 有 FileNotFoundException and IOException.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;创建 新的 exception
    &lt;ul&gt;
      &lt;li&gt;新创建的 exception 应该继承 exception 或者 任何 除 RunTimeException 之外的 子类。 因为 新创建的 exception  为 checked exception&lt;/li&gt;
      &lt;li&gt;An exception is thrown to indicate the occurrence of a runtime error. Only checked exceptions should be thrown, as all unchecked exceptions should be eliminated. 意思是： 只有 checked exceptions 需要throw 声明， unchecked exception 因为无法预测，只能 尽量消除掉。（If a method’s header does not contain a throws clause, then the method throws no checked exceptions.）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Throwing an Exception
&lt;div class="highlight"&gt;&lt;pre class="highlight java"&gt;&lt;code&gt;  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="kd"&gt;throws&lt;/span&gt; &lt;span class="nc"&gt;IOException&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                                          &lt;span class="nc"&gt;FileNotFoundException&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;ul&gt;
      &lt;li&gt;A method’s header advertises the checked exceptions that may occur when the method executes&lt;/li&gt;
      &lt;li&gt;An exception can occur in two ways: explicitly through the use of a throw statement or implicitly by calling a method that can throw an exception 意思是：异常产生有两种方式：1. 直接抛出异常 2. 调用 能够抛出异常的函数&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Catching an Exception: catch 异常的方式同其他 语言一致， 即是 不断的递归的 解开栈，以找到合适的 catch。如果无法找到适合的 catch 则  使用默认的 default exception handler 来捕获异常，所以default exception handler 是在哪一层？main 层面吗？
&lt;div class="highlight"&gt;&lt;pre class="highlight java"&gt;&lt;code&gt;  &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
     &lt;span class="n"&gt;code&lt;/span&gt; &lt;span class="n"&gt;that&lt;/span&gt; &lt;span class="n"&gt;could&lt;/span&gt; &lt;span class="n"&gt;cause&lt;/span&gt; &lt;span class="n"&gt;exceptions&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;catch&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;Exception&lt;/span&gt; &lt;span class="n"&gt;e1&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
     &lt;span class="n"&gt;code&lt;/span&gt; &lt;span class="n"&gt;that&lt;/span&gt; &lt;span class="n"&gt;does&lt;/span&gt; &lt;span class="n"&gt;something&lt;/span&gt; &lt;span class="n"&gt;about&lt;/span&gt; &lt;span class="n"&gt;exception&lt;/span&gt; &lt;span class="n"&gt;e1&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;catch&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;Exception&lt;/span&gt; &lt;span class="n"&gt;e2&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
     &lt;span class="n"&gt;code&lt;/span&gt; &lt;span class="n"&gt;that&lt;/span&gt; &lt;span class="n"&gt;does&lt;/span&gt; &lt;span class="n"&gt;something&lt;/span&gt; &lt;span class="n"&gt;about&lt;/span&gt; &lt;span class="n"&gt;exception&lt;/span&gt; &lt;span class="n"&gt;e2&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="a-little-book-on-shell"&gt;A Little Book on Shell&lt;/h2&gt;
&lt;h3 id="常用-command"&gt;常用 command&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;file cp mv mkdir rm ln &lt;br /&gt;
  其中ln  命令 ln file link, 默认 创建 hard link， ln -s file link 才 为 soft link， soft link 同样增加 file 的link count&lt;/li&gt;
  &lt;li&gt;Working with Commands (type which  help man apropos info whatis alias)&lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;| command | meaning                                           |
|---------|---------------------------------------------------|
| type    | Indicate how a command name is interpreted        |
| which   | Display which executable program will be executed |
| help    | Get help for shell builtins                       |
| man     | Display a command's manual page                   |
| apropos | Display a list of appropriate commands            |
| info    | Display a command's info entry                    |
| whatis  | Display one-line manual page descriptions         |
| alias   | Create an alias for a command                     |
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;commands 的来源： &lt;br /&gt;
    * An executable program: 例如 /usr/bin 下面的 可执行文件，&lt;br /&gt;
    * A command built into the shell itself.： bash 支持的内建 的 命令&lt;br /&gt;
    * A shell function： shell 函数 Shell functions are miniature shell scripts incorporated into the environment&lt;br /&gt;
    * An alias： Aliases are commands that we can define ourselves, built from other commands.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;man 详细内容： Display a Program’s Manual Page。 手册内容 被分为 几个 章节， 出了 使用 man command, 之外 可以使用 man 1 command 来显示 User commands 章节&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;| section | contents                                       |
|---------|------------------------------------------------|
| 1       | User commands                                  |
| 2       | Programming interfaces for kernel system calls |
| 3       | Programming interfaces to the C library        |
| 4       | Special files such as device nodes and drivers |
| 5       | File formats                                   |
| 6       | Games and amusements such as screen savers     |
| 7       | Miscellaneous                                  |
| 8       | System administration commands                                               |
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;apropos – Display Appropriate Commands 展示相关的 命令。通过  apropos ls 可以获得 lscpu, lshw, 等一系列 命令&lt;/li&gt;
  &lt;li&gt;whatis – Display One-line Manual Page Descriptions:  展示一行关于 command的简单描述&lt;/li&gt;
  &lt;li&gt;info 另一种展现形式的 man&lt;/li&gt;
  &lt;li&gt;alias: alias name=’string’ 来构建 名为 name 的command line， type name 可以获得 name 对应的 具体string 内容&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="redirection"&gt;Redirection&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;cat sort uniq grep wc head tail tee(Read from standard input and write to standard output and files)&lt;/li&gt;
  &lt;li&gt;command line  数据流 有： 标准输入 标准输出 标准错误输出，即： stdin, stdout, stderr, 0, 1, 2&lt;/li&gt;
  &lt;li&gt;重定向 stdout， 使用 &amp;gt; 来将 输出 重定向到 file 中，file中内容将被覆盖。  »  将 数据重定向 到file中，不覆盖 追加到 file 末尾中&lt;/li&gt;
  &lt;li&gt;重定向 stderr, 类似 重定向 stdout 使用 2&amp;gt;, 2» 进行 标准错误输出 的数据重定向&lt;/li&gt;
  &lt;li&gt;将stdout &amp;amp; stderr 重定向 到一个 file 中：
    &lt;ul&gt;
      &lt;li&gt;ls -l /bin/usr &amp;gt; ls-output.txt 2&amp;gt;&amp;amp;1 ， 注意 其中的 2&amp;gt;&amp;amp;1 的写法，以及， &amp;gt; 与 2&amp;gt;&amp;amp;1 的顺序， 其中原因，为shell 语法需要 控制 两次重定向 打开的是同一个文件&lt;/li&gt;
      &lt;li&gt;ls -l /bin/usr &amp;amp;&amp;gt; ls-output.txt 也可以这样 &amp;amp;&amp;gt; 代表 stdout stderr， ls -l /bin/usr &amp;amp;» ls-output.txt 则代表 将stdout stderr 数据流 追加到 文件中&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Disposing of Unwanted Output:  ls -l /bin/usr 2&amp;gt; /dev/null 将 数据流 重定向 到 /dev/null 则可以起到忽略 数据流的作用&lt;/li&gt;
  &lt;li&gt;重定向 stdin, 使用 &amp;lt; 来重定向 stdin 从 键盘 到 file 上， 但是并不是特别有用（很少用到）&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;Pipelines： 使用 pipe operator&lt;/td&gt;
          &lt;td&gt;将 一个command 的标准输出  输送 到 一个command 的标准输入中。 command1&lt;/td&gt;
          &lt;td&gt;command2&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;Pipelines 与 重定向的 区别： 重定向只能 定向到 file， 而 pipelines 则可以 重定向到  一个command&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="seeing-the-world-as-the-shell-sees-it"&gt;Seeing the World as the Shell Sees It&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;扩展 Expansion: how a simple character sequence, for example *, can have a lot of meaning to the shell. The process that makes this happen is called expansion. With expansion, we enter some- thing and it is expanded into something else before the shell acts upon it. 也就是 说 在 传递 参数给 command， command 接收参数处理前，会被 进行处理，该处理过程 即是： expansion。&lt;/li&gt;
  &lt;li&gt;echo 是如何 显式化  看到 expansion 结果的 重要方式&lt;/li&gt;
  &lt;li&gt;Pathname Expansion （路径扩展）： 如下释义：&lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;  &lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;ls
  &lt;/span&gt;Desktop ls-output.txt Pictures Templates Documents Music Public Videos

  &lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;echo &lt;/span&gt;D&lt;span class="k"&gt;*&lt;/span&gt;
  Desktop Documents

  &lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="k"&gt;*&lt;/span&gt;s
  Documents Pictures Templates Videos

  &lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="o"&gt;[[&lt;/span&gt;:upper:]]&lt;span class="k"&gt;*&lt;/span&gt;
  Desktop Documents Music Pictures Public Templates Videos

  &lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; /usr/&lt;span class="k"&gt;*&lt;/span&gt;/share
  /usr/kerberos/share /usr/local/share

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;
  &lt;li&gt;Arithmetic Expansion: $((expression)), expression 是 算术表达式， 操作数 只能是整数， 操作符 有 +, -, *, /, %, **&lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;  &lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="k"&gt;$(($((&lt;/span&gt;&lt;span class="m"&gt;5&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="k"&gt;))&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="m"&gt;3&lt;/span&gt;&lt;span class="k"&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;Brace Expansion:&lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;  &lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;echo &lt;/span&gt;Front-&lt;span class="o"&gt;{&lt;/span&gt;A,B,C&lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="nt"&gt;-Back&lt;/span&gt;
  Front-A-Back Front-B-Back Front-C-Back

  &lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;echo &lt;/span&gt;Number_&lt;span class="o"&gt;{&lt;/span&gt;1..5&lt;span class="o"&gt;}&lt;/span&gt;
  Number_1 Number_2 Number_3 Number_4 Number_5

  &lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;01..15&lt;span class="o"&gt;}&lt;/span&gt;
  01 02 03 04 05 06 07 08 09 10 11 12 13 14 15

  &lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;001..15&lt;span class="o"&gt;}&lt;/span&gt;
  001 002 003 004 005 006 007 008 009 010 011 012 013 014 015

  &lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;Z..A&lt;span class="o"&gt;}&lt;/span&gt;
  Z Y X W V U T S R Q P ON M L K J I H G F E D C B A


  &lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;mkdir &lt;/span&gt;Photos
  &lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;cd &lt;/span&gt;Photos
  &lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox Photos]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;mkdir&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;2007..2009&lt;span class="o"&gt;}&lt;/span&gt;-&lt;span class="o"&gt;{&lt;/span&gt;01..12&lt;span class="o"&gt;}&lt;/span&gt; 
  &lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox Photos]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;ls
  &lt;/span&gt;2007-01 2007-07 2008-01 2008-07 2009-01 2009-07 2007-02 2007-08 2008-02 2008-08 2009-02 2009-08 2007-03 2007-09 2008-03 2008-09 2009-03 2009-09 2007-04 2007-10 2008-04 2008-10 2009-04 2009-10 2007-05 2007-11 2008-05 2008-11 2009-05 2009-11 2007-06 2007-12 2008-06 2008-12 2009-06 2009-12
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;Parameter Expansion&lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;  &lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$USER&lt;/span&gt; 
  me
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;
  &lt;li&gt;Command Substitution: 子命令， 允许在表达式中 执行子命令 并展开. $(command sub)&lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;  &lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="si"&gt;$(&lt;/span&gt;&lt;span class="nb"&gt;ls&lt;/span&gt;&lt;span class="si"&gt;)&lt;/span&gt;
  Desktop Documents ls-output.txt Music Pictures Public Templates Videos
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;Quoting: 可以用来控制 是否进行 扩展 展开。
    &lt;ul&gt;
      &lt;li&gt;下面两个示例：&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;  &lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;echo &lt;/span&gt;this is a    &lt;span class="nb"&gt;test
  &lt;/span&gt;this is a &lt;span class="nb"&gt;test&lt;/span&gt;

  &lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;echo &lt;/span&gt;The total is &lt;span class="nv"&gt;$100&lt;/span&gt;.00
  The total is 00.00
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意 这两个 的存在的问题： 1. 第一个中 shell 将 params 中多余的空格 去掉了， 即是： ‘a    test’中多余的空格， 因为 shell 将 通过 空格 分隔 参数，认为 a test  为两个参数。 2. $100.00 展开为了 00.00 是因为 $1 不存在的缘故&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Double Quotes： 将参数 加上 “” 之后， ““内的内容 将被视为 一个 参数， 但  parameter expansion, arithmetic expansion, and command substitution 依然 有效。&lt;br /&gt;
  如下示例:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;  &lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;ls&lt;/span&gt; &lt;span class="nt"&gt;-l&lt;/span&gt; two words.txt
  &lt;span class="nb"&gt;ls&lt;/span&gt;: cannot access two: No such file or directory
  &lt;span class="nb"&gt;ls&lt;/span&gt;: cannot access words.txt: No such file or directory

  &lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;ls&lt;/span&gt; &lt;span class="nt"&gt;-l&lt;/span&gt; &lt;span class="s2"&gt;"two words.txt"&lt;/span&gt;
  &lt;span class="nt"&gt;-rw-rw-r--&lt;/span&gt; 1 me me 18 2016-02-20 13:03 two words.txt &lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;mv&lt;/span&gt; &lt;span class="s2"&gt;"two words.txt"&lt;/span&gt; two_words.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;  &lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;echo &lt;/span&gt;this is a    &lt;span class="nb"&gt;test
  &lt;/span&gt;this is a &lt;span class="nb"&gt;test&lt;/span&gt;

  &lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"this is a   test"&lt;/span&gt;
  this is a   &lt;span class="nb"&gt;test&lt;/span&gt;




  &lt;span class="o"&gt;(&lt;/span&gt;calvagrant@precise64:~&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="si"&gt;$(&lt;/span&gt;cal&lt;span class="si"&gt;)&lt;/span&gt;
  September 2020 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30

  vagrant@precise64:~&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="si"&gt;$(&lt;/span&gt;cal&lt;span class="si"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
     September 2020
  Su Mo Tu We Th Fr Sa
         1  2  3  4  5
   6  7  8  9 10 11 12
  13 14 15 16 17 18 19
  20 21 22 23 24 25 26
  27 28 29 30

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;Single Quotes： 单引号 中的内容 扩展 全部 失效。&lt;/li&gt;
  &lt;li&gt;Escaping Characters： \&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;escape sequence&lt;/th&gt;
      &lt;th&gt;meaning&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;\a&lt;/td&gt;
      &lt;td&gt;Bell&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\b&lt;/td&gt;
      &lt;td&gt;Backspace&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\n&lt;/td&gt;
      &lt;td&gt;Newline&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\r&lt;/td&gt;
      &lt;td&gt;Carriage return&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\t&lt;/td&gt;
      &lt;td&gt;Tab&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;Signals: Signals are one of several ways that the operating system communicates with programs
    &lt;ul&gt;
      &lt;li&gt;kill: The kill command doesn’t exactly “kill” processes: rather it sends them signals &lt;br /&gt;
kill [-signal] PID…&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;keyboard&lt;/th&gt;
      &lt;th&gt;signal&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl-c&lt;/td&gt;
      &lt;td&gt;INT&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl-z&lt;/td&gt;
      &lt;td&gt;TSTP&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Number&lt;/th&gt;
      &lt;th&gt;Name&lt;/th&gt;
      &lt;th&gt;Meaning&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;HUP&lt;/td&gt;
      &lt;td&gt;Hangup. This is a vestige of the good old days when terminals were attached to remote computers with phone lines and modems. The signal is used to indicate to programs that the controlling terminal has “hung up.” The effect of this signal can be demonstrated by closing a terminal session. The foreground program running on the terminal will be sent the signal and will terminate.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;INT&lt;/td&gt;
      &lt;td&gt;Interrupt. This performs the same function as a Ctrl-c sent from the terminal. It will usually terminate a program.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;KILL&lt;/td&gt;
      &lt;td&gt;Kill. This signal is special. Whereas programs may choose to handle signals sent to them in different ways, including ignoring them all together, the KILL signal is never actually sent to the target program. Rather, the kernel immediately terminates the process. When a process is terminated in this manner, it is given no opportunity to “clean up” after itself or save its work. For this reason, the KILL signal should be used only as a last resort when other termination signals fail.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;15&lt;/td&gt;
      &lt;td&gt;TERM&lt;/td&gt;
      &lt;td&gt;Terminate. This is the default signal sent by the kill command. If a program is still “alive” enough to receive signals, it will terminate.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;18&lt;/td&gt;
      &lt;td&gt;CONT&lt;/td&gt;
      &lt;td&gt;Continue. This will restore a process after a STOP or TSTP signal. This signal is sent by the bg and fg commands.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;19&lt;/td&gt;
      &lt;td&gt;STOP&lt;/td&gt;
      &lt;td&gt;Stop. This signal causes a process to pause without terminating. Like the KILL signal, it is not sent to the target process, and thus it cannot be ignored.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;20&lt;/td&gt;
      &lt;td&gt;TSTP&lt;/td&gt;
      &lt;td&gt;Terminal stop. This is the signal sent by the terminal when Ctrl-z is pressed. Unlike the STOP signal, the TSTP signal is received by the program, but the program may choose to ignore it.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;QUIT&lt;/td&gt;
      &lt;td&gt;Quit&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;11&lt;/td&gt;
      &lt;td&gt;SEGV&lt;/td&gt;
      &lt;td&gt;Segmentation violation. This signal is sent if a program makes illegal use of memory, that is, if it tried to write somewhere it was not allowed to write.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;28&lt;/td&gt;
      &lt;td&gt;WINCH&lt;/td&gt;
      &lt;td&gt;Window change. This is the signal sent by the system when a window changes size. Some programs , such as top and less will respond to this signal by redrawing themselves to fit the new window dimensions.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;example, kill -number | -Name 也即是说 kill 可以接受 number 或者 显示的名称
&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;kill&lt;/span&gt; &lt;span class="nt"&gt;-1&lt;/span&gt; 13546
&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;kill&lt;/span&gt; &lt;span class="nt"&gt;-SIGINT&lt;/span&gt; 13608
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;h4 id="configuration-and-the-environment"&gt;Configuration and the Environment&lt;/h4&gt;
    &lt;ol&gt;
      &lt;li&gt;Environment: shell 维护 一个 shell的 session 信息 称为 环境； shell 中保存 environment variables and shell variables 在环境中。但是无法区分 两种类型的变量。&lt;/li&gt;
    &lt;/ol&gt;
    &lt;ul&gt;
      &lt;li&gt;printenv： 用来展现所有的 变量&lt;/li&gt;
      &lt;li&gt;set： 不带参数 展现所有变量以及 shell函数&lt;/li&gt;
      &lt;li&gt;alias： 展现所有 alias 相关的&lt;br /&gt;
    2. Environment 中的变量是 如何定义的：&lt;/li&gt;
      &lt;li&gt;A login shell session： A login shell session is one in which we are prompted for our username and password. This happens when we start a virtual console session, for example.&lt;/li&gt;
      &lt;li&gt;A non-login shell session： A non-login shell session typically occurs when we launch a terminal session in the GUI.&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Login Shell Sessions 读取配置文件&lt;/p&gt;

        &lt;table&gt;
          &lt;thead&gt;
            &lt;tr&gt;
              &lt;th&gt;File&lt;/th&gt;
              &lt;th&gt;Contents&lt;/th&gt;
            &lt;/tr&gt;
          &lt;/thead&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;/etc/profile&lt;/td&gt;
              &lt;td&gt;A global configuration script that applies to all users.&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;~/.bash_profile&lt;/td&gt;
              &lt;td&gt;A user’s personal startup file. This can be used to extend or override settings in the global configuration script.&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;~/.bash_login&lt;/td&gt;
              &lt;td&gt;If ~/.bash_profile is not found, bash attempts to read this script.&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;~/.profile&lt;/td&gt;
              &lt;td&gt;If neither ~/.bash_profile nor ~/.bash_login is found, bash attempts to read this file. This is the default in Debian-based distributions, such as Ubuntu.&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt; &lt;/td&gt;
              &lt;td&gt; &lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
      &lt;li&gt;Non-Login Shell Sessions 读取配置文件： non-login shells inherit the environ- ment from their parent process, usually a login shell. Non-login 会 继承  Login shell 的环境&lt;/li&gt;
    &lt;/ul&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;File&lt;/th&gt;
          &lt;th&gt;Contents&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;/etc/bash.bashrc&lt;/td&gt;
          &lt;td&gt;A global configuration script that applies to all users&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;~/.bashrc&lt;/td&gt;
          &lt;td&gt;A user’s personal startup file. It can be used to extend or  override settings in the global configuration script.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;命令查找： ls 命令的 定义在哪里， 又是如何找到的呢？
    &lt;ul&gt;
      &lt;li&gt;shell 从 PATH 变量中 包含的 Path 中 顺序查找&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;  &lt;span class="nv"&gt;PATH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$PATH&lt;/span&gt;:&lt;span class="nv"&gt;$HOME&lt;/span&gt;/bin
  &lt;span class="nb"&gt;export &lt;/span&gt;PATH

  简单的将 &lt;span class="nv"&gt;$HOME&lt;/span&gt;/bin 添加到 PATH 中 &lt;span class="o"&gt;(&lt;/span&gt;注意 &lt;span class="nv"&gt;$HOME&lt;/span&gt; 会在此处求值&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="nb"&gt;export &lt;/span&gt;PATH 让 shell之后的process 中的PATH都改变
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="查找文件"&gt;查找文件&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;locate : 非常简单有效，只能使用 filename 用来查找。 locate 足够高效 因为 其从 updatedb command 更新的数据库中来进行查找，updatedb 经常 放在cron job 来执行（需要确认下，因为没有找到 相关的配置文件）&lt;/li&gt;
  &lt;li&gt;find 寻找文件 则显得 复杂 而详尽。可以根据给定的 目录 以及 各个限定 来查找文件。&lt;br /&gt;
可选参数与 含义&lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th&gt;可选值&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-type&lt;/td&gt;
      &lt;td&gt;b: Block special device file; c: Character special device file; d: Directory; f: regular file; l Symbolic link&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-size&lt;/td&gt;
      &lt;td&gt;c Bytes; w: 2-byte words; k: kilobytes; M: megabytes; G: Gigabytes;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-cmin n&lt;/td&gt;
      &lt;td&gt;Match files or directories whose content or attributes were last modified exactly n minutes ago. To specify less than n minutes ago, use -n, and to specify more than n minutes ago, use +n.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-cnewer file&lt;/td&gt;
      &lt;td&gt;Match files or directories whose contents or attributes were last modified more recently than those of file.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-ctime n&lt;/td&gt;
      &lt;td&gt;Match files or directories whose contents or attributes were last modified n*24 hours ago.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-empty&lt;/td&gt;
      &lt;td&gt;Match empty files and directories.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-iname pattern&lt;/td&gt;
      &lt;td&gt;Like the -name test but case-insensitive.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-inum n&lt;/td&gt;
      &lt;td&gt;Match files with inode number n. This is helpful for finding all the hard links to a particular inode.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-mmin n&lt;/td&gt;
      &lt;td&gt;Match files or directories whose contents were last modified n minutes ago.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-mtime n&lt;/td&gt;
      &lt;td&gt;Match files or directories whose contents were last modified n*24 hours ago.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-name pattern&lt;/td&gt;
      &lt;td&gt;Match files and directories with the specified wildcard pattern.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-newer file&lt;/td&gt;
      &lt;td&gt;Match files and directories whose contents were modified more recently than the specified file. This is useful when writing shell scripts that perform file backups. Each time you make a backup, update a file (such as a log) and then use find to determine which files have changed since the last update&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-samefile name&lt;/td&gt;
      &lt;td&gt;Similar to the -inum test. Match files that share the same inode number as file name&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-user name&lt;/td&gt;
      &lt;td&gt;Match files or directories belonging to user name. The user may be expressed by a username or by a numeric user ID.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;for example&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;find ~ &lt;span class="nt"&gt;-type&lt;/span&gt; f &lt;span class="nt"&gt;-name&lt;/span&gt; &lt;span class="s2"&gt;"*.JPG"&lt;/span&gt; &lt;span class="nt"&gt;-size&lt;/span&gt; +1M | &lt;span class="nb"&gt;wc&lt;/span&gt; &lt;span class="nt"&gt;-l&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意 其中的 -name 参数需要添加 “” 来防止 pathname expansion， size: 则使用 +1M 表示大于 1M 的文件&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;find logical Operators： find 则可以更复杂的 使用 -and -or -not () 等来进行  logic 之间的 与或 操作 来设定更复杂的 test 关系&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="o"&gt;(&lt;/span&gt; expression 1 &lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="nt"&gt;-or&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt; expression 2 &lt;span class="o"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;Predefined Actions:&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Action&lt;/th&gt;
      &lt;th&gt;Meaning&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-delete&lt;/td&gt;
      &lt;td&gt;delete match file&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-ls&lt;/td&gt;
      &lt;td&gt;ls -dils match file&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-print&lt;/td&gt;
      &lt;td&gt;output full pathname of match file&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-quit&lt;/td&gt;
      &lt;td&gt;Quit once a match has been made&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;User-Defined Actions： -exec rm ‘{}’ ‘;’： {} 代表 match file 的pathname。 这里面 存在的问题是： -exec 中的命令会被  实例化 多次，在每次match file的时候 就会实例化一次。可以简单的 实例化多次 修改为 实例化一次 。 即：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;find ~ &lt;span class="nt"&gt;-type&lt;/span&gt; f &lt;span class="nt"&gt;-name&lt;/span&gt; &lt;span class="s1"&gt;'foo*'&lt;/span&gt; &lt;span class="nt"&gt;-exec&lt;/span&gt; &lt;span class="nb"&gt;ls&lt;/span&gt; &lt;span class="nt"&gt;-l&lt;/span&gt; &lt;span class="s1"&gt;'{}'&lt;/span&gt; &lt;span class="s1"&gt;';'&lt;/span&gt;
&lt;span class="nt"&gt;-rwxr-xr-x&lt;/span&gt; 1 me me 224 2007-10-29 18:44 /home/me/bin/foo 
&lt;span class="nt"&gt;-rw-r--r--&lt;/span&gt; 1 me me 0 2016-09-19 12:53 /home/me/foo.txt

// 修改后
find ~ &lt;span class="nt"&gt;-type&lt;/span&gt; f &lt;span class="nt"&gt;-name&lt;/span&gt; &lt;span class="s1"&gt;'foo*'&lt;/span&gt; &lt;span class="nt"&gt;-exec&lt;/span&gt; &lt;span class="nb"&gt;ls&lt;/span&gt; &lt;span class="nt"&gt;-l&lt;/span&gt; &lt;span class="s1"&gt;'{}'&lt;/span&gt; +
&lt;span class="nt"&gt;-rwxr-xr-x&lt;/span&gt; 1 me me 224 2007-10-29 18:44 /home/me/bin/foo 
&lt;span class="nt"&gt;-rw-r--r--&lt;/span&gt; 1 me me 0 2016-09-19 12:53 /home/me/foo.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;xargs: 用于将 接受的input 的信息 作为参数 传递给 command. xargs存在的原因在于： 一些 命令 接受 命令行参数+标准输入，但是其他一些命令 则 只接受命令行 输入，所以需要 xargs 将标准输入 转换为 命令行参数&lt;br /&gt;
Some commands such as grep and awk can take input either as command-line arguments or from the standard input. However, others such as cp and echo can only take input as arguments, which is why xargs is necessary. &lt;a href="https://en.wikipedia.org/wiki/Xargs"&gt;[name]&lt;/a&gt;&lt;br /&gt;
xargs 中存在一些 问题，主要是 关于 filename 中的空格，等分隔符号 对整个 shell的参数接收 都有影响。 所以 接受filename 的时候 –null 参数 将 是xargs 不被 ‘ ’分隔（ 使用 空字符串 作为分隔）， -d ‘&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="archiving-and-backup"&gt;Archiving and Backup：&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;compressor command: gzip bzip2  gzip options&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;Option&lt;/th&gt;
          &lt;th&gt;Long Option&lt;/th&gt;
          &lt;th&gt;Desc&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;-c&lt;/td&gt;
          &lt;td&gt;–stdout&lt;/td&gt;
          &lt;td&gt;Write output to standard output and keep the original files.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;-d&lt;/td&gt;
          &lt;td&gt;–decompress&lt;/td&gt;
          &lt;td&gt;Decompress This causes gzip act like gunzip&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;-f&lt;/td&gt;
          &lt;td&gt;–force&lt;/td&gt;
          &lt;td&gt;force compress event if a compressed file already exists&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;-l&lt;/td&gt;
          &lt;td&gt;–list&lt;/td&gt;
          &lt;td&gt;应用 已压缩文件 展示 压缩信息&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;-r&lt;/td&gt;
          &lt;td&gt;–recursive&lt;/td&gt;
          &lt;td&gt;递归压缩目录下的文件（目录下的文件各自压缩为 各自的压缩文件，所以 依然需要archive 程序）&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;-v&lt;/td&gt;
          &lt;td&gt;–verbose&lt;/td&gt;
          &lt;td&gt;Display verbose messages while compressing.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;-number&lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt;Set amount of compression. number is an integer in the range of 1 (fastest, least compression) to 9 (slowest, most compression). The values 1 and 9 may also be expressed as –fast and –best, respectively. The default value is 6.&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;blockquote&gt;
      &lt;p&gt;bzip2 同gzip 一样 为压缩程序，其中的参数 都大概相同，除了-r -number 外。 bunzip2 bzcat 用于解压缩。 bzip2recover 可以恢复受损的 压缩文件&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;archive command: tar zip:  Archiving is the process of gathering up many files and bundling them together into a single large file.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Mode&lt;/th&gt;
      &lt;th&gt;Meaning&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;c&lt;/td&gt;
      &lt;td&gt;Create an archive from a list of files and/or directories.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;x&lt;/td&gt;
      &lt;td&gt;Extract an archive.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;r&lt;/td&gt;
      &lt;td&gt;Append specified pathnames to the end of an archive&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;t&lt;/td&gt;
      &lt;td&gt;List the content of an archive&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;  &lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;gzip &lt;/span&gt;foo.txt
  &lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;ls&lt;/span&gt; &lt;span class="nt"&gt;-l&lt;/span&gt; foo.&lt;span class="k"&gt;*&lt;/span&gt;
  &lt;span class="nt"&gt;-rw-r--r--&lt;/span&gt; 1 me me 3230 2018-10-14 07:15 foo.txt.gz

  &lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;gzip&lt;/span&gt; &lt;span class="nt"&gt;-d&lt;/span&gt; foo.txt.gz

  &lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;gunzip &lt;/span&gt;foo.txt
  &lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;ls&lt;/span&gt; &lt;span class="nt"&gt;-l&lt;/span&gt; foo.&lt;span class="k"&gt;*&lt;/span&gt;
  &lt;span class="nt"&gt;-rw-r--r--&lt;/span&gt; 1 me me 15738 2018-10-14 07:15 foo.txt


  &lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;bzip2 foo.txt
  &lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;ls&lt;/span&gt; &lt;span class="nt"&gt;-l&lt;/span&gt; foo.txt.bz2
  &lt;span class="nt"&gt;-rw-r--r--&lt;/span&gt; 1 me me 2792 2018-10-17 13:51 foo.txt.bz2
  &lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;bunzip2 foo.txt.bz2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;tar： 只能以 相对路径 archive 文件。unarchive 的时候 在 当前路径下 以相对路径 恢复文件。example&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;  &lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;tar &lt;/span&gt;cf playground2.tar ~/playground

  &lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;cd &lt;/span&gt;foo
  &lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox foo]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;tar &lt;/span&gt;xf ../playground2.tar
  &lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox foo]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;ls
  &lt;/span&gt;home playground
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;–wildcards 可以用来过滤掉 特定的 match 文件 \n  find 经常用来 与 tar 配合进行 批量 archive&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;  find playground &lt;span class="nt"&gt;-name&lt;/span&gt; &lt;span class="s1"&gt;'file-A'&lt;/span&gt; &lt;span class="nt"&gt;-exec&lt;/span&gt; &lt;span class="nb"&gt;tar &lt;/span&gt;rf playground.tar &lt;span class="s1"&gt;'{}'&lt;/span&gt; &lt;span class="s1"&gt;'+'&lt;/span&gt;

  find playground &lt;span class="nt"&gt;-name&lt;/span&gt; &lt;span class="s1"&gt;'file-A'&lt;/span&gt; | &lt;span class="nb"&gt;tar &lt;/span&gt;cf - &lt;span class="nt"&gt;--files-from&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;- | &lt;span class="nb"&gt;gzip&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; playground.tgz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;第二条命令比较 特殊，在其中  tar cf - –files-from=- 中， - 代表 标准 标准输入或者输出 &lt;br /&gt;
 tar 可以通过添加 z j 参数，直接 使用gzip bzip2 进行压缩, z: gzip .tgz, j: bzip2 .tbz&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;  find playground &lt;span class="nt"&gt;-name&lt;/span&gt; &lt;span class="s1"&gt;'file-A'&lt;/span&gt; | &lt;span class="nb"&gt;tar &lt;/span&gt;czf playground.tgz &lt;span class="nt"&gt;-T&lt;/span&gt; -
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;通过网络进行 文件备份：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;  ssh remote-sys &lt;span class="s1"&gt;'tar cf - Documents'&lt;/span&gt; | &lt;span class="nb"&gt;tar &lt;/span&gt;xf -
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;zip, unzip： 的命令 比较详细，所以只列出简短  的示例：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;  zip &lt;span class="nt"&gt;-r&lt;/span&gt; playground.zip playground // &lt;span class="nt"&gt;-r&lt;/span&gt; 是必须，这样才能 得到 playground 下的所有 archive
  unzip ../playground.zip // 不同与 &lt;span class="nb"&gt;tar&lt;/span&gt;, zip 使用unzip 来进行 unarchive
  unzip &lt;span class="nt"&gt;-l&lt;/span&gt; ../playground.zip
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;sync command: rsync  rsync options source destination&lt;br /&gt;
  where source and destination are one of the following:&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;A local file or directory&lt;/li&gt;
  &lt;li&gt;A remote file or directory in the form of [user@]host:path&lt;/li&gt;
  &lt;li&gt;A remote rsync server specified with a URI of rsync://[user@]host[:port]/path&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意： source destination 其中之一 必须 为 本地的文件， 远程 到 远程的 copy 是不被允许的。&lt;br /&gt;
  示例：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;  rsync &lt;span class="nt"&gt;-av&lt;/span&gt; &lt;span class="nb"&gt;source &lt;/span&gt;destination // &lt;span class="nt"&gt;-a&lt;/span&gt; 代表 archive mode， v verbose output
  rsync &lt;span class="nt"&gt;-av&lt;/span&gt; &lt;span class="nb"&gt;source&lt;/span&gt;/ destination
  // 两种方式不同的地方在于 后一种 只拷贝 &lt;span class="nb"&gt;source &lt;/span&gt;中的内容到 destination, 而 第一种 则将source 目录也 拷贝到 destination 中.

  rsync &lt;span class="nt"&gt;-av&lt;/span&gt; &lt;span class="nt"&gt;--delete&lt;/span&gt; &lt;span class="nb"&gt;source&lt;/span&gt;/ destination   // delete 参数 为 完全拷贝， &lt;span class="nb"&gt;source &lt;/span&gt;中删除掉的file 将在 destination 中删除掉。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;Using rsync Over a Network： 的两种方式
    &lt;ul&gt;
      &lt;li&gt;source 安装了 rsync  的机器 以及 destination 安装了 远程shell 程序， 如： ssh&lt;/li&gt;
      &lt;li&gt;destination 安装了 rsync server， rsync 可以配置为 daemon 模式 等待 sync 请求&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;  &lt;span class="nb"&gt;sudo &lt;/span&gt;rsync &lt;span class="nt"&gt;-av&lt;/span&gt; &lt;span class="nt"&gt;--delete&lt;/span&gt; &lt;span class="nt"&gt;--rsh&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;ssh /etc /home /usr/local remote-sys:/backup
  // 这里面 &lt;span class="nt"&gt;--rsh&lt;/span&gt; 指定为 ssh， 使 rsync 能够 使用ssh 来进行同步操作
  rsync &lt;span class="nt"&gt;-av&lt;/span&gt; –delete rsync://archive.linux.duke.edu/ fedora/linux/development/rawhide/Everything/x86_64/os/ fedora-devel
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="text-processing"&gt;Text Processing&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;cat： 可以这样使用&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;  &lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;cat&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; foo.txt // ctrl-d结束输入
  &lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;cat&lt;/span&gt; &lt;span class="nt"&gt;-A&lt;/span&gt; foo.txt // 其中 ^I 代表 tab, &lt;span class="nv"&gt;$ &lt;/span&gt;代表 line末尾， 所以可以用此来 区分 tab 与 space
  &lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;cat&lt;/span&gt; &lt;span class="nt"&gt;-nA&lt;/span&gt; foo.txt // n 显式 line number
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;[[https://www.gnu.org/software/coreutils/manual/html_node/sort-invocation.html#sort-invocation][sort]]:  对输入进行排序， 是一个比较复杂，有用的命令：下面是详细参数&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;Option&lt;/th&gt;
          &lt;th&gt;Long Option&lt;/th&gt;
          &lt;th&gt;meaning&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;-b&lt;/td&gt;
          &lt;td&gt;–ignore-leading-blanks&lt;/td&gt;
          &lt;td&gt;使忽略掉 行前的 空格，使用第一个非空格排序&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;-f&lt;/td&gt;
          &lt;td&gt;–ignore-case&lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;-n&lt;/td&gt;
          &lt;td&gt;–numeric-sort&lt;/td&gt;
          &lt;td&gt;将字符串当做number 来进行比较&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;-r&lt;/td&gt;
          &lt;td&gt;–reverse&lt;/td&gt;
          &lt;td&gt;reverse order 排序&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;-k&lt;/td&gt;
          &lt;td&gt;–key=field1[,field2]&lt;/td&gt;
          &lt;td&gt;使用 field1..field2 作为排序的key, field1 不存在则为1， field2 不存在则 从field1直至末尾， field1 都可以是如此形式 f[.c][opts]  .c 为内部的offset&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;-m&lt;/td&gt;
          &lt;td&gt;–merge&lt;/td&gt;
          &lt;td&gt;将每个参数作为预排序文件的名称。 将多个文件合并为单个排序结果，而不执行任何其他排序。&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;-o&lt;/td&gt;
          &lt;td&gt;–output=file&lt;/td&gt;
          &lt;td&gt;输出到 file 而非 标准输出&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;-t&lt;/td&gt;
          &lt;td&gt;–field-separator=char&lt;/td&gt;
          &lt;td&gt;使用 char 作为分隔符，默认为 space 或者tab&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt;–debug&lt;/td&gt;
          &lt;td&gt;将用作sort 的key 进行标记&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;下面是几个示例&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;  &lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;du&lt;/span&gt; &lt;span class="nt"&gt;-s&lt;/span&gt; /usr/share/&lt;span class="k"&gt;*&lt;/span&gt; | &lt;span class="nb"&gt;head
  &lt;/span&gt;252 /usr/share/aclocal
  96 /usr/share/acpi-support
  8 /usr/share/adduser
  196 /usr/share/alacarte 344 /usr/share/alsa
  8 /usr/share/alsa-base 12488 /usr/share/anthy
  8 /usr/share/apmd


  //  下面对结果进行排序 其中 &lt;span class="nt"&gt;-nr&lt;/span&gt; 将string作为number 处理并 翻转排序, 这里面之所有管用，是因为 第一列 为 数字, 即 默认按照第一列进行排序
  &lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;du&lt;/span&gt; &lt;span class="nt"&gt;-s&lt;/span&gt; /usr/share/&lt;span class="k"&gt;*&lt;/span&gt; | &lt;span class="nb"&gt;sort&lt;/span&gt; &lt;span class="nt"&gt;-nr&lt;/span&gt; | &lt;span class="nb"&gt;head
  &lt;/span&gt;509940 /usr/share/locale-langpack
  242660 /usr/share/doc
  197560 /usr/share/fonts
  179144 /usr/share/gnome
  146764 /usr/share/myspell
  144304 /usr/share/gimp
  135880 /usr/share/dict
  76508 /usr/share/icons
  68072 /usr/share/apps
  62844 /usr/share/foomatic

  // 如果是这样的又如何排序?
  &lt;span class="o"&gt;[&lt;/span&gt;shaohua.li@10-11-112-3 ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;ls&lt;/span&gt; &lt;span class="nt"&gt;-l&lt;/span&gt; /usr/bin/ | &lt;span class="nb"&gt;head
  &lt;/span&gt;total 58404
  &lt;span class="nt"&gt;-rwxr-xr-x&lt;/span&gt;  1 root root     33408 Nov 10  2015 &lt;span class="o"&gt;[&lt;/span&gt;
  &lt;span class="nt"&gt;-rwxr-xr-x&lt;/span&gt;  1 root root    106792 Nov 10  2015 a2p
  &lt;span class="nt"&gt;-rwxr-xr-x&lt;/span&gt;&lt;span class="nb"&gt;.&lt;/span&gt; 1 root root     14984 Aug 18  2010 acpi_listen
  &lt;span class="nt"&gt;-rwxr-xr-x&lt;/span&gt;&lt;span class="nb"&gt;.&lt;/span&gt; 1 root root     23488 Nov 11  2010 addftinfo
  &lt;span class="nt"&gt;-rwxr-xr-x&lt;/span&gt;  1 root root     24904 Jul 23  2015 addr2line
  &lt;span class="nt"&gt;-rwxr-xr-x&lt;/span&gt;&lt;span class="nb"&gt;.&lt;/span&gt; 1 root root      1786 Feb 21  2013 apropos
  &lt;span class="nt"&gt;-rwxr-xr-x&lt;/span&gt;  1 root root     56624 Jul 23  2015 ar
  &lt;span class="nt"&gt;-rwxr-xr-x&lt;/span&gt;  1 root root    328392 Jul 23  2015 as
  &lt;span class="nt"&gt;-rwxr-xr-x&lt;/span&gt;&lt;span class="nb"&gt;.&lt;/span&gt; 1 root root     10400 Sep 23  2011 attr

  // &lt;span class="nt"&gt;-k&lt;/span&gt; 5 使用 第 5 field 作为key 用作 排序使用
  &lt;span class="o"&gt;[&lt;/span&gt;shaohua.li@10-11-112-3 ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;ls&lt;/span&gt; &lt;span class="nt"&gt;-l&lt;/span&gt; /usr/bin/ | &lt;span class="nb"&gt;sort&lt;/span&gt; &lt;span class="nt"&gt;-nr&lt;/span&gt; &lt;span class="nt"&gt;-k&lt;/span&gt; 5 | &lt;span class="nb"&gt;head&lt;/span&gt;
  &lt;span class="nt"&gt;-rwxr-xr-x&lt;/span&gt;  1 root root   3214440 Dec 12  2016 mysql
  &lt;span class="nt"&gt;-rwxr-xr-x&lt;/span&gt;  1 root root   3051080 Dec 12  2016 mysqlbinlog
  &lt;span class="nt"&gt;-rwxr-xr-x&lt;/span&gt;  1 root root   2998400 Dec 12  2016 mysqldump
  &lt;span class="nt"&gt;-rwxr-xr-x&lt;/span&gt;  1 root root   2948832 Dec 12  2016 mysqlslap
  &lt;span class="nt"&gt;-rwxr-xr-x&lt;/span&gt;  1 root root   2936680 Dec 12  2016 mysqladmin
  &lt;span class="nt"&gt;-rwxr-xr-x&lt;/span&gt;  1 root root   2935688 Dec 12  2016 mysqlcheck
  &lt;span class="nt"&gt;-rwxr-xr-x&lt;/span&gt;  1 root root   2933128 Dec 12  2016 mysqlimport
  &lt;span class="nt"&gt;-rwxr-xr-x&lt;/span&gt;  1 root root   2931712 Dec 12  2016 mysqlshow
  &lt;span class="nt"&gt;-rwxr-xr-x&lt;/span&gt;  1 root root   2814328 Dec 12  2016 my_print_defaults
  &lt;span class="nt"&gt;-rwxr-xr-x&lt;/span&gt;  1 root root   2811544 Dec 12  2016 mysql_waitpid


  // 下面是 比较复杂的示例
  root@precise64:~/shell_test#  &lt;span class="nb"&gt;cat &lt;/span&gt;distros.txt
  Fedora  5    03/20/2006
  Fedora  6    10/24/2006
  Fedora  7    05/31/2007
  Fedora  8    11/08/2007
  Fedora  9    05/13/2008
  Fedora  10   11/25/2008
  SUSE    10.1 05/11/2006
  SUSE    10.2 12/07/2006
  SUSE    10.3 10/04/2007
  SUSE    11.0 06/19/2008
  Ubuntu  6.06 06/01/2006
  Ubuntu  6.10 10/26/2006
  Ubuntu  7.04 04/19/2007
  Ubuntu  7.10 10/18/2007
  Ubuntu  8.04 04/24/2008
  Ubuntu  8.10 10/30/2008

  // 如何对 distros 按照其 发布的版本 以及 发布时间 进行排序呢？

  // 单纯的 按照 发布版本排序
  root@precise64:~/shell_test# &lt;span class="nb"&gt;sort &lt;/span&gt;distros.txt  &lt;span class="nt"&gt;-nrk&lt;/span&gt; 2
  SUSE    11.0 06/19/2008
  SUSE    10.3 10/04/2007
  SUSE    10.2 12/07/2006
  SUSE    10.1 05/11/2006
  Fedora  10   11/25/2008
  Fedora  9    05/13/2008
  Ubuntu  8.10 10/30/2008
  Ubuntu  8.04 04/24/2008
  Fedora  8    11/08/2007
  Ubuntu  7.10 10/18/2007
  Ubuntu  7.04 04/19/2007
  Fedora  7    05/31/2007
  Ubuntu  6.10 10/26/2006
  Ubuntu  6.06 06/01/2006
  Fedora  6    10/24/2006
  Fedora  5    03/20/2006

  // 综合排序， 使用多个key， 版本，以及版本号 进行综合排序
  root@precise64:~/shell_test# &lt;span class="nb"&gt;sort&lt;/span&gt; &lt;span class="nt"&gt;--key&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1,1 &lt;span class="nt"&gt;--key&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;2n distros.txt
  Fedora  5    03/20/2006
  Fedora  6    10/24/2006
  Fedora  7    05/31/2007
  Fedora  8    11/08/2007
  Fedora  9    05/13/2008
  Fedora  10   11/25/2008
  SUSE    10.1 05/11/2006
  SUSE    10.2 12/07/2006
  SUSE    10.3 10/04/2007
  SUSE    11.0 06/19/2008
  Ubuntu  6.06 06/01/2006
  Ubuntu  6.10 10/26/2006
  Ubuntu  7.04 04/19/2007
  Ubuntu  7.10 10/18/2007
  Ubuntu  8.04 04/24/2008
  Ubuntu  8.10 10/30/2008

  // k 可以为 f[.c][opts]  可以指定 field 中的 c pos 用来比较
  root@precise64:~/shell_test# &lt;span class="nb"&gt;sort&lt;/span&gt; &lt;span class="nt"&gt;-k&lt;/span&gt; 3.7nbr &lt;span class="nt"&gt;-k&lt;/span&gt; 3.1nbr &lt;span class="nt"&gt;-k&lt;/span&gt; 3.4nbr distros.txt
  Fedora  10   11/25/2008
  Ubuntu  8.10 10/30/2008
  SUSE    11.0 06/19/2008
  Fedora  9    05/13/2008
  Ubuntu  8.04 04/24/2008
  Fedora  8    11/08/2007
  Ubuntu  7.10 10/18/2007
  SUSE    10.3 10/04/2007
  Fedora  7    05/31/2007
  Ubuntu  7.04 04/19/2007
  SUSE    10.2 12/07/2006
  Ubuntu  6.10 10/26/2006
  Fedora  6    10/24/2006
  Ubuntu  6.06 06/01/2006
  SUSE    10.1 05/11/2006
  Fedora  5    03/20/2006


  // &lt;span class="nt"&gt;--debug&lt;/span&gt; 选项 是比较有意思的，用来在 不知道 key 以及sort情况时候，用来展现 其内部sort key 的方式
  root@precise64:~/shell_test# &lt;span class="nb"&gt;cat&lt;/span&gt; /etc/passwd | &lt;span class="nb"&gt;sort&lt;/span&gt; &lt;span class="nt"&gt;-t&lt;/span&gt; &lt;span class="s1"&gt;':'&lt;/span&gt; &lt;span class="nt"&gt;-k&lt;/span&gt; 7 &lt;span class="nt"&gt;--debug&lt;/span&gt; | &lt;span class="nb"&gt;head
  sort&lt;/span&gt;: using &lt;span class="sb"&gt;`&lt;/span&gt;en_US&lt;span class="s1"&gt;' sorting rules
  root:x:0:0:root:/root:/bin/bash
                        _________
  _______________________________
  vagrant:x:1000:1000:vagrant,,,:/home/vagrant:/bin/bash
                                               _________
  ______________________________________________________
  messagebus:x:102:105::/var/run/dbus:/bin/false
                                      __________
  ______________________________________________
  mysql:x:106:111:MySQL Server,,,:/nonexistent:/bin/false
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;uniq: 去除 重复的 条目, 比较有意思的是 需要在sort之后 使用，也就是说 uniq只能去除掉 相邻的 重复的条目&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;cat&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; foo.txt 
a
b
c
a
b
c

&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;uniq &lt;/span&gt;foo.txt 
a
b
c
a
b
c

&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;sort &lt;/span&gt;foo.txt | &lt;span class="nb"&gt;uniq 
&lt;/span&gt;a
b
c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;cut: 用于 使用 -d, –delimiter=DELIM 默认为tab 分隔line， 然后提取 field， characters 等&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;root@precise64:~/shell_test# &lt;span class="nb"&gt;cat&lt;/span&gt; /etc/passwd | &lt;span class="nb"&gt;cut&lt;/span&gt; &lt;span class="nt"&gt;-d&lt;/span&gt; &lt;span class="s1"&gt;':'&lt;/span&gt; &lt;span class="nt"&gt;-f&lt;/span&gt; 1 | &lt;span class="nb"&gt;head
&lt;/span&gt;root
daemon
bin
sys
&lt;span class="nb"&gt;sync
&lt;/span&gt;games
man
lp
mail
news
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;comm: 用于比较 两个文本的变化差异: comm file1 file2 其结果 第一列 显式 file1 独有的，第二列 显示 file2 独有的， 第三列 显示 file1 file2 共同的&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;root@precise64:~/shell_test# &lt;span class="nb"&gt;cat &lt;/span&gt;file1.text
a
b
c
d

root@precise64:~/shell_test# &lt;span class="nb"&gt;cat &lt;/span&gt;file2.text
b
c
d
e

// 注意 其展现形式， 第一列only file1 have  第二列 only file2 have  第三列 &lt;span class="nb"&gt;comm
&lt;/span&gt;root@precise64:~/shell_test# &lt;span class="nb"&gt;comm &lt;/span&gt;file1.text file2.text
a
        b
        c
        d
    e
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/li&gt;
  &lt;li&gt;https://toroid.org/unix-pipe-implementation&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;diff: diff file1.txt file2.txt； diff 展现的格式 都为 更改 file1.txt 转变到 file2.txt 的操作序列，即是 字符串 之间最小编辑记录 在文件中的应用。&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;root@precise64:~/shell_test# &lt;span class="nb"&gt;cat &lt;/span&gt;file1.text
a
b
c
d
root@precise64:~/shell_test# &lt;span class="nb"&gt;cat &lt;/span&gt;file2.text
b
c
d
e

root@precise64:~/shell_test# diff file1.text  file2.text
1d0
&amp;lt; a
4a4
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; e
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;Change&lt;/th&gt;
          &lt;th&gt;meaning&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;r1ar2&lt;/td&gt;
          &lt;td&gt;将 file2 中的 r2行 追加到 file1 中的 r1 行中&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;r1cr2&lt;/td&gt;
          &lt;td&gt;将 file1 中 r1 行 替换为 file2中的 r2 行&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;r1dr2&lt;/td&gt;
          &lt;td&gt;将 file1中的r1行删除掉，下一行将出现在 file2中的 r2 行&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;blockquote&gt;
      &lt;p&gt;此格式为默认格式，但是因为不够直观，所以这种格式并不常用。&lt;br /&gt;
上下文格式：diff -c file1.txt file2.txt&lt;/p&gt;
    &lt;/blockquote&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;root@precise64:~/shell_test# diff &lt;span class="nt"&gt;-c&lt;/span&gt; file1.text  file2.text
&lt;span class="k"&gt;***&lt;/span&gt; file1.text	2020-09-24 08:02:08.202406914 +0000 // &lt;span class="k"&gt;**&lt;/span&gt; 代表 file1.txt，其后是 时间戳
&lt;span class="nt"&gt;---&lt;/span&gt; file2.text	2020-09-24 08:02:15.854515682 +0000 // &lt;span class="nt"&gt;--&lt;/span&gt; 代表 file2.txt 其后是 时间戳
&lt;span class="k"&gt;***************&lt;/span&gt;
&lt;span class="k"&gt;***&lt;/span&gt; 1,4 &lt;span class="k"&gt;****&lt;/span&gt; // &lt;span class="k"&gt;**&lt;/span&gt; 代表 file1.txt
- a
  b
  c
  d
&lt;span class="nt"&gt;---&lt;/span&gt; 1,4 &lt;span class="nt"&gt;----&lt;/span&gt; // &lt;span class="nt"&gt;--&lt;/span&gt; 代表 file2.txt
  b
  c
  d
+ e
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;Indicator&lt;/th&gt;
          &lt;th&gt;Meaning&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;blank&lt;/td&gt;
          &lt;td&gt;此行 两个文件没有差别&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;需要删除该行(只会出现在 file1中，因为目的是 将file1 转向 file2)&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;+&lt;/td&gt;
          &lt;td&gt;添加该行 （只会出现在file2中，代表 需要将该行添加到 file1中）&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;!&lt;/td&gt;
          &lt;td&gt;两个文件中都会出现，代表 file1中的该行 需要被 file2中的 对应行 替换&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;blockquote&gt;
      &lt;p&gt;统一格式： diff -u file1.txt file2.txt&lt;/p&gt;
    &lt;/blockquote&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;root@precise64:~/shell_test# diff &lt;span class="nt"&gt;-u&lt;/span&gt; file1.text file2.text
&lt;span class="nt"&gt;---&lt;/span&gt; file1.text	2020-09-24 08:02:08.202406914 +0000
+++ file2.text	2020-09-25 04:41:15.154310271 +0000
@@ &lt;span class="nt"&gt;-1&lt;/span&gt;,4 +1,4 @@
&lt;span class="nt"&gt;-a&lt;/span&gt;
 b
 c
 d
+e
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;Character&lt;/th&gt;
          &lt;th&gt;Meaning&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;blank&lt;/td&gt;
          &lt;td&gt;no change&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;从file1 文件中删除该行&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;+&lt;/td&gt;
          &lt;td&gt;从file1 文件中添加该行&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;blockquote&gt;
      &lt;p&gt;也就是说 统一格式 中，将 ！替换操作去除了，通过 - + 来实现了 替换操作&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;patch: 用来将diff 出的结果 apply。 即是： diff -Naur old_file new_file &amp;gt; diff_file; patch &amp;lt; diff_file; 之后 old_file 会转变为 same as new_file&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="shell-语法"&gt;shell 语法&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;Variables and Constants
    &lt;ul&gt;
      &lt;li&gt;shell 中的变量 是 动态的，不需要预先声明 与类型指定（因为没有类型，可能都为字符串），对于 使用 未定义 未赋值 的变量 其 数值 为 空。 所以我们需要 注意自己的拼写错误，因为 shell可能会将其视为 新变量。&lt;/li&gt;
      &lt;li&gt;常量： 规范 使用 全大写 命名 常量，以区分于 普通变量。 也可以使用 declare -r TITLE=”Page Title” 来进行声明&lt;/li&gt;
      &lt;li&gt;赋值： variable=value  shell 并不区分 value的类型， value 全部被视为 string， 注意= 左右没有空格&lt;/li&gt;
      &lt;li&gt;变量数值引用 需要注意， 因为语法原因 可能 需要使用 {} 来避免 变量名与表达式 的歧义&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;  &lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;z &lt;span class="c"&gt;# a 赋值为 string z&lt;/span&gt;
  &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"a string"&lt;/span&gt;
  &lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"a string and &lt;/span&gt;&lt;span class="nv"&gt;$b&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="c"&gt;# c &lt;/span&gt;

  &lt;span class="nv"&gt;d&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="si"&gt;$(&lt;/span&gt;&lt;span class="nb"&gt;ls&lt;/span&gt; &lt;span class="nt"&gt;-l&lt;/span&gt; foo.txt&lt;span class="si"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="c"&gt;# value 为子命令结果&lt;/span&gt;
  &lt;span class="nv"&gt;e&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$((&lt;/span&gt;&lt;span class="m"&gt;5&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="m"&gt;7&lt;/span&gt;&lt;span class="k"&gt;))&lt;/span&gt; &lt;span class="c"&gt;# 数值计算展开&lt;/span&gt;

  &lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;5 &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"string"&lt;/span&gt; &lt;span class="c"&gt;# 多个变量可以 同时声明&lt;/span&gt;

  &lt;span class="nv"&gt;filename&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"myfile"&lt;/span&gt;
  &lt;span class="nb"&gt;touch&lt;/span&gt; &lt;span class="nv"&gt;$filename&lt;/span&gt;
  &lt;span class="nb"&gt;mv&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$filename&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$filename1&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;  &lt;span class="c"&gt;# 这里面的本意是 更改myfile 文件为 myfile1，但是因为并没有 区分 $filename1 是变量还是表达式, 所以这里需要 使用新的形势 来进行区分&lt;/span&gt;
  &lt;span class="nb"&gt;mv&lt;/span&gt;: missing destination file operand after &lt;span class="sb"&gt;`&lt;/span&gt;myfile&lt;span class="s1"&gt;'
  Try `mv --help'&lt;/span&gt; &lt;span class="k"&gt;for &lt;/span&gt;more information.

  &lt;span class="nb"&gt;mv&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$filename&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;filename&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;1"&lt;/span&gt; &lt;span class="c"&gt;# 使用 {} 来解决歧义&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="function-define"&gt;function define:&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;  &lt;span class="k"&gt;function &lt;/span&gt;name &lt;span class="o"&gt;{&lt;/span&gt;
      commands
      &lt;span class="k"&gt;return&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;

  name&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
      commands
      &lt;span class="k"&gt;return&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;local var: 局部变量， local foo=&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="flow-control"&gt;Flow Control:&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;if&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;  &lt;span class="k"&gt;if &lt;/span&gt;commands&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then 
    &lt;/span&gt;commands
  &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="k"&gt;elif &lt;/span&gt;commands&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then 
    &lt;/span&gt;commands...]
  &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="k"&gt;else 
    &lt;/span&gt;commands]
  &lt;span class="k"&gt;fi&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;exit status: 一般为 为一个 0-255 的数值， 0 代表 success， 其他值代表不同的错误。所以0 代表true，false 代表1， 不同于其他语言中的惯例。$? 代表 上个命令执行的返回结果&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;  root@precise64:~/shell_test# &lt;span class="nb"&gt;ls&lt;/span&gt; &lt;span class="nt"&gt;-d&lt;/span&gt; /usr/bin/
  /usr/bin/
  root@precise64:~/shell_test# &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$?&lt;/span&gt;
  0
  root@precise64:~/shell_test# &lt;span class="nb"&gt;ls&lt;/span&gt; &lt;span class="nt"&gt;-d&lt;/span&gt; /bin/usr
  &lt;span class="nb"&gt;ls&lt;/span&gt;: cannot access /bin/usr: No such file or directory
  root@precise64:~/shell_test# &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$?&lt;/span&gt;
  2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;test： 配合if 使用，返回condition 结果: 两种形式. 成功返回0， 失败 返回1&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="nb"&gt;test &lt;/span&gt;expression

&lt;span class="o"&gt;[&lt;/span&gt;expression]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;h4 id="相关的测试expression"&gt;相关的测试expression&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;file Expression&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;Expression&lt;/th&gt;
          &lt;th&gt;Is True?&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;file1 -ef file2&lt;/td&gt;
          &lt;td&gt;file1 inode eq file2 inode true&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;file1 -nt file2&lt;/td&gt;
          &lt;td&gt;file1 is newer than file2&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;file1 -ot file2&lt;/td&gt;
          &lt;td&gt;file1 is older than file2&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;-b file&lt;/td&gt;
          &lt;td&gt;file exist and is a block-special file&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;-c file&lt;/td&gt;
          &lt;td&gt;file exist and is a char-special file&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;-d file&lt;/td&gt;
          &lt;td&gt;file exists and is a dir&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;-e file&lt;/td&gt;
          &lt;td&gt;file exists&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;-f file&lt;/td&gt;
          &lt;td&gt;file exists and a regular file&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;-g file&lt;/td&gt;
          &lt;td&gt;file exists and is set-group-id&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;-G file&lt;/td&gt;
          &lt;td&gt;file exists and is owner by the effective group ID&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;-k file&lt;/td&gt;
          &lt;td&gt;file exists and has its ‘sticky bit’ sit&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;-L file&lt;/td&gt;
          &lt;td&gt;file exists and is a sym link&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;-p file&lt;/td&gt;
          &lt;td&gt;file exists and a named pipe&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;-r file&lt;/td&gt;
          &lt;td&gt;file exists and can readable&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;-s file&lt;/td&gt;
          &lt;td&gt;file exists and has a length greater than zero&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;-S file&lt;/td&gt;
          &lt;td&gt;file exists and a socket&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;-w file&lt;/td&gt;
          &lt;td&gt;file exists and writable&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;-x fiel&lt;/td&gt;
          &lt;td&gt;file exists and executeable&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;string expression&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;Expression&lt;/th&gt;
          &lt;th&gt;Meaning&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;string&lt;/td&gt;
          &lt;td&gt;string is not null&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;-n string&lt;/td&gt;
          &lt;td&gt;string len is not zero&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;-z string&lt;/td&gt;
          &lt;td&gt;string len is zero&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;str1 == str2&lt;/td&gt;
          &lt;td&gt;equal&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;str1 != str2&lt;/td&gt;
          &lt;td&gt;not equal&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;str1 &amp;gt; str2&lt;/td&gt;
          &lt;td&gt;str1 sorts after str2&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;str1 &amp;lt; str2&lt;/td&gt;
          &lt;td&gt;str1 sort before str2&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;blockquote&gt;
      &lt;p&gt;这里面 需要注意: the &amp;gt; and &amp;lt; expression operators must be quoted (or escaped with a backslash) when used with test. If they are not, they will be interpreted by the&lt;br /&gt;
shell as redirection operators&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Integer Expressions&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;Expression&lt;/th&gt;
          &lt;th&gt;Meaning&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;int1 -eq int2&lt;/td&gt;
          &lt;td&gt;equal&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;int1 -ne int2&lt;/td&gt;
          &lt;td&gt;not equal&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;int1 -le int2&lt;/td&gt;
          &lt;td&gt;int1 &amp;lt;= int2&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;int1 -lt int2&lt;/td&gt;
          &lt;td&gt;int1 &amp;lt; int2&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;int1 -ge int2&lt;/td&gt;
          &lt;td&gt;int1 &amp;gt;= int2&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;int1 -gt int2&lt;/td&gt;
          &lt;td&gt;int1 &amp;gt; int2&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;[[ expression ]] : 类似于 [ expression ], 大使可以测试 string1 =~ regex&lt;/li&gt;
  &lt;li&gt;(( )): Designed for Integers, 用于测试 数学计算， 如果 数值 为非0 则是true， 0 则为false。在(()) 中变量可以直接 使用，不用带 $, 例如, 在其中 可以使用 所有的数学表达式，比如 &amp;gt;, &amp;lt;, &amp;gt;=, &amp;lt;=, ==, %, /, * etc&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;  &lt;span class="nv"&gt;INT&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;5
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;((&lt;/span&gt;INT &lt;span class="o"&gt;==&lt;/span&gt; 0&lt;span class="o"&gt;))&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then
      &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"INT is zero"&lt;/span&gt;
  &lt;span class="k"&gt;fi&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Combining Expressions:&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;Operation&lt;/th&gt;
          &lt;th&gt;test&lt;/th&gt;
          &lt;th&gt;[[]] and (())&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;AND&lt;/td&gt;
          &lt;td&gt;-a&lt;/td&gt;
          &lt;td&gt;&amp;amp;&amp;amp;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;OR&lt;/td&gt;
          &lt;td&gt;-o&lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;NOT&lt;/td&gt;
          &lt;td&gt;!&lt;/td&gt;
          &lt;td&gt;!&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;for example:&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="c"&gt;#!/bin/bash&lt;/span&gt;

&lt;span class="nv"&gt;MIN_VAL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1
&lt;span class="nv"&gt;MAX_VAL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;100


&lt;span class="nv"&gt;INT&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;50
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[[&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$INT&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;~ ^-?[0-9]+&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="o"&gt;]]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then
    if&lt;/span&gt; &lt;span class="o"&gt;[[&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$INT&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="nt"&gt;-ge&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$MIN_VAL&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$INT&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="nt"&gt;-le&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$MAX_VAL&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;]]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then
        &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$INT&lt;/span&gt;&lt;span class="s2"&gt; is within &lt;/span&gt;&lt;span class="nv"&gt;$MIN_VAL&lt;/span&gt;&lt;span class="s2"&gt; to &lt;/span&gt;&lt;span class="nv"&gt;$MAX_VAL&lt;/span&gt;&lt;span class="s2"&gt;."&lt;/span&gt;
    &lt;span class="k"&gt;else
        &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$INT&lt;/span&gt;&lt;span class="s2"&gt; is out of range."&lt;/span&gt;
    &lt;span class="k"&gt;fi
else
    &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"INT is not an integer."&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&amp;amp;2
    &lt;span class="nb"&gt;exit &lt;/span&gt;1
&lt;span class="k"&gt;fi&lt;/span&gt;


&lt;span class="c"&gt;# 等价的另一种方式&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$INT&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="nt"&gt;-ge&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$MIN_VAL&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="nt"&gt;-a&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$INT&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="nt"&gt;-le&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$MAX_VAL&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then
  &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$INT&lt;/span&gt;&lt;span class="s2"&gt; is within &lt;/span&gt;&lt;span class="nv"&gt;$MIN_VAL&lt;/span&gt;&lt;span class="s2"&gt; to &lt;/span&gt;&lt;span class="nv"&gt;$MAX_VAL&lt;/span&gt;&lt;span class="s2"&gt;."&lt;/span&gt;
&lt;span class="k"&gt;else
  &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$INT&lt;/span&gt;&lt;span class="s2"&gt; is out of range."&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="read-read-用于-从标准输入中-读取数值"&gt;read: read 用于 从标准输入中 读取数值。&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Options&lt;/th&gt;
      &lt;th&gt;Desc&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-a array&lt;/td&gt;
      &lt;td&gt;将输入赋值（转化）给 数组&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-e&lt;/td&gt;
      &lt;td&gt;使用 Readline 模式 处理输入&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-i string&lt;/td&gt;
      &lt;td&gt;默认数值，在玩家仅仅按 enter的时候 有用&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-p prompt&lt;/td&gt;
      &lt;td&gt;输入的 提示信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-r&lt;/td&gt;
      &lt;td&gt;Raw mode. Do not interpret backslash characters as escapes.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-s&lt;/td&gt;
      &lt;td&gt;slient mode, 用于密码输入&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-t seconds&lt;/td&gt;
      &lt;td&gt;Timeout after seconds&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-u fd&lt;/td&gt;
      &lt;td&gt;使用file 作为输入，而不是标准输入&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;read：将 标准输入 转到 变量 的使用格式： read  [-options] [variable…]&lt;/li&gt;
  &lt;li&gt;read 存在默认变量 REPLY，即当没有 variable 传递的时候&lt;/li&gt;
  &lt;li&gt;for example&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;  &lt;span class="c"&gt;#!/bin/bash&lt;/span&gt;

  &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nt"&gt;-n&lt;/span&gt; &lt;span class="s2"&gt;"please enter an integer -&amp;gt; "&lt;/span&gt;
  &lt;span class="nb"&gt;read &lt;/span&gt;int

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[[&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$int&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;~ ^-?[0-9]+&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="o"&gt;]]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then
      if&lt;/span&gt; &lt;span class="o"&gt;((&lt;/span&gt; int &lt;span class="o"&gt;==&lt;/span&gt; 0 &lt;span class="o"&gt;))&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then
          &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"int is zero"&lt;/span&gt;
      &lt;span class="k"&gt;else
          if&lt;/span&gt; &lt;span class="o"&gt;((&lt;/span&gt; int &amp;lt; 0&lt;span class="o"&gt;))&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then
              &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$int&lt;/span&gt;&lt;span class="s2"&gt; is negative"&lt;/span&gt;
          &lt;span class="k"&gt;else
              &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$int&lt;/span&gt;&lt;span class="s2"&gt; is positive"&lt;/span&gt;
          &lt;span class="k"&gt;fi
      fi
  fi&lt;/span&gt;

  &lt;span class="c"&gt;#  read 多个var 测试, 与ruby array 复制差不多，&lt;/span&gt;
  &lt;span class="c"&gt;# 即是：当多个 参数数目 &amp;gt; 变量数目 时 剩余的变量为空值，当 参数数目 &amp;lt; 变量数目时 最后后一个变量 存储多个数值&lt;/span&gt;

  &lt;span class="c"&gt;#!/bin/bash&lt;/span&gt;
  &lt;span class="c"&gt;# read-multiple: read multiple values from keyboard&lt;/span&gt;
  &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nt"&gt;-n&lt;/span&gt; &lt;span class="s2"&gt;"Enter one or more values &amp;gt; "&lt;/span&gt;
  &lt;span class="nb"&gt;read &lt;/span&gt;var1 var2 var3 var4 var5
  &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"var1 = '&lt;/span&gt;&lt;span class="nv"&gt;$var1&lt;/span&gt;&lt;span class="s2"&gt;'"&lt;/span&gt;
  &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"var2 = '&lt;/span&gt;&lt;span class="nv"&gt;$var2&lt;/span&gt;&lt;span class="s2"&gt;'"&lt;/span&gt;
  &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"var3 = '&lt;/span&gt;&lt;span class="nv"&gt;$var3&lt;/span&gt;&lt;span class="s2"&gt;'"&lt;/span&gt;
  &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"var4 = '&lt;/span&gt;&lt;span class="nv"&gt;$var4&lt;/span&gt;&lt;span class="s2"&gt;'"&lt;/span&gt;
  &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"var5 = '&lt;/span&gt;&lt;span class="nv"&gt;$var5&lt;/span&gt;&lt;span class="s2"&gt;'"&lt;/span&gt;

  vagrant@precise64:/vagrant_data/shell_test&lt;span class="nv"&gt;$ &lt;/span&gt;./read-multiple.sh
  Enter one or more values &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; 1 2 3 4 4 45 5
  var1 &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'1'&lt;/span&gt;
  var2 &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'2'&lt;/span&gt;
  var3 &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'3'&lt;/span&gt;
  var4 &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'4'&lt;/span&gt;
  var5 &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'4 45 5'&lt;/span&gt;

  vagrant@precise64:/vagrant_data/shell_test&lt;span class="nv"&gt;$ &lt;/span&gt;./read-multiple.sh
  Enter one or more values &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; 1
  var1 &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'1'&lt;/span&gt;
  var2 &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;''&lt;/span&gt;
  var3 &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;''&lt;/span&gt;
  var4 &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;''&lt;/span&gt;
  var5 &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;''&lt;/span&gt;

  &lt;span class="c"&gt;# read 不传递 var 时候，默认使用变量 REPLY&lt;/span&gt;
  &lt;span class="c"&gt;#!/bin/bash&lt;/span&gt;
  &lt;span class="c"&gt;# read-single: read multiple values into default variable&lt;/span&gt;
  &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nt"&gt;-n&lt;/span&gt; &lt;span class="s2"&gt;"Enter one or more values &amp;gt; "&lt;/span&gt;
  &lt;span class="nb"&gt;read
  echo&lt;/span&gt; &lt;span class="s2"&gt;"REPLY = '&lt;/span&gt;&lt;span class="nv"&gt;$REPLY&lt;/span&gt;&lt;span class="s2"&gt;'"&lt;/span&gt;

  vagrant@precise64:/vagrant_data/shell_test&lt;span class="nv"&gt;$ &lt;/span&gt;./read-single.sh
  Enter one or more values &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; 1
  REPLY &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'1'&lt;/span&gt;



&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;IFS （Internal Field Separator） : 用来控制 read 分隔line 的分隔符， 默认的IFS 包含 space, tab, newline&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用read的 这种方式， 可以很简单的 做 字符串的 split&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="nv"&gt;IFS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;":"&lt;/span&gt; &lt;span class="nb"&gt;read &lt;/span&gt;user pw uid gid name home shell &lt;span class="o"&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s2"&gt;"root:x:0:0:root:/root:/bin/bash"&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"string: &lt;/span&gt;&lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;user&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;, pw: &lt;/span&gt;&lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;pw&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;, uid: &lt;/span&gt;&lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;uid&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;, shell: &lt;/span&gt;&lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;shell&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="flow-control-looping-with-whileuntil"&gt;Flow Control: Looping with while/until&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;while: shell 中 同样存在 continue break 可供使用，以便提前 循环、或者 终止循环&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;  &lt;span class="k"&gt;while &lt;/span&gt;commands&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do
      &lt;/span&gt;commands
  &lt;span class="k"&gt;done


  &lt;/span&gt;&lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1
  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="o"&gt;[[&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$count&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="nt"&gt;-le&lt;/span&gt; 5 &lt;span class="o"&gt;]]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="k"&gt;do &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$count&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
      &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$((&lt;/span&gt;count &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="k"&gt;))&lt;/span&gt;
  &lt;span class="k"&gt;done
  &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"Finished."&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;until: 与while 同样的基本结构，不过测试条件相反&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;  &lt;span class="c"&gt;#!/bin/bash&lt;/span&gt;
  &lt;span class="c"&gt;# until-count: display a series of numbers count=1&lt;/span&gt;
  &lt;span class="k"&gt;until&lt;/span&gt; &lt;span class="o"&gt;[[&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$count&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="nt"&gt;-gt&lt;/span&gt; 5 &lt;span class="o"&gt;]]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do
      &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$count&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
      &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$((&lt;/span&gt;count &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="k"&gt;))&lt;/span&gt;
  &lt;span class="k"&gt;done
  &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"Finished."&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;读取文件的循环示例：&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="c"&gt;#!/bin/bash&lt;/span&gt;
&lt;span class="c"&gt;# while-read: read lines from a file&lt;/span&gt;
&lt;span class="k"&gt;while &lt;/span&gt;&lt;span class="nb"&gt;read &lt;/span&gt;distro version release&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do
    &lt;/span&gt;&lt;span class="nb"&gt;printf&lt;/span&gt; &lt;span class="s2"&gt;"Distro: %s&lt;/span&gt;&lt;span class="se"&gt;\t&lt;/span&gt;&lt;span class="s2"&gt;Version: %s&lt;/span&gt;&lt;span class="se"&gt;\t&lt;/span&gt;&lt;span class="s2"&gt;Released: %s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
        &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$distro&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
        &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$version&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
        &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$release&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
&lt;span class="k"&gt;done&lt;/span&gt; &amp;lt; distros.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;shell 的测试： 1） 除了 print 大法好(在这里是echo 之外) 2) #!/bin/bash -x  这样在脚本运行期间，将会 展示详细信息, 可以 使用 set +x 关闭 tracing set -x开启 tracing&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;case:  使用 pattern 进行匹配，) 结束 匹配。 还可以参考链接 http://tiswww.case.edu/php/chet/bash/bashref.html#SEC21 http://tldp.org/LDP/abs/html/testbranch.html 因为这里面介绍的十分简单&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;Pattern&lt;/th&gt;
          &lt;th&gt;Desc&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;a)&lt;/td&gt;
          &lt;td&gt;Match if word equal ‘a’&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;[[:aplpha:]])&lt;/td&gt;
          &lt;td&gt;Match if word is a single alphabetic char&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;???)&lt;/td&gt;
          &lt;td&gt;Match if word is exactly three char long&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;*.txt)&lt;/td&gt;
          &lt;td&gt;Match if word ends with the char “.txt”&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;*)&lt;/td&gt;
          &lt;td&gt;Matches anyy value of word&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="k"&gt;case&lt;/span&gt; word &lt;span class="k"&gt;in&lt;/span&gt;
    &lt;span class="o"&gt;[&lt;/span&gt;pattern &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt; pattern]...&lt;span class="p"&gt;)&lt;/span&gt; commands &lt;span class="p"&gt;;;&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;...
&lt;span class="k"&gt;esac&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;for example&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="c"&gt;#!/bin/bash -x&lt;/span&gt;

&lt;span class="nb"&gt;read&lt;/span&gt; &lt;span class="nt"&gt;-p&lt;/span&gt; &lt;span class="s2"&gt;"Enter selection [0-3] &amp;gt; "&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$REPLY&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="k"&gt;in
    &lt;/span&gt;0&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"Program terminated."&lt;/span&gt;
       &lt;span class="nb"&gt;exit&lt;/span&gt;
       &lt;span class="p"&gt;;;&lt;/span&gt;
    1&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"Hostname: &lt;/span&gt;&lt;span class="nv"&gt;$HOSTNAME&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
       &lt;span class="nb"&gt;uptime&lt;/span&gt;
       &lt;span class="p"&gt;;;&lt;/span&gt;
    2&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nb"&gt;df&lt;/span&gt; &lt;span class="nt"&gt;-h&lt;/span&gt;
       &lt;span class="p"&gt;;;&lt;/span&gt;
    3&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[[&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="si"&gt;$(&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt; &lt;span class="nt"&gt;-u&lt;/span&gt;&lt;span class="si"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="nt"&gt;-eq&lt;/span&gt; 0 &lt;span class="o"&gt;]]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then
           &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"Home Space Utilization (All Users)"&lt;/span&gt;
           &lt;span class="nb"&gt;du&lt;/span&gt; &lt;span class="nt"&gt;-sh&lt;/span&gt; /home/&lt;span class="k"&gt;*&lt;/span&gt;
       &lt;span class="k"&gt;else
           &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"Home Space Utilization (&lt;/span&gt;&lt;span class="nv"&gt;$USER&lt;/span&gt;&lt;span class="s2"&gt;)"&lt;/span&gt;
           &lt;span class="nb"&gt;du&lt;/span&gt; &lt;span class="nt"&gt;-sh&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$HOME&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
       &lt;span class="k"&gt;fi&lt;/span&gt;
       &lt;span class="p"&gt;;;&lt;/span&gt;
    &lt;span class="k"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"Invalid entry"&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&amp;amp;2
       &lt;span class="nb"&gt;exit &lt;/span&gt;1
       &lt;span class="p"&gt;;;&lt;/span&gt;
&lt;span class="k"&gt;esac&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;h3 id="accessing-the-command-line"&gt;Accessing the Command Line:&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;shell 中 通过 $0-$9 来接受 command line 传递的参数。其中9 并不是 参数个数的上线，可以使用 更多的比如 $11, $100000 来使用 第 1000000 个参数。&lt;/li&gt;
  &lt;li&gt;$# 标志 参数个数。其中 $0 总是为 shell本身&lt;/li&gt;
  &lt;li&gt;shift： shift可以将 将 $1后续的变量，转移到 $1上， 同时 $# 减少&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;  &lt;span class="c"&gt;#!/bin/bash&lt;/span&gt;
  &lt;span class="c"&gt;# posit-param2: script to display all arguments count=1&lt;/span&gt;
  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="o"&gt;[[&lt;/span&gt; &lt;span class="nv"&gt;$# &lt;/span&gt;&lt;span class="nt"&gt;-gt&lt;/span&gt; 0 &lt;span class="o"&gt;]]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do
    &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"Argument &lt;/span&gt;&lt;span class="nv"&gt;$count&lt;/span&gt;&lt;span class="s2"&gt; = &lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
    &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$((&lt;/span&gt;count &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="k"&gt;))&lt;/span&gt;
    &lt;span class="nb"&gt;shift
  &lt;/span&gt;&lt;span class="k"&gt;done&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;同样是 作为 函数 传递参数的方式：&lt;/li&gt;
  &lt;li&gt;常量： PROGNAME当前shell运行的函数， FUNCNAME 为shell当前运行的shell函数&lt;/li&gt;
  &lt;li&gt;$* $@ “$*” “$@” : “$@” 在这里面是最为 重要的，以为保留了 原来参数传递的样式&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;// fun_test.sh file
&lt;span class="c"&gt;#!/bin/bash&lt;/span&gt;
&lt;span class="c"&gt;# posit-params3: script to demonstrate $* and $@&lt;/span&gt;
print_params &lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\$&lt;/span&gt;&lt;span class="s2"&gt;1 = &lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\$&lt;/span&gt;&lt;span class="s2"&gt;2 = &lt;/span&gt;&lt;span class="nv"&gt;$2&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\$&lt;/span&gt;&lt;span class="s2"&gt;3 = &lt;/span&gt;&lt;span class="nv"&gt;$3&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\$&lt;/span&gt;&lt;span class="s2"&gt;4 = &lt;/span&gt;&lt;span class="nv"&gt;$4&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
pass_params &lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nt"&gt;-e&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="s1"&gt;'$*'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; print_params &lt;span class="nv"&gt;$*&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nt"&gt;-e&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="s1"&gt;'$*'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; print_params &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$*&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nt"&gt;-e&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="s1"&gt;'$@'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; print_params &lt;span class="nv"&gt;$@&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nt"&gt;-e&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="s1"&gt;'$@'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; print_params &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$@&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
pass_params &lt;span class="s2"&gt;"word"&lt;/span&gt; &lt;span class="s2"&gt;"words with spaces"&lt;/span&gt;


// ./fun_test.sh 测试
root@precise64:/vagrant_data/shell_test# ./fun_test.sh

 &lt;span class="nv"&gt;$*&lt;/span&gt;
&lt;span class="nv"&gt;$1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; word
&lt;span class="nv"&gt;$2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; words
&lt;span class="nv"&gt;$3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; with
&lt;span class="nv"&gt;$4&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; spaces

 &lt;span class="nv"&gt;$*&lt;/span&gt;
&lt;span class="nv"&gt;$1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; word words with spaces
&lt;span class="nv"&gt;$2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
&lt;span class="nv"&gt;$3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
&lt;span class="nv"&gt;$4&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;

 &lt;span class="nv"&gt;$@&lt;/span&gt;
&lt;span class="nv"&gt;$1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; word
&lt;span class="nv"&gt;$2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; words
&lt;span class="nv"&gt;$3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; with
&lt;span class="nv"&gt;$4&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; spaces

 &lt;span class="nv"&gt;$@&lt;/span&gt;
&lt;span class="nv"&gt;$1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; word
&lt;span class="nv"&gt;$2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; words with spaces
&lt;span class="nv"&gt;$3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
&lt;span class="nv"&gt;$4&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="for-loop"&gt;for loop:&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;传统形式&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="k"&gt;for &lt;/span&gt;variable &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="k"&gt;in &lt;/span&gt;words]&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do 
  &lt;/span&gt;commands
&lt;span class="k"&gt;done&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;c语言形式： 只支持 在对 数字 进行操作的时候&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;((&lt;/span&gt; expression1&lt;span class="p"&gt;;&lt;/span&gt; expression2&lt;span class="p"&gt;;&lt;/span&gt; expression3 &lt;span class="o"&gt;))&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do
  &lt;/span&gt;commands
&lt;span class="k"&gt;done

for&lt;/span&gt; &lt;span class="o"&gt;((&lt;/span&gt; &lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0&lt;span class="p"&gt;;&lt;/span&gt; i&amp;lt;5&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;i+1 &lt;span class="o"&gt;))&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do
    &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$i&lt;/span&gt;
&lt;span class="k"&gt;done&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;example&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="k"&gt;for &lt;/span&gt;i &lt;span class="k"&gt;in &lt;/span&gt;A B C D&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;done
&lt;/span&gt;A
B
C
D


&lt;span class="k"&gt;for &lt;/span&gt;i &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;A..D&lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;done
&lt;/span&gt;A
B
C
D

&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="k"&gt;for &lt;/span&gt;i &lt;span class="k"&gt;in &lt;/span&gt;distros&lt;span class="k"&gt;*&lt;/span&gt;.txt&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$i&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;done
&lt;/span&gt;distros-by-date.txt
distros-dates.txt
distros-key-names.txt
distros-key-vernums.txt
distros-names.txt
distros.txt
distros-vernums.txt
distros-versions.txt



&lt;span class="c"&gt;# ./for_test.sh file&lt;/span&gt;
&lt;span class="k"&gt;for &lt;/span&gt;i&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do
    &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"i in ---------- &lt;/span&gt;&lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt;&lt;span class="s2"&gt; &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
&lt;span class="k"&gt;done&lt;/span&gt;


&lt;span class="c"&gt;# 可以使用如此的方式，循环打印 command line 参数&lt;/span&gt;
root@precise64:/vagrant_data/shell_test# ./for_test.sh  a b c d e f j
i &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="nt"&gt;----------&lt;/span&gt; a &lt;span class="se"&gt;\n&lt;/span&gt;
i &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="nt"&gt;----------&lt;/span&gt; b &lt;span class="se"&gt;\n&lt;/span&gt;
i &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="nt"&gt;----------&lt;/span&gt; c &lt;span class="se"&gt;\n&lt;/span&gt;
i &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="nt"&gt;----------&lt;/span&gt; d &lt;span class="se"&gt;\n&lt;/span&gt;
i &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="nt"&gt;----------&lt;/span&gt; e &lt;span class="se"&gt;\n&lt;/span&gt;
i &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="nt"&gt;----------&lt;/span&gt; f &lt;span class="se"&gt;\n&lt;/span&gt;
i &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="nt"&gt;----------&lt;/span&gt; j &lt;span class="se"&gt;\n&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="strings-and-numbers"&gt;Strings and Numbers&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;expression&lt;/th&gt;
      &lt;th&gt;meaning&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;${para:-word}&lt;/td&gt;
      &lt;td&gt;para 为空 express result 为 word&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;${para:=word}&lt;/td&gt;
      &lt;td&gt;para 为空 express &amp;amp; para result 为 word (position 参数不能够如此赋值)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;${pars:?word}&lt;/td&gt;
      &lt;td&gt;pars 为空 则exit，word被输出到 stderr&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;${para:+word}&lt;/td&gt;
      &lt;td&gt;para不为空，则 expres 为 word&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;${!prefix*} 或者  ${!prefix@}&lt;/td&gt;
      &lt;td&gt;返回 以 prefix 为前缀的 变量名称&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;${#para}&lt;/td&gt;
      &lt;td&gt;para length, 如果 para 为 @ 或者 * 则 展开为 command line params size&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;${para:offset} ${para:offset:length}&lt;/td&gt;
      &lt;td&gt;用于string 的片段截取，没有length时候，则直到末尾, para为 @时候, 则为 参数 从 offset开始 到结尾&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;${para#pattern} ${para##pattern}&lt;/td&gt;
      &lt;td&gt;将字符串remove pattern match的部分，结果为 剩下的部分， #pattern remove 最短的 match 部分， ## 则remove 最长的match&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;${para%pattern}  ${para%%pattern}&lt;/td&gt;
      &lt;td&gt;同上，但是 remove 片段从string 的末尾开始，而非开头开始&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;${para/pattern/string} ${para//pattern/string} ${para/#pattern/string} ${para/%pattern/string}&lt;/td&gt;
      &lt;td&gt;string 的查找替换操作，使用 string 替换 para中的 pattern matched，第一个只替换第一个， 第二个则全部替换， 第三个 则替换开头， 第四个只替换末尾&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;case conversion parameter&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Format&lt;/th&gt;
      &lt;th&gt;Result&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;${pars,,}&lt;/td&gt;
      &lt;td&gt;展开为  para 的 全部小写形式&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;${para,}&lt;/td&gt;
      &lt;td&gt;展开式 para 首字母 小写&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;${para^^}&lt;/td&gt;
      &lt;td&gt;展开为 para 的全部 大写形式&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;${para^}&lt;/td&gt;
      &lt;td&gt;展开为 para 首字母 大写形式&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id="数字操作-expression-基本形式"&gt;数字操作: $((expression)) 基本形式&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Operators&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Operator&lt;/th&gt;
      &lt;th&gt;Desc&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;+&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;*&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;*&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;**&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;%&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;para = value&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;para += value&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;para -= value&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;para *= value&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;para /= value&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;para %= value&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;para ++&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;para –&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;++ para&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;– para&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&amp;lt;=&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&amp;gt;=&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&amp;lt;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&amp;gt;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tfoot&gt;
    &lt;tr&gt;
      &lt;td&gt;!=&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&amp;amp;&amp;amp;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;expre1?expre2:expre3&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tfoot&gt;
&lt;/table&gt;

&lt;h4 id="array-bash-version2-才得到支持在原先的shell中-并不支持-array"&gt;Array: bash version2 才得到支持，在原先的shell中 并不支持 array&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Create a Array :&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;a[1]&lt;span class="o"&gt;=&lt;/span&gt;foo
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[1]&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt;

&lt;span class="nb"&gt;declare&lt;/span&gt; &lt;span class="nt"&gt;-a&lt;/span&gt; a
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;Assigning Values to an Array: name[subscript]=value; name=(value1 value2 …)&lt;/li&gt;
  &lt;li&gt;Array Operations: 遍历数组&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ animals&lt;/span&gt;&lt;span class="o"&gt;=(&lt;/span&gt;&lt;span class="s2"&gt;"a dog"&lt;/span&gt; &lt;span class="s2"&gt;"a cat"&lt;/span&gt; &lt;span class="s2"&gt;"a fish"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; 
&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="k"&gt;for &lt;/span&gt;i &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;animals&lt;/span&gt;&lt;span class="p"&gt;[*]&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;done 
&lt;/span&gt;a
dog
a
&lt;span class="nb"&gt;cat
&lt;/span&gt;a
fish

&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="k"&gt;for &lt;/span&gt;i &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;animals&lt;/span&gt;&lt;span class="p"&gt;[@]&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;done &lt;/span&gt;a
dog
a
&lt;span class="nb"&gt;cat
&lt;/span&gt;a
fish

&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="k"&gt;for &lt;/span&gt;i &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;animals&lt;/span&gt;&lt;span class="p"&gt;[*]&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;done
&lt;/span&gt;a dog a &lt;span class="nb"&gt;cat &lt;/span&gt;a fish

&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="k"&gt;for &lt;/span&gt;i &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;animals&lt;/span&gt;&lt;span class="p"&gt;[@]&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;done
&lt;/span&gt;a dog
a &lt;span class="nb"&gt;cat
&lt;/span&gt;a fish

&lt;span class="c"&gt;# "${!array[*]}", "${!array[@]}"&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ foo&lt;/span&gt;&lt;span class="o"&gt;=([&lt;/span&gt;2]&lt;span class="o"&gt;=&lt;/span&gt;a &lt;span class="o"&gt;[&lt;/span&gt;4]&lt;span class="o"&gt;=&lt;/span&gt;b &lt;span class="o"&gt;[&lt;/span&gt;6]&lt;span class="o"&gt;=&lt;/span&gt;c&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="k"&gt;for &lt;/span&gt;i &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;[@]&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;done 
&lt;/span&gt;a
b
c

&lt;span class="c"&gt;# 展示数组 有value的 indexs&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="k"&gt;for &lt;/span&gt;i &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="p"&gt;!foo[@]&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;done
&lt;/span&gt;2
4
6

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;Sorting an Array:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="c"&gt;#!/bin/bash&lt;/span&gt;
&lt;span class="c"&gt;# array-sort: Sort an array a=(f e d c b a)&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"Original array: &lt;/span&gt;&lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[@]&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
&lt;span class="c"&gt;# 传统的数组排序方式，因为shell并不会构建复杂的 类型系统 来进行 数组函数排序&lt;/span&gt;
&lt;span class="nv"&gt;a_sorted&lt;/span&gt;&lt;span class="o"&gt;=(&lt;/span&gt;&lt;span class="si"&gt;$(&lt;/span&gt;&lt;span class="k"&gt;for &lt;/span&gt;i &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[@]&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;done&lt;/span&gt; | &lt;span class="nb"&gt;sort&lt;/span&gt;&lt;span class="si"&gt;)&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"Sorted array: &lt;/span&gt;&lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;a_sorted&lt;/span&gt;&lt;span class="p"&gt;[@]&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;Deleting an Array: unset array; unset ‘array[index]’ array=xxxx 修改 array[0] 中的数值&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ foo&lt;/span&gt;&lt;span class="o"&gt;=(&lt;/span&gt;a b c d e f&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;[@]&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt;
a b c d e f
&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;unset &lt;/span&gt;foo
&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;[@]&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt;

&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="err"&gt;$&lt;/span&gt;


&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ foo&lt;/span&gt;&lt;span class="o"&gt;=(&lt;/span&gt;a b c d e f&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;[@]&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt;
a b c d e f
&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;unset&lt;/span&gt; &lt;span class="s1"&gt;'foo[2]'&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;[@]&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt;
a b d e f


&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ foo&lt;/span&gt;&lt;span class="o"&gt;=(&lt;/span&gt;a b c d e f&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ foo&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;[@]&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt;
b c d e f


&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ foo&lt;/span&gt;&lt;span class="o"&gt;=(&lt;/span&gt;a b c d e f&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;[@]&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt;
a b c d e f
&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ foo&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;A
&lt;span class="o"&gt;[&lt;/span&gt;me@linuxbox ~]&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;[@]&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt;
A b c d e f
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="group-commands-and-subshells"&gt;Group Commands and Subshells:&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;{ command1; command2; [command3; …] }&lt;/li&gt;
  &lt;li&gt;(command1; command2; [command3;…])&lt;br /&gt;
group commands  可以将  其中的command 的结果 很方便的 合并到一个 数据流汇总，例如：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;ls&lt;/span&gt; &lt;span class="nt"&gt;-l&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"Listing of foo.txt"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nb"&gt;cat &lt;/span&gt;foo.txt&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; output.txt
&lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="nb"&gt;ls&lt;/span&gt; &lt;span class="nt"&gt;-l&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"Listing of foo.txt"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nb"&gt;cat &lt;/span&gt;foo.txt&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; output.txt

&lt;span class="c"&gt;#等同于： &lt;/span&gt;
&lt;span class="nb"&gt;ls&lt;/span&gt; &lt;span class="nt"&gt;-l&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; output.txt
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"Listing of foo.txt"&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; output.txt
&lt;span class="nb"&gt;cat &lt;/span&gt;foo.txt &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; output.txt

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="process-substitution-区别于-group-commands--process-sub-运行在-子进程-中而group-command-则运行在当前进程中-所以从效率上来说-group-command-要快于-process-substitution-该技术使得--子进程-中的输出-到当前进程中-进行处理通常-将-子进程中的数据流-输出到当前-进程使用-read-处理"&gt;Process Substitution： 区别于 group commands ， Process sub 运行在 子进程 中，而group command 则运行在当前进程中， 所以从效率上来说 group command 要快于 process substitution, 该技术使得  子进程 中的输出 到当前进程中 进行处理。通常 将 子进程中的数据流 输出到当前 进程使用 read 处理。&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;形式为： &amp;lt;(list)， &amp;gt;(list)。 for example&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;
&lt;span class="c"&gt;#!/bin/bash&lt;/span&gt;
&lt;span class="c"&gt;# pro-sub: demo of process substitution&lt;/span&gt;
&lt;span class="k"&gt;while &lt;/span&gt;&lt;span class="nb"&gt;read &lt;/span&gt;attr links owner group size &lt;span class="nb"&gt;date time &lt;/span&gt;filename&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do
done&lt;/span&gt; &amp;lt; &amp;lt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;ls&lt;/span&gt; &lt;span class="nt"&gt;-l&lt;/span&gt; | &lt;span class="nb"&gt;tail&lt;/span&gt; &lt;span class="nt"&gt;-n&lt;/span&gt; +2&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="traps-处理-信号trap-argument-signal-signal--其中-argument-为string-例如"&gt;Traps: 处理 信号。trap argument signal [signal…]  其中 argument 为string， 例如：&lt;/h4&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;&lt;span class="nb"&gt;trap&lt;/span&gt; &lt;span class="s2"&gt;"echo 'I am ignoring you.'"&lt;/span&gt; SIGINT SIGTERM

&lt;span class="nb"&gt;trap &lt;/span&gt;exit_on_signal_SIGINT SIGINT
&lt;span class="nb"&gt;trap &lt;/span&gt;exit_on_signal_SIGTERM SIGTERM
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="docker-书籍"&gt;Docker 书籍&lt;/h2&gt;
&lt;h3 id="docker-的结构--客户端--服务器-docker-服务器-为一个守护进程下层抽象-docker-容器与客户端配合-提供了-一个restful-api-给-客户端"&gt;Docker 的结构：  客户端 + 服务器。 Docker 服务器 为一个守护进程，下层抽象 Docker 容器，与客户端配合 提供了 一个RESTful API 给 客户端。&lt;/h3&gt;
&lt;h3 id="概念-镜像-与-容器镜像是docker世界的基石类似于-面向对象中的-类-所有容器-都是基于-镜像-运行的也就是说-容器类似于-实例对象镜像-是-docker生命周期-中的-构建或-打包阶段容器则是启动和-执行阶段"&gt;概念： 镜像 与 容器。镜像是Docker世界的基石，类似于 面向对象中的 类， 所有容器 都是基于 镜像 运行的。也就是说 容器类似于 实例对象。镜像 是 Docker生命周期 中的 构建或 打包阶段，容器则是启动和 执行阶段。&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Docker容器： 一个镜像格式，一系列标准的操作，一个执行环境
    &lt;h3 id="docker-能够帮助我们做什么"&gt;docker 能够帮助我们做什么：&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;加速本地开发和构建流程，因为其高效轻量，可以方便本地开发人员进行构建&lt;/li&gt;
  &lt;li&gt;能够让独立服务在不同的应用环境中，得到相同的运行结果。&lt;/li&gt;
  &lt;li&gt;创建隔离的环境进行测试&lt;/li&gt;
  &lt;li&gt;都建一个多用户的平台及服务（PaaS）基础设施&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="docker的特性-linux-namespace-的作用"&gt;Docker的特性？ linux namespace 的作用：&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;文件系统隔离：每个容器都有自己的root文件系统&lt;/li&gt;
  &lt;li&gt;进程隔离： 每个容器都运行在自己的进程环境中&lt;/li&gt;
  &lt;li&gt;网络隔离：荣期间的虚拟网络接口和IP地址都是分开的&lt;/li&gt;
  &lt;li&gt;资源隔离和分组： 使用cgroups 将CPU 和内存之类的资源独立分配给每个Docker容器&lt;/li&gt;
  &lt;li&gt;写时复制： 文件系统都是通过写时复制创建的，这就意味着文件系统是分层的、快速的、占用小的磁盘空间&lt;/li&gt;
  &lt;li&gt;日志： 容器产生的STDOUT stderr, stdin 这些IO都会被收集并记录入日志，用来进行日志分析和故常排查&lt;/li&gt;
  &lt;li&gt;交互式shell： 用户可以创建一个伪造tty中断连接的，STDIN，为容器提供一个交互式的Shell
    &lt;h3 id="docker-守护进程服务器"&gt;Docker 守护进程（服务器）：&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;需要以root权限运行，以便处理 诸如 挂载文件系统 等特殊操作。&lt;/li&gt;
  &lt;li&gt;守护进程 监听 /var/run/docker.sock Unix套接字 来获得 Docker客户端的请求。&lt;/li&gt;
  &lt;li&gt;启动： ubuntu 中 start docker, stop docker， centos 中 service docker stop service docker start
    &lt;h3 id="docker-操作docker容器-则为-docker的运行态运行着-用户的process-容器内部同linux-namespace-一样进行了完全的隔离"&gt;Docker 操作：Docker容器 则为 Docker的运行态，运行着 用户的process， 容器内部同linux namespace 一样，进行了完全的隔离&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;创建容器： docker run -i -t ubuntu /bin/bash  -i 标志打开容器的STDIN， -t 为容器 分配一个伪 tty 终端&lt;/li&gt;
  &lt;li&gt;停止容器： docker stop daemon_dave; docker stop 2q3412c&lt;/li&gt;
  &lt;li&gt;删除容器： docker rm daemon_dave // 容器停止运行并不会自动清理，而需要 手动 rm，因为可能存在 重新 start 的需求。类似于进程&lt;/li&gt;
  &lt;li&gt;命名容器： docker run –name test_container -i -t ubuntu /bin/bash 容器的命名必须是唯一的。&lt;/li&gt;
  &lt;li&gt;创建守护式容器： (daemonized container): docker run –name daemon_dave -d ubuntu /bin/bash -c “while true; do echo hello world; sleep 1; done”//  -d 为 daemon运行的标志， 容器中的进程不能够退出&lt;/li&gt;
  &lt;li&gt;重启已经停止的容器： docker start test_container
    &lt;ul&gt;
      &lt;li&gt;附着到容器： docker attach test_container&lt;/li&gt;
      &lt;li&gt;查看容器日志： docker logs -f daemon_dave //&lt;/li&gt;
      &lt;li&gt;查看容器内进程： docker top daemon_dave&lt;/li&gt;
      &lt;li&gt;在容器内运行进程： docker exec -d daemon_dave touch /etc/new_config_file 可以在现有的容器内 启动新进程，无论是后台任务还是交互式任务, docker exec -it &lt;container_id_or_name&gt; /bin/bash&lt;/container_id_or_name&gt;&lt;/li&gt;
      &lt;li&gt;自动重启容器： docker run –restart=always –name daemon_dave // docker可以通过设定  –restart 标志来检测 容器的退出代码 来决定是否重启容器&lt;/li&gt;
      &lt;li&gt;深入容器： docker inspect daemon_dave&lt;/li&gt;
      &lt;li&gt;查看运行中的容器： docker ps&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="docker-镜像"&gt;Docker 镜像:&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;列出镜像：docker images&lt;/li&gt;
  &lt;li&gt;拉取镜像： docker pull ubuntu&lt;/li&gt;
  &lt;li&gt;查找镜像: docker search puppet&lt;/li&gt;
  &lt;li&gt;使用Dockerfile构建镜像：
    &lt;h4 id="使用dockerfile构建镜像-dockerfile-有一系列-指令和参数构成每条命令-都必须为大写字母-比如-run-from-后面跟随参数-dockerfile-从上到下执行每条指令都会创建一个新的镜像层并对镜像进行提交流程如下"&gt;使用Dockerfile构建镜像： Dockerfile 有一系列 指令和参数构成，每条命令 都必须为大写字母 比如 RUN FROM 后面跟随参数， Dockerfile 从上到下执行，每条指令都会创建一个新的镜像层并对镜像进行提交。流程如下：&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;FROM ubuntu:14.04
RUN apt-get update
RUN apt-get &lt;span class="nb"&gt;install&lt;/span&gt; &lt;span class="nt"&gt;-y&lt;/span&gt; nginx
RUN &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;'Hi, I am in your container'&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; /usr/share/nginx/html/index.html
EXPOSE 80

docker build &lt;span class="nt"&gt;-t&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"static_web"&lt;/span&gt; ./
docker run &lt;span class="nt"&gt;-d&lt;/span&gt; &lt;span class="nt"&gt;-p&lt;/span&gt; 80 &lt;span class="nt"&gt;--name&lt;/span&gt; static_web static_web nginx &lt;span class="nt"&gt;-g&lt;/span&gt; &lt;span class="s2"&gt;"daemon off;"&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h5 id="1-流程"&gt;1. 流程:&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;Docker 从基础镜像运行一个容器&lt;/li&gt;
  &lt;li&gt;执行一条指令，对容器做出修改&lt;/li&gt;
  &lt;li&gt;执行类似docker commit 操作，提交一个新的镜像层&lt;/li&gt;
  &lt;li&gt;Docker在基于刚才提交的镜像层运行一个新容器&lt;/li&gt;
  &lt;li&gt;执行Dockerfile 中的下一条命令，知道所有指令运行完毕
    &lt;h5 id="2-详细"&gt;2. 详细：&lt;/h5&gt;
  &lt;/li&gt;
  &lt;li&gt;每个Dockerfile 的第一条指令 都是从FROM 开始的，该镜像 被称为基础镜像&lt;/li&gt;
  &lt;li&gt;expose 指令 指明 容器 使用的端口号，但 docker 在运行容器时候，并不会打开端口，需要使用指令来明确docker 打开特定的端口号&lt;/li&gt;
  &lt;li&gt;Dockerfile 的构建方式，导致如果 在因为一些命令失败，则可以得到一个 最近成功命令 的镜像，可以基于该命令 运行一个交换式的容器 来方便调试, 比如 docker run -t -i 最后commit  /bin/bash
    &lt;h5 id="构建-docker-build--txxxx-"&gt;构建: docker build -t=”xxxx” ./&lt;/h5&gt;
  &lt;/li&gt;
  &lt;li&gt;docker 构建 过程会添加缓存： 可以如此 docker build –no-cache -t=”xxxx” 来跳过缓存&lt;/li&gt;
  &lt;li&gt;docker 在修改命令之后的 的命令 重建缓存&lt;/li&gt;
  &lt;li&gt;可以添加 ENV REFRESHED_AT 2020-10-09 在头部，当希望 重建镜像时候，可以更改 其时间来 进行  之后命令的重建&lt;/li&gt;
  &lt;li&gt;查看镜像： docker images;&lt;/li&gt;
  &lt;li&gt;查看镜像的构造过程: docker history&lt;/li&gt;
  &lt;li&gt;容器端口： -p 用来指定端口， 方式有： -p 80:80 -p 127.0.0.1:80:80, -p 127.0.0.1::80 -P 前两个指定端口绑定到 容器中的端口， 后面两个则 将随机端口绑定到 容器中的端口， -P 表示 将随机的本地端口 绑定到 Dockerfile中的expose 的端口&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id="dockerfile-指令"&gt;Dockerfile 指令:&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;CMD: 指定容器启动时候的运行的命令， 区分于RUN 为镜像被构建时运行的命令，CMD 则是容器启动时候运行的命令。同docker run时候指定的命令， docker run中的命令会覆盖CMD命令，即 docker run中指定了命令，则CMD中的命令将不会被执行&lt;/li&gt;
  &lt;li&gt;ENTRYPOINT： 区分于 CMD，不会被 docker run中的命令 所替代，而是 替代 CMD 一起传递给 ENTRYPOINT，示例：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;    ENTRYPOINT &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"/usr/sbin/nginx"&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
    CMD &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"-h"&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;

      docker  run &lt;span class="nt"&gt;-t&lt;/span&gt; &lt;span class="nt"&gt;-i&lt;/span&gt; static_web &lt;span class="nt"&gt;-g&lt;/span&gt; &lt;span class="s2"&gt;"daemon off;"&lt;/span&gt;
    &lt;span class="sb"&gt;```&lt;/span&gt;
  &lt;span class="k"&gt;*&lt;/span&gt; WORKDIR: 为后续的指令 执行  设定工作目录， 
  &lt;span class="k"&gt;*&lt;/span&gt; ENV: 指定环境变量， 在后续的 RUN 中使用，也可以在其他命令中使用环境变量。 该变量 持久的保存到 从我们的镜像创建的任何容器中。 相反 在docker run &lt;span class="nt"&gt;-e&lt;/span&gt; 中传递的环境变量 则一次性有效
  
    &lt;span class="sb"&gt;```&lt;/span&gt;shell
    ENV RVM_PATH /home/rvm
    RUN gem &lt;span class="nb"&gt;install &lt;/span&gt;unicorn
    // 等同于  &lt;span class="nv"&gt;RVM_PATH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/home/rvm gem &lt;span class="nb"&gt;install &lt;/span&gt;unicorn

    ENV TARGET_DIR /opt/app
    WORKDIR &lt;span class="nv"&gt;$TARGET_DIR&lt;/span&gt;
    &lt;span class="sb"&gt;```&lt;/span&gt;
  &lt;span class="k"&gt;*&lt;/span&gt; VOLUME: 向 从该镜像创建的容器 添加卷。卷是容器中的特殊目录 ，可以跨越文件系统，进行共享，提供持久化功能，有如下特性
    &lt;span class="k"&gt;*&lt;/span&gt; 卷 可以再 容器间 共享和重用
    &lt;span class="k"&gt;*&lt;/span&gt; 一个容器 可以不是必须 和 其他容器共享卷
    &lt;span class="k"&gt;*&lt;/span&gt; 对卷的修改 立即生效
    &lt;span class="k"&gt;*&lt;/span&gt; 对卷的修改不会影响镜像
    &lt;span class="k"&gt;*&lt;/span&gt; 卷会一直存在知道没有任何 容器使用它。&lt;span class="o"&gt;(&lt;/span&gt;标志着 卷 是由 docker管理的，而非容器，也非操作系统&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;*&lt;/span&gt; VOLUME &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"/opt/project"&lt;/span&gt;, &lt;span class="s2"&gt;"/data"&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; 可以使用数组形式 创建多个挂载点
  &lt;span class="k"&gt;*&lt;/span&gt; ADD: 将 构建环境下 的文件或 目录  复制到 镜像中。ADD software /opt/application/software&lt;span class="p"&gt;;&lt;/span&gt; ADD &lt;span class="nb"&gt;source &lt;/span&gt;target 
    &lt;span class="k"&gt;*&lt;/span&gt; 其中source可以是 文件或者目录 或者url，不能对构建目录之外的文件进行ADD操作。&lt;span class="o"&gt;(&lt;/span&gt;因为docker只关心 构建环建， 构建环境之外的任何东西 在命令中都是不可用的&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;*&lt;/span&gt; target 如果目录不存在的话，则 docker会创建 全路径，新建文件目录的权限 为0755
    &lt;span class="k"&gt;*&lt;/span&gt; ADD命令会屎之后的命令不能够使用缓存。
    &lt;span class="k"&gt;*&lt;/span&gt; ADD 会将 归档文件 进行 解压，例如 ADD latest.tar.gz /var/www/wordpress/
  &lt;span class="k"&gt;*&lt;/span&gt; COPY： 区分于 ADD， copy只做纯粹的复制操作。不会进行解压缩操作.
  &lt;span class="k"&gt;*&lt;/span&gt; 产出镜像： docker rmi static_web

&lt;span class="c"&gt;### 实践：&lt;/span&gt;
&lt;span class="nt"&gt;-v&lt;/span&gt; 允许我们将宿主机的目录作为卷，挂在到容器里。-v &lt;span class="nb"&gt;source&lt;/span&gt;:target 

&lt;span class="k"&gt;*&lt;/span&gt; 构建 Redis 镜像

&lt;span class="sb"&gt;```&lt;/span&gt;shell
FROM ubuntu:14.04
ENV REFRESHED_AT 2020-10-09
RUN apt-get update
RUN apt-get &lt;span class="nt"&gt;-y&lt;/span&gt; &lt;span class="nb"&gt;install &lt;/span&gt;redis-server redis-tools
EXPOSE 6379
ENTRYPOINT &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"/usr/bin/redis-server"&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
CMD &lt;span class="o"&gt;[]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;连接到 redis 容器: 容器之间 互连。 如果使用 映射到宿主机 的ip 来连接到 对应的容器，在 容器重启之后，因为其port会改变（当然可以使用 参数固定 其对应的宿主机 port） 会导致 之前的链接配置失效，从而无法使用 该种 方法 建立长久的固定的链接。&lt;/li&gt;
  &lt;li&gt;docker 提供了另一种方法: –link 使用 该标志 创建两个容器的父子链接。链接让 父容器有能力访问子容器， 并将子容器的一些详细信息分享给父容器，应用程序可以利用 这些信息 建立链接。示例：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;docker run  &lt;span class="nt"&gt;-d&lt;/span&gt; &lt;span class="nt"&gt;--name&lt;/span&gt; redis_con  redis

docker run &lt;span class="nt"&gt;-p&lt;/span&gt; 4567 &lt;span class="nt"&gt;--name&lt;/span&gt; webapp &lt;span class="nt"&gt;--link&lt;/span&gt; redis:db &lt;span class="nt"&gt;-t&lt;/span&gt; &lt;span class="nt"&gt;-i&lt;/span&gt; sinatra /bin/bash
// 该命令中 使用--link标志创建了  sinatra 到 redis_conn 的父子链接关系
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;链接的特点：
    &lt;ul&gt;
      &lt;li&gt;使子链接 无需公开端口，从而更安全一些。容器端口不需要在宿主机 上 公开，就可以限制被攻击的方面，减少应用暴露的网络&lt;/li&gt;
      &lt;li&gt;被连接的容器 必须运行在同一个 Docker宿主机上，不同的Docker宿主机 上的容器不能够互相链接&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;链接的实现方法： docker 在父容器里的两个地方写入了链接信息。
    &lt;ul&gt;
      &lt;li&gt;/etc/hosts 文件&lt;/li&gt;
      &lt;li&gt;包含链接信息的环境变量 ( 自动创建的环境变量包括： 子容器的名字， 子容器服务所运行的 协议 ip 端口 )&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;
docker run &lt;span class="nt"&gt;-d&lt;/span&gt; &lt;span class="nt"&gt;--name&lt;/span&gt; redis_con redis
docker run &lt;span class="nt"&gt;--link&lt;/span&gt; redis:db &lt;span class="nt"&gt;-i&lt;/span&gt; &lt;span class="nt"&gt;-t&lt;/span&gt; ubuntu /bin/bash

root@31c4f6ac36a4:/# &lt;span class="nb"&gt;cat&lt;/span&gt; /etc/hosts
127.0.0.1	localhost
::1	localhost ip6-localhost ip6-loopback
fe00::0	ip6-localnet
ff00::0	ip6-mcastprefix
ff02::1	ip6-allnodes
ff02::2	ip6-allrouters
172.17.0.3	db 949baab68dd4 redis_con
172.17.0.4	31c4f6ac36a4


root@31c4f6ac36a4:/# &lt;span class="nb"&gt;env

&lt;/span&gt;&lt;span class="nv"&gt;DB_PORT_6379_TCP_ADDR&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;172.17.0.3
&lt;span class="nv"&gt;DB_PORT_6379_TCP&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;tcp://172.17.0.3:6379
&lt;span class="nv"&gt;DB_PORT&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;tcp://172.17.0.3:6379
....
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;所以： 在应用程序中  通过使用 环境变量 来链接 子容器 是非常方便的方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;require &lt;span class="s1"&gt;'uri

uri = URI.parse(ENV['&lt;/span&gt;DB_PORT&lt;span class="s1"&gt;'])
redis = Redis.new(:host =&amp;gt; uri.host, :port =&amp;gt; uri.port)
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="实践-通过-jekyll-apache-来构建-自动构建一个博客网站"&gt;实践： 通过 Jekyll Apache 来构建 自动构建一个博客网站&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;jekyll 镜像&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;FROM ubuntu:14.04
ENV refreshed_at 2020-10-10

RUN apt-get update
RUN apt-get &lt;span class="nb"&gt;install&lt;/span&gt; &lt;span class="nt"&gt;-y&lt;/span&gt; ruby ruby-dev make nodejs
RUN gem &lt;span class="nb"&gt;install&lt;/span&gt; &lt;span class="nt"&gt;--no-rdoc&lt;/span&gt; &lt;span class="nt"&gt;--no-ri&lt;/span&gt; jekyll

VOLUME /data
VOLUME /var/www/html

WORKDIR /data

ENTRYPOINT &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;"jekyll"&lt;/span&gt;, &lt;span class="s2"&gt;"build"&lt;/span&gt;, &lt;span class="s2"&gt;"--destination=/var/www/html"&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;

docker build &lt;span class="nt"&gt;-t&lt;/span&gt; jekyll ./
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;apache 镜像&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;FROM ubuntu:14.04
ENV REFRESHED_AT 2020-10-10

RUN apt-get update
RUN apt-get &lt;span class="nb"&gt;install&lt;/span&gt; &lt;span class="nt"&gt;-y&lt;/span&gt; apache2

VOLUME &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;"/var/www/html"&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
WORKDIR /var/www/html

ENV APACHE_RUN_USER www-data
ENV APACHE_RUN_GROUP www-data
ENV APACHE_LOG_DIR /var/logapache2
ENV APACHE_PID_FILE /var/run/apache2.pid
ENV APACHE_RUN_DIR /var/run/apache2
ENV APACHE_LOCK_DIR /var/lock/apache2

RUN &lt;span class="nb"&gt;mkdir&lt;/span&gt; &lt;span class="nt"&gt;-p&lt;/span&gt; &lt;span class="nv"&gt;$apache_run_dir&lt;/span&gt; &lt;span class="nv"&gt;$apache_lock_dir&lt;/span&gt; &lt;span class="nv"&gt;$apache_log_dir&lt;/span&gt;
EXPOSE 80

ENTRYPOINT &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;"/usr/sbin/apache2"&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
CMD &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"-D"&lt;/span&gt;, &lt;span class="s2"&gt;"foreground"&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;

docker build &lt;span class="nt"&gt;-t&lt;/span&gt; apache ./
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;docker run -v /home/james/blog:/data/ –name jekyll_con jekyll&lt;br /&gt;
docker run -d -P –volumns-from jekyll_con –name apache_conn apache&lt;br /&gt;
// 这里使用了 标志 –volumes-from 标志 将指定容器 中的所有卷 添加到 新创建 的容器中。意味着容器 apache_conn 可以访问 容器 jekyll_conn 中的所有卷，即： 可以访问 jekyll_conn 产生的博客文件 目录 /var/www/html 中的内容。&lt;br /&gt;
// 卷 只有在没有容器 使用的时候才会被清理，也就是说 在 删除 docker rm jekyll_conn 之后 /var/www/html 中的内容就不复存在了 （这里面是否需要 同时删除 apache_conn 才可以？ 因为apache_conn 依然在使用，把持 该卷. 可以进行实验验证）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;备份卷：&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;docker run –rm –volumnes-from jekyll_conn -v $(pwd):/backup ubuntu tar cvf /backup/blog.tar /var/www/html&lt;br /&gt;
创建一个 docker 容器，将 共享的 /var/www/html 卷，进行打包 到 外部目录中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id="不使用-ssh-管理-docker-容器"&gt;不使用 ssh 管理 Docker 容器&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;传统上将，通过ssh 登入运行环境或者虚拟机 来管理服务，在Docker世界中， 大部分容器只运行一个进程，所以不能够使用该方法进行访问。可以通过如下方式进行访问： 使用卷 或者 链接 完成大部分管理操作。比如服务通过某个网络接口做管理， 或者使用 Unix套接字 做管理， 就可以通过 卷 来公开这个套接字，或者发信号 可以 docker kill -s &lt;signal&gt; &lt;container&gt;&lt;/container&gt;&lt;/signal&gt;&lt;/li&gt;
  &lt;li&gt;如果是登录 容器，则可以使用 nsenter 工具。使用方法如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;  &lt;span class="nv"&gt;PID&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="si"&gt;$(&lt;/span&gt;docker inspect &lt;span class="nt"&gt;--format&lt;/span&gt; &lt;span class="o"&gt;{{&lt;/span&gt;.State.Pid&lt;span class="o"&gt;}}&lt;/span&gt; 949baab68dd4&lt;span class="si"&gt;)&lt;/span&gt;
  nsenter &lt;span class="nt"&gt;--target&lt;/span&gt; 16870 &lt;span class="nt"&gt;--mount&lt;/span&gt; &lt;span class="nt"&gt;--uts&lt;/span&gt; &lt;span class="nt"&gt;--ipc&lt;/span&gt; &lt;span class="nt"&gt;--net&lt;/span&gt; &lt;span class="nt"&gt;--pid&lt;/span&gt;
  nsenter &lt;span class="nt"&gt;--target&lt;/span&gt; 16870 &lt;span class="nt"&gt;--mount&lt;/span&gt; &lt;span class="nt"&gt;--uts&lt;/span&gt; &lt;span class="nt"&gt;--ipc&lt;/span&gt; &lt;span class="nt"&gt;--net&lt;/span&gt; &lt;span class="nt"&gt;--pid&lt;/span&gt; &lt;span class="nb"&gt;ls&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id="对-docker-容器的编排或者是非常重要的一步-k8s"&gt;对 Docker 容器的编排，或者是非常重要的一步. K8s&lt;/h4&gt;
</content>
  </entry>
</feed>
