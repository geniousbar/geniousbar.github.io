<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>日常学习</title>
  <id>http://geniousbar.github.io</id>
  <link href="http://geniousbar.github.io"/>
  <link href="http://geniousbar.github.io/feed.xml" rel="self"/>
  <updated>2021-06-30T00:00:00+00:00</updated>
  <author>
    <name>geniousbar</name>
  </author>
  <entry>
    <title>rust 编码模式</title>
    <link rel="alternate" href="http://geniousbar.github.io/2021/06/30/rust-design-patterns/"/>
    <id>http://geniousbar.github.io/2021/06/30/rust-design-patterns/</id>
    <published>2021-06-30T00:00:00+00:00</published>
    <updated>2021-06-29T10:01:35+00:00</updated>
    <summary type="html">&lt;h3 id="设计模式"&gt;设计模式&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Design Patterns: 是在编写软件时解决常见问题的方法。&lt;/li&gt;
  &lt;li&gt;Anti-patterns: 反模式是解决这些相同常见问题的方法。 然而，虽然设计模式给我们带来了好处，但反模式却带来了更多的问题。&lt;/li&gt;
  &lt;li&gt;idioms(惯用方法): 是编码时要遵循的准则。 它们是社区的社会规范。 你可以打破它们，但如果你这样做了，你应该有一个很好的理由。
    &lt;h4 id="示例"&gt;示例：&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;使用 borrowed type 作为 参数（为参数提供灵活）， 例如： &amp;amp;str 替换 &amp;amp;String...&lt;/li&gt;
&lt;/ul&gt;</summary>
    <content type="html">&lt;h3 id="设计模式"&gt;设计模式&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Design Patterns: 是在编写软件时解决常见问题的方法。&lt;/li&gt;
  &lt;li&gt;Anti-patterns: 反模式是解决这些相同常见问题的方法。 然而，虽然设计模式给我们带来了好处，但反模式却带来了更多的问题。&lt;/li&gt;
  &lt;li&gt;idioms(惯用方法): 是编码时要遵循的准则。 它们是社区的社会规范。 你可以打破它们，但如果你这样做了，你应该有一个很好的理由。
    &lt;h4 id="示例"&gt;示例：&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;使用 borrowed type 作为 参数（为参数提供灵活）， 例如： &amp;amp;str 替换 &amp;amp;String, &amp;amp;[T] 替换 &amp;amp;Vec[T]&lt;/li&gt;
  &lt;li&gt;使用format! 拼接字符串： 该方法是最清晰、可读的 组合string的方法， 缺点是 并不是最高效的。&lt;/li&gt;
  &lt;li&gt;提供 static new 方法 作为 构造方法&lt;/li&gt;
  &lt;li&gt;Default trait 实现： 提供默认的构造方法， new 则提供具体参数的构造方法&lt;/li&gt;
  &lt;li&gt;Collection 是 smart pointers： 一般的collect 实现了 Deref trait 来 提供 smart pointers
    &lt;ul&gt;
      &lt;li&gt;优势： 提供更多的灵活性&lt;/li&gt;
      &lt;li&gt;劣势： 边界检查时不考虑仅通过解引用可用的方法和特征，因此使用这种模式的数据结构的泛型编程可能会变得复杂（参见 Borrow 和 AsRef 特征等）。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;rust 没有提供 finally 代码块： 函数可能存在多个返回点， 导致 finally块（退出时执行）变得困难，对于 ？ macro， panick 来说更是如此， 所以rust 并没有提供 finally 块， 相反的 对象的 Drop trait中的drop方法 总是调用，无论怎样退出。（但是在drop 中发生panic 会导致 线程终止，从而不能够运行所有的 析构drop函数， 所以 drop 析构函数 可能并不能够得到保障，所以 需要在drop中格外小心，不能panic）&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;mem::take, mem::replace 来 替换已有的enum中的数值， 示例： 我们使用 mem::take 来 将数值 使用 default 替换 并返回前值。 replace 则需要自己提供 数值。&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;MyEnum&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;String&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;u8&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;String&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;a_to_b&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;MyEnum&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="nn"&gt;MyEnum&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c"&gt;// this takes out our `name` and put in an empty String instead&lt;/span&gt;
        &lt;span class="c"&gt;// (note that empty strings don't allocate).&lt;/span&gt;
        &lt;span class="c"&gt;// Then, construct the new enum variant (which will&lt;/span&gt;
        &lt;span class="c"&gt;// be assigned to `*e`).&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;MyEnum&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nn"&gt;mem&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;take&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/li&gt;
  &lt;li&gt;在 stack 上 进行动态分发（dynamic dispatch）：  rust 只保证 每个使用到的 变量 是 初始化过的。所以 可以存在未使用的变量 是未初始化的。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;fs&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;


&lt;span class="c"&gt;// These must live longer than `readable`, and thus are declared first:&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;stdin_read&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;file_read&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c"&gt;// We need to ascribe the type to get dynamic dispatch.&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;readable&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;dyn&lt;/span&gt; &lt;span class="nn"&gt;io&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Read&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;"-"&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;stdin_read&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;io&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;stdin&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;stdin_read&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;file_read&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;fs&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nn"&gt;File&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;file_read&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="c"&gt;// Read from `readable` here.&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;Option 可以被 视为 Interator， 一个 包装 None 或者 element 的iterator， 可以如下使用：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;turing&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;Some&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Turing"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;logicians&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nd"&gt;vec!&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;"Curry"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Kleene"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Markov"&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="n"&gt;logicians&lt;/span&gt;&lt;span class="nf"&gt;.extend&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;turing&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c"&gt;// equivalent to&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="nf"&gt;Some&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;turing_inner&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;turing&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;logicians&lt;/span&gt;&lt;span class="nf"&gt;.push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;turing_inner&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;



&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;turing&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;Some&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Turing"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;logicians&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nd"&gt;vec!&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;"Curry"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Kleene"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Markov"&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;logician&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;logicians&lt;/span&gt;&lt;span class="nf"&gt;.iter&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="nf"&gt;.chain&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;turing&lt;/span&gt;&lt;span class="nf"&gt;.iter&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"{} is a logician"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;logician&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;private in struct:  struct 中private field  可以 使用如下模式 来进行修改：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;
&lt;span class="k"&gt;mod&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c"&gt;// Public struct.&lt;/span&gt;
    &lt;span class="k"&gt;pub&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;S&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;pub&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;i32&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="c"&gt;// Private field.&lt;/span&gt;
        &lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;i32&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nn"&gt;a&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c"&gt;// Because S::bar is private, it cannot be named here and we must use `..`&lt;/span&gt;
    &lt;span class="c"&gt;// in the pattern.&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="nn"&gt;a&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;..&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;temporary mutable 暂时性的 mut：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="c"&gt;// 使用 内嵌的 {} 嵌套代码&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;get_vec&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="nf"&gt;.sort&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;data&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="c"&gt;// 重新绑定&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;get_vec&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="nf"&gt;.sort&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content>
  </entry>
  <entry>
    <title>现代操作系统  内存篇</title>
    <link rel="alternate" href="http://geniousbar.github.io/2021/05/25/current-os-virtual-memory/"/>
    <id>http://geniousbar.github.io/2021/05/25/current-os-virtual-memory/</id>
    <published>2021-05-25T00:00:00+00:00</published>
    <updated>2021-08-17T08:00:01+00:00</updated>
    <summary type="html">&lt;h2 id="内存管理"&gt;内存管理&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;因为： 不管存储器多大，程序都可以将其填满。&lt;br&gt;
所以： 分层存储器体系： 在这个体系中，存在 MB 的快速、昂贵、易失性的高速缓存，GB的速度价格适中的同样易失的内存 ，以及 TB的低速、廉价、非易失的磁盘存储。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id="操作系统的工作之一-就是-将层次存储系统体系-抽象成为一个-有用的模型-并管理这个抽象"&gt;操作系统的工作之一 就是 将层次存储系统体系 抽象成为一个 有用的模型 并管理这个抽象。&lt;/h3&gt;

&lt;p&gt;分层存储器系统称为 存储管理系统：  他的任务是 有效的管理内存，即记录哪些 内存是正在使用的，哪些 是空闲的， 在进程需要时候为其分配内存 ，不需要时释放内存。&lt;/p&gt;

&lt;h3 id="探索-内存抽象方案"&gt;探...&lt;/h3&gt;</summary>
    <content type="html">&lt;h2 id="内存管理"&gt;内存管理&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;因为： 不管存储器多大，程序都可以将其填满。&lt;br /&gt;
所以： 分层存储器体系： 在这个体系中，存在 MB 的快速、昂贵、易失性的高速缓存，GB的速度价格适中的同样易失的内存 ，以及 TB的低速、廉价、非易失的磁盘存储。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id="操作系统的工作之一-就是-将层次存储系统体系-抽象成为一个-有用的模型-并管理这个抽象"&gt;操作系统的工作之一 就是 将层次存储系统体系 抽象成为一个 有用的模型 并管理这个抽象。&lt;/h3&gt;

&lt;p&gt;分层存储器系统称为 存储管理系统：  他的任务是 有效的管理内存，即记录哪些 内存是正在使用的，哪些 是空闲的， 在进程需要时候为其分配内存 ，不需要时释放内存。&lt;/p&gt;

&lt;h3 id="探索-内存抽象方案"&gt;探索 内存抽象方案：&lt;/h3&gt;

&lt;h4 id="无存储器抽象--最简单的存储器抽象-即-没有抽象--早期的大型机小型计算机-都没有存储抽象-每一个程序-都直接访问物理内存"&gt;无存储器抽象：  最简单的存储器抽象 即 没有抽象。  早期的大型机、小型计算机 都没有存储抽象。 每一个程序 都直接访问物理内存。&lt;/h4&gt;
&lt;p&gt;因此 那时候呈现给编程人员的存储器 即是：  从0到某个上限的地址集合，每个地址 对应一个 可容纳 一定数目（通常是 8位）的二进制数据。&lt;br /&gt;
指令 Move Register1， 100  即：将  100的物理内存的内容，复制到 register1中。&lt;/p&gt;

&lt;p&gt;该种方案下， 系统中同时运行两个程序 是不可能的。如果进程 A在 地址 100位置写入数据，进程 2  在稍后的时间中 对地址 100进行了改写，可能导致 进程A的崩溃。&lt;/p&gt;

&lt;h5 id="无内存抽象-模式下-内存的布局方式有以下三种"&gt;无内存抽象 模式下 内存的布局方式有以下三种：&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;操作系统位于 RAM 的底部&lt;/li&gt;
  &lt;li&gt;操作系统位于内存顶端 的ROM（只读存储器） 中&lt;/li&gt;
  &lt;li&gt;设备驱动程序位于顶端的ROM中，操作系统位于底端的RAM中&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第二种方案 经常用在 一些掌上电脑，和嵌入式系统中。&lt;br /&gt;
第三种方案 用于早期的个人计算机中， ROM中的系统部分 为 BIOS（basic  input output system）&lt;/p&gt;

&lt;h5 id="如何-在没有存储器抽象的情况下-同时运行多个程序"&gt;如何 在没有存储器抽象的情况下 同时运行多个程序？&lt;/h5&gt;
&lt;p&gt;操作系统 只需要 把当前的内存中的内容 保存到磁盘上 ，然后将下一个程序 读入到内存中 再次运行即可。 &lt;strong&gt;只要在同一时刻 内存中只有一个程序 即可&lt;/strong&gt;。&lt;/p&gt;

&lt;h5 id="历史中-ibm-360-的做法"&gt;历史中 IBM 360 的做法：&lt;/h5&gt;
&lt;ol&gt;
  &lt;li&gt;内存被划分为 大小2KB的块。&lt;/li&gt;
  &lt;li&gt;每个块 分配一个 4位的保护键， 保护键 存储在cpu PSW中的特殊寄存器中。
    &lt;ul&gt;
      &lt;li&gt;所以：  一个运行中的进程如果访问保护码 与 PSW中的不同的内存，硬件将会捕获该事件。  因为只有系统可以修改保护键，这样就可以 防止 用户进程 之间、用户和操作系统之间的相互干扰。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;静态重定位技术： 即便 存在保护键，依然无法解决 两个进程 使用重复的绝对地址的问题，我们希望每个进程使用一套自己私有的内存地址来进行内存访问。&lt;br /&gt;
IBM  360 采用的方法 即：在第二个 程序 装载到内存 100地址时， 常数100将被 加到 程序的每一个 程序地址上。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;缺少存储器抽象在嵌入式系统中 依然非常常见， 比如 洗衣机、微波炉 此类设备 都已经完全被&lt;strong&gt;ROM形式&lt;/strong&gt;的软件控制。 这种情况下，软件都采用 绝对地址寻址的方式，因为 所有运行的程序 都可以被事先确定，  用户不需要运行自己的软件。&lt;/p&gt;

&lt;h3 id="存储器抽象-地址空间"&gt;存储器抽象： 地址空间&lt;/h3&gt;

&lt;p&gt;直接暴露物理地址的问题： 1） 用户程序可以简单的寻址内存地址，很容易地破坏 操作系统。 2） 同时运行多个程序将非常困难。&lt;/p&gt;

&lt;h4 id="地址空间的概念"&gt;地址空间的概念：&lt;/h4&gt;

&lt;p&gt;要多个应用程序 同时处于内存 而不互相影响 需要解决两个问题： 1）保护 2）重定位 。&lt;br /&gt;
IBM 360的办法 实际效果并不好，因为 其 静态重定位 技术，不仅缓慢，还需要 额外的标记 来确定 哪些地址 需要被加。（比如 相对地址指令并不需要 + 程序的起始位置&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;就像 进程的概念 创造了 cpu的抽象 为 进程使用 一样。&lt;br /&gt;
地址空间:  为程序 创造了一种抽象 的内存，地址空间 是一个进程可以用于寻址内存的地址集合。每个进程都有自己的地址空间，独立于 其他的进程地址空间。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;地址空间的概念非常常见：  比如 电话号码、url等。&lt;/p&gt;
&lt;h5 id="动态重定位-简单实现--给cpu配置两个寄存器-基址寄存器-界限寄存器-使程序装载期间无需重定位-此方法可以简单实现存储器抽象"&gt;动态重定位： (简单实现)  给cpu配置两个寄存器： 基址寄存器 、界限寄存器。 使程序装载期间无需重定位。 此方法可以简单实现存储器抽象。&lt;/h5&gt;
&lt;p&gt;具体做法：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;当一个进程运行时 &lt;strong&gt;程序的起始地址装载到基址寄存器中&lt;/strong&gt;，&lt;strong&gt;程序的长度&lt;/strong&gt; 装载到 界限寄存器中。&lt;/li&gt;
  &lt;li&gt;每次 进程访问内存，取一条指令、读写一个内存地址时: 读写地址 —&amp;gt; 地址 + 基址寄存器 —&amp;gt; 检查 是否在 界限寄存器范围内 —&amp;gt;  发送到 内存总线 (cpu硬件会将 地址发送到内存总线 之前， 自动把基址寄存器的数值 + 进程发出的地址上。 同时检查结果是否在界限寄存器范围内。 超过了界限则捕获错误。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;基址寄存器 16384， 界限寄存器： 17000  指令 jmp 28 被翻译成 jmp  16412(16384 + 28)&lt;/p&gt;

&lt;h5 id="如何解决-程序需要的内存--实际物理内存--两种处理内存超载的方法"&gt;如何解决 程序需要的内存 &amp;gt; 实际物理内存 ？ (两种处理内存超载的方法)&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;交换技术：(最简单的策略)
    &lt;ul&gt;
      &lt;li&gt;将进程完整的调入内存中，多个进程同时运行，&lt;/li&gt;
      &lt;li&gt;当前内存不能满足新进程的内存需要时候，将空闲进程 换出到磁盘中， 通过对进程 内存到磁盘 的换入换出 操作，来实现 同时运行多个进程。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;虚拟内存： 使程序只有一部分被调入内存的情况下运行。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;交换技术需要处理的一些问题：
    &lt;ul&gt;
      &lt;li&gt;频繁的将程序 换入换出 将导致内存出现碎片， 需要通过内存紧缩技术： 将空闲内存区域 合并成为 一大块的空闲内存。（非常耗时&lt;/li&gt;
      &lt;li&gt;程序内存空间的动态增长：  通过为程序预留 增长空间 来应对程序动态 分配内存的需要（包括 堆栈（stack 以及  heap） ） 如果 预留空间依然不能满足程序需要，则通过将程序换入换出操作 来重新分配更大的内存空间。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="空闲内存管理-不同于-交换技术-预留分配空间-因为-物理内存是有限的系统-在有限的物理内存-上构建无限的虚拟内存-系统或程序-都需要动态分配内存所以需要对-动态区域进行管理"&gt;空闲内存管理 （不同于 交换技术 预留分配空间， 因为 物理内存是有限的，系统 在有限的物理内存 上构建无限的虚拟内存， 系统或程序 都需要动态分配内存，所以需要对 动态区域进行管理）&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;动态分配内存时， 操作系统 必须 对其进行管理 ，一般有两种办法： 1） 位图 2） 空闲区链表&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;使用位图的存储管理：
    &lt;ul&gt;
      &lt;li&gt;内存可能被划分为 几个字 或 几千字的分配单位，每个分配单位 对应于图中的一位。0表示空闲，1表示占用。&lt;/li&gt;
      &lt;li&gt;分配单元的大小是一个重要的设计元素， 分配单元小 则位图大，位图占用的内存空间的比例就会提升。分配单元大 ，则位图小。但进程分配的存在更多的浪费。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;strong&gt;位图： 可以使用一块固定大小的内存空间，来管理无限大小的内存。（只是分配单位或大或小）&lt;/strong&gt;&lt;br /&gt;
位图主要的问题是：  在决定分配一个 大小 为k个分配单元的进程调入内存时，存储管理器 必须搜索位图 已找到 k个连续的0串，因为 位图中该串可能跨越字的边界。 查找位图中 特定长度的连续0串是一个耗时操作。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;使用链表的存储管理： 维护一个记录已分配内存段和空闲内存段的链表。 有几种方法  为 新创建的进程 分配内存：
    &lt;ul&gt;
      &lt;li&gt;首次匹配算法：  沿着链表进行搜索， 直到找到一个足够大的空闲区间。 除非空闲空间与需要分配的空间大小一样，否则将该空闲区分为两部分，一部分供进程使用，一部分成为新的空闲区。 速度非常快的算法，因为它可以尽可能少的搜索节点。&lt;/li&gt;
      &lt;li&gt;最佳适配算法：搜索整个链表， 找到能够容纳新进程的最小空闲区间。该算法试图找到最接近实际需要的空闲区。&lt;/li&gt;
      &lt;li&gt;其他算法： 快速适配法&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="虚拟内存-虽然-基址寄存器--界限寄存器-能够很好的应对内存抽象管理要求但是--随着软件的膨胀-需要运行的程序往往大到内存-无法容纳-而系统必须能够支撑起多个程序的同时运行-即使内存仅仅-可以满足其中一个的程序需要"&gt;虚拟内存： 虽然 基址寄存器 + 界限寄存器 能够很好的应对内存抽象管理要求，但是  随着软件的膨胀 需要运行的程序往往大到内存 无法容纳， 而系统必须能够支撑起多个程序的同时运行， 即使内存仅仅 可以满足其中一个的程序需要。&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;总体来看 程序对内存的需求超过了实际内存大小。交换技术并不是一个很好的方案，因为一个典型的SATA磁盘的峰值传输效率 只有几百兆每秒，这意味着需要好几秒 才能换入 一个1GB的程序。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;因为： 交换技术太过缓慢。所以： 虚拟内存技术&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;即便是在计算机发展早期该类问题就已经出现了，初始的简单解决办法为：覆盖 （overlay）&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;把程序分割成为许多片段&lt;/li&gt;
  &lt;li&gt;程序开始，将覆盖管理模块转入内存，该管理模块立即 装并运行程序的片段0，在系统需要时 将由 管理模块 程序片段1装载到内存中，&lt;/li&gt;
  &lt;li&gt;覆盖管理模块允许多个 片段  同时在内存中，部分在磁盘上，在需要时候动态的换入换出。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;覆盖 （overlay） 存在的缺点：  虽然有管理模块来负责 换入换出操作，但是依然需要程序员将程序 分割成多个片段，最后人们将这种费事重复性的操作 交给了计算机去做。&lt;br /&gt;
采用的这个方法 称为:&lt;/p&gt;

&lt;h4 id="虚拟内存"&gt;虚拟内存&lt;/h4&gt;

&lt;h5 id="基本思想为"&gt;基本思想为：&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;每个程序拥有自己的地址空间，这个空间被分割成为多个块，每一块称作一页或页面（page）&lt;/li&gt;
  &lt;li&gt;每一页 都有连续的地址范围，这些页面被影射到 物理内存&lt;/li&gt;
  &lt;li&gt;但并不需要 所有页面 都在内存中才能够运行程序&lt;/li&gt;
  &lt;li&gt;当程序引用到一部分在物理内存中的地址空间时， 由硬件执行必要的映射，&lt;/li&gt;
  &lt;li&gt;当程序引用到 一部分不在物理内存中的地址空间时， 由 操作系统负责将缺失的部分数据装入到 物理内存并重新执行失败的指令。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;非常适合， 在多道程序系统中使用（多个程序片段能够共同存在内存中（可能是部分），并运行）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id="分页paging-技术-大部分-虚拟内存使用的技术"&gt;分页（Paging 技术）： 大部分 虚拟内存使用的技术&lt;/h4&gt;

&lt;p&gt;Move reg, 1000  &lt;br /&gt;
将内存地址 1000 的内存复制到 reg中，其中的1000地址 可以由 索引、基址寄存器、段寄存器 或其他方式产生。&lt;/p&gt;

&lt;p&gt;由程序产生的地址称为虚拟地址（virtual address） 它们构成了一个虚拟地址空间。 没有虚拟内存的计算机上，虚拟地址 就是 内存物理地址， 使用虚拟内存的情况下， 虚拟地址 并不直接传送到内存总线上，而是 先传到  内存管理单元（memory  management unit MMU） mmu将虚拟地址映射称为 物理内存地址 ，在传送到物理内存地址总线上。&lt;/p&gt;

&lt;p&gt;地址转换过程： 指令地址(virtual address)  —-&amp;gt; mmu  —–&amp;gt; 总线&lt;/p&gt;

&lt;h5 id="页面的定义--相关概念"&gt;页面的定义 + 相关概念&lt;/h5&gt;
&lt;p&gt;虚拟地址 被划分为 固定大小划 称为 页面 （page）的单元， 物理内存中对应的为 页框（page frame）  RAM与磁盘之间的交换总是以整个页面为单元进行的。&lt;/p&gt;

&lt;p&gt;页面（Page）：虚拟地址，固定大小 连续地址 的空间， page 通常等于 page frame&lt;br /&gt;
页框（Page frame）： 物理内存， 对应的page 单元&lt;br /&gt;
Ram 与 disk 之间的交换大小单位 为 page&lt;/p&gt;

&lt;p&gt;x86: page大小 可选为 4kb 2mb 1Gb （page 的可选大小 需要硬件支持）&lt;br /&gt;
混合使用：  用户程序 page 为4kb ， 内核程序 page 为1gb&lt;/p&gt;

&lt;h5 id="分页中-虚拟地址到物理地址的转换过程"&gt;分页中 虚拟地址到物理地址的转换过程:&lt;/h5&gt;
&lt;p&gt;程序执行 指令 MOV REG，0 &lt;br /&gt;
&lt;strong&gt;虚拟地址  --&amp;gt; MMU ( MMU 根据地址 找到 页面  --&amp;gt;  找到对应的 物理地址 页框 ) --&amp;gt; 转换为 物理地址&lt;/strong&gt;&lt;br /&gt;
详细的转换论述过程: 将虚拟地址 0 送到MMU， MMU 看到虚拟地址落在页面0，根据映射结果 该页面对应得是页框是2（8192-12287）  因此 MMU把地址变换为8192 并将地址 8192发送到总线上，内存对MMU一无所知，他知道看到一个读写地址 8192 的请求并执行它，MMU从而有效的将 程序虚拟地址空间0-4095 映射到 8192-12287。&lt;/p&gt;

&lt;h5 id="如何解决-虚拟地址空间--物理内存空间的问题virtual-address--ram-address"&gt;如何解决： 虚拟地址空间 &amp;gt;&amp;gt; 物理内存空间的问题（Virtual address &amp;gt; Ram address&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;将无限的虚拟页面 映射到  有限的物理页框中(缺页中断)&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;通过恰当的设定 MMU，可以讲16个虚拟页面，映射到 8个页表框中的任何一个&lt;/li&gt;
  &lt;li&gt;当程序需要访问 第9个页面的时候，会发生什么情况呢？
    &lt;ul&gt;
      &lt;li&gt;MMU注意到 第9个页面并没有被影射到内存中， 于是使cpu陷入到操作系统(称为缺页中断 或者缺页错误)&lt;/li&gt;
      &lt;li&gt;操作系统找到一个很少使用的页框 并把他的内容写入到磁盘中，随后把需要访问的页面 读到刚才 回收的页框中，修改映射关系，然后重新执行引起缺页中断的指令。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;缺页处理的具体步骤为：
    &lt;ol&gt;
      &lt;li&gt;os 决定放弃 PF 1， 将 Page 8 装入PF 1中 （需要 从磁盘中读入 数据 装载到 PF 1， 原先 PF 1 的数据写回到 磁盘&lt;/li&gt;
      &lt;li&gt;将PF 1 之前 对应的 Page 1 标记为 未映射， 以免Page 1内的地址请求 映射错误&lt;/li&gt;
      &lt;li&gt;将 Page 8 与 PF 1 映射起来， 以便 重启 缺页中断指令时，能够正确映射&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id="mmu内部结构如下"&gt;MMU内部结构如下：&lt;/h5&gt;

&lt;p&gt;可以将16位的虚拟地址，划分为 4位的 页号 + 12 位的便宜里那个。 4位的页号 可以表达16个 页面 ， 12位的偏移地址 可以为一页内部的全部4096个字节编码。&lt;br /&gt;
使用页号作为页表的索引。以找出对于该虚拟页面的页框号， 如果 不在 则 引发一个缺页中断， 如果在 ，则 将在页表中查找到的 页框号 + 虚拟地址的偏移量  构成一个 物理地址。 输出到物理内存地址总线上。&lt;/p&gt;

&lt;h5 id="如何将--page--映射到-page-frame---页表-page-table"&gt;如何将  page  映射到 page frame ？  页表 （Page table）&lt;/h5&gt;
&lt;p&gt;最简单的实现（也是 最普遍的实现）：  虚拟地址 被划分为 虚拟页号（高地址位） + 偏移量（低地址位） &lt;br /&gt;
16位地址 和 4KB的页面大小： 高4位 是 虚拟页号（指定page 通过 page table 找到 page frame）， 低12位 位偏移量。&lt;/p&gt;

&lt;p&gt;虚拟页号 作为 页表(page table)索引，找到 虚拟页 对应 的 页表(page)项目， 页表项目 找到页框号(page frame)， 然后 将页框号  于 低位的偏移地址 拼接 作为 物理内存的物理地址&lt;/p&gt;

&lt;h5 id="页表项目的结构"&gt;页表项目的结构：&lt;/h5&gt;

&lt;p&gt;|(高速缓存禁止位)|访问位| 修改位\｜保护位\｜在/不在 位\｜ 页框号 \｜&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;页框号： 页表项中最重要的内容， 是 页表转换:  页号 到 页框号 的数据依据。&lt;/li&gt;
  &lt;li&gt;在/不在位： 数值 为1时标志 该页表项有效，为0表示该页表项 对应的虚拟页面 不存在内存中，访问该页面会触发一个 Page fault（缺页中断）&lt;/li&gt;
  &lt;li&gt;保护位：  允许什么类型的操作访问，简单的只有一位 ： 0表示 读/写， 1表示只读。复杂一些 的 可能设定三位 ： 读、写、执行&lt;/li&gt;
  &lt;li&gt;修改位（也称为dirty  bit）： 表示 该页 是否存在修改，在 os 重新分配 页框时 非常有用，即：在 该页表项 重新分配给其他页面时， 如果该页被修改过了，则需要将 对应的页框 写回disk， 否则直接 使用disk中的数据 进行覆盖。&lt;/li&gt;
  &lt;li&gt;访问位： 帮助os在发生缺页中断时候，进行页面的淘汰，&lt;/li&gt;
  &lt;li&gt;高速缓存禁止位：  对于 没有独立IO空间，而是映射到内存的设备 该位非常重要。可以总是从 设备中读取数据，而不是  缓存页面中。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;重要的： 如页面不在 页表中，page在disk中的位置，并不是 页表的 组成部分（页表只保存 将虚拟地址转换为物理地址所必需的信息）。所以 需要 os来进行保存。&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;虚拟内存本质： 通过 将 地址空间划分为 页（page） 来 在 物理内存空间上 建立一个 抽象 虚拟地址空间&lt;/strong&gt;&lt;/p&gt;

&lt;h5 id="加速分页过程-分页系统中都需要解决两个问题--1-虚拟地址-到-物理地址-的转换速度需要-非常快-2-页表大小如果虚拟地址空间非常大则-页表项目-也非常大-"&gt;加速分页过程： 分页系统中都需要解决两个问题：  1） 虚拟地址 到 物理地址 的转换速度需要 非常快 2） 页表大小，如果虚拟地址空间非常大，则 页表项目 也非常大 。&lt;/h5&gt;

&lt;p&gt;第一点： 很多指令都会访问内存 ，如果指令的执行时间 为1ns，则 页表查询 必须在0.2ns内完成，否则 地址转换 将成为瓶颈。&lt;br /&gt;
第二点： 假设页面大小 为4KB， 则32位的机器 的页表项数目位 100w， 64位机器的页表项将多到无法想象。另外每个进程都存在自己的页表。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;所以 构建大而快的页表 成为了分页式虚拟内存的重要约束&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;可能的设计方法：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;使用特殊硬件（快速寄存器阵列） 组成页表， 每次进程切换 os将 进程页表加载到寄存器中， 每次指令访问内存 进行地址转换 都不需要再次访问内存。简单、快速，缺点 是代价高。&lt;/li&gt;
  &lt;li&gt;将整个页表存在内存中 + 一个指向页表内存起始位置的寄存器。 这样在进程切换时，只需要将 表内存地址装载到寄存器即可。简单，但是 每次访问内存，都需要多访问一次 页表项（内存）。&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id="tlb"&gt;TLB:&lt;/h5&gt;
&lt;p&gt;实际中的加速方法： 转换检测缓冲区：  基于(2/8原则或局部性)大多数程序总是对少量的页面进行多次的访问，而不是相反。 因此只有少量的页表项 会反复的访问。&lt;/p&gt;

&lt;p&gt;所以： 设立一个小的硬件设备，将 虚拟地址 直接映射到物理地址，而不必再访问内存中的页表 即: 转换检测缓冲区（translation lookaside  buffer TLB） 又称为 快表。&lt;br /&gt;
该设备 存在 MMU中，包含少量的页表项 ，实践中 一般不会超过 256个， 每个表项 记录着  简单的数据信息 以减少存储 。&lt;/p&gt;
&lt;h6 id="tlc-的mmu-地址转换方式"&gt;TLC 的MMU 地址转换方式：&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;MMU 将 同时进行 TLB  中的寻找  以及 在页表 中的寻找。&lt;/li&gt;
  &lt;li&gt;如果TLB命令，则立即返回&lt;/li&gt;
  &lt;li&gt;否则： 进行正常的 页表查询，在完成之后，更新TLB中的表项，使下次能够命中TLB&lt;/li&gt;
  &lt;li&gt;TLB中的页表项 淘汰时，将信息同步到 页表中。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;？ 问题: 首次 程序装载时候，TLB 中是否存在数据？  主动装载 还是 被动装载。&lt;/p&gt;

&lt;h6 id="tlb-缺失-处理"&gt;TLB 缺失 处理：&lt;/h6&gt;
&lt;ol&gt;
  &lt;li&gt;TLB 缺失 错误:
    &lt;ul&gt;
      &lt;li&gt;之前 ，TLB的管理、TLB未命中 都是由 MMU硬件实现的。&lt;/li&gt;
      &lt;li&gt;现在， TLB 一般是由 os（在软件中）实现的。TLB 被操作系统 显式的 装载。 当发生  TLB （TLB未命中）生成一个TLB 失效 中断 交给os处理，os必须找到该页面，然后从TLB 中删除一个项目，装载该项目，然后重新执行指令。 该操作需要在几个指令间完成，因为  TLB失效中断 比 缺页中断  更加频繁。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;？ 这里面的TLB失效，具体含义是什么？ 是TLB中不存在， page table中存在吗？，还是两个都不存在， 1 种情况 将简单的将页表项 装载到TLB中， 第二种情况则 可能发生 page fault。 这其中的 硬件 系统之间的交互 将比较复杂。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;在TLB失效 中断的处理程序中，需要遍历页表 以找到 缺失的页表项，但是 页表可能也不再TLB中，造成 额外的TLB失效。一般需要 在TLB表项中固定  页表的内存地址 ，以减少 TLB失效。&lt;br /&gt;
？ 这里面的意思是， TLB 失效 完全由 os托管，而非 部分的硬件的来寻找 页表项，然后在交由 os处理。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TLB失效的两种类型： 1） 软失效（soft  miss）  即：页面在内存中而不在 TLB中，只需要 进行 页表项的查找，并更新TLB即可， 消耗在10-20个机器指令范围。2）硬失效（hard miss） 即页面不在内存中，需要一次磁盘读取来换取该页面， 处理时间 总是 软失效的 百万倍， 几毫秒内。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;段错误：  程序访问了一个非法地址，根本不需要更新TLB， 属于程序错误。&lt;/p&gt;

&lt;h4 id="构建更大的页表-tlb-可以加快虚拟地址到--物理地址的转换解决的是第一个问题-第二个问题的解决方案为"&gt;构建更大的页表： TLB 可以加快虚拟地址到  物理地址的转换，解决的是第一个问题 ，第二个问题的解决方案为：&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;多级页表：  引入多级页表的原因： 避免将全部页表一直保存在内存中， 所以可以扩大页表项的数目， 比如 32位的虚拟地址 被划为 10位的PT1  10的PT2， 以及 12 的 偏移量 offset， 页面大小位 4KB，共 2 ** 20 个页面。&lt;/li&gt;
  &lt;li&gt;倒排页表：  该设计中  实际内存中的每个页框对应一个页表项，而不是每个虚拟页对应一个页表项。  虽然减少了 页表的大小（在 虚拟地址空间 比 物理内存 空间大得多的时候） 但是 将导致 虚拟地址 到物理地址 的转换变的困难，因为不能简单的  通过 地址作为索引来寻找页表项， 而是变量 页表 来找到表项。  使用TLB能够有效的 减缓这种情况的发生。&lt;br /&gt;
？ 这里没有明白， 倒排页表 实际的存储结构，以及内容。页表 的功能 依然是 从 虚拟地址 转换到 物理地址吧，为什么 他存储的 是每个页框对应的页表项呢？   前面存储的也是这样的啊，因为页表的大小存储是有限的，所以才会发生 页表项的 淘汰与替换呢啊。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id="页面置换算法-缺页中断时候-操作系统--如何选择-高效-的-置换页面-能够显著的提高系统性能"&gt;页面置换算法： 缺页中断时候， 操作系统  如何选择 高效 的 置换页面 能够显著的提高系统性能&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;页面置换问题 在计算机的其他领域 依然存在， 比如web 服务器 将经常访问的 页面 放到 内存中，但是内存存储是有限的，当新的页面需要缓存时， 就会遇到同样的问题&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;最优页面置换算法：  很容易描述，但是无法实现。
    &lt;ul&gt;
      &lt;li&gt;描述如下：在缺页中断发生时， 我们知晓 存在内存中的页面 在未来 多少个指令后 将要被访问，则最优置换算法为： 选取 最大的指令 过后 才会访问的 页面进行替换。 即： 选择替换 未来 最近不需要访问的页面， 将 因为访问而再次发生页面中断 推迟，越久越好。&lt;/li&gt;
      &lt;li&gt;该算法无法实现， 因为os并不知道将来 页面在下一次访问的时间。但是可以作为 衡量其他算法的标准。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;最近未使用页面置换算法：（ Not Recently Used 最近未使用） 页表项设定有  读写位 + 修改位， M 位有硬件进行设定， R 位 被os周期性的进行重置。 所以最终的页表项的状态集为：&lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;       0： 没有访问，没有修改
       1： 没有访问，已被修改
       2:  已被访问，没有修改
       3: 已被访问， 已被修改
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt; * 该算法将 按照 编号 从小到大的 页面集合中 随机选取 淘汰页面。 
 * 该算法 认为 类目从小到大 在将来访问的可能性依次增大
 * 实现简单 易于理解。虽然性能不是最好的。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;先进先出页面置换算法：
    &lt;ul&gt;
      &lt;li&gt;该算法采用先进先出（FIFO first in first out） 思想， os维护一个 当前内存中的页面链表， 最新进入的放在表尾，最早进入的在表头， 发生缺页中断时候， 淘汰 表头的页面，并将新加入的页面放到表尾&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;第二次机会页面置换算法： 对FIFO算法的改进， FIFO算法可能回把经常使用的页面置换出去。该算法对FIFO算法进行一个简单的改进。  即： 淘汰表头的页面时 检查其 读写位， 如果是 0 则 该页面 最近没有被读取过，既老又没用，简单的淘汰掉。 如果是1 则 将 读写位 重置， 当作 新页面一样 放入到链表 末尾， 然后继续搜索。（即第二次机会）&lt;/li&gt;
  &lt;li&gt;时钟页面置换算法： FIFO算法  + 第二次机会算法   都需要经常在链表中移动，并移动页面。 一个更好的算法是 将所有的页面 保存为 环形链表中， 使用一个指针 指向 最老的页面。（淘汰页面）
    &lt;ul&gt;
      &lt;li&gt;缺页中断时， 首先检查 指针指向的页面， 读写位 为 0 则淘汰页面，替换为新页面， 并将指针位置 + 1， 如果读写位 为1， 则 重置 读写位，指针 + 1，继续寻找 淘汰页面。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;最近最少使用页面置换算法： 对最有算法的一个很好的近似：  是 前面频繁使用的页面 在后面也经常被使用，该思想 描述了 一个可以实现的算法。 即： 缺页中断时， 置换未使用时间最长的页面。 该算法成为 LRU least recently used
    &lt;ul&gt;
      &lt;li&gt;该算法 理论上可实现，但是代价很高， 完全的实现  需要维护 一个 所有页的 以及对应的 访问次数。&lt;/li&gt;
      &lt;li&gt;硬件实现： 在页表项中添加访问次数，每次 页面被访问，访问次数+ 1，以上由硬件实现，缺页中断时  os检查所有页面中的访问次数数值最小的一个。即 最近最少使用的页面。&lt;br /&gt;
硬件费用较高。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;NFU 因为 LRU 在软件实现中无法跟硬件一样 实现对页面访问的精确统计， 所以 采用 NFU not frequently Used 算法
    &lt;ul&gt;
      &lt;li&gt;将每个页面与一个软件计数器相关联，初始值为0， 每次时钟中断时，os扫描所有页面，如果页面 别读过 则将 计数器+1， 这个计数器大概能够反映 每个页面 被访问的频繁程度。缺页中断时， 置换计数器 最小的页面。&lt;/li&gt;
      &lt;li&gt;NFU 的问题 在于 总不会忘记过去，可以加入老化算法来优化 该算法。&lt;/li&gt;
      &lt;li&gt;优化的点在于： 在扫描页面累加计数器时，首先  先将计数器右移一位， 然后将R 位加入到计数器最左端的位。&lt;/li&gt;
      &lt;li&gt;缺页中断时： 选择计数器数值最小的页面。&lt;/li&gt;
      &lt;li&gt;与LRU的区别在于： NFU的老化算法 的计数器只有有限的位置。即 发生的时间过长 将不会被记忆。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;工作集 页面置换算法：
    &lt;blockquote&gt;
      &lt;p&gt;单纯的分页系统中，启动进程时候， 在内存中并没有页面， cpu取第一条指令 即会发生缺页中断，其他的全局变量 和堆栈 引起的缺页中断 会紧接着发生。进程 运行一段时间后， 其需要的大部分页面就都已经存在内存中了。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;根据程序的局部性访问行为， 进程运行的任何阶段，只需要访问一小部分页面。&lt;br /&gt;
为此我们设定了 工作集的概念：进程正在使用的页面集合称为 工作集。&lt;/p&gt;

&lt;p&gt;如果整个工作集 都在内存中，那么我们可以预期 在进程运行的下一个阶段之前， 不会产生很多的缺页中断&lt;br /&gt;
如果内存太小无法容纳下整个工作集，那么在进程运行的下一个阶段之前， 进程可能会产生大量的缺页中断， 导致运行速度变慢， 可能会每执行几条指令 就发生一次缺页中断， 我们称这种现象为 颠簸。&lt;/p&gt;

&lt;p&gt;多道程序系统中，在有限的内存空间中，会将进程的页面转移到磁盘中，以让其他的进程拥有cpu， 当该进程重新调入内存时，该如何处理？ 可以什么都不做，只需要处理缺页中断 ，即可，一直到 进程的工作集全部 调入内存。 然而 缺页中断的处理 太过耗时。&lt;br /&gt;
进程在缺少页面时运行，这个策略被称为 请求调页（demand paging）  即: 页面在需要时被调入，区分于 预先装入。&lt;/p&gt;

&lt;p&gt;工作集模型： 不少分页系统中跟踪 进程的工作集。 以确保进程在运行前， 他的工作集就已经在内存中了，目的在于大大减少缺页中断率。&lt;/p&gt;

&lt;p&gt;在进程运行前预先装入其工作集 页面  成为预先调页(pre paging)&lt;br /&gt;
&lt;strong&gt;注意 进程的 工作集 是随时间变化的&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;工作集 定义： w（k， t）  任意时刻 t，存在一个集合，包含所有最近k次内存访问的页面  的集合。&lt;br /&gt;
该集合 单调递增，但是不会无限的变大。 其图形如下。&lt;br /&gt;
[image]&lt;br /&gt;
？ 并没有绘制出 w（k， t） 随时间变化的曲线， 程序随时间变化是 没有规律的吗？&lt;/p&gt;

&lt;p&gt;所以图片的 x 轴 是 时间or k？  应该是k， 而 直接论断 工作集 随时间变化缓慢的结论，&lt;br /&gt;
因为工作集随时间变化很慢， 那么当程序重新开始执行时，可以根据 程序上次结束的工作集 对本次的工作集 做一个合理的推测， 预先调入 工作集中的页面，以减少缺页中断。&lt;br /&gt;
？ 即便是 预先调入进程的页面 vs 缺页中断调入， 不一样的浪费 cpu时间吗？ 如果想让 预先调入变得有用的话，则需要 cpu 在空闲时间 调入 或者 用DMA 进行（不占用cpu时间） 调入。&lt;/p&gt;

&lt;p&gt;然而很难精确的计算工作集。存在几种近似方案：&lt;/p&gt;

&lt;p&gt;将最近k次，转化为时间，即 求最近 x ms内，访问的内存页面集合。 具体如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;维护一个 记录 页面最近访问时间 以及 硬件的R位。&lt;/li&gt;
  &lt;li&gt;定期清理R位&lt;/li&gt;
  &lt;li&gt;发生缺页中断时，遍历页面，寻找 R位 为 0 以及 最近访问时间不在 xms 内的 页面（因为该页面 在 xms内 没有被访问过，所以不在工作集内） 进行淘汰。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;该算法的一个改进，即 不采用链表的方法来 维护 页面信息，而是采用 clock，工作集时钟方式 ，称为工作集时钟（WSClock） 因为 其实现简单、性能好，而在实践中得到广泛应用。 （因为时钟区分于 链表 不需要 对链表进行移动 以保持顺序，只需要简单的移动指针即可）&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;工作集时钟页面置换算法&lt;br /&gt;
页面置换中的问题： 应尽量的避免 将脏页面 换出，因为 同样会存在 IO操作，所以？ 何时对 脏页面进行换出？以及 如何控制 换出可能导致的磁盘 阻塞？  是否应将此类问题 提高一层面，交给 os处理？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;页面置换算法小结： &lt;br /&gt;
[image]&lt;/p&gt;

&lt;h4 id="分页系统中的实际问题"&gt;分页系统中的实际问题：&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;置换算法的 局部分配与全局分配：
    &lt;ul&gt;
      &lt;li&gt;局部即为进程内部分配内存， 全局则为在竞争的进程间分配内存。&lt;/li&gt;
      &lt;li&gt;全局性的页面置换算法能够 在进程之间动态的分配页框（page frame） 因此 各个进程的页框数 是随时间变化的，而 局部性的 置换算法则是固定不变的。&lt;br /&gt;
&lt;strong&gt;全局性算法通常 优于局部性算法， 尤其是在进程的工作集大小 随时间变化时，此种算法 需要监控进程工作集大小&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;可以采用单独的算法来为进程分配页框：
    &lt;ul&gt;
      &lt;li&gt;公平分配，为所有 进程 分配相同等额大小的 内存空间。&lt;/li&gt;
      &lt;li&gt;PFF（Page Fault Frequently） 缺页中断率算法&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;缺页中断率：
    &lt;ul&gt;
      &lt;li&gt;缺页中断率会随着 分配页框的增加而降低， 缺页中断率指出了何时增加或降低进程的分配页框。 但是不能当作 缺页中断时的页面置换算法。因为不能用该算法用来确定应该被淘汰的页面。&lt;/li&gt;
      &lt;li&gt;缺页中断率： 可以采用 连续平均法： 当前数值 + 之前连续平均数值 / 2  来老化之前的影响&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;分页系统中的设计问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;置换算法的 局部分配 与 全局分配：  局部即为 进程内部分配内存， 全局则为 在竞争的进程间分配内存。  全局性的页面置换算法 能够 在 进程之间动态的分配页框（page frame） 因此 各个进程的页框数 是随时间变化的，而 局部性的 置换算法 则 是固定不变的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;全局性算法 通常 优于  局部性算法， 尤其是在 进程的工作集大小 随时间变化时，此种算法 需要监控进程工作集大小。&lt;/p&gt;

&lt;p&gt;可以采用单独的算法 来 为 进程分配页框：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;公平分配，为所有 进程 分配相同等额大小的 内存空间。&lt;/li&gt;
  &lt;li&gt;PFF（Page Fault Frequently） 缺页中断率算法：&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;缺页中断率会随着 分配页框的增加而降低， 缺页中断率指出了何时增加或降低 进程 的分配页框。 但是 不能当作 缺页中断时的页面置换算法。因为 不能用该算法用来确定应该被淘汰的页面。&lt;/p&gt;

&lt;p&gt;缺页中断率： 可以采用 连续平均法： 当前数值 + 之前连续平均数值 / 2&lt;/p&gt;

&lt;p&gt;工作集算法 于 工作集时钟算法 只适用于 局部算法， 即进程内部的内存置换。&lt;/p&gt;

&lt;p&gt;负载控制： 即便是采用了最优页面置换算法， 并对进程采用理想的全局页框分配， 系统依然可能发生颠簸， 事实上 一旦所有进程 的组合工作集 超出了内存的容量限制，就可能发生颠簸。 PFF 算法的假设 指出 进程需要更多的内存， 但是没有进程需要更少的内存。  没有任何办法 能够在 不影响 其他进程的情况下，满足进程更多对内存的需要。  唯一的解决办法 即是： 将部分进程从内存交换出去。&lt;/p&gt;

&lt;p&gt;具体方法为：  将部分进程交换到磁盘中，并释放其占用的内存，这样其页框就可以被颠簸的进程使用，如果颠簸结束则停止操作，否则继续此操作 直到颠簸停止。&lt;/p&gt;

&lt;p&gt;页面大小： 需要权衡的因素：&lt;/p&gt;

&lt;p&gt;因素有：  1. 页框的内存碎片，即  分配一个页框， 而无法完全占满 页框的情况。2. 页表大小&lt;/p&gt;

&lt;p&gt;页面小： 有利于减少 页框的内存碎片，提高内存的利用率， 但 需要更大的页表。 占用的TLB 更大。&lt;br /&gt;
页面大： 增大 内存碎片，减少页表大小。&lt;/p&gt;

&lt;h1 id="总结-实践情况为--内核使用大页面而-用户进程-使用小页面-普遍的页面大小-为-4kb-8kb"&gt;总结： 实践情况为：  内核使用大页面，而 用户进程 使用小页面。 普遍的页面大小 为 4KB， 8KB&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;工作集算法与工作集时钟算法 只适用于局部算法， 即进程内部的内存置换&lt;/strong&gt;&lt;/p&gt;

&lt;h5 id="页面大小-需要权衡的因素-1-页框的内存碎片即-分配一个页框-而无法完全占满-页框的情况2-页表大小"&gt;页面大小： 需要权衡的因素： 1) 页框的内存碎片，即 分配一个页框， 而无法完全占满 页框的情况。2) 页表大小&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;页面小： 有利于减少 页框的内存碎片，提高内存的利用率， 但 需要更大的页表。 占用的TLB 更大。&lt;/li&gt;
  &lt;li&gt;页面大： 增大 内存碎片，减少页表大小。&lt;/li&gt;
  &lt;li&gt;总结： 实践情况为：  内核使用大页面，而 用户进程 使用小页面。 普遍的页面大小 为 4KB， 8KB&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;共享页面：&lt;/p&gt;

&lt;p&gt;多个进程AB 共享相同的页框 可能存在问题， 如果 进程A 因为调度决策 或者 进程结束 导致 进程 A 的内存被释放， 则会引起与 A共享内存的B 发生大量的缺页中断，把共享页框重新调入 才能继续运行。&lt;/p&gt;

&lt;p&gt;考察一个页面 是否存在共享， 便利 page table 代价较大， 需要单独的 为 共享页面 保存数据结构。&lt;/p&gt;

&lt;p&gt;linux 中的 写时复制 能够 共享 代码 与 数据。fork系统调用后， 进程 分配 自己的页表，但是指向 同一个页面集合，页表项目 都是只读，当发生 数据修改时，就会触发只读保护， 引发 系统陷阱， 然后生成 页面的副本，实现各自的修改。&lt;/p&gt;

&lt;p&gt;共享库： DLL（Dynamic Link Library） 链接 命令中指定多个 目标文件， 会将  目标文件中  使用、调用 但是未定义的外部函数 在 目标文件中 进行寻找， 并在输出的目标文件中  记录 函数调用的存根。 在操作系统 加载该目标文件时， 会根据 存根 找到 需要加载的目标文件 并加载之，如果该文件 已经被 其他的程序 使用并加载了  则  不需要重新加载， 创建新的页表 映射到 对应的内存地址。&lt;/p&gt;

&lt;p&gt;因为共享库 可能被不同程序 加载到不同的 内存位置， 则 在共享库代码中 不能够使用绝对地理位置，  需要使用 地址无关代码 编写 才能在各个 内存位置正确运行。&lt;/p&gt;

&lt;p&gt;共享库 是 更为 通用的  内存映射文件  memory-mapped file 技术的一个特例。 进程发起系统调用，将 文件映射称为 虚拟地址空间的一部分 。访问内存时 内存页面会 一页一页的加载。 磁盘文件作为 后备存储。 进程退出 或 显式的解除映射 关系时候， 内存的改动会 被写会到磁盘。&lt;/p&gt;

&lt;p&gt;提供了一种IO 模型， 可以将文件 映射称为 一个大的内存字符数组 进行访问。&lt;/p&gt;

&lt;p&gt;多个进程 映射同一文件，  他们就可以使用 共享内存进行通讯，一个进程的修改在其他的进程能立即生效， 该机制提供了一个 进程之间的高速带宽。&lt;/p&gt;

&lt;p&gt;分页守护进程（paging daemon）： 为保证系统中存在 足够的空闲页框（一定数目的 页框供给比）， 以使 分页系统保持最佳状态。 该进程 多数时间在休眠，周期性唤醒 以检查内存状态， 空闲页框过少，则 使用 预定的 页面置换算法 将页面换出内存。&lt;/p&gt;

&lt;h3 id="实现的实际问题"&gt;实现的实际问题：&lt;/h3&gt;
&lt;h5 id="os-需要与分页有关的工作时间点-进程创建进程-执行-缺页中断进程终止"&gt;os 需要与分页有关的工作时间点： 进程创建、进程 执行， 缺页中断、进程终止。&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;进程创建时:  os需要确定 程序 和 数据 初识时内存大小，并 创建页表（并初始化 初始化为0？），&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;调度:&lt;br /&gt;
页表： 进程 被换出时， 页表不需要在内存中，进程在内存时，页表必须在内存中。&lt;br /&gt;
os需要在磁盘中 创建交换区， 以便进程在 被交换时、缺页中断发生时 使用。一些系统 直接从磁盘上的可执行文件 进行分页，以节省 磁盘空间 和 初始化时间。os 需要将  页表 与 磁盘上的交换信息 保存在 进程表中。&lt;/p&gt;

    &lt;p&gt;？ 这里面 系统 对 磁盘可执行文件 直接执行分页 时如何操作的， 该操作确实应该如此， 因为 程序正文  不可能 更改，也没有必要 在 交换区中进行映射。&lt;br /&gt;
？ 页表 应该存在哪里？ 页表存储在 内存中 应该不小，如果 进程 被交换出去的话，应该放在哪里？&lt;/p&gt;

    &lt;p&gt;调度一个进程执行时， 必须为 新进程 重置MMU， 刷新 TLB， 以清除 以前进程的痕迹。 新进程的页表成为当前页表，(该操作通常 可以通过复制页表 或 将指向页表的指针放到 硬件寄存器中 来完成。 os可以选择将 进程的部分或者全部页表将入内存中，以减少缺页中断的发生， 例如： PC指向的页面。)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;缺页中断发生时: os 需要读取 硬件寄存器 来确定 哪个虚拟内存地址 造成了 内存中断， 通过该信息  与 进程表中的 信息 ，os 确定 该页面 在磁盘中的位置， 并找到 该页框 来存放页面， 可能还需要 进行页面置换， 然后将 所需的页面 读入页框， 最后 os 回退 pc地址， 指向 引起缺页中断的指令， 并重新执行该指令。&lt;/li&gt;
  &lt;li&gt;程序退出时:  os 需要释放 进程 的内存占用 以及 磁盘的交换区，其中包括： 页表、 页面在磁盘中的占用。  如果 某些 页面 是与 其他进程所共享的， 当最后一个进程 退出时，才能被释放。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id="缺页中断的-细节"&gt;缺页中断的 细节：&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;硬件陷入内核， 在堆栈 中 保存pc， cpu的各种状态 保存在寄存器 中。&lt;/li&gt;
  &lt;li&gt;执行汇编代码，保存 通用寄存器 等信息，以避免被 os 破坏，该 程序 将 os作为 函数调用&lt;/li&gt;
  &lt;li&gt;os 发现 一个缺页中断 发生时， 尝试发现需要哪个页面 ， 通常一个硬件寄存器 包含了 该信息， 如果没有的话，os必须 检索 pc， 软件分析 该指令， 已获得  发生缺页中断的 虚拟地址。&lt;/li&gt;
  &lt;li&gt;os检查该地址是否有效（包括 范围 以及 保护位），如果 出现错误（地址越界 等）  则 os向 进程发送信号 杀死进程。否则， os 检查是否 有空闲页框， 如果没有空闲页框， 执行页面置换算法 淘汰一个页面。&lt;/li&gt;
  &lt;li&gt;如果 选择的页框 被修改过，则 安排该页面写回磁盘， 并发生一次 上下文切换，挂起产生缺页中断的 进程， 让其他进程运行直到 磁盘传输结束，无论如何，该页框被标记为 忙， 以免  因为其他原因 被其他进程占用。&lt;/li&gt;
  &lt;li&gt;一旦 页框 干净 后 ， os查找所需页面在磁盘上的位置， 通过磁盘操作将其装入， 该页面被装入时， 产生缺页中断的 进程 被挂起。&lt;/li&gt;
  &lt;li&gt;磁盘中断发生时，表明该页 已经被装入， 页表被更新， 页框 也标记为正常状态。&lt;/li&gt;
  &lt;li&gt;恢复发生缺页中断 指令以前的状态， 重新执行该指令&lt;/li&gt;
  &lt;li&gt;调度引发 缺页中断的 进程，os返回调用它 的汇编程序例程&lt;/li&gt;
  &lt;li&gt;该例程  恢复 寄存器 和其他的 状态信息， 返回到用户空间继续执行，就好像 缺页中断 未曾发生 一样。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;？ 这里面发生了几次的调用切换，  程序 指令 导致 硬件陷入 内核 ，执行 一段汇编代码 （汇编代码  执行低级指令， 保存pc 状态信息等）  该汇编代码 call os函数， os代码只存在一份， 需要在 该代码中 确定 发生什么， 在这里 需要确定 缺页中断， 然后执行  缺页中断 的处理程序， 缺页中断程序 需要确定 引起发生 缺页中断的 虚拟地址， 并 将需要的页面 调入内存中（其中 可能发生 页面置换，即 页面别换入或换出）， 页面调入内存中， 需要 os 通过进程表中记录的 磁盘地址，将 磁盘内容读到 内存中 已实现 页面的调入，&lt;br /&gt;
磁盘的读取 会浪费cpu时间， cpu可以切换到 其他进程的执行，以有效利用cpu。 磁盘读取完毕 发生 中断调用， 中断调用程序  需要确定发生的情况， 已重新执行 os函数代码，并返回到  汇编代码， 重新执行 引发 缺页中断 的中断。&lt;/p&gt;

&lt;p&gt;问题：&lt;/p&gt;
&lt;h4 id="执行备份--引起缺页中断的指令-会中途停止-引发-os的陷阱-等待-os-调入-页面的内容后-并重新执行-指令然而-实现该结果-并不简单"&gt;执行备份：  引起缺页中断的指令 会中途停止 引发 os的陷阱， 等待 os 调入 页面的内容后， 并重新执行 指令。然而 实现该结果 并不简单。&lt;/h4&gt;

&lt;p&gt;例如 move  A1, A0  该指令， 引起引起 缺页中断，  但是在该指令 中， 访问了内存3次： 一次指令本身地址 + 2个内存操作数， 如果是操作数内存访问引起的 缺页中断，os 是无法弄清楚 完整的指令的， 因为 os 无法判断 引起缺页中断的内存地址 的具体含义（即 是 参数 还是 指令）&lt;/p&gt;

&lt;p&gt;为此 cpu的 设计者 提供了一种简单的 处理方法： 提供 一个隐藏的内容寄存器， 在每条指令执行之前， 把程序计数器的内容 复制到 该寄存器。 通过此信息， os可以消除 引起缺页中断指令 造成的影响。&lt;/p&gt;

&lt;h4 id="锁定内存中的页面"&gt;锁定内存中的页面：&lt;/h4&gt;
&lt;p&gt;进程 A: 通过系统调用 从文件或其他设备 读取到其 内存空间中的缓冲区， 在等待IO过程中，被挂起。进程B执行&lt;br /&gt;
进程 B： 产生一个缺页中断&lt;/p&gt;

&lt;p&gt;如果分页算法 是全局算法， 则 IO 缓冲区的 内存 则有可能 被 选中换出内存，IO 设备正在对该页面进行DMA 传输过程中， 页面 被换出，将导致 部分数据写入 IO映射的内存， 部分写入到新的页面中。？ 因为 cpu 无法考量 内存是否 正在DMA吗？&lt;/p&gt;

&lt;p&gt;两种方法： 1） 将正在进行IO的内存 钉住（Pinning） 以保证其不会被 换出， 移出内存。2） 在内核缓冲区中 完成所有IO操作，然后 再将 数据复制到 用户页面。 &lt;br /&gt;
？ 两种操作 本质应该是一样的吧， 所以内核缓冲区不会被 置换算法 选中？  现在 linux  应该采用的 是 第二种方法。&lt;/p&gt;

&lt;h4 id="后备存储---我们已经知道了-如何选择-换出内存的页面但是-没有讨论-被换出的页面--如何存储在-磁盘上"&gt;后备存储：   我们已经知道了 如何选择 换出内存的页面，但是 没有讨论 被换出的页面  如何存储在 磁盘上。&lt;/h4&gt;
&lt;p&gt;交换分区： 在磁盘上分配 页面空间的最简单的方法， 从文件系统划分一块独立的 磁盘 ， 大多数的Unix 是如此处理的（swap分区）  该分区 不是普通的文件系统，而是 使用 直接的相应的分区块号， 取消了文件偏移量 到 块地址的映射 步骤。&lt;/p&gt;

&lt;p&gt;进程表中记录着每个进程对应交换区的 磁盘地址。&lt;/p&gt;

&lt;p&gt;两种 进程交换区初始化方式：  1）  初始化什么也不做，在页面被换出时候，为其分配磁盘空间， 换入时候 回首磁盘空间。 缺点为： 进程表 需要记录每个页面对应的磁盘地址。&lt;br /&gt;
 2） 初始化 创建出 与进程空间同样大的 交换区， 每个页面都存在对应的磁盘空间， 映射也非常简单， 进程的交换区 起始块地址 + 页面偏移量。缺点是：磁盘空间占用大。&lt;/p&gt;

&lt;h4 id="虚拟内存的分段实现"&gt;虚拟内存的分段实现：&lt;/h4&gt;

&lt;p&gt;分段： 在编译器 编译程序的过程中， 会划分出 许多的段， 符号表段，源程序正文段， 变量表段 etc。  而对应的计算机 虚拟内存实现中，除了 分页的实现方式之外，还存在另类的 分段 实现设计。&lt;/p&gt;

&lt;p&gt;段 segment 每个段 范围是 0  到 最大的地址空间，  每个段 是独立的 地址空间， 其增长或者减小，对其他的段不会造成影响。&lt;br /&gt;
其 与 分页 存在本质的不同， 分页是定长的，而 段 不是。&lt;/p&gt;

&lt;p&gt;MULTICS系统采用了分段 + 分页 的虚拟内存实现方式。 将每个段视为虚拟内存 并对其进行分页。 以结合两者的优点。 在使用段的一部分时， 并不需要把整个段 加载进来。&lt;/p&gt;

&lt;p&gt;每个 程序 都存在一个段表，  段表 存在 25W 个表项， 所以段表本身 也会被分页。 每个表项 对应一个描述符，其 包含的标记有：   该段是否在内存中（ 该段的 任何一个 页面 存在内存中 即被认为 该段在内存中）  一个指向 对应页表的指针，  段大小， 保护位  以及其他的一些条目。&lt;br /&gt;
、&lt;br /&gt;
multics中的 地址 由两部分构成： 段 + 段内地址。 段内地址 分为 页号 + 页内地址。 执行内存访问时 执行如下算法（理想状况下，不考虑 段表的缺页中断）&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;根据段号 找到 段表项（段描述符）&lt;/li&gt;
  &lt;li&gt;检查页表是否在内存中， 不在 则产生一个段错误， 在 则找到对应的位置。&lt;/li&gt;
  &lt;li&gt;检查 地址对应的页表项， 检查该页面是否在内存中，不在 则产生 一个缺页中断， 在 则 取出对应的页框地址&lt;/li&gt;
  &lt;li&gt;将偏移量 + 页框地址， 既是内存地址&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;TLB 缓存 映射结果。&lt;/p&gt;

&lt;p&gt;Intel x86: 硬件的实现细节：&lt;/p&gt;

&lt;p&gt;虚拟内存的核心两张表：  LDT local descriptor table 局部描述符表，  GDT global descriptor table 全局描述符表，  每个进程 都存在自己的 LDT， 存储 自己的代码、数据、堆栈等。 GDT 则 在所有进程间共享，存储包括 操作系统 在内 的信息。&lt;/p&gt;

&lt;p&gt;x86 cs ds 寄存器 为 段选择子。包含  段表项 地址 + gdt/ldt + 特权级。  下面是  将 描述地址： 选择子 + 偏移量  转化为 物理地址的过程：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;根据 对应的 段选择子 将 从LDT 或 GDT 中 段表项（段描述符） 取出 转入到 微程序寄存器中， 以便快速访问&lt;/li&gt;
  &lt;li&gt;将段描述的 基址 添加到 偏移量&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如何解释 相加之后得到的 地址： 存在 两种情况：  是否允许分页。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;禁止分页： 线性地址 被解释为物理地址 ，直接被送往 存储器&lt;/li&gt;
  &lt;li&gt;允许分页： 线性地址 被解释为 虚拟地址，  通过页表映射到 物理地址 。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里采用了 二级映射， 因为 32为虚拟地址 页面大小为 4kb 的情况下， 需要的页表项 太多。&lt;/p&gt;

&lt;p&gt;线性的虚拟地址  被解释为 ：  10 位的 页目录  +  10位的 页表项 + 12位 偏移量。&lt;/p&gt;

&lt;p&gt;通过 页目录 找到 对应的页表的指针，再通过 页表项 找到 页表项 对应的 物理页框 地址  +  偏移量 = 物理地址&lt;/p&gt;

&lt;p&gt;为了避免 重复的内存访问， intel使用 TLB 将 （页目录，页表项） 直接 映射到页框地址。&lt;/p&gt;

&lt;p&gt;这里面依然 可以使用 不分段的  纯粹分页的 虚拟内存实现。  即 将所有的段寄存器 使用一个 数值 进行设置。 即： 程序 只是用 一个 段，段 被设定为最大，加上 指令偏移 即是 虚拟地址， 使用分页 进行 到 物理地址的转换。 既是 纯粹的 分页。&lt;/p&gt;

&lt;p&gt;因为 Unix + Windows 都未曾 使用其 分段 设计（ 为 x86 单独使用存储模型，回破坏系统 的可移植性）， 导致 intel 最后 剔除了 对 分段的支持。&lt;/p&gt;

&lt;h2 id="总结-本章-主要讲解了-虚拟内存的实现-的一些技术"&gt;总结： 本章 主要讲解了 虚拟内存的实现 的一些技术&lt;/h2&gt;

&lt;p&gt;交换技术：  通过交换技术， 可以使 系统同时运行 超过物理内存大小的 多个进程，如果 一个进程没有空间可用，则可以将它 周期性的交换到磁盘上 来运行。&lt;br /&gt;
内存和磁盘的空闲空间:  可以使用 位图 或 空闲区链表 来记录。&lt;/p&gt;

&lt;p&gt;为了减少程序对于物理内存的需求，并提供一个 无限制大小的 内存抽象。 技术有：&lt;/p&gt;

&lt;p&gt;将进程的地址空间 划分为同等大小的称为页面的块。 对应与物理内存 称为页框。 通过也部分程序 需要的页面 加载到内存中，即可实现 部分程序在内存中即可运行。&lt;br /&gt;
而因为物理内存是有限的， 则需要在 一定时机将页面 换入换出来使用有限的物理内存 建立无限的内存抽象。&lt;/p&gt;

&lt;p&gt;页面置换算法:&lt;/p&gt;

&lt;p&gt;为了使分页系统良好工作 。还需要关注更多的全局性问题， 比如 程序工作集大小的确定， 程序间的内存分配策略 以及其所需的页面大小等。&lt;/p&gt;

&lt;p&gt;除了通过分页方案来构建虚拟内存 抽象之外 分段也是一个选择，然而因为几乎没有操作系统的开发者 喜欢分段系统。导致分段 无人问津， intel x86 的64位版本 也取消对分段的支持。&lt;/p&gt;

&lt;h2 id="重要的问题"&gt;重要的问题：&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;虚拟内存的抽象 建立的目的 是啥， 需要复习&lt;/li&gt;
  &lt;li&gt;交换技术 存在的目的 又是为了什么？ 采用分页系统之后 依然需要  交换技术吗？  是否依然有必要 记录 物理内存的空闲区呢？&lt;/li&gt;
  &lt;li&gt;分页系统中， 页表的 存储地方 在哪里？ 内存 还是专门的 硬件设备？ 如果 是的话，又存在什么问题？ 不是的话 又是 如何解决的？ 为何 需要 TLB 其解决的问题的目的是啥？&lt;/li&gt;
  &lt;li&gt;为什么 存在页面置换算法？  算法存在的根本目的是啥？ 各个算法 考虑的点 是什么？ 什么才是最优的页面置换算法？ 置换算法 是否仅考虑 单个进程即可？ 进程间对于  系统 物理内存的 争抢 如何解决？ 工作集的概念 又是为了解决什么问题？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;虚拟内存共享：  允许多个进程 共享同一部分内存， 使高带宽 进程 消息传递称为可能。 可用来实现高性能的 消息传递系统。 传递消息的方式：&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>现代操作系统</title>
    <link rel="alternate" href="http://geniousbar.github.io/2021/05/24/current-os/"/>
    <id>http://geniousbar.github.io/2021/05/24/current-os/</id>
    <published>2021-05-24T00:00:00+00:00</published>
    <updated>2021-06-15T10:50:52+00:00</updated>
    <summary type="html">&lt;h3 id="现代操作系统"&gt;现代操作系统：&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;抽象是管理复杂性的关键， 好的抽象可以把一个 不可能管理的任务 分为 两个可管理的部件。 抽象的定义和实现 + 用这些抽象解决的问题。&lt;br&gt;
操作系统的任务 就是 创建好的抽象 并实现和管理它所创建的抽象对象。抽象内容是理解操作系统的关键。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id="作为资源管理者的操作系统"&gt;作为资源管理者的操作系统：&lt;/h4&gt;

&lt;h5 id="资源管理包括-以下两种不同方式实现-多路复用共享资源时间上-复用--空间上复用-"&gt;资源管理包括 以下两种不同方式实现 多路复用（共享）资源：时间上 复用 + 空间上复用 。&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;时间复用 例子 比如 打印机， 问题： 如何决定下一个执行哪个任务？ 以及 任务运行的时间&lt;/p&gt;
...&lt;/li&gt;
&lt;/ul&gt;</summary>
    <content type="html">&lt;h3 id="现代操作系统"&gt;现代操作系统：&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;抽象是管理复杂性的关键， 好的抽象可以把一个 不可能管理的任务 分为 两个可管理的部件。 抽象的定义和实现 + 用这些抽象解决的问题。&lt;br /&gt;
操作系统的任务 就是 创建好的抽象 并实现和管理它所创建的抽象对象。抽象内容是理解操作系统的关键。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id="作为资源管理者的操作系统"&gt;作为资源管理者的操作系统：&lt;/h4&gt;

&lt;h5 id="资源管理包括-以下两种不同方式实现-多路复用共享资源时间上-复用--空间上复用-"&gt;资源管理包括 以下两种不同方式实现 多路复用（共享）资源：时间上 复用 + 空间上复用 。&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;时间复用 例子 比如 打印机， 问题： 如何决定下一个执行哪个任务？ 以及 任务运行的时间&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;空间复用 比如硬盘、内存。 问题： 任务之间的公平， 保护问题。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;网络操作系统 与 分布式 操作系统： 网络操作系统 与 单处理器的操作系统没有本质区别。 分布式操作系统 则 与 集中式系统 有本质的区别，用户根本不知道自己的文件存储在什么地方，任务在那个机器上运行，网络中的通信延迟导致 分布式算法必须能够适应信息不完备、信息过时、信息错误的情况。这与 单机形成对比， 单机系统中操作系统掌握着完全的信息。因此 需要更复杂的处理器调度算法  来获得 更大的并行度。&lt;/p&gt;

&lt;h4 id="处理器"&gt;处理器：&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;访问内存 以得到指令或数据 的时间  要比执行指令花费的时间 长得多。所以 CPU内部都保存 一些用来 保存关键变量+临时数据的寄存器。
    &lt;h5 id="cpu包含"&gt;cpu包含：&lt;/h5&gt;
  &lt;/li&gt;
  &lt;li&gt;程序计数器： 下一条指令的内存地址&lt;/li&gt;
  &lt;li&gt;堆栈指针： 内存中当前栈的顶端，用于 函数调用中的 参数传递&lt;/li&gt;
  &lt;li&gt;程序状态字 PSW program status word： 包含  条件码 + cpu优先级 + 用户态内核态 + 控制位 （在系统调用中、IO 中 PSW 作用非常重要）&lt;/li&gt;
  &lt;li&gt;指令流水线： 将指令分解为 取指 + 解码 + 执行 多个单元 并行执行的结构。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;超标量CPU： 此设计中， 存在多个执行单元比如： 1个CPU 用于整数计算 + 1个cpu用于浮点数计算。 该设计 可能导致  程序中的指令 经常不按照 顺序执行。在多数情况下， 硬件负责  保证这种运算结果与顺序执行指令的结果相同，但是，应有部分 复杂情形 需要操作系统 来处理。&lt;/p&gt;

&lt;h5 id="内核态--用户态-psw-中存在-二进制-位-控制该模式内核态-cpu-可执行-指令集中的任何一条命令-用户态-则-只能执行指令集的一个子集比如io-操作-为了从操作系统获得服务-用户必须-使用-系统调用--以陷入内核-调用-操作系统trap-指令-从用户态切换到内核态"&gt;内核态 + 用户态： PSW 中存在 二进制 位 控制该模式，内核态： cpu 可执行 指令集中的任何一条命令， 用户态： 则 只能执行指令集的一个子集。（比如IO 操作） 为了从操作系统获得服务， 用户必须 使用 系统调用  以陷入内核 调用 操作系统。TRAP 指令 从用户态切换到内核态。&lt;/h5&gt;

&lt;blockquote&gt;
  &lt;p&gt;计算机使用陷阱 而非 一条指令来执行 系统调用， 而其他的多数陷阱 是由硬件引起的，用于 异常的发生，比如 除以 0。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;多线程 和 超线程：  多线程允许 cpu 保持两个不同的线程状态， 然后在纳秒级别内进行切换，多线程并非真正的并行处理， 在同一时刻 只有一个进程运行，但是线程的切换时间 为纳秒级别&lt;/strong&gt;&lt;/p&gt;

&lt;h5 id="多核cpu"&gt;多核CPU&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;GPU：  Graphics Processing Unit 上万个微核组成的处理器， 擅长大量的并行简单运算，很难编程， 虽然GPU对于操作系统 非常有用（比如加密 ，图像处理 etc） 但是 操作系统本身 不太可能 运行在GPU上。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="存储器系统--寄存器--高速缓存--主存--磁盘"&gt;存储器系统：  寄存器  高速缓存  主存  磁盘&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;任何缓存系统 都需要考虑的问题：
    &lt;ol&gt;
      &lt;li&gt;何时把一个新的内容放到缓存&lt;/li&gt;
      &lt;li&gt;把新的内容 放在缓存的哪一行上&lt;/li&gt;
      &lt;li&gt;在需要时， 应该把那个内容村缓存移走&lt;/li&gt;
      &lt;li&gt;应该把新移走的内容放在某个较大存储器的何处&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;通常通过 所引用内存地址的 高位地址 计算应该使用的缓存行。比如 对于64字节的 4096个缓存行 以及32位地址， 其中 6-17位 用来定位缓存行，而 0-5 则用来确定缓存行中的字节&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;缓存层级设计:
    &lt;ol&gt;
      &lt;li&gt;缓存是好方法： 现代cpu有两个L1缓存，第一个 L1 总是在 CPU中， 用来将 已解码 的指令调入CPU的执行引擎。 第二个L1 则存放 频繁使用的数据字节。&lt;/li&gt;
      &lt;li&gt;二级缓存L2 用来存放最近使用的若干兆内存字节，L2 延迟 1-2个时钟， L1 则没有延迟&lt;/li&gt;
      &lt;li&gt;在多核芯片中， 设计师 需要确定缓存的位置， Intel 中多核 CPU 共享L2缓存， AMD 则 每个核 都有自己的 L2缓存。Intel 需要设计 更复杂的缓存同步问题， AMD 则需要在 缓存一致上 存在困哪。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;存储设备类型：
    &lt;ol&gt;
      &lt;li&gt;内存： RAM random access Memory：&lt;/li&gt;
      &lt;li&gt;ROM: read only memory&lt;/li&gt;
      &lt;li&gt;Flash Memory:介于  RAM 与 磁盘之间， 与磁盘存储器不同， 如果 flash 擦除次数过多， 就会被磨损。&lt;/li&gt;
      &lt;li&gt;CMOS: 用于保存时间 和日期，还可以用来保存 配置参数 等，比如 那个是启动磁盘。&lt;/li&gt;
      &lt;li&gt;磁盘：&lt;/li&gt;
      &lt;li&gt;固态硬盘： 数据存储在Flash memory (闪存)中, 应该是一份 大的 Flash。&lt;/li&gt;
      &lt;li&gt;虚拟内存：  将程序放在磁盘上，而将主内存作为一种缓存， 用来保存频繁访问的区域。能够提供大于内存 的 ”内存地址“ MMU 是其实现中的重要一环。&lt;br /&gt;
&lt;strong&gt;缓存 + MMU 对于系统的性能 具有重要的影响，程序间上下文切换， 需要修改MMU的配置，将 需要同步的数据 从内存写回到 磁盘中。&lt;/strong&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id="io-设备包括-设备控制器----设备本身-控制器-从操作系统接受指令完成数据的处理-控制器的任务是为操作系统提供一个简单的接口-来处理-设备提供的数据"&gt;IO 设备包括： 设备控制器  +  设备本身， 控制器 从操作系统接受指令，完成数据的处理。 控制器的任务是为操作系统提供一个简单的接口， 来处理 设备提供的数据。&lt;/h5&gt;

&lt;h6 id="驱动程序"&gt;驱动程序&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;设备控制器的不同，导致需要不同的 设备驱动程序。 并为不同的操作系统提供相应的驱动程序。(即驱动程序 为 设备控制器 与 操作系统的桥梁。 设备控制器为  为了简化驱动程序 对操作系统的接口 而设计的，用来隐藏 设备的复杂性的控制设备)&lt;/li&gt;
  &lt;li&gt;大部分的驱动程序都需要装入操作系统中，这样他可以在 内核态 运行， 但是其也可以在 内核外运行。 现代的Linux与Windows也的确对该种方式提供了一定的支持，但绝大部分 驱动程序 依然需要在内核态运行， 非常少的 现代系统 能够在内核外运行全部驱动程序。&lt;/li&gt;
  &lt;li&gt;在用户态运行的驱动程序 必须能够 以某种受控的 方式访问设备，然后这并不容易。&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id="将设备驱动程序-装载到-操作系统有三个方法"&gt;将设备驱动程序 装载到 操作系统有三个方法：&lt;/h6&gt;
&lt;ol&gt;
  &lt;li&gt;将内核与驱动程序重新链接， 然后重启操作系统&lt;/li&gt;
  &lt;li&gt;在操作系统文件中设定一个入口，并通知该文件需要一个设备驱动程序， 然后重启系统， 在启动中， 操作系统 去寻找所需的设备驱动程序 并将其装载 （Windows 工作方式）&lt;/li&gt;
  &lt;li&gt;操作系统在运行时 接受新的设备驱动程序 并立即 将其安装好， 无需重启， 即是热插拔， USG IEEE 1394设备。&lt;/li&gt;
&lt;/ol&gt;

&lt;h6 id="输入输出的三种方式"&gt;输入+输出的三种方式：&lt;/h6&gt;
&lt;ol&gt;
  &lt;li&gt;忙等待： 用户程序发出一个系统调用，内核将其翻译成对应的 设备驱动程序 调用， 然后设备驱动程序 在一个连续不断的循环中检查设备，查看该设备是否万和城呢够了工作， 当IO 接手后， 设备驱动程序 将数据送到指定的地方， 并返回，然后操作系统将控制返回给 调用者，确定为 占据CPU， CPU 会一直轮训 设备知道对应的IO操作完成。&lt;/li&gt;
  &lt;li&gt;设备驱动程序 启动设备并且让该设备在操作完成时 发出一个中断， 设备驱动程序在这个时候 返回， 操作系统 阻塞调用者，并进行其他工作， 当设备驱动程序 检测到该设备完成时候，将发出一个中断通知操作完成。其中中断是一个非常重要的概念，IO 分为三步， 1） 设备驱动程序 通过写设备寄存器通知设备控制器做什么，然后 设备控制器 启动该设备， 当设备控制器完成操作 2） 使用特定的总线发送信号给中断控制器芯片&lt;/li&gt;
  &lt;li&gt;中断控制芯片 接受中断，他会在CPU芯片的一个管脚上声明，&lt;/li&gt;
  &lt;li&gt;中断控制器将该设备的编号 放到总线上，这样 CPU可以读取总线，并指导那个设备完成了操作。 中断 处理程序：  …  d第三种） 使用特殊的直接存储器访问 (Direct Memory Access, DMA) 芯片， 它可以 控制内存和某些控制前 之间的位流， 而无需 持续的CPU 干涉，cpu 对dma芯片 进行设置， 说明 需要传送的字节数、有关设备、和内存地址 以及操作方向， 接着启动DMA 当DMA芯片完成时，它会 引发一个中断，。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;中断&lt;/strong&gt;： 中断会发生在非常不合适的时刻， 比如另外一个中断程序正在运行时发生，如果此时接受中断 可能导致 中断程序的递归处理。所以cpu 会关闭中断并在稍后在开启中断，中断关闭时： 任何已经发出中断的设备，可以继续保持其中断信号，但是cpu不会被中断，直到中断再次启用为止， 如果多个设备发生了中断，则 中断控制器 将决定先处理那个中断， 通常这取决于 事先赋予每个设备的静态优先级，最高优先级的设备得到优先处理，其他的设备则等待。&lt;/p&gt;

&lt;h6 id="总线以及其演变"&gt;总线以及其演变&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;总线：单总线（IBM PC） 因为 处理器以 传输 需求的提升被废弃。&lt;/li&gt;
  &lt;li&gt;PCIe： 其之前的总线 都是并行 且共享的。即： 共享总线架构， 多个设备使用一些相同的导线传递数据，因为多个设备同时需要发送数据时，需要进行仲裁来决定哪一个设备优先使用。其传输方式 是”并行的“ 即 通过多条导线发送数据的每一个字，例如 一个32位 数据通过 32条并行的导线进行发送。 PCIe 则使用分离的端到端的链路，进行串行总线架构，通过一套 被称为 数据通路的链路传递集合了所有位 的一条消息，类似网络包。 即： 同时可以多个设备共享使用总线。&lt;/li&gt;
  &lt;li&gt;USB (universal serial bus) 是用来将所有的慢速设备 与计算机进行连接的。USB 是一种集中式总线， 其根设备 每1ms 轮训一次IO 设备，看是否有消息收发， usb 1.0 处理  12Mb/s, 2.0 提高到 480Mb/s 3.0 则可以达到 不小语言  5Gb/s 的速率。&lt;/li&gt;
  &lt;li&gt;在即插即用的IO设备之前， 每个IO卡 都有一个固定的 中断请求级别 和 用于 其IO寄存器的固定地址， 比如 键盘 中断级别为1， 并使用0x60-0x64 的IO地址， 即插即用 所做的操作 即是： 系统 自动的收集有关IO设备的信息，集中赋予 中断级别和 IO地址，然后通知设备控制器其所使用的数值， 这项工作 与 计算机的启动密切相关。&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id="操作系统分类"&gt;操作系统分类：&lt;/h6&gt;
&lt;ol&gt;
  &lt;li&gt;大型机操作系统  主要面向多作业的同时处理， 多数这样的作业 需要大量的IO能力， 系统主要提供三类服务： 批处理、事务处理、分时。事务处理系统负责大量小的任务， 比如航班预订任务， 每个业务量很小，但是 系统需要每秒处理上千个业务。在部分领域 大型机系统 正在被 Linux 取代&lt;/li&gt;
  &lt;li&gt;服务器操作系统： 服务器可以是 大型的个人计算、工作站、甚至是大型机， 他们通过网络为若干个用户服务，。&lt;/li&gt;
  &lt;li&gt;多处理器操作系统： 将大量CPU链接成单个系统。 根据连接和共享方式的不同，这些系统称为 并行计算机 、多计算机、多处理器。个人计算机也开始普及 多核芯片。&lt;/li&gt;
  &lt;li&gt;个人计算机操作系统&lt;/li&gt;
  &lt;li&gt;掌上计算机操作系统：&lt;/li&gt;
  &lt;li&gt;嵌入式操作系统&lt;/li&gt;
  &lt;li&gt;传感器节点操作系统：  许多用途需要微小传感器的节点网络。比如森林火灾探测，气象探测器。 此类传感器 能源资源有限。 每个节点上运行一个小型但是真实的操作系统，通常操作系统是事件驱动的，可以相应外部事件 或者基于内部的时钟进行周期性检测，该系统必须小而简单，InyOS 是一个知名的该类操作系统&lt;/li&gt;
  &lt;li&gt;实时操作系统： 系统的特征是将时间作为关键参数，比如工业过程控制系统，焊接机器人 焊接的太早 或者太晚 都有可能造成物品 损坏，所以需要在规定的时间内进行操作， 这就是硬实时系统。另一个则是软实时系统， 即： 偶尔的超时是可以接受的。&lt;/li&gt;
  &lt;li&gt;智能卡系统： 比如包含一块cpu芯片的信用卡&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id="操作系统周边概念"&gt;操作系统周边概念:&lt;/h5&gt;
&lt;ol&gt;
  &lt;li&gt;进程： 正在执行的程序，容纳一个程序所需要的所有信息的容器。包括相关的地址空间（存放 可执行程序， 程序数据，以及堆栈 ） + 进程相关的资源集  + 寄存器 + 打开的文件清单 + 信号  等 以及 运行进程需要的其他的信息。&lt;/li&gt;
  &lt;li&gt;进程表： 操作系统中存储 每一个进程有关的所有信息 放在一张表中：进程表。&lt;/li&gt;
  &lt;li&gt;系统调用： 创建进程 、 申请内存、等待进程结束 etc&lt;/li&gt;
  &lt;li&gt;信号： 无论进程在做什么，进程将被暂时挂起， 然后运行进程信号处理器， 这些信号 是软件模拟的硬件中断。&lt;/li&gt;
  &lt;li&gt;系统管理授权； 启动进程的用户UID， GID group id
    &lt;h6 id="地址空间-虚拟内存技术--本质上-操作系统创建了一个地址空间的抽象作为进程可以引用地址的集合-改地址空间与物理内存解耦可能大于也可能小于-物理空间-对地址空间和物理空间的管理组成了操作系统功能的一个重要部分"&gt;地址空间： 虚拟内存技术，  本质上 操作系统创建了一个地址空间的抽象，作为进程可以引用地址的集合， 改地址空间与物理内存解耦，可能大于也可能小于 物理空间。 对地址空间和物理空间的管理组成了操作系统功能的一个重要部分。&lt;/h6&gt;
    &lt;h6 id="文件系统"&gt;文件系统：&lt;/h6&gt;
    &lt;ul&gt;
      &lt;li&gt;文件： 支持操作系统的另一个关几年概念。 一项重要功能 即是：隐藏磁盘和其他IO设备的细节特性， 提供一个良好的清晰的独立与设备的抽象文件模型。&lt;/li&gt;
      &lt;li&gt;目录： 将文件分类成组。  目录中的目录项可以使文件或者目录， 从而产生了一个层次结构—-文件系统。&lt;/li&gt;
      &lt;li&gt;进程和文件层次都可以组成为树状结构，但是： 一般进程的树状结构 不会超过三层， 而文件结构 则 不受控制， 进程树 是暂时的，而目录层次则是 永久的。&lt;/li&gt;
      &lt;li&gt;每个进程 有一个 工作目录， 对于 非绝对路径 都将 从该工作目录下 开始寻找，&lt;/li&gt;
      &lt;li&gt;安装文件系统： 如果安装一个 DVD光盘 时候，我们需要mount 系统调用 来讲Cd-rom上的我呢间系统连接到程序所希望的根文件系统上。&lt;/li&gt;
      &lt;li&gt;特殊文件： 提供特殊文件是为了是IO设备看起来 想文件一般。 这样就可以使用系统调用 来读写文件， IO 设备也可以通过同样的系统调用 来进行读写，包含： 块特殊文件， 字符特殊文件。 可以随机存储区的块组成的设备，比如磁盘。  字符特殊文件 用于打印机， 调制解调器，输出为字符流的设备。 按照惯例，特殊文件 放在/dev 目录下。&lt;/li&gt;
      &lt;li&gt;管道： 虚拟文件， 可以连接两个进程，通过在管道上写读 来进行进程间通讯。&lt;/li&gt;
      &lt;li&gt;保护： 管理系统的安全依靠 操作系统。 例如文件只能授权用户使用。 在文件系统中，对每个文件 富裕一个 9位 的 二进制保护码&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id="操作系统体系结构"&gt;操作系统体系结构：&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;单体系统： 整个操作系统 在内核态 以单一程序的方式运行， 整个操作系统 以过程集合的方式编写， 链接成一个大型的可执行文件 的二进制程序。&lt;/li&gt;
  &lt;li&gt;层次式 系统： 其上层软件都是在下层软件的基础上进行构建的。Dijkstra 领导开发 的THE 系统 是此模式的第一个系统， 该系统分为六层。MuLTICS 系统 采用了更进一步的通用层次化概念。 采用同心环 构成， 内环比外环 有更高的级别，外环的过程调用内环过程时候，他必须执行一条等价于系统调用的trap指令， 内环对调用进行详细的参数检查校验，执行，然后返回给内环结果。&lt;/li&gt;
  &lt;li&gt;微内核： 背后的思想是： 为了实现高可靠性，将操作系统划分为小的、良好定义的模块，只有其中的一个模块 —微内核 运行在内核态， 其余的模块 由于功能相对较弱，则作为普通用户进程运行，特别的，由于把每个设备驱动程序 作为普通用户进程，这些模块的崩溃，并不会导致系统的死机。相对应的 单体系统中  因为所有的驱动程序都在内核中， 一个驱动程序的故障 很有可能导致系统的崩溃。&lt;/li&gt;
  &lt;li&gt;客户端-服务器模式：一个微内核思想的变体是将进程分为两类： 服务器 + 客户端， 每个服务器提供某种服务，客户单使用这些服务。 通常 在系统最底层是微内核。泛化的现象为： 服务器与客户端运行在不同的计算机上。他们通过网络连接， 成为 web服务。&lt;/li&gt;
  &lt;li&gt;虚拟机：&lt;/li&gt;
  &lt;li&gt;外核：&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="虚拟机-todo"&gt;虚拟机： todo&lt;/h4&gt;

&lt;h5 id="进程--线程"&gt;进程 + 线程：&lt;/h5&gt;
&lt;h6 id="相关概念"&gt;相关概念&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;伪并行： 并行的错觉，瞬间仍然是一个进程执行，只是在1s内能够运行多个进程。 区分于 多处理器系统。&lt;/li&gt;
  &lt;li&gt;前台进程: 与用户交互的进程。&lt;/li&gt;
  &lt;li&gt;守护进程：与用户交互 无关的，后台进程。（简单的定义，在Linux programming interface 中存在更准确的定义）
    &lt;h6 id="进程"&gt;进程：&lt;/h6&gt;
  &lt;/li&gt;
  &lt;li&gt;进程终止： 1） 正常退出 2） 出错 或 严重错误 3）被杀死
    &lt;ol&gt;
      &lt;li&gt;编译器在 main中添加 exit系统调用&lt;/li&gt;
      &lt;li&gt;除以0，非法操作 等错误，Linux 中能否定义 此类错误处理器？&lt;/li&gt;
      &lt;li&gt;kill 系统调用&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;层次结构：
    &lt;ol&gt;
      &lt;li&gt;windows 中 不存在进程间的层次结构。&lt;/li&gt;
      &lt;li&gt;linux 中 init 启动之后， 会为每个终端创建一个新进程，这些进程等待用户登录，如果登录成功，该进程执行一个shell终端 来接受命令，所接受的命令会创建更多的 进程， 所以整个系统会成为一个以init 为根的进程树。&lt;/li&gt;
      &lt;li&gt;进程组： 进程 + 后代进程&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;进程状态以及其之间的转换：todo&lt;/li&gt;
  &lt;li&gt;理论来说：调度程序( 包含 中断处理， 启动、停止进程等 功能) 是 进程的根基。&lt;/li&gt;
  &lt;li&gt;假设： 程序的IO操作 / 停留在内存的时间（运行态） = P 则 n个进程的cpu利用率为 1 - P ** n。 该模型 可以简单的抽象 估计 进程数目 对于cpu利用率的提升。&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id="线程"&gt;线程：&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;特点：
    &lt;ol&gt;
      &lt;li&gt;并行实体， 共享同一个 地址空间、数据（即：全局变量 打开文件描述符，定时器， 信号处理器 etc）&lt;/li&gt;
      &lt;li&gt;比进程轻量，创建速度是进程的10-100 倍&lt;/li&gt;
      &lt;li&gt;在多核CPU中可以真正的并行&lt;/li&gt;
      &lt;li&gt;多线程 可以调用 阻塞系统调用，但是依然能够 实现并行。 否则需要 单进程 状态机来 执行非阻塞的调用 并在 各个状态机之间不断切换。即： 多线程 具有 不用更改代码 很容易的实现调用 阻塞系统调用，简单的实现 并行。&lt;/li&gt;
      &lt;li&gt;源于独立的两个概念： 资源分组 与 执行。 将两个概念分离开来 则形成了： 进程为系统的资源管理单位， 线程 为执行的单位。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;相关调用 :  thread_create, thread_exit, thread_join, threa_yield&lt;/li&gt;
  &lt;li&gt;线程可以存在层次关系，但是多数时候，并不需要，即： 线程之间是平等的。&lt;/li&gt;
  &lt;li&gt;实现方式： 1） 用户空间实现 2）内核实现  3） 混合实现
    &lt;ol&gt;
      &lt;li&gt;用户空间实现： 内核对用户中的多线程一无所知，即 内核视角中： 单进程
        &lt;ul&gt;
          &lt;li&gt;优点： 线程间的切换 无需 系统调用，不需要在用户空间 与 内核空间 中进行切换。所以 速度 比 内核快一个数量级。&lt;/li&gt;
          &lt;li&gt;方便的实现自己的调度算法&lt;/li&gt;
          &lt;li&gt;问题： 如何实现阻塞的系统调用&lt;/li&gt;
          &lt;li&gt;缺页中断问题：缺页中断 会阻塞整个进程导致进程中的所有线程阻塞&lt;/li&gt;
          &lt;li&gt;无时钟中断：即一个线程不自己yield，导致其一直占用cpu，导致其他thread饥饿&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id="进程间通讯"&gt;进程间通讯：&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;3个问题： 三个问题中，出第一个问题外， 2，3 问题对于 进程、线程来说同样适用。第一个问题对于线程来说 比较简单，因为他们共享同样的地址空间。
    &lt;ol&gt;
      &lt;li&gt;一个进程如何传递消息给另一个进程&lt;/li&gt;
      &lt;li&gt;确保两个或者更多的进程在关键活动中不会出现交叉&lt;/li&gt;
      &lt;li&gt;进程间正确的执行顺序，比如A进程产生数据而B进程进行打印，那么 B在打印之前 必须进行等待，知道A已经产生数据&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;简单概念：
    &lt;ul&gt;
      &lt;li&gt;竞争条件： 多核的普及，使条件竞争越来越普通。&lt;/li&gt;
      &lt;li&gt;临界区：对共享内存进行访问的程序片段 被称为 临界区。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;互斥进入临界区 mutual exclusion 的几种方法：
    &lt;ol&gt;
      &lt;li&gt;屏蔽中断： 屏蔽所有中断，在离开时 再开打开中断。屏蔽中断后，时钟中断也被屏蔽。cpu只有发生时钟中断或其他中断时才会进行进程切换。这样屏蔽中断之后，cpu就不会切换到其他进程，所以进程能够安全的更改内存，而不必担心其他家吃的介入。 适合os使用（比如在更进程队列等数据时），并且只对单个cpu起作用。&lt;/li&gt;
      &lt;li&gt;设定锁变量： 普通的锁变量 对于 进程调度 产生的竞争条件 不起作用&lt;/li&gt;
      &lt;li&gt;严格轮换法： 两个进程相互等待对方的吧变量标志，严格的进行 进程A,B交替执行。&lt;/li&gt;
      &lt;li&gt;Peterson 算法：&lt;/li&gt;
      &lt;li&gt;TSL指令：（测试并加锁 test and set lock） 该指令将锁住 内存总线，已禁止其他CPU在被指令结束之前 访问内存。执行如下原子操作： 将内存字节lock读到寄存器RX中，然后在该内存地址上存储一个非零值。 一个可以代替该命令的命令为XCHG，该指令原子性的交换两个位置的内容。本质上同TSL指令一样&lt;br /&gt;
&lt;strong&gt;以上的锁都称为spin lock 自旋锁，即在没有获得锁的时候 进行 cpu的忙等待 busy waiting，因为此种方式 非常浪费cpu时间，所以同行应该尽量避免， 只有有理由认为 忙等待时间是非常短的时候 才使用忙等待&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;自旋锁可能存在的问题： 1）优先级反转问题： 即两个进程 高优先级H与低优先级L，调度规则为 只要H处于就绪状态 即可运行。 在某一时刻 L处于临界区中，H处于就绪态，准备进入临界区，此时H开始忙等待，由于H就绪就不会调度L运行，导致L无法完成工作，离开临界区。所以H将无限的等待下去&lt;/strong&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;互斥进入临界区的 睡眠与唤醒 解法： 假设存在连个系统调用 sleep与wakeup，sleep引起系统阻塞，即被挂起。直到另外一个进程将其唤醒。wakeup 调用一个参数，即被唤醒的进程。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;生产者消费者问题：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight c"&gt;&lt;code&gt;&lt;span class="cp"&gt;#define N 100
&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;producer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;item&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;produce_item&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; 
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="err"&gt;（&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="err"&gt;）&lt;/span&gt; &lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// 缓冲区满 则 休眠&lt;/span&gt;
        &lt;span class="n"&gt;insert_item&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;wakeup&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;consumer&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 缓冲区&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;consumer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// 缓冲区空，则进入休眠状态&lt;/span&gt;
        &lt;span class="n"&gt;item&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;remove_item&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; 
        &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;wakeup&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;producer&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 缓冲区满，则 唤醒 生产者&lt;/span&gt;
        &lt;span class="n"&gt;consume_item&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;此代码结构中存在两个问题&lt;/strong&gt;：1） 共同修改的count变量 未进行访问保护  2） 消费者 在逻辑上 未进行睡眠时，生产者的wakeup 信号丢失了。情况如下： 在 count 为0时，消费者 进行消费，读取了count 为0。此时调度器 决定执行 生产者，生产者 生产完毕，并执行 wakeup。因为消费者没有sleep所以生产者的wakeup信号丢失了，之后 消费者执行，count == 0 sleep操作。消费者将阻塞。而生产者 则一直生产 直到缓冲区已满 也阻塞起来。&lt;/p&gt;

&lt;h6 id="信号量dijkstra-提出来的算法-使用整型变量累计唤醒次数供以后使用"&gt;信号量：Dijkstra 提出来的算法， 使用整型变量累计唤醒次数，供以后使用&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;其存在两种操作；down， up（类似于 sleep 与 wakeup）&lt;/li&gt;
  &lt;li&gt;down操作； 检查信号量 数值是否大于 0，大于0  则将其数值减一。并继续，若该值为0  则进程将睡眠。操作为原子操作，  保证一个一个信号的操作完成，则 在改造做完成或阻塞之前，其他进程 均不允许访问该信号量。&lt;/li&gt;
  &lt;li&gt;原子性 对于解决 同步问题和避免竞争问题 是必不可少的。&lt;br /&gt;
up操作； 对信号数值+1， 如果一个或者多个进程在该信号量上 睡眠（即因为之前的down操作无法完成） 则由系统 选择其中的一个 进程，并允许该进程完成它的down操作。否则，将信号量数值+1。 则 对一个有进程在其上睡眠的信号量执行一个up操作之后，该信号量的值依然是0，但是其上的睡眠进程少了一个。区别于down操作，不会有进程在up操作上阻塞。&lt;/li&gt;
  &lt;li&gt;因为其中 依然需要保证原子操作，即： 依然需要使用 TSL或者XCHG 指令 来保证同一个时刻，只有一个cpu在对 信号量进行操作。但是需要注意 区别于 使用 TSL spin lock 自旋锁来 使生产者 等待 消费者 消费 是完全不同的。即：up down操作 中使用TSL 只是为了更新 信号量，然后睡眠或者唤醒进程，而自旋锁 则 对 消费者或者生产者 在临界区中的执行操作 一直进行等待&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id="互斥锁-不需要-信号量的计数功能-将信号量的初始数值设定为1-即-保证只有一个进程能够进入-临界区称为-二元信号量即为互斥锁又称为互斥量"&gt;互斥锁: 不需要 信号量的计数功能, 将信号量的初始数值设定为1， 即 保证只有一个进程能够进入 临界区，称为 二元信号量,即为互斥锁。又称为互斥量。&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;使用信号量 来实现 生产者消费者问题：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight c"&gt;&lt;code&gt;
&lt;span class="cp"&gt;#define N 100
&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;semaphore&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;semaphore&lt;/span&gt; &lt;span class="n"&gt;mutex&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 将 信号量的数值设置为1，即为 二元信号量，互斥锁.&lt;/span&gt;
&lt;span class="n"&gt;semaphore&lt;/span&gt; &lt;span class="n"&gt;full&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;semaphore&lt;/span&gt; &lt;span class="n"&gt;empty&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;


&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;producer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;item&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;produce_item&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;down&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 将 空槽位 数量 - 1&lt;/span&gt;
        &lt;span class="n"&gt;down&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 获取互斥锁&lt;/span&gt;
        &lt;span class="n"&gt;insert_item&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;up&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 释放互斥锁&lt;/span&gt;
        &lt;span class="n"&gt;up&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;full&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;// 将 满槽数 + 1&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;consumer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;down&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;full&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//将 满槽数 - 1&lt;/span&gt;
        &lt;span class="n"&gt;down&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 获取互斥锁&lt;/span&gt;
        &lt;span class="n"&gt;item&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;remove_item&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;up&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 释放互斥锁&lt;/span&gt;
        &lt;span class="n"&gt;up&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 将 空槽位 数量 + 1&lt;/span&gt;
        &lt;span class="n"&gt;consume_item&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;解释&lt;/strong&gt;: 其中信号量 full以及 empty 作为 同步使用，即保证 消费者 与 生产者 按照 正确的顺序发生。而mutex 则 互斥进入临界区。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;进程实现的一些方法:
    &lt;ul&gt;
      &lt;li&gt;线程能够 共享内存空间，所以很方便的使用上述技术。但是进程是否可以呢？ 答案是可以： 1） 使用 共享数据结构，比如信号量，可以放在内核中，并只能通过系统调用来访问。 2） Linux提供系统调用方法 来使多个进程共享 部分地址空间。 3）可以使用共享文件。&lt;/li&gt;
      &lt;li&gt;如果两个进程共享全部或者部分内存的话，进程和线程之间的差别就变得模糊起来。但无论怎样差别还是有的， 共享地址空间的进程依然依然持有各自打开的文件，定时器 以及其他的一些进程特性，多线程中 则共享全部进程特性。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id="快速用户互斥量-futex-结合了-自旋锁--与-信号量的-优点"&gt;快速用户互斥量 futex： 结合了 自旋锁  与 信号量的 优点。&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;短时间的自旋锁 会很快，但是 如果等待时间长，则会浪费cpu周期，如果有很多竞争，那么阻塞进程 并且当锁被释放时候 让内核接触阻塞会更加有效。&lt;/li&gt;
  &lt;li&gt;futex 分为两部分： 内核服务 + 用户库。内和服务提供了一个队列，允许多个进程在一个锁上进行等待， 他们不会运行，除非显示的解除阻塞。将一个进程阻塞 放到等待队列中。&lt;/li&gt;
  &lt;li&gt;在没有竞争的情况下，futex 运行在用户空间中，线程通过原子操作TSL 来争夺锁。如果发生竞争， 即该锁被其他线程持有，那么线程必须等待，这种情况下 futex锁不自旋，而是使用系统调用将自己放到内核的等待队列上，当一个线程使用完该锁时，通过原子性操作释放锁之后，并检查内核的等待队列上是否有线程阻塞，如果有 则对一个或者多个线程解除阻塞。&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id="条件变量"&gt;条件变量:&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;pthread： 中的互斥量。pthrea提供了许多的同步线程函数，其基本机制即是 使用一个可以被锁定和释放的互斥量 保护每个临界区。&lt;/li&gt;
  &lt;li&gt;除了互斥量外：还提供了另外一种同步机制 条件变量。条件变量 允许线程由于一些未达到的条件而阻塞。 大部分情况下 互斥量与条件变量是一起使用的。&lt;/li&gt;
  &lt;li&gt;pthread 互斥量相关: todo 表格&lt;/li&gt;
  &lt;li&gt;pthread与条件变量相关：todo表格&lt;/li&gt;
  &lt;li&gt;条件变量与互斥量经常一起使用，这种模式： 让一个线程锁住一个互斥量，进入临界区 当不能获得期望的结果时 等待一个条件变量。最后另一个线程向他发送信号，使它可以继续执行。pthread_cond_wait 原子性的调用并解锁他持有的互斥量，所以互斥量也是其参数之一。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;值得指出的是：条件变量并不在内存中，如果将一个信号传递给一个没有线程等待的条件变量，那么这个信号将消失，编码时应该小心的避免信号丢失情况的发生。条件变量 并不能像信量那样积累信号以便 以后使用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;下面是生产者消费者的 互斥量 + 条件变量 使用方法：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight c"&gt;&lt;code&gt;
&lt;span class="cp"&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;pthread.h&amp;gt;
#define MAX 1000000
&lt;/span&gt;
&lt;span class="n"&gt;pthread_mutex_t&lt;/span&gt; &lt;span class="n"&gt;the_mutex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;pthread_cond_t&lt;/span&gt; &lt;span class="n"&gt;condc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;condp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;buff&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;


&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;producer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;MAX&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;pthread_mutex_lock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;the_mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buff&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;pthread_cond_wait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;condp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;the_mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;buff&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;pthread_cond_signal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;condc&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;pthread_mutex_unlock&lt;/span&gt;&lt;span class="err"&gt;（&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;the_mutex&lt;/span&gt;&lt;span class="err"&gt;）&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;pthread_exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;consumer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;MAX&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;pthread_mutex_lock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;the_mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buff&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;pthread_cond_wait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;condc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;the_mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;buff&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;pthread_cond_signal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;condp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;pthread_mutex_unlock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;the_mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;pthread_exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;pthread_t&lt;/span&gt; &lt;span class="n"&gt;pro&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;con&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;pthread_mutex_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;the_mutex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;pthread_cond_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;condc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;pthread_cond_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;condp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;pthread_create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;con&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;consumer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;pthread_create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;pro&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;producer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;pthread_join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pro&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;pthread_join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;con&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;pthread_cond_destroy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;condc&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;pthread_cond_destroy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;condp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;pthread_mutex_destroy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;the_mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;以上是使用  互斥量 + 条件变量 的典型实例。 注意其中 的pthread_cond_wait的使用 以及其前缀条件。 应该总是使用 while循环 来检查 线程被唤醒后，条件是否满足。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="管程-高级同步原语-其重要的特性为-任一时刻--管程-中-只能有一个活跃的线程-这一特性使管程能够有效的完成互斥管程是编程语言的基本组成部分编译知道如何-处理对管程的调用-进入管程的互斥-通常由编译器负责其通常的的做法为使用一个-互斥量但是-依然存在问题-在上面的例子中我们使用-条件变量来使线程从-阻塞状态中恢复所以-我们--也需要同样的-同步机制-即-我们在管程中引入了-条件变量"&gt;管程: 高级同步原语 其重要的特性为： 任一时刻  管程 中 只能有一个活跃的线程。 这一特性使管程能够有效的完成互斥。管程是编程语言的基本组成部分，编译知道如何 处理对管程的调用。 进入管程的互斥 通常由编译器负责。其通常的的做法为使用一个 互斥量。但是 依然存在问题， 在上面的例子中，我们使用 条件变量来使线程从 阻塞状态中恢复。所以 我们  也需要同样的 同步机制 。即 我们在管程中引入了 条件变量。&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;当一个管程过程发现自己 不能够继续进行下去的时候， 它将会在某个条件变量上进行wait操作，该操作将导致线程阻塞，并释放临界区的锁，导致其他的管程进入临界区域，并等待其他线程在条件变量上的唤醒操作。&lt;/li&gt;
  &lt;li&gt;当一个线程对阻塞在条件变量进行唤醒操作时， 即发送signal时，为了避免管程中同时存在两个活跃线程，我们需要一条规则来确定 唤醒操作 之后 应该怎么办：&lt;/li&gt;
  &lt;li&gt;两个方法： 1）让新唤醒的线程运行，而挂起另外一个。2）执行signal的线程立即退出管程，即signal应该为函数的最后一条语句。&lt;/li&gt;
  &lt;li&gt;Java中的管程实现： 使用sychronized 标记管程函数，也不使用显示的条件变量，而是提供了对应的函数wait,notify。&lt;/li&gt;
&lt;/ol&gt;

&lt;h6 id="总结信号量的提供已经很好地解决了线程之间的临界区同步以及发生顺序问题确-为什么依然-要提供--互斥量--条件变量的组合呢"&gt;总结：信号量的提供已经很好地解决了，线程之间的临界区同步，以及发生顺序问题，确 为什么依然 要提供  互斥量 + 条件变量的组合呢？&lt;/h6&gt;
&lt;ol&gt;
  &lt;li&gt;现实的情况比较复杂，. 信号量是一个比较高级的操作原语，其可以使用互斥量 + 条件变量 + counter来实现。对程序暴露出更低级的操作  是非常有必要的。&lt;/li&gt;
  &lt;li&gt;互斥量 可以简单地 实现 1个互斥量 +  n个条件变量 的 组合实现。即 在临界区中 可以实现多种情况的 wait 与 signal&lt;/li&gt;
  &lt;li&gt;互斥量 + 条件变量 与  信号量 的使用 规则形式不同。信号量 需要先 down(full) 然后才 down(mutex) 进入临界区。而 互斥量 +条件变量的使用 ，则 是 先 lock(&amp;amp;mutex) 然后 根据条件 进行条件变量 的wait。&lt;/li&gt;
  &lt;li&gt;管程模式 导致 管程 中确实需要 条件变量。 因为管程 优先锁定互斥量进入临界区。&lt;/li&gt;
&lt;/ol&gt;

&lt;h6 id="消息传递-message-passing-使用两条-通信原语send-receive他们是-信号量而不像管程是系统调用-而不是语言成分"&gt;消息传递： message passing, 使用两条 通信原语：send receive，他们是 信号量而不像管程，是系统调用 而不是语言成分。&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;send(destination, &amp;amp;message)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;receive(source, &amp;amp;message)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;设计要点：  系统面临着  许多信号量 与管程 所未涉及的问题和设计难点。 特别是 通过网络在不同机器之间进行通讯的情况。 可能会发生 网络问题，导致消息丢失等情况的发生。 为了防止消息丢失，需要接收方，向发送方回复 确认消息，防止发送方 未收到确认消息超时重发。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;使用 消息传递解决 生产者-消费者问题：即：消费者 receive消息，而发送者 send消息。&lt;/li&gt;
  &lt;li&gt;消息传递方式 可以有多种形式： 一种方法则是 引入信箱（mail box ）用来对一定数量的消息进行缓冲的地方。 一个进程向一个满的信箱发送消息时，进程将被挂起。直到信箱中有消息被取走。&lt;/li&gt;
  &lt;li&gt;通常 在并行程序设计系统中 使用消息传递。例如著名的消息传递接口(Message-Passing Interface MPI )&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id="屏障-用于同步进程组一些应用中划分了若干阶段并且规定除非所有的进程-都准备就绪否则任何进程都不能进入下一个阶段-可以通过在每一个阶段的结尾安置--屏障-来实现此类型行为--当一个进程到达屏障时他就被阻拦直到所有进程都到达-该屏障为止屏障用于一组进程的同步"&gt;屏障： 用于同步进程组，一些应用中划分了若干阶段，并且规定，除非所有的进程 都准备就绪，否则任何进程都不能进入下一个阶段。 可以通过在每一个阶段的结尾安置  屏障 来实现此类型行为。  当一个进程到达屏障时，他就被阻拦，直到所有进程都到达 该屏障为止。屏障用于一组进程的同步，&lt;/h6&gt;

&lt;h4 id="调度-当计算机同时存在多个进程或者线程同时竞争cpu只要有两个或更多的进程处于就绪状态如果只有一个cpu发生那么就必须选择下一个要运行的进程在操作系统中完成选择工作的这一部分称为-调度程序该程序使用的算法称为-调度算法"&gt;调度： 当计算机同时存在多个进程或者线程同时竞争cpu，只要有两个或更多的进程处于就绪状态，如果只有一个cpu发生，那么就必须选择下一个要运行的进程，在操作系统中完成选择工作的这一部分称为 调度程序。该程序使用的算法称为 调度算法。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;周边概念：
    &lt;ul&gt;
      &lt;li&gt;进程调度 与线程调度 没有本质区别，但是线程调度 依然会存在 一些独特的问题。&lt;/li&gt;
      &lt;li&gt;进程的切换 代价 是比较高的。  首先 用户态 必须 切换到内核态，然后保存当前进程的状态，包括在进程表 中存储寄存器的数值、内存映像等 以便进程的 重新装载，同时 进程切换 还要使整个内存高速缓存失效，强迫 从换内存中 动态重新装入两次（进入内核一次，离开内核一次）。即：进程切换会耗费cpu时间，&lt;/li&gt;
      &lt;li&gt;进程 行为： 几乎所有的进程的IO请求与计算都是 交替发生的。即：cpu 运行一段时间之后，然后发起一个系统调用 以 读写文件，在完成系统调用之后，cpu开始计算，直到他需要读取更多的 数据 为止。  请注意某些IO活动 可以看做计算 。 当一个进程 等待外部设备 完成工作 而被阻塞时，才是IO活动。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;根据检查花费在 cpu计算与 IO上的时间 可以将进程划分为 两类：
    &lt;ul&gt;
      &lt;li&gt;计算密集型：较长时间的cpu集中使用 + 较小频繁的IO等待&lt;/li&gt;
      &lt;li&gt;IO密集型： 较短时间的cpu集中使用 + 频繁的IO等待&lt;br /&gt;
&lt;strong&gt;随着cpu变得越来越快&lt;/strong&gt;，更多的进程倾向为 IO 密集型。因为cpu的改进比磁盘的改进快得多。结果是， 未来对于 IO密集型进程的调度处理 更加重要。两个结论：1）IO密集型进程应该尽快得到调度，而使磁盘得到充分的发挥， 2） 如果进程是IO密集型，则可以 多运行一些这类进程 以便 保持cpu利用率。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;何时调度： 调度时机
    &lt;ol&gt;
      &lt;li&gt;在创建一个新的进程后&lt;/li&gt;
      &lt;li&gt;在一个进程退出时&lt;/li&gt;
      &lt;li&gt;在一个进程阻塞在IO和信号量上 或由于其他原因阻塞时&lt;/li&gt;
      &lt;li&gt;在一个IO中断发生后&lt;/li&gt;
      &lt;li&gt;硬件时钟中断： 可以在 每个时钟中断 或者每k个时钟中断 时，做出决策。 感觉如何处理时钟中断可将调度算法 分为两类：
        &lt;ul&gt;
          &lt;li&gt;非抢占式 调度算法 挑选一个进程 然后让该进程运行直到被阻塞 或者 进程主动释放cpu，即是该进程运行数个小时，依然不会被挂起。这样的结果是，在时钟中断 发生时不会进行调度，在处理完 时钟中断后，如果没有更高优先级的进程 等待到时，则中断的进程会继续进行。&lt;/li&gt;
          &lt;li&gt;抢占式调度算法： 挑选一个进程并让该进程运行某个固定时段的最大值。如果该时间段结束，该进程依然在运行，将被挂起，调度程序将挑选另一个进程运行。抢占式调度算法。需要在时间末端发生时钟中断。以便把cpu控制返回给调度程序，如果没有可用的时钟，那么不能够实现 抢占式调度算法。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;调度算法分类：不同的环境 需要不同的调度算法，以为需要不同的目标。分为三类环境：批处理、交互式、实时
    &lt;ol&gt;
      &lt;li&gt;批处理环境中： 可以运行非抢占式算法，&lt;/li&gt;
      &lt;li&gt;交互式环境中：抢占式必须要的，&lt;/li&gt;
      &lt;li&gt;实时系统中： 抢占有时是不需要的。以为进程知道他们可能会长时间得不到运行，而尽快完成任务。与交互环境的区别，在于：实时系统只运行那些用来推进现有应用的程序，而交互是系统是通用的。  他可以运行任意的非写作甚至是恶意的程序。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;调度算法的目标：取决于环境目标 + 通用目标：
    &lt;ul&gt;
      &lt;li&gt;通用目标：
        &lt;ul&gt;
          &lt;li&gt;1）公平， 相似的进程得到的cpu时间是相似的，不同类型的进程 得到的计算 可以采用不同的方式，或者有差异。&lt;/li&gt;
          &lt;li&gt;2） 保持系统中的所有部分尽可能忙碌，例如cpu、磁盘。 在批处理系统中，调度程序控制那些任务的调入内存。 内存中既有 cpu密集型 与IO密集型 作业 要优于 先运算完  cpu密集型任务，然后再运算 IO密集型任务。 因为 在集中计算 所有的cpu密集型任务时，cpu 保持忙碌，任务保持对cpu的争抢，而磁盘保持闲置状态。显然 可以通过仔细的安排任务，能够 使整个系统运行的更好一些。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;场景目标：  &lt;br /&gt;
批处理系统： 吞吐量- 每小时做大作业量， 周转时间- 从提交到终止间的最小时间， CPU利用率- 保持cpu始终忙碌。&lt;br /&gt;
交互式系统： 响应时间–快速响应请求，均衡性– 满足用户的期望。&lt;br /&gt;
实时系统–满足截止时间： 避免丢失数据，可预测性- 在多媒体系统中避免低品质。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;批处理作业中的 三个衡量指标:  吞吐量，周转时间，cpu利用率。&lt;/li&gt;
  &lt;li&gt;吞吐量（throught）: 系统每个小时完成的工作量。每小时完成50个作业好于 完成40个作业。&lt;/li&gt;
  &lt;li&gt;周转时间(turnaround time): 从一个作业提交时刻开始直到 作业完成时刻为止 的统计平均时间。度量了 用户要得到输出所需要的平均时间，越小越好。&lt;/li&gt;
  &lt;li&gt;cpu利用率： cpu利用比率。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;吞吐量与 周转时间之间的冲突： 例如 对于确定的短作业 与长作业 的一个组合。 总是运行短作业而不是长作业，会获得出色的吞吐性能。但是其代价为 长的作业周转时间较差。即得到了较高的吞吐量 ，但是 平均周转较差。&lt;/p&gt;

&lt;p&gt;交互式系统的不同指标： 最小响应时间： 从命令到得到响应之间的时间。均衡性： 用户对于一件事情完成需要多少时间 总是一个固定的期望。&lt;/p&gt;

&lt;p&gt;实时系统： 特点是 必须满足截止时间要求。&lt;/p&gt;

&lt;p&gt;批处理中的调度算法：&lt;/p&gt;

&lt;p&gt;先来先服务：first-come first-serverd 算法。该算法 按照 进程请求cpu的顺序 使用cpu， 可以想象有一个 就绪进程的队列， 产生新作业时，新进程排在就绪队列 尾部。 当正在运行的进程由 就绪变为阻塞时，就绪队列中的第一个进程运行，当被阻塞的进程变为就绪状态时，就像一个新来的作业进程一样，排到就绪队列的末尾。 该类算法 实现起来比较简单。但是存在一个明显的缺点，即： 对于IO密集型进程不太友好，没有很好的考量 是系统中的 设备是否充分利用。  考虑 两个进程，一个cpu密集型进程 每次运行1s的cpu计算 和一个 IO密集型进程，很少利用cpu，但是需要都要运行1000次的磁盘读写操作才能完成任务。 如果 按照该类调度算法 的话，则IO密集型进程需要运行1000s才能够运行完成，但是如果 使用抢占式 调度算法的话，则可以 没10ms进行一次抢占调度，则 IO密集型进程将在10s内完成，而对于 cpu密集型进程 则没有太大影响。&lt;/p&gt;

&lt;p&gt;最短作业优先： 适用于一种运行时间预知的非抢占式调度算法。 即：作业按照 完成时间 从小到大排列，即 shortest job first.&lt;br /&gt;
考虑有4各作业。其运行时间 分别为 a ,b,c,d  其平均周转时间为 (4a + 3b + 2c + d)/4，可见第一个作业a的完成时间，对于 平均周转 影响最大，而 吞吐量 同样为最大。  又必须要指出， 只有在所有的作业都可同时运行的情况下，最短作业优先算法才是最优的。反例： 5各作业，A-E,运行时间分别为：2,4,1,1,1 他们到达系统的时间分别为 0,0,3,3,3， 系统在开始时 只能选择A与B， 按照 该调度算法的排序 为A,B,C,D,E 其平均周转时间为4.6，但是按照 B,C,D,E,A的调度安排，时间为4.4，优于  最短作业优先。&lt;/p&gt;

&lt;p&gt;最短剩余时间优先： 最短作业优先的抢占式调度版本。 调度程序总是选择 剩余运行时间 最短的那个进程 进行运行。当新加入的进程的剩余时间最短时，则当前进程就被挂起，运行新的进程。&lt;/p&gt;

&lt;p&gt;交互式系统中的调度：&lt;/p&gt;

&lt;p&gt;轮转调度（round robin）： 简单公平的调度算法， 每个进程被分配一个时间段，称为时间片。 （quantum）&lt;/p&gt;

&lt;p&gt;即允许 进程在该时间段内运行，如果在时间片结束时候该进程还在运行 则剥夺cpu并分配给另一个进程。如果该进程在时间片内 阻塞或者结束 则 cpu将立即切换。&lt;/p&gt;

&lt;p&gt;轮转调度算法 实现非常简单，即维护一个 可以运行的进程列表。不断的从列表头上取出进程运行，时间片用完后，将进程放到列表队尾。&lt;/p&gt;

&lt;p&gt;关于时间片的长度设定： 从一个进程切换到另一个进程 即 进程切换 也称为 上下文切换。 其中需要 保存和装入寄存器数值，更新各种列表，清除和重新调入内存 高速缓存等 操作。&lt;/p&gt;

&lt;p&gt;如果时间片设定为4ms 而进程切换需要 1ms，则 cpu时间将花费 20% 的时间在进程的切换上。&lt;br /&gt;
如果将时间片设定为100ms，则cpu时间将花费1%在进程间的切换上。但是 可以想见的是，排在队尾的进程将在很久之后才能得到cpu的时间，对于交互式系统用户而言，将是缓慢的。&lt;br /&gt;
如果将时间片设置为长于平均的cpu突发时间，那么将不会经常发生抢占，相反 多数进程将在时间片内发生 阻塞操作，从而引起进程切换，抢占的消失改善了性能，因为进程只有在逻辑上需要的时候发生了切换，即：进程确实不能够在继续进行下去。&lt;/p&gt;

&lt;p&gt;总结：时间片设定的太短，导致cpu利用率的降低，时间片设定的太长，导致交互请求的响应变长，普遍间时间片设定为 20-50ms范围内 。&lt;/p&gt;

&lt;p&gt;优先级调度：&lt;/p&gt;

&lt;p&gt;在轮转调度中 存在一个隐藏的假设，即： 所有的进程是同样重要的。实际上 进程的优先级是可以调整的。即进程之间存在重要性的差异。比如 在屏幕上显示视频的进程 比 后台发送邮件的进程具有较高的优先级。&lt;/p&gt;

&lt;p&gt;从此可以看到 时钟滴答 与 时间片 是不同的概念。这里面的时钟中断 应该是 linux中 可以控制的时钟周期，即cpu频率保持不变，但是在 配置的滴答个数 可以 进行时钟中断，而 时间片的概念呢？是建立在 时钟中断上的吧？&lt;/p&gt;

&lt;p&gt;两种方法：&lt;br /&gt;
为了防止 高优先级的进程一直无休止的运行下去，调度程序可能在每个时钟滴答（时钟中断）降低当前进程的优先级，如果这一行为导致该进程的优先级低于此高级优先级的进程，则进行进程切换。&lt;br /&gt;
给每个进程赋予一个允许运行的最大时间片。 当用完这个时间片  则 此高优先级的进程 便能获得运行机会，即进行进程切换。&lt;/p&gt;

&lt;p&gt;优先级 可静态确定 或 动态确定。 比如 按照行政等级 确定 等级高的人 的任务具有更高的优先级。&lt;/p&gt;

&lt;p&gt;动态确定： 的比如，将IO密集型进程设定更高的优先级，算法 1/f，f为进程在上次的时间片上用的时间片。IO密集型进程 其多数时间 用来等待 IO结束，当这样的进程需要CPU时候，应该立即分配给他，以便让其 启动下一个 IO请求，以充分利用cpu与IO设备。一个在50ms时间片中花费 1ms 时间的 进程 将获得 50的优先级，一个进行  2mscpu运算的进程将获得25的优先级。&lt;/p&gt;

&lt;p&gt;多级队列： 优先级调度 中优先级之间 改变优先级 的另外一种方法： 设立优先级类，将最高优先级类的 进程运行一个时间片，此高级优先级的进程 运行 2个时间片， 下一个优先级的进程类运行 4个时间片。 以此类推，当一个进程用完分配的时间片之后，将被移到下一个优先级类。 这样的规则将导致 cpu密集型进程将获得更低的优先级，更大的时间片进行运行。 这里面的存在的缺陷在于，没有将 优先级提升的方法，如果 交互式进程因为 偶尔的 用完时间片的行为  将导致 不断的惩罚，将导致 降低为 低优先级。&lt;/p&gt;

&lt;p&gt;最短进程优化：&lt;/p&gt;

&lt;p&gt;再批处理系统中 使用 最暖进程优先算法是非常好的。 然而如何将其 应用在交互式系统中 则成为问题，因为 如何从当前进程中找到运行时间 最短的那个进程。 交互式 进程通常的模式 为：  等待命令、执行命令、等待命令、执行命令 如此往复。&lt;br /&gt;
一种办法为： 根据进程过去的行为进行推测。使用时间老化算法来估算 进程运行时间。 假设进程 之前进程运行的时间  为  T0，当前估计时间 T1，本次 实际时间 为 T0/2 + T1/2 则  aT0 + (1 - a) T1 通过选择 a，可以决定 尽快忘掉老的运行时间。当 a = 1/2时，我们可以得到如下的队列：&lt;/p&gt;

&lt;p&gt;T0， T0/2 + T1/2， T0/4 + T1/4 + T2/2， T0/8 + T/8 + T2/4 + T3/2 在 3此过后 T0的权重 降低为 1/8&lt;/p&gt;

&lt;p&gt;我们把 这种通过当前预测值 + 先前估计值  加权平均 而得到 一个 估计值 的技术 成为 老化技术。&lt;/p&gt;

&lt;p&gt;保证调度： 向用户做出明确的性能保障，然后去实现它。一个简单的保证为： 如有n各用户登录，则保证用户将获得 1/n 的计算能力。 即系统 需要追踪 系统的运行参数， 诸如 用户进程 实际占用的cpu运行时间，以及 应该占用的cpu时间。其数值比率 大 则说明 获得时间多，而数值小 则说明 获得cpu时间少。  该算法 将优先调度 数值小的 进程 ，已实现 性能保证要求。&lt;/p&gt;

&lt;p&gt;彩票调度： 保证调度 很难实现，一种近似实现 为 彩票调度（lottery scheduling） 基本思想为 为进程提供 各种系统资源 的彩票。 需要做出调度决策时，就随机抽取一张彩票，拥有该彩票的进程获得调度。&lt;br /&gt;
如果cpu出售了1000张彩票 ，某个进程 持有 20张，则每一次抽奖 该进程就有20%的几率 获得cpu， 在较长的运行时间中，该进程将获得20%的cpu。与  优先级调度 相比较，很难解释进程的优先级为 20 是什么意思，也更难预测 进程将获得与 优先级相关的多少cpu时间。而彩票调度  则 非常明确，拥有 f分彩票 进程 大约得到 系统资源的f份额。&lt;/p&gt;

&lt;p&gt;彩票调度 可以用来解决一些 难题，比如 视频流服务器， 服务器上若干进程 为用户提供 帧速率 为10，20，25 的视频流，  只需要 分配 进程 对应的 彩票份额，10， 20，25 即可。&lt;/p&gt;

&lt;p&gt;公平分享调度： 需要具体考虑 公平 的定义，用户公平的调度 则需要考虑 在 进程调度 期间 用户的进程 分配 cpu占用问题。&lt;/p&gt;

&lt;p&gt;策略和机制： 调度机制 与 调度策略 分离开来。调度机制位于内核，而调度策略 则由用户进程 决定。&lt;/p&gt;

&lt;p&gt;线程调度： 若干进程 由多个线程 时候，系统中就存在两个层次的并行： 进程和线程， 在这样的系统中 调度 处理 有本质上的差别。当然这取决于线程 的实现： 即 用户级线程 还是内核级线程。&lt;/p&gt;

&lt;p&gt;在 用户级别线程下： 由于内核并不知道线程的存在 ，所以 内核 依然 按照 进程调度，即 用户线程调度 决定 选择那个一个线程。 调度算法 选取中 可以选用上面的任何一种，但 轮转调度 和优先级 调度更为常用。 缺陷则是缺乏 一个时钟中断中断运行时间 过长的线程，但是因为线程之间 为合作关系，所以通常并不是问题。&lt;br /&gt;
内核级线程： 对于内核  可以考虑优先调度同属于一个进程的线程，以为同进程间的线程调度 代价要小于 进程之间的调度。其他方面 则与 进程间调度没有什么不同。Linux中 线程与进程同为 调度实体。&lt;/p&gt;

&lt;p&gt;用户级线程 与 内核级线程 之间的差别在于 性能： 用户级线程的线程切换 需要较少的机器指令，而内核级线程 切换  则需要 完整的上下文切换、修改内存映像、高速缓存失效（而同样归于同进程的线程 则是不需要） 等操作，这导致了数量级别的延迟。&lt;/p&gt;

&lt;p&gt;用户级线程 可以使用 特定优化的调度算法，以为 应用程序 知道自己的应用场景，而 内核级线程 内核从来不了解 每个线程的作用。一般而言，应用定制的线程调度算法 能够比内核 更好的满足 应用的需要。&lt;/p&gt;

&lt;p&gt;经典的IPC问题：  哲学家就餐问题， 读者-写者问题&lt;/p&gt;

&lt;p&gt;哲学家就餐问题：&lt;/p&gt;

&lt;p&gt;直观的解法： 显然是错误的，如果 五位哲学家 同时执行（拿起 左边的筷子 、拿起右边的筷子） 将会导致 没有人能够拿起 右边的筷子， 从而导致死锁。  一个简单的解决方法为：  在哲学家拿起 左边的筷子时候，查看右边的筷子 是否可用，如果不可用，则先放下左边的筷子 ， 等一段时间，再重复这个过程。  但这个解法同样存在问题。 尽管原因不同，同一时间 所有的哲学家 都开始进行 该算法，同时 拿起左边的筷子，同时 查看右边筷子是否可用，放下，等待。 如此运行下去 所有的进程都在运行，但是却无法取得进展，该现象 我们称之为饥饿。&lt;br /&gt;
我们简单的将 上述 中的等待时间 设定为一个 动态的随机时间，而不是等待一个固定的时间 。这样发生饥饿的可能性就非常小了， 几乎在所有的程序中，稍后再试的办法并不会演化成为一个问题。例如 ： 在流行的以太网上，  如果两台计算机同时发送包 ，那么每台计算机会稍等一哥随机时间之后 再次尝试，在实践中  该方案工作良好。 少数的程序中， 人们希望一种总是能够工作的方案，他不会因为一串 随机数字而失败。&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight c"&gt;&lt;code&gt;&lt;span class="cp"&gt;#define N 5
&lt;/span&gt;

&lt;span class="n"&gt;vodi&lt;/span&gt; &lt;span class="nf"&gt;philosopher&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;think&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
  &lt;span class="n"&gt;take_fork&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;take_fork&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;eat&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
  &lt;span class="n"&gt;put_fork&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
  &lt;span class="n"&gt;put_fork&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最优的解法： 这里应该搜索，没有理解其代码意思。&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight c"&gt;&lt;code&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;philosopher&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;take_forks&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;down&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;hungry&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;up&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;down&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;put_forks&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;down&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;thinking&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LEFT&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;RIGHT&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;up&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;test&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;hungry&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;LEFT&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;EATING&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;RIGHT&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;EATING&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;EATING&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;up&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;读者-写者问题：一个数据库访问模型：  多个进程可以同时读取数据库，但是如果一个进程 正在更新 写数据库，则所有的其他进程 都不能够访问数据库。&lt;/p&gt;

&lt;p&gt;下面是一个读者优先访问示例代码：&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight c"&gt;&lt;code&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;semaphore&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;semaphore&lt;/span&gt; &lt;span class="n"&gt;mutex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;semaphore&lt;/span&gt; &lt;span class="n"&gt;db&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;rc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;reader&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;down&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mutext&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;rc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;rc&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rc&lt;/span&gt; &lt;span class="o"&gt;===&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;down&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;up&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;read_data_base&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;down&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;rc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;rc&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rc&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;up&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;up&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;use_data_read&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="n"&gt;think_up_data&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  &lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="n"&gt;down&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
   &lt;span class="n"&gt;write_data_base&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
   &lt;span class="n"&gt;up&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该解法中 隐含着一种情况：即 数据库当前存在一个读者 时候，另一个读者来了 以及 更多的读者来了，同样允许。这时 一个写者到来  由于写者是拍他的，不允许进入数据库，导致被挂起。需要等待所有的读者处理完成之后 才能开始进行处理写操作。即 读者比 写者拥有更多高的优先级， 写总是排在读后面，如果读者多的情况下 将导致 写 迟迟不能完成操作。&lt;/p&gt;

&lt;p&gt;写优先的解法 需要查找 courtois等人的相关资料。&lt;/p&gt;

&lt;p&gt;总结：&lt;br /&gt;
进程问题已经有了成熟的解决方案，几乎所有的系统都将进程视为一个容器， 用以管理相关的资源，比如地址空间、线程、打开的文件描述符等。 不同的系统管理进程资源的基本想法大致相同。 只是在工程处理上略有差异。&lt;br /&gt;
线程是比进程新的概念，但是也经过了深入了的研究。&lt;br /&gt;
进行执行过程的 记录和重放  也是一个非常活跃的研究领域。 重放技术 可以帮助开发者 追踪一些难以发现的程序漏洞。&lt;br /&gt;
调度问题  也是研究者感兴趣的问题。 一些研究主题包括移动设备上的低能耗调度， 超线程级调度 和偏执意识调度 。 智能手机的计算量 增加 因为电池容量有限。 一些研究者提出 可能的时候将进程迁移到云上某个更强大的服务器上执行。但实际系统的设计者  很少会因为没有合适的线程调度算法 而苦恼。所以这是一个由 研究者推送而不是 需求推动的研究类型。总而言之， 进程，线程 与调度已经不再是研究热点了，功耗管理 、虚拟化、云计算 、与安全问题 成为了热点主题。&lt;/p&gt;

&lt;p&gt;习题答案 ：（部分重要）&lt;/p&gt;

&lt;p&gt;当代计算机中，为什么中断处理程序中 至少部分是由汇编程序来编的？&lt;br /&gt;
答： 高级语言不允许访问 必要的cpu资源，比如 一个中断处理程序中 可能需要开启、禁止 中断。 此外 中断处理程序 需要尽可能的快。&lt;/p&gt;

&lt;p&gt;中断 或 系统调用 将控制权 转移到 操作系统时，为什么 通常会 用到与 被中断进程 的栈分离的 内核栈？&lt;br /&gt;
答： 为内核使用单独的堆栈有几个原因。 其中两个如下。 首先，您不希望操作系统崩溃，因为编写得不好的用户程序不允许有足够的堆栈空间。 其次，如果内核在从系统调用返回时将堆栈数据留在用户程序的内存空间中，恶意用户可能能够使用这些数据来查找有关其他进程的信息。&lt;/p&gt;

&lt;h3 id="内存管理-"&gt;内存管理 ：&lt;/h3&gt;

&lt;p&gt;不管存储器多大，程序都可以将其填满。&lt;/p&gt;

&lt;p&gt;分层存储器体系： 在这个体系中，存在 MB 的快速、昂贵、易失性的高速缓存，GB的速度价格适中的同样易失的内存 ，以及 TB的低速、廉价、非易失的磁盘存储。&lt;/p&gt;

&lt;p&gt;操作系统的工作之一 就是 将层次存储系统体系 抽象成为一个 有用的模型 并管理这个抽象。&lt;/p&gt;

&lt;p&gt;分层存储器系统称为 存储管理系统：  他的任务是 有效的管理内存，即记录哪些 内存是正在使用的，哪些 是空闲的， 在进程需要时候为其分配内存 ，不需要时释放内存。&lt;/p&gt;

&lt;p&gt;探索 内存抽象方案 的步骤：&lt;/p&gt;

&lt;p&gt;无存储器抽象：  最简单的存储器抽象 即 没有抽象。  早期的大型机  小型计算机 都没有存储抽象。 每一个程序 都直接访问物理内存。&lt;br /&gt;
因此  那时候呈现给编程人员的存储器 即是：  从0到某个上限的地址集合，每个地址 对应一个 可容纳 一定数目的二进制数据，通常是 8位。&lt;br /&gt;
指令 MOve Register1， 100  即：将  100的物理内存的内容，转移到 register1中。&lt;/p&gt;

&lt;p&gt;改种方案下， 系统中同时运行两个程序 是不可能的。如果进程 A在 地址 100位置写入数据，进程 2  在稍后的时间中 对地址 100进行了改写，可能导致 进程A的崩溃。&lt;/p&gt;

&lt;p&gt;在该模式 内存的布局方式有以下三种：&lt;/p&gt;

&lt;p&gt;操作系统位于 RAM 的底部&lt;br /&gt;
操作系统位于内存顶端 的ROM（只读存储器） 中&lt;br /&gt;
设备驱动程序位于顶端的ROM中，操作系统位于底端的RAM中&lt;/p&gt;

&lt;p&gt;第二种方案 经常用在 一些掌上电脑，和嵌入式系统中。&lt;br /&gt;
第三种方案 用于早期的个人计算机中， ROM中的系统部分 为 BIOS（basic  input output system）&lt;/p&gt;

&lt;p&gt;在没有存储器抽象的情况下 同时运行多个程序。&lt;/p&gt;

&lt;p&gt;操作系统 只需要 把当前的内存中的内容 保存到磁盘上 ，然后将下一个程序 读入到内存中 再次运行即可。 只要在同一时刻 内存中只有一个程序 即可。&lt;/p&gt;

&lt;p&gt;IBM 360 的做法：&lt;br /&gt;
内存被划分为 大小2KB的块。 每个块 分配一个 4位的保护键， 保护键存储在cpu的特殊寄存器中， PSW中存在一个 4位码， 一个运行中的进程如果访问保护码 与 PSW中的不同的内存，硬件将会捕获该事件。  因为只有系统可以修改保护键，这样就可以放置用户进程 之间、用户和操作系统之间的相互干扰。&lt;/p&gt;

&lt;p&gt;静态重定位技术： 即便 存在保护键，依然无法解决 两个进程 使用重复的绝对地址的问题，我们希望每个进程使用一套自己私有的内存地址来进行内存访问。IBM  360 采用的方法 即：在第二个 程序 装载到内存 100地址时， 常数100将被 加到 每一个 程序地址上。&lt;/p&gt;

&lt;p&gt;缺少存储器抽象在嵌入式系统中 依然非常常见， 比如 洗衣机 微波炉 此类 设备 都已经完全被ROM形式的软件控制。 这种情况下，软件都采用 绝对地址寻址的方式，以为 所有的运行的程序 都可以被事先确定，  用户不需要运行自己的软件。&lt;/p&gt;

&lt;p&gt;存储器抽象：地址空间&lt;/p&gt;

&lt;p&gt;直接暴露物理地址的问题： 1） 用户程序可以简单的寻址内存地址，很容易地破坏 操作系统。 2） 同时运行多个程序将非常困难。&lt;/p&gt;

&lt;p&gt;地址空间的概念：&lt;/p&gt;

&lt;p&gt;要多个应用程序 同时处于内存 而不互相影响 需要解决两个问题： 1）保护 2）重定位 。&lt;/p&gt;

&lt;p&gt;IBM 360的办法 实际效果并不好，因为 其 静态重定位 技术，不仅缓慢，还需要 额外的标记 来确定 那些地址 需要被加。&lt;/p&gt;

&lt;p&gt;就像 进程的概念 创造了 cpu的抽象 为 进程使用 一样。&lt;/p&gt;

&lt;p&gt;地址空间 为程序 创造了 一种抽象 的内存，地址空间 是一个进程可以用于寻址内存的地址集合。每个进程 都有自己的 地址空间，独立于 其他的 进程 地址空间。&lt;/p&gt;

&lt;p&gt;地址空间的概念非常常见：  比如 电话号码、url等。&lt;br /&gt;
简单实现：动态重定位：  给cpu配置两个寄存器： 基址寄存器 、界限寄存器。 使程序 装载期间 无需 重定位。当一个进程运行时 程序的起始地址 装载到 基址寄存器中，程序的长度 装载到 界限寄存器中。每次 进程访问内存，取一条指令、读写一个内存地址时， cpu硬件会将 地址发送到内存总线前， 自动把基址寄存器的数值 +  进程发出的地址上。 同时检查 结果是否在 界限寄存器 范围内。 超过了 界限 则捕获错误。&lt;/p&gt;

&lt;p&gt;基址寄存器 16384， 界限寄存器： 17000  指令 jmp 28 被翻译成 jmp  16412&lt;/p&gt;

&lt;p&gt;此方法可以简单实现存储器抽象。&lt;/p&gt;

&lt;p&gt;内存管理技术：&lt;/p&gt;

&lt;p&gt;1）交换技术：  两种处理内存超载的方法： 最简单的策略 是 交换技术， 即 将把进程完整的调入内存中，使该进程运行一段时间，然后把他 存回磁盘。 虚拟内存： 使程序只有一部分被调入内存的情况下 运行。&lt;/p&gt;

&lt;p&gt;空闲内存管理：&lt;/p&gt;

&lt;p&gt;动态分配内存时， 操作系统 必须 对其进行管理 ，一般有两种办法： 1） 位图 2） 空闲去链表，&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用位图的存储管理： 内存可能被划分为 几个字 或 几千字的分配单位，每个分配单位 对应于图中的一位。0表示空闲，1表示占用。分配单元的大小是一个重要的设计元素， 分配单元小 则位图大，位图占用的内存空间的比例就会提升。分配单元大 ，则位图小。但进程分配的存在更多的浪费。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;位图主要的问题是：  再决定分配一个 大小 为k个分配单元的进程调入内存时，存储管理器 必须搜索位图 已找到 k个连续的0串，因为 位图中该串可能跨越字的边界。 查找位图中 制定长度的连续0串是一个耗时操作。&lt;/p&gt;

&lt;p&gt;使用链表的存储管理：&lt;/p&gt;

&lt;p&gt;维护一个记录已分配内存段和空闲内存段的链表。&lt;/p&gt;

&lt;p&gt;有几种方法  为 新创建的进程 分配内存：&lt;br /&gt;
1） 首次匹配算法：  沿着链表进行搜索， 直到找到一个足够大的空闲区间。 除非空闲空间与 需要分配的空间大小一样，否则将该空闲区分为两部分，一部分供进程使用，一部分 成为新的空闲区。 速度非常快的算法，因为它可以尽可能少的搜索节点。&lt;/p&gt;

&lt;p&gt;2） 最佳适配算法：搜索整个链表， 找到能够容纳新进程的最小空闲区间。该算法试图找到最接近实际需要的空闲区。&lt;br /&gt;
其他算法： 快速适配法&lt;/p&gt;

&lt;p&gt;虚拟内存： 虽然 基址寄存器 + 界限寄存器 能够很好的 应对 内存抽象管理要求，但是  随着软件的膨胀 需要运行的程序往往大到内存 无法容纳， 而系统必须能够支撑起多个程序的同时运行， 即使内存仅仅 可以满足其中一个的程序需要。&lt;/p&gt;

&lt;p&gt;总体来看 程序对内存的需求 超过了实际内存大小。  交换技术 并不是一个很好的方案，因为 一个典型的SATA磁盘的峰值传输效率 只有几百兆每秒，这意味着需要好几秒 才能换入 一个1GB的程序。&lt;/p&gt;

&lt;p&gt;该类问题 很早就出现了，初始的简单解决办法 成为 ：覆盖 （overlay） 把程序分割成为许多片段， 程序开始，将覆盖管理模块转入内存，该管理模块立即 装并运行程序的片段0，在系统需要时 将由 管理模块 程序片段1装载到内存中，覆盖管理模块允许多个 片段  同时在内存中，部分在磁盘上，在需要时候动态的换入换出。&lt;/p&gt;

&lt;p&gt;虽然 有管理模块来负责 换入换出操作，但是 依然需要程序员将程序 分割成多个片段，最后人们将这种费事重复性的操作 交给了计算机去做。&lt;/p&gt;

&lt;p&gt;采用的这个方法 称为虚拟内存。 基本思想为： 每个程序拥有自己的地址空间，这个空间被分割成为多个块，每一块称作一页或页面（page）， 每一页 都有连续的地址范围，这些页面被影射到 物理内存， 但并不需要所有页面都在内存中才能够运行程序， 当程序引用到一部分在物理内存中的地址空间时，  由硬件执行必要的映射， 当程序引用到 一部分不在物理内存中的地址空间时， 由 操作系统负责将缺失的部分程序装入到 物理内存并重新执行失败的指令。&lt;/p&gt;

&lt;p&gt;分页： 大部分 虚拟内存使用的技术。&lt;/p&gt;

&lt;p&gt;Mov reg, 1000  将内存地址 1000 的内存复制到 reg中，其中的1000地址 可以由 索引、基址寄存器、段寄存器 或其他方式产生。&lt;/p&gt;

&lt;p&gt;由程序产生的地址称为虚拟地址（virtual address） 它们构成了一个虚拟地址空间。 没有虚拟内存的计算机上，虚拟地址 就是 内存物理地址， 使用虚拟内存的情况下， 虚拟地址 并不直接传送到内存总线上，而是 先传到  内存管理单元（memory  management unit MMU） mmu将虚拟地址映射称为 物理内存地址 ，在传送到物理内存地址总线上。&lt;/p&gt;

&lt;p&gt;虚拟地址 按照固定大小划分为称为 页面 （page）的单元， 物理内存中对应的为 页框（page frame）  RAM与磁盘之间的交换总是以整个页面为单元进行的。&lt;/p&gt;

&lt;p&gt;转换：&lt;/p&gt;

&lt;p&gt;程序执行 指令 MOV REG， 0 将虚拟地址 0 送到MMU， MMU 看到u虚拟地址落在页面0，根据映射结果 该页面对应得是页框是2（8192-12287）  因此 MMU把地址变换为8192 并将地址 8192发送到总线上，内存对MMU一无所知，他知道看到一个读写地址 8192 的请求并执行它，MMU从而有效的将 程序虚拟地址空间0-4095 映射到 8192-12287。&lt;/p&gt;

&lt;p&gt;通过且当的设定 MMU，可以讲16个虚拟页面，映射到 8个页表框中的任何一个。但是这并没有解决 虚拟地址空间大于物理内存空间的问题。   当程序需要访问 第9个页面的时候，会发生什么情况呢？ MMU注意到 第9个页面并没有被影射到内存中， 于是使cpu陷入到操作系统 ，称为缺页中断 或者缺页错误。 操作系统找到一个很少使用的页框 并把他的内容写入到磁盘中，随后把需要访问的页面 读到刚才 回收的页框中，修改映射关系，然后重新执行引起缺页中断的指令。&lt;/p&gt;

&lt;p&gt;缺页处理的具体步骤为：&lt;br /&gt;
1） 如果操作系统决定放弃页框1， 将虚拟页面8 装入物理地址4096，然后对MMU做两处修改，&lt;br /&gt;
1） 将虚拟页面1 标记为未映射，以便 以后任何对于 虚拟地址 4096-8191的访问 都会导致 缺页中断&lt;br /&gt;
2） 将虚拟页面8的标记页框为1，因此在重新执行引起缺页中断的指令时，能够将虚拟地址 32780 映射为物理地址 4108&lt;/p&gt;

&lt;p&gt;MMU内部结构如下：&lt;/p&gt;

&lt;p&gt;可以将16位的虚拟地址，划分为 4位的 页号 + 12 位的便宜里那个。 4位的页号 可以表达16个 页面 ， 12位的偏移地址 可以为一页内部的全部4096个字节编码。&lt;br /&gt;
使用页号作为页表的索引。以找出对于该虚拟页面的页框号， 如果 不在 则 引发一个缺页中断， 如果在 ，则 将在页表中查找到的 页框号 + 虚拟地址的偏移量  构成一个 物理地址。 输出到物理内存地址总线上。&lt;/p&gt;

&lt;p&gt;页表：&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Rust Async</title>
    <link rel="alternate" href="http://geniousbar.github.io/2021/05/09/rust-async/"/>
    <id>http://geniousbar.github.io/2021/05/09/rust-async/</id>
    <published>2021-05-09T00:00:00+00:00</published>
    <updated>2021-06-23T09:29:55+00:00</updated>
    <summary type="html">&lt;h3 id="并发模型"&gt;并发模型&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
&lt;strong&gt;OS threads&lt;/strong&gt;:  1) 不需要改变代码编码模式  2) 线程间 同步困难  3) 性能开销比较大， 线程池 可以一定程度上减少这些开销， 但是并不能够支撑起 庞大的IO 工作&lt;/li&gt;
  &lt;li&gt;
&lt;strong&gt;事件驱动模型(Event-driven)&lt;/strong&gt;： 结合callback, 性能非常好，但是 导致 非线性的控制流， Data flow and error propagation is often hard to follow.&lt;/li&gt;
  &lt;li&gt;
&lt;strong&gt;协程(coroutines)&lt;/strong&gt;： like thread， 不需...&lt;/li&gt;
&lt;/ul&gt;</summary>
    <content type="html">&lt;h3 id="并发模型"&gt;并发模型&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;OS threads&lt;/strong&gt;:  1) 不需要改变代码编码模式  2) 线程间 同步困难  3) 性能开销比较大， 线程池 可以一定程度上减少这些开销， 但是并不能够支撑起 庞大的IO 工作&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;事件驱动模型(Event-driven)&lt;/strong&gt;： 结合callback, 性能非常好，但是 导致 非线性的控制流， Data flow and error propagation is often hard to follow.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;协程(coroutines)&lt;/strong&gt;： like thread， 不需要改变代码编码模式， 共容易使用，提供了包括async 的工具， 支持大量的 任务，但是，其对于 底层的细节抽象 导致 系统编程非常困难&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Actor model&lt;/strong&gt;： 将所有的并行运算抽象为 actor ，其之间的沟通通过 message passing 非常像 分布式系统， 可以实现非常好的性能， 但是留下了许多实际问题 依然没有解决， 比如 flow control and retry logic&lt;/li&gt;
  &lt;li&gt;总结： async 编程 能够让 Rust 此类 &lt;strong&gt;系统编程语言&lt;/strong&gt; 编写出高性能代码，同时具有 thread 与 协程(coroutines) 的优势;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="rust-async-的现状"&gt;Rust Async 的现状&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;Rust Async 的特点：
    &lt;ul&gt;
      &lt;li&gt;Futures是rust 内置的&lt;/li&gt;
      &lt;li&gt;Async是zero-cost 的，即： 并不需要 在堆上 进行内存分配 和动态分发，即高性能（you can use async without heap allocations and dynamic dispatch, which is great for performance!）&lt;/li&gt;
      &lt;li&gt;没有内建的runtime， 由社区提供&lt;/li&gt;
      &lt;li&gt;可以支持 单线程 或者 多线程 的runtime&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Rust Async vs threads 的比较
    &lt;ul&gt;
      &lt;li&gt;threads： 适合少量的工作， 不用改变代码结构， 生成 线程 与线程之间的切换 是非常昂贵的， 线程池可以一定程度上减轻此类开销&lt;/li&gt;
      &lt;li&gt;Async： 可以显著的减少CPU 与 内存的开销， 尤其是在对于 大量IO任务时。 比thread 模式能够处理更多的任务，因为 该模型，使用 较少的 threads 处理大量的 task。 但是其二进制的文件会比传统的非异步编码的代码要大。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;异步编程的支持：
    &lt;ul&gt;
      &lt;li&gt;标准库： 提供 Future trait 抽象&lt;/li&gt;
      &lt;li&gt;Rust Compiler： 提供对  async/await 语法的支持&lt;/li&gt;
      &lt;li&gt;futures crate： 提供 工具类型， macros， 以及 方法&lt;/li&gt;
      &lt;li&gt;async runtime： 提供对 async code, IO, task spawn 的运行。有 TOkio, async-std&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;编译 与  debug：
    &lt;ul&gt;
      &lt;li&gt;为了支持异步代码：  rust 需要使用异常一些更复杂的 语言特性， 比如lifetimes pinning。 你可能将经常遇到此类错误&lt;/li&gt;
      &lt;li&gt;runtime errors： 编译器 遇到 async function，将产生一个 状态机（state machine）， Stack traces 将包含状态机内部的详细信息， 对比 Rust 同步代码, runtime errors debug 要复杂不少&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;New failure modes： 异步Rust中可能会出现一些新颖的故障模式，例如，如果您从异步上下文中调用了阻止函数，或者您错误地实现了Future特性。 这样的错误可以无声地通过编译器，有时甚至可以通过单元测试。 本书旨在为您提供对底层概念的深刻理解，可以帮助您避免这些陷阱。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="rust-异步编程-简单示例"&gt;Rust 异步编程 简单示例：&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;async/.await 语法： rust compiler 为 async 声明的block转换成一个实现了 Future trait 的 state machine。 await 等待Future的完成， 但是将thread yield 出去以允许其他Future执行&lt;/li&gt;
  &lt;li&gt;block_on: 阻塞当前 thread，直到 future 完成， 不允许 thread 运行其他的 Future&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="c"&gt;// Cargo.toml&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;dependencies&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;futures&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"0.3"&lt;/span&gt;

&lt;span class="c"&gt;// main.rs&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;futures&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nn"&gt;executor&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;block_on&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;hello_world&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"hello, world!"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;future&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;hello_world&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c"&gt;// Nothing is printed&lt;/span&gt;
  &lt;span class="nf"&gt;block_on&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;future&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c"&gt;// `future` is run and "hello, world!" is printed&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="c"&gt;// await 示例： &lt;/span&gt;

&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;learn_song&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Song&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* ... */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;sing_song&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;song&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Song&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* ... */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;dance&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* ... */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="c"&gt;// 这里使用 block_on 导致  learn_song  aing_song dance 的 串行执行, 因为block_on 将阻塞thread，直到 Future 执行完成&lt;/span&gt;
&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;song&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;block_on&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;learn_song&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
  &lt;span class="nf"&gt;block_on&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sing_song&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;song&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
  &lt;span class="nf"&gt;block_on&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;dance&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;



&lt;span class="c"&gt;// 这里使用await 可以将 thread 让出，以便  Future f2 执行。 join 能够同时执行 两个 future&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;learn_and_sing&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="c"&gt;// Wait until the song has been learned before singing it.&lt;/span&gt;
  &lt;span class="c"&gt;// We use `.await` here rather than `block_on` to prevent blocking the // thread, which makes it possible to `dance` at the same time.&lt;/span&gt;
  &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;song&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;learn_song&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="nf"&gt;sing_song&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;song&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;async_main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;f1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;learn_and_sing&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; 
  &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;f2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;dance&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
  &lt;span class="c"&gt;// `join!` is like `.await` but can wait for multiple futures concurrently. &lt;/span&gt;
  &lt;span class="c"&gt;// If we're temporarily blocked in the `learn_and_sing` future, the `dance`&lt;/span&gt;
  &lt;span class="c"&gt;// future will take over the current thread. If `dance` becomes blocked, &lt;/span&gt;
  &lt;span class="c"&gt;// `learn_and_sing` can take back over. If both futures are blocked, then &lt;/span&gt;
  &lt;span class="c"&gt;// `async_main` is blocked and will yield to the executor. &lt;/span&gt;
  &lt;span class="nn"&gt;futures&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;join!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;f2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;



&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
  &lt;span class="nf"&gt;block_on&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async_main&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="future-trait-rust-异步编程的-核心点-future-即是一个可以产生-value-的异步计算抽象简单的-future-可以如下"&gt;Future Trait: rust 异步编程的 核心点， Future 即是一个可以产生 value 的异步计算抽象。简单的 Future 可以如下：&lt;/h4&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="k"&gt;trait&lt;/span&gt; &lt;span class="n"&gt;SimpleFuture&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;poll&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;wake&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Poll&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nn"&gt;Self&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;Poll&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nf"&gt;Ready&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="n"&gt;Pending&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;pub&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;SocketRead&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;'a&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nv"&gt;'a&lt;/span&gt; &lt;span class="n"&gt;Socket&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;SimpleFuture&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;SocketRead&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;'_&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="n"&gt;Output&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;Vec&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;u8&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;poll&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;wake&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Poll&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nn"&gt;Self&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="py"&gt;.socket&lt;/span&gt;&lt;span class="nf"&gt;.has_data_to_read&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="c"&gt;// The socket has data-- read it into a buffer and return it.&lt;/span&gt;
            &lt;span class="nn"&gt;Poll&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;Ready&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="py"&gt;.socket&lt;/span&gt;&lt;span class="nf"&gt;.read_buf&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="c"&gt;// The socket does not yet have data. //&lt;/span&gt;
            &lt;span class="c"&gt;// Arrange for `wake` to be called once data is available.&lt;/span&gt;
            &lt;span class="c"&gt;// When data becomes available, `wake` will be called, and the&lt;/span&gt;
            &lt;span class="c"&gt;// user of this `Future` will know to call `poll` again and&lt;/span&gt;
            &lt;span class="c"&gt;// receive data. self.socket.set_readable_callback(wake); Poll::Pending&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;poll func 为Future 接口， 如果future 完成  则返回 Poll::Ready(result), 否则 返回 Poll::Pending, 并在当 Future 可以取得进一步进展时 调用 wake() 函数， 当wake 函数调用， Future 的 executor 将再次 在future 调用poll 以取得进展&lt;/li&gt;
  &lt;li&gt;wake 的作用： 如果没有wake 则 executor 将没有任何知识 能够知道 一个特定的future 可以取得进展， 除非周期性的在 每个future 上进行poll。 wake的存在能够让 executor 知道 那个 future 需要被poll&lt;/li&gt;
  &lt;li&gt;Timer Future 的简单实现：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;
&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::{&lt;/span&gt;
    &lt;span class="nn"&gt;future&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Future&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nn"&gt;pin&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Pin&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nn"&gt;sync&lt;/span&gt;&lt;span class="p"&gt;::{&lt;/span&gt;&lt;span class="nb"&gt;Arc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Mutex&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="nn"&gt;task&lt;/span&gt;&lt;span class="p"&gt;::{&lt;/span&gt;&lt;span class="n"&gt;Context&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Poll&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Waker&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="n"&gt;thread&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nn"&gt;time&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Duration&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;


&lt;span class="k"&gt;pub&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;TimerFuture&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;shared_state&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;Arc&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Mutex&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;SharedState&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c"&gt;// 需要使用锁， 跨 thread 更改变量&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c"&gt;/// Shared state between the future and the waiting thread&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;SharedState&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c"&gt;/// Whether or not the sleep time has elapsed&lt;/span&gt;
    &lt;span class="n"&gt;completed&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;bool&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

    &lt;span class="c"&gt;// The waker for the task that `TimerFuture` is running on.&lt;/span&gt;
    &lt;span class="c"&gt;// The thread can use this after setting `completed = true` to tell&lt;/span&gt;
    &lt;span class="c"&gt;// `TimerFuture`'s task to wake up, see that `completed = true`, and&lt;/span&gt;
    &lt;span class="c"&gt;// move forward.&lt;/span&gt;
    &lt;span class="n"&gt;waker&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;Option&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Waker&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;Future&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;TimerFuture&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="n"&gt;Output&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="c"&gt;// 需要注意 这里面 self参数类型为Pin&amp;lt;&amp;amp;mut Self&amp;gt; 以及cx 为Context&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;poll&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Pin&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;Self&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cx&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;Context&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;'_&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Poll&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nn"&gt;Self&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c"&gt;// Look at the shared state to see if the timer has already completed.&lt;/span&gt;
        &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;shared_state&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="py"&gt;.shared_state&lt;/span&gt;&lt;span class="nf"&gt;.lock&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="nf"&gt;.unwrap&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;shared_state&lt;/span&gt;&lt;span class="py"&gt;.completed&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nn"&gt;Poll&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;Ready&lt;/span&gt;&lt;span class="p"&gt;(())&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="c"&gt;// Set waker so that the thread can wake up the current task&lt;/span&gt;
            &lt;span class="c"&gt;// when the timer has completed, ensuring that the future is polled&lt;/span&gt;
            &lt;span class="c"&gt;// again and sees that `completed = true`.&lt;/span&gt;
            &lt;span class="c"&gt;//&lt;/span&gt;
            &lt;span class="c"&gt;// It's tempting to do this once rather than repeatedly cloning&lt;/span&gt;
            &lt;span class="c"&gt;// the waker each time. However, the `TimerFuture` can move between&lt;/span&gt;
            &lt;span class="c"&gt;// tasks on the executor, which could cause a stale waker pointing&lt;/span&gt;
            &lt;span class="c"&gt;// to the wrong task, preventing `TimerFuture` from waking up&lt;/span&gt;
            &lt;span class="c"&gt;// correctly.&lt;/span&gt;
            &lt;span class="c"&gt;//&lt;/span&gt;
            &lt;span class="c"&gt;// N.B. it's possible to check for this using the `Waker::will_wake`&lt;/span&gt;
            &lt;span class="c"&gt;// function, but we omit that here to keep things simple.&lt;/span&gt;
            &lt;span class="n"&gt;shared_state&lt;/span&gt;&lt;span class="py"&gt;.waker&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;Some&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cx&lt;/span&gt;&lt;span class="nf"&gt;.waker&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="nf"&gt;.clone&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
            &lt;span class="nn"&gt;Poll&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Pending&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;TimerFuture&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c"&gt;// Create a new `TimerFuture` which will complete after the provided&lt;/span&gt;
    &lt;span class="c"&gt;// timeout.&lt;/span&gt;
    &lt;span class="k"&gt;pub&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;duration&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Duration&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Self&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;shared_state&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;Arc&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nn"&gt;Mutex&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SharedState&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;completed&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;false&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;waker&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="p"&gt;}));&lt;/span&gt;

        &lt;span class="c"&gt;// Spawn the new thread&lt;/span&gt;
        &lt;span class="c"&gt;// 这个 Future 实现的 比较奇怪，直接 使用另一个 thread 中sleep 进行 timer 的实现, 所以 在上面 TimerFuture 中的 Sharedstate 需要进行 Mutex 进行保护&lt;/span&gt;
        &lt;span class="c"&gt;// 这也是后面提到 Runtime  需要提供 Timer的 重要原因吧&lt;/span&gt;
        &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;thread_shared_state&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;shared_state&lt;/span&gt;&lt;span class="nf"&gt;.clone&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="nn"&gt;thread&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;spawn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;move&lt;/span&gt; &lt;span class="p"&gt;||&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nn"&gt;thread&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;duration&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;shared_state&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;thread_shared_state&lt;/span&gt;&lt;span class="nf"&gt;.lock&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="nf"&gt;.unwrap&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="c"&gt;// Signal that the timer has completed and wake up the last&lt;/span&gt;
            &lt;span class="c"&gt;// task on which the future was polled, if one exists.&lt;/span&gt;
            &lt;span class="n"&gt;shared_state&lt;/span&gt;&lt;span class="py"&gt;.completed&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="nf"&gt;Some&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;waker&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;shared_state&lt;/span&gt;&lt;span class="py"&gt;.waker&lt;/span&gt;&lt;span class="nf"&gt;.take&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;waker&lt;/span&gt;&lt;span class="nf"&gt;.wake&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;});&lt;/span&gt;

        &lt;span class="n"&gt;TimerFuture&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;shared_state&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="c"&gt;// Executor 的实现：&lt;/span&gt;

&lt;span class="c"&gt;/// Task executor that receives tasks off of a channel and runs them.&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Executor&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;ready_queue&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Receiver&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;Arc&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Task&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c"&gt;/// `Spawner` spawns new futures onto the task channel.&lt;/span&gt;
&lt;span class="nd"&gt;#[derive(Clone)]&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Spawner&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;task_sender&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;SyncSender&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;Arc&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Task&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c"&gt;/// A future that can reschedule itself to be polled by an `Executor`.&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Task&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c"&gt;/// In-progress future that should be pushed to completion.&lt;/span&gt;
    &lt;span class="c"&gt;///&lt;/span&gt;
    &lt;span class="c"&gt;/// The `Mutex` is not necessary for correctness, since we only have&lt;/span&gt;
    &lt;span class="c"&gt;/// one thread executing tasks at once. However, Rust isn't smart&lt;/span&gt;
    &lt;span class="c"&gt;/// enough to know that `future` is only mutated from one thread,&lt;/span&gt;
    &lt;span class="c"&gt;/// so we need to use the `Mutex` to prove thread-safety. A production&lt;/span&gt;
    &lt;span class="c"&gt;/// executor would not need this, and could use `UnsafeCell` instead.&lt;/span&gt;
    &lt;span class="n"&gt;future&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Mutex&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;Option&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;BoxFuture&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;'static&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

    &lt;span class="c"&gt;/// Handle to place the task itself back onto the task queue.&lt;/span&gt;
    &lt;span class="n"&gt;task_sender&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;SyncSender&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;Arc&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Task&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;new_executor_and_spawner&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Executor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Spawner&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c"&gt;// Maximum number of tasks to allow queueing in the channel at once.&lt;/span&gt;
    &lt;span class="c"&gt;// This is just to make `sync_channel` happy, and wouldn't be present in&lt;/span&gt;
    &lt;span class="c"&gt;// a real executor.&lt;/span&gt;
    &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;MAX_QUEUED_TASKS&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;usize&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10_000&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;task_sender&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ready_queue&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;sync_channel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MAX_QUEUED_TASKS&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Executor&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;ready_queue&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="n"&gt;Spawner&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;task_sender&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;Spawner&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;spawn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;future&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;Future&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Output&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nv"&gt;'static&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;Send&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;future&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;future&lt;/span&gt;&lt;span class="nf"&gt;.boxed&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;task&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;Arc&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Task&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;future&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nn"&gt;Mutex&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;Some&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;future&lt;/span&gt;&lt;span class="p"&gt;)),&lt;/span&gt;
            &lt;span class="n"&gt;task_sender&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="py"&gt;.task_sender&lt;/span&gt;&lt;span class="nf"&gt;.clone&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;
        &lt;span class="p"&gt;});&lt;/span&gt;
        &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="py"&gt;.task_sender&lt;/span&gt;&lt;span class="nf"&gt;.send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;.expect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"too many tasks queued"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;ArcWake&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;Task&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;wake_by_ref&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arc_self&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nb"&gt;Arc&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Self&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c"&gt;// Implement `wake` by sending this task back onto the task channel&lt;/span&gt;
        &lt;span class="c"&gt;// so that it will be polled again by the executor.&lt;/span&gt;
        &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;cloned&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arc_self&lt;/span&gt;&lt;span class="nf"&gt;.clone&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;arc_self&lt;/span&gt;
            &lt;span class="py"&gt;.task_sender&lt;/span&gt;
            &lt;span class="nf"&gt;.send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cloned&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="nf"&gt;.expect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"too many tasks queued"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="n"&gt;Executor&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;run&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="nf"&gt;Ok&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;&lt;span class="py"&gt;.ready_queue&lt;/span&gt;&lt;span class="nf"&gt;.recv&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="c"&gt;// Take the future, and if it has not yet completed (is still Some),&lt;/span&gt;
            &lt;span class="c"&gt;// poll it in an attempt to complete it.&lt;/span&gt;
            &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;future_slot&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="py"&gt;.future&lt;/span&gt;&lt;span class="nf"&gt;.lock&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="nf"&gt;.unwrap&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="nf"&gt;Some&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;future&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;future_slot&lt;/span&gt;&lt;span class="nf"&gt;.take&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="c"&gt;// Create a `LocalWaker` from the task itself&lt;/span&gt;
                &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;waker&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;waker_ref&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="nn"&gt;Context&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;from_waker&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;*&lt;/span&gt;&lt;span class="n"&gt;waker&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="c"&gt;// `BoxFuture&amp;lt;T&amp;gt;` is a type alias for&lt;/span&gt;
                &lt;span class="c"&gt;// `Pin&amp;lt;Box&amp;lt;dyn Future&amp;lt;Output = T&amp;gt; + Send + 'static&amp;gt;&amp;gt;`.&lt;/span&gt;
                &lt;span class="c"&gt;// We can get a `Pin&amp;lt;&amp;amp;mut dyn Future + Send + 'static&amp;gt;`&lt;/span&gt;
                &lt;span class="c"&gt;// from it by calling the `Pin::as_mut` method.&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="nn"&gt;Poll&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Pending&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;future&lt;/span&gt;&lt;span class="nf"&gt;.as_mut&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="nf"&gt;.poll&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                    &lt;span class="c"&gt;// We're not done processing the future, so put it&lt;/span&gt;
                    &lt;span class="c"&gt;// back in its task to be run again in the future.&lt;/span&gt;
                    &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;future_slot&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;Some&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;future&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;



&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;executor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;spawner&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;new_executor_and_spawner&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="c"&gt;// Spawn a task to print before and after waiting on a timer.&lt;/span&gt;
    &lt;span class="n"&gt;spawner&lt;/span&gt;&lt;span class="nf"&gt;.spawn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"howdy!"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="c"&gt;// Wait for our timer future to complete after two seconds.&lt;/span&gt;
        &lt;span class="nn"&gt;TimerFuture&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nn"&gt;Duration&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"done!"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;});&lt;/span&gt;

    &lt;span class="c"&gt;// Drop the spawner so that our executor knows it is finished and won't&lt;/span&gt;
    &lt;span class="c"&gt;// receive more incoming tasks to run.&lt;/span&gt;
    &lt;span class="k"&gt;drop&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;spawner&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c"&gt;// Run the executor until the task queue is empty.&lt;/span&gt;
    &lt;span class="c"&gt;// This will print "howdy!", pause, and then print "done!".&lt;/span&gt;
    &lt;span class="n"&gt;executor&lt;/span&gt;&lt;span class="nf"&gt;.run&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="executors-and-system-io"&gt;Executors and System IO:&lt;/h3&gt;
&lt;h4 id="executor-谁来调用-future-的poll-方法-答案是-future-executor-executor-调用一大堆-futures-的poll方法-以便让future-取得进展-当-future-能够-取得进一步进展时通过调用wake-方法-以便-executor-再次执行-future"&gt;Executor： 谁来调用 Future 的poll 方法？ 答案是 Future Executor。 executor 调用一大堆 Futures 的poll方法 以便让Future 取得进展， 当 Future 能够 取得进一步进展时，通过调用wake 方法， 以便 executor 再次执行 Future。&lt;/h4&gt;
&lt;h4 id="system-io-在上面的-simplefuture-代码中-谁来执行-wake-方法呢-selfsocketset_readable_callbackwake-又是如何触发的呢-答案是-epoll-的io多路复用可以让我们-使用thread-对-socket文件进行-监听循环检测-io-事件"&gt;System IO: 在上面的 SimpleFuture 代码中， 谁来执行 wake 方法呢？ self.socket.set_readable_callback(wake) 又是如何触发的呢？ 答案是 epoll 的IO多路复用，可以让我们 使用thread 对 socket文件进行 监听，循环检测 IO 事件。&lt;/h4&gt;
&lt;h4 id="executors-单线程-与-多线程"&gt;Executors: 单线程 与 多线程&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;多线程执行程序可同时在多个任务上取得进展。 对于具有许多任务的工作负载，它可以极大地加快执行速度，但是在任务之间同步数据通常会更加昂贵。 在单线程和多线程运行时之间进行选择时，建议测量应用程序的性能。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;任务可以在创建任务的线程上运行，也可以在单独的线程上运行。&lt;br /&gt;
异步运行时通常提供将任务生成到单独线程上的功能。 即使任务在单独的线程上执行，它们也应该是非阻塞的。 为了在多线程执行器上安排任务，它们也必须是Send。 一些运行时提供了 生成并发送任务 的功能，以确保每个任务都在生成它的线程上执行。 它们还可以提供用于将阻塞任务生成到专用线程上的功能，这对于从其他库运行阻塞同步代码很有用。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;async Lifetimes， async move， 因为异步的存在， 导致 async { /../ } 可以 传递给变量 并进行 .await， 导致  block {} 中 的包含的变量，以及 引用 需要与 Future 存在的周期相同。 async move 允许 like normal block 一样， 允许将 block中变量 移入到 block中， 并跟随 Future 一样的生命周期&lt;/li&gt;
  &lt;li&gt;当使用 多线程的 executor时， Future 可能在 threads 中进行移动，所以 在async block中的 any variables 必须同样能够在 threads中进行移动， 意味着  任何没有实现 &lt;a href="https://doc.rust-lang.org/std/marker/trait.Send.html"&gt;Send trait&lt;/a&gt;、reference type 没有 实现 &lt;a href="https://doc.rust-lang.org/std/marker/trait.Sync.html"&gt;Sync trait&lt;/a&gt; 的都不能够 在async block中使用。&lt;/li&gt;
  &lt;li&gt;锁：不能使用 传统的 non-futures-aware lock, 因为Future 可能在threads 中进行移动 从而导致死锁，应该使用  futures::lock 中的Mutex&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="工具以及-trait"&gt;工具以及 trait:&lt;/h3&gt;

&lt;h4 id="pin"&gt;Pin:&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Pin： maker， 保证 对象 implement !Unpin 永远不会被移动。因为比较难以理解， 下面为英文：&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;The Pin type wraps pointer types, guaranteeing that the values behind the pointer won’t be moved. For example, Pin&amp;lt;&amp;amp;mut T&amp;gt; , Pin&amp;lt;&amp;amp;T&amp;gt; , Pin&amp;lt;Box&lt;T&gt;&amp;gt; all guarantee that T won't be moved if T: !Unpin .
Most types don't have a problem being moved. These types implement a trait called Unpin . Pointers to Unpin types can be freely placed into or taken out of Pin . For example, u8 is
Unpin , so Pin&amp;lt;&amp;amp;mut u8&amp;gt; behaves just like a normal &amp;amp;mut u8 .
However, types that can't be moved after they're pinned have a marker called !Unpin .
Futures created by async/await is an example of this.&lt;/T&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Pinning: 大概的以为是 是一个编译器 标记（marker） 用来保证 impl  !Unpin 的对象 在内存中 不被移动，即pin:&lt;/li&gt;
  &lt;li&gt;Pin Summary:
    &lt;ol&gt;
      &lt;li&gt;If T: Unpin (which is the default), then Pin&amp;lt;’a, T&amp;gt; is entirely equivalent to &amp;amp;’a mut T. in other words: Unpin means it’s OK for this type to be moved even when pinned, so Pin will have no effect on such a type.&lt;/li&gt;
      &lt;li&gt;Getting a &amp;amp;mut T to a pinned T requires unsafe if T: !Unpin.&lt;/li&gt;
      &lt;li&gt;Most standard library types implement Unpin. The same goes for most “normal” types you encounter in Rust. A Future generated by async/await is an exception to this rule.&lt;/li&gt;
      &lt;li&gt;You can add a !Unpin bound on a type on nightly with a feature flag, or by adding std::marker::PhantomPinned to your type on stable.&lt;/li&gt;
      &lt;li&gt;You can either pin data to the stack or to the heap.&lt;/li&gt;
      &lt;li&gt;Pinning a !Unpin object to the stack requires unsafe&lt;/li&gt;
      &lt;li&gt;Pinning a !Unpin object to the heap does not require unsafe. There is a shortcut for doing this using Box::pin.&lt;/li&gt;
      &lt;li&gt;For pinned data where T: !Unpin you have to maintain the invariant that its memory will not get invalidated or repurposed from the moment it gets pinned until when drop is called. This is an important part of the pin contract.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="stream-trait-like-future-但是能够-在完成之前-传递多个数值-like-iterator即-返回对象为---polloptionselfitem--stream-可以实现并行函数有-for_each_concurrent-try_for_each_concurrent"&gt;Stream Trait: like Future 但是能够 在完成之前 传递多个数值 like Iterator，即： 返回对象为   Poll&amp;lt;Option&amp;lt;Self::Item&amp;gt; &amp;gt;。 stream 可以实现并行，函数有 for_each_concurrent， try_for_each_concurrent&lt;/h4&gt;
&lt;h4 id="多个future-同时执行"&gt;多个Future 同时执行:&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;工具方法:
    &lt;ol&gt;
      &lt;li&gt;join! : waits for futures to all complete&lt;/li&gt;
      &lt;li&gt;select! : waits for one of several futures to complete&lt;/li&gt;
      &lt;li&gt;Spawning: creates a top-level task which ambiently runs a future to completion&lt;/li&gt;
      &lt;li&gt;FuturesUnordered : a group of futures which yields the result of each subfuture&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;join! 示例代码: try_join!  在其中一个 Future 返回错误的时候，立即返回&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="c"&gt;// book 与 music 串行执行， music 等待book 执行完 才能执行&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;get_book_and_music&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Book&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Music&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;book&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;get_book&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;music&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;get_music&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;book&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;music&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c"&gt;// 错误的尝试，将 book 与 music 并行执行&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;get_book_and_music&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Book&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Music&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;book_future&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;get_book&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;music_future&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;get_music&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;book_future&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;music_future&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c"&gt;// 真正的并行执行&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;get_book_and_music&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Book&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Music&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;book_fut&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;get_book&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;music_fut&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;get_music&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="nd"&gt;join!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;book_fut&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;music_fut&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;select! 示例代码： select macro 的使用风格比较奇怪， 需要在深入理解一下&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;
&lt;span class="nd"&gt;#![allow(unused)]&lt;/span&gt;
&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;futures&lt;/span&gt;&lt;span class="p"&gt;::{&lt;/span&gt;
    &lt;span class="nn"&gt;future&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;FutureExt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c"&gt;// for `.fuse()`&lt;/span&gt;
    &lt;span class="n"&gt;pin_mut&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;select&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;task_one&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* ... */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;task_two&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* ... */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;race_tasks&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;task_one&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="nf"&gt;.fuse&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;t2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;task_two&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="nf"&gt;.fuse&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="nd"&gt;pin_mut!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;t2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="nd"&gt;select!&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"task one completed first"&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;t2&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"task two completed first"&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;Unpin ： Unpin 是必须的， 因为在 select 中 数值是使用mut reference，而非take ownership 的， 没有完成的future 依然可以在后面的select 中使用。&lt;/li&gt;
  &lt;li&gt;FusedFuture: 同样是必须的， 因为 select 中 必须 not poll 已经完成的Future， FusedFuture 实现了 跟踪 Future 是否已经完成，&lt;/li&gt;
  &lt;li&gt;这两个 trait 能够让 select 在 loop block 中使用。 如下代码示例：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="nd"&gt;#![allow(unused)]&lt;/span&gt;
&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;futures&lt;/span&gt;&lt;span class="p"&gt;::{&lt;/span&gt;&lt;span class="n"&gt;future&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;select&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;count&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;a_fut&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;future&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;ready&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;b_fut&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;future&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;ready&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;mut&lt;/span&gt; &lt;span class="n"&gt;total&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nd"&gt;select!&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a_fut&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;total&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b_fut&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;total&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;complete&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;default&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nd"&gt;unreachable!&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="c"&gt;// never runs (futures are ready, then complete)&lt;/span&gt;
        &lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nd"&gt;assert_eq!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;total&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="async-blocks-编码存在的一些问题"&gt;Async Blocks 编码存在的一些问题:&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;？: 在 async block 中  使用 ? 需要  额外的 声明 Error type 来帮助 编译器确定 错误类型， 如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="c"&gt;// 产生 编译错误&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;fut&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nf"&gt;Ok&lt;/span&gt;&lt;span class="p"&gt;(())&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="c"&gt;// 正确的解决方法&lt;/span&gt;
&lt;span class="nd"&gt;#![allow(unused)]&lt;/span&gt;
&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;MyError&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Result&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;MyError&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nf"&gt;Ok&lt;/span&gt;&lt;span class="p"&gt;(())&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Result&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;MyError&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nf"&gt;Ok&lt;/span&gt;&lt;span class="p"&gt;(())&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;fut&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nn"&gt;Ok&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;MyError&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(())&lt;/span&gt; &lt;span class="c"&gt;// &amp;lt;- note the explicit type annotation here&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;Future 是否 能够 send： 有些Future state machines 可以安全地被send, 而有些则不能。 是否Future 可以被 send 取决于是否在.await点上保留 non-send type。 当可能在.await点上保留值时，编译器会尽力进行近似，但是编译器的分析在许多地方都过于保守。 如下面代码示例：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="c"&gt;// 通过编译&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nn"&gt;rc&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nb"&gt;Rc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nd"&gt;#[derive(Default)]&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nf"&gt;NotSend&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;Rc&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nn"&gt;NotSend&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;default&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;require_send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;_&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="nb"&gt;Send&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nf"&gt;require_send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c"&gt;// 产生编译错误&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nn"&gt;rc&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nb"&gt;Rc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nd"&gt;#[derive(Default)]&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nf"&gt;NotSend&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;Rc&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;NotSend&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;default&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;require_send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;_&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="nb"&gt;Send&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="nf"&gt;require_send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="c"&gt;// 正确的解决方法&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nn"&gt;rc&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nb"&gt;Rc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nd"&gt;#[derive(Default)]&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nf"&gt;NotSend&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;Rc&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;NotSend&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;default&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;require_send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;_&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;impl&lt;/span&gt; &lt;span class="nb"&gt;Send&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="nf"&gt;require_send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;递归问题： 因async fn 内部的状态机 实现导致 递归的使用 需要 额外 解决方案. 如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight rust"&gt;&lt;code&gt;&lt;span class="c"&gt;// This function:&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nf"&gt;step_one&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nf"&gt;step_two&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c"&gt;// generates a type like this:&lt;/span&gt;
&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;Foo&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nf"&gt;First&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;StepOne&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="nf"&gt;Second&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;StepTwo&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c"&gt;// So this function:&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;recursive&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nf"&gt;recursive&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nf"&gt;recursive&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c"&gt;// generates a type like this:  因为类型对象存在递归，导致 无法通过编译，需要通过 Box 进行封装 来进行规避&lt;/span&gt;
&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;Recursive&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nf"&gt;First&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Recursive&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="nf"&gt;Second&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Recursive&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c"&gt;// --------------------&lt;/span&gt;
&lt;span class="c"&gt;// In order to allow this, we have to introduce an indirection using Box. Unfortunately, compiler limitations mean that just wrapping the calls to recursive() in Box::pin isn't enough. To make this work, we have to make recursive into a non-async function which returns a .boxed() async block:&lt;/span&gt;

&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;futures&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nn"&gt;future&lt;/span&gt;&lt;span class="p"&gt;::{&lt;/span&gt;&lt;span class="n"&gt;BoxFuture&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;FutureExt&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;recursive&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;BoxFuture&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;'static&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;move&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nf"&gt;recursive&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="nf"&gt;recursive&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;.await&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="nf"&gt;.boxed&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="async-生态"&gt;Async 生态:&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Async Runtimes = reactor + one or more executors&lt;/li&gt;
  &lt;li&gt;Reactors： 提供对于 外部事件 比如: 异步IO 进程内通讯 timer 等 简单的订阅方式 (provide subscription mechanisms for external events, like async I/O, interprocess communication, and timers. In an async runtime, subscribers are typically futures representing low-level I/O operations)&lt;/li&gt;
  &lt;li&gt;Executors: Future 具体的执行者， 因为只有 thread ，process 才能够执行代码，所以Future等 抽象事物，依然需要具体的executor  (handle the scheduling and execution of tasks. They keep track of running and suspended tasks, poll futures to completion, and wake tasks when they can make progress)&lt;/li&gt;
  &lt;li&gt;Futures Crate： 包含 async code 有用的trait 与 函数， 包含trait有： Stream, Sink, AsyncRead, AsyncWrite  , 工具有： join! select! etc （这些可能将成为 标准库 的一部分） future 实现了自己的 executor， 但是并没有 reactor。 所以一个常见的组合是： Future 的工具 + 其他crate 的executor&lt;/li&gt;
  &lt;li&gt;常见的 Async runtime:
    &lt;ul&gt;
      &lt;li&gt;Tokio: A popular async ecosystem with HTTP, gRPC, and tracing frameworks. async-std: A crate that provides asynchronous counterparts to standard library components.&lt;/li&gt;
      &lt;li&gt;smol: A small, simplified async runtime. Provides the Async trait that can be used to wrap structs like*  UnixStream or TcpListener&lt;/li&gt;
      &lt;li&gt;fuchsia-async: An executor for use in the Fuchsia OS.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="相关资料"&gt;相关资料：&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Event-driven programming（事件驱动 模型， rust future 就是此类模型 ） https://en.wikipedia.org/wiki/Event-driven_programming&lt;/li&gt;
  &lt;li&gt;event driven  同样存在多种形式， refactor  pattern &amp;amp; https://en.wikipedia.org/wiki/Proactor_pattern&lt;/li&gt;
  &lt;li&gt;相关资料： 有： http://www.alan-g.me.uk/l2p/tutevent.htm http://www.dre.vanderbilt.edu/~schmidt/PDF/reactor-siemens.pdf  https://altushost-swe.dl.sourceforge.net/project/eventdrivenpgm/event_driven_programming.pdf&lt;/li&gt;
  &lt;li&gt;在rust 的 async program 中： 主要有  rust async 的语法支持， 社区提供的 future 模型， 以及 对应 runtime executor 实现，则有： async-std, tokio， smol， fuchsia-async。 future 的抽象只有一种，而对应的 runtime executor 因为 与 操作系统 生态有关，则有多种的实现&lt;/li&gt;
  &lt;li&gt;Coroutines （协程， 即是语言在 OS上 对于 轻量线程的抽象， 在 《现代操作系统》 中 有详细介绍过此类模型，但是因为其 一些根源性问题， 对于系统信号、调度等并不友好）&lt;/li&gt;
  &lt;li&gt;The actor model: 将单元划分为 actor， 使用消息进行 通讯， Erlang 是典型的 actor并发代表&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>Mysql</title>
    <link rel="alternate" href="http://geniousbar.github.io/2021/04/11/mysql-relearn/"/>
    <id>http://geniousbar.github.io/2021/04/11/mysql-relearn/</id>
    <published>2021-04-11T00:00:00+00:00</published>
    <updated>2021-04-22T02:50:09+00:00</updated>
    <summary type="html">&lt;h2 id="mysql-relearn"&gt;Mysql Relearn&lt;/h2&gt;
&lt;h3 id="内存模型"&gt;内存模型：&lt;/h3&gt;
&lt;p&gt;&lt;img src="../../../../images/innodb-change-buffer-5fbd1a84.png" alt="memory-cache"&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Change BUffer： 缓存 不在Buffer pool 中的 索引页的变动， 变动 可能由 insert update， delete 等操作 导致， 将在以后 页面 被加载到 Buffer pool时 被合并
    &lt;ul&gt;
      &lt;li&gt;[image]&lt;/li&gt;
      &lt;li&gt;不同于 聚簇索引， 普通的索引 通常是不唯一的，索引 的插入 删除 更新 通常是 random 的， 随后 将 change Buffer 的合并到 Buffer pool（当...&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    <content type="html">&lt;h2 id="mysql-relearn"&gt;Mysql Relearn&lt;/h2&gt;
&lt;h3 id="内存模型"&gt;内存模型：&lt;/h3&gt;
&lt;p&gt;&lt;img src="../../../../images/innodb-change-buffer-5fbd1a84.png" alt="memory-cache" /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Change BUffer： 缓存 不在Buffer pool 中的 索引页的变动， 变动 可能由 insert update， delete 等操作 导致， 将在以后 页面 被加载到 Buffer pool时 被合并
    &lt;ul&gt;
      &lt;li&gt;[image]&lt;/li&gt;
      &lt;li&gt;不同于 聚簇索引， 普通的索引 通常是不唯一的，索引 的插入 删除 更新 通常是 random 的， 随后 将 change Buffer 的合并到 Buffer pool（当索引页被load 到 buffer pool时） 将减少 随机 的IO 操作。&lt;/li&gt;
      &lt;li&gt;当系统 空闲时，或者缓慢关闭时 会定时的进行清理操作（将cache 写回到 硬盘中） 清理操作 将 一系列的 索引更新 写入到磁盘中 的速度 远高于 每个更新立即写入&lt;/li&gt;
      &lt;li&gt;当存在大量的 受影响的row 和 众多的 索引时， change Buffer 的合并（这里的合并 应该不是简单的与 Buffer pool的合并，而是 合并之后，需要写回到 硬盘中吧） 可能 需要数个小时， 在这期间， IO将显著增加， 导致 磁盘绑定查询（意思是 需要 访问硬盘？） 的速度显著变慢，&lt;/li&gt;
      &lt;li&gt;在Memory中， change buff 是Buffer pool 的一部分， 在disk上， change buff 是 system tablespace 的一部分（当服务器关闭是， 索引的更改change buff 可能保存其中）&lt;/li&gt;
      &lt;li&gt;配置：
        &lt;ol&gt;
          &lt;li&gt;innodb_change_buffering 因为 change buffer 虽然能够 减少IO操作，但 依然占用了 部分的 Buffer pool, 所以提供了此变量 来精确的控制 insert， delete， purge（physical deletion happen in background）， changes(insert + delete) 操作 是否使用  change buffer&lt;/li&gt;
          &lt;li&gt;innodb_change_buffer_max_size 可以控制 buffer的大小，数值为 其所占 Buffer pool 的百分比， 默认为 25，最高 为 50&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;Monitor：
        &lt;ul&gt;
          &lt;li&gt;show engine Innodb status 中的 INSERT BUFFER AND ADAPTIVE HASH INDEX 段&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;  -------------------------------------
  INSERT BUFFER AND ADAPTIVE HASH INDEX
  -------------------------------------
  Ibuf: size 1, free list len 0, seg size 2, 0 merges
  merged operations:
   insert 0, delete mark 0, delete 0
  discarded operations:
   insert 0, delete mark 0, delete 0
  Hash table size 4425293, used cells 32, node heap has 1 buffer(s)
  13577.57 hash searches/s, 202.47 non-hash searches/s

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;ul&gt;
      &lt;li&gt;数据库方式： information_schema 中 相关的table 可以查询到相关信息 &lt;a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-change-buffer.html#innodb-change-buffer-maximum-size"&gt;url&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="自适应hash-索引"&gt;自适应Hash 索引：&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Hash 索引： 通过 索引 的前缀 构建 hash 的 key， 通过监控到的搜索， 如果InnoDB 认为可以 让查询从 简历Hash索引中 收益， 他会自动构建。&lt;/li&gt;
  &lt;li&gt;在一些负载比较繁重的情况下， 导致 监控 争用 Hash索引 的开销 并不能够 使其 受益，则可以选择关闭 该选项， 以为很难判定 这种情况的出现， 则 应该使用 准确的基准测试 之后来决定&lt;/li&gt;
  &lt;li&gt;自适应 Hash索引： 已经实现了 分区(partition)， 每个索引都绑定到特定的分区（并不知道有啥用,这里要讲啥?） 分区数量由 innodb_adaptive_hash_index_parts  控制，在 8…512 范围内&lt;/li&gt;
  &lt;li&gt;可以 在 show engine innodb  status 中的  SEMAPHORES 段 来查看 btr0sea.c 的rw 锁 争用情况， 可以考虑增加 Hash索引的分区数值，或者关闭 该功能&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="log-buffer"&gt;Log Buffer:&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Log buffer 用来缓存 将要写入 disk 的 log file的数据，&lt;/li&gt;
  &lt;li&gt;配置：
    &lt;ol&gt;
      &lt;li&gt;innodb_log_buffer_size  用来控制Buffer 的大小， default is 16MB, 定期 刷新到 disk, 一个大 的 log buffer 可以让一个 da的 transaction 在commit 提交前 不需要将 redo log 刷新到disk 中。&lt;/li&gt;
      &lt;li&gt;innodb_flush_log_at_trx_commit  控制 log buffer 而如何 同步到disk中&lt;/li&gt;
      &lt;li&gt;innodb_flush_log_at_timeout： 控制log buffer 同步的频率&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="innodb-磁盘数据结构"&gt;InnoDB 磁盘数据结构：&lt;/h3&gt;

&lt;h4 id="table"&gt;Table&lt;/h4&gt;
&lt;h4 id="创建表-create-table"&gt;创建表： create table,&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt;   &lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;TABLE&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="nb"&gt;INT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="nb"&gt;CHAR&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="k"&gt;PRIMARY&lt;/span&gt; &lt;span class="k"&gt;KEY&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="n"&gt;ENGINE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
  &lt;li&gt;Innodb 默认 table 的存储方式 为一个 文件 一个table， 配置 innodb_file_per_table 用来打开、关闭 此行为
    &lt;h4 id="row-format"&gt;Row format：&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;row 的格式，决定了 InnoDB 行 在物理上的disk 的存储，支持 4中format， 每个格式 都有对应的存储特性。格式有：
    &lt;ul&gt;
      &lt;li&gt;redundant： 冗余&lt;/li&gt;
      &lt;li&gt;compact： 紧凑&lt;/li&gt;
      &lt;li&gt;dynamic： 动态&lt;/li&gt;
      &lt;li&gt;compressed： 压缩&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;row 格式控制： 默认为 dynamic， 变量 innodb_default_row_format 可以控制 默认的row 存储格式， create table, alter table 也同样可以控制 row 格式&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="primary-key"&gt;Primary key&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;建议 为每个table 创建自己的 primary key, 选取 primary key 的column 规则为：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;重要查询所使用&lt;/li&gt;
      &lt;li&gt;永远不会存储空&lt;/li&gt;
      &lt;li&gt;永远不会存储重复数值&lt;/li&gt;
      &lt;li&gt;插入之后 很少更新的数值&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;如果没有 明显的选择的话， 则 可以创建一个 type 为number auto-increment 的column 作为主建&lt;/li&gt;
  &lt;li&gt;尽管在没有定义主键的情况下表可以正常工作，但是主键涉及性能的许多方面，并且对于任何大型或经常使用的表都是至关重要的设计方面。 建议始终在CREATE TABLE语句中指定主键&lt;/li&gt;
  &lt;li&gt;查看table的相关的属性：
    &lt;ol&gt;
      &lt;li&gt;SHOW TABLE STATUS&lt;/li&gt;
    &lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt;   &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;SHOW&lt;/span&gt; &lt;span class="k"&gt;TABLE&lt;/span&gt; &lt;span class="n"&gt;STATUS&lt;/span&gt; &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt; &lt;span class="k"&gt;LIKE&lt;/span&gt; &lt;span class="s1"&gt;'t%'&lt;/span&gt; &lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="k"&gt;G&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="o"&gt;***************************&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="k"&gt;row&lt;/span&gt; &lt;span class="o"&gt;***************************&lt;/span&gt;
              &lt;span class="n"&gt;Name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt;
            &lt;span class="n"&gt;Engine&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt;
           &lt;span class="k"&gt;Version&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
        &lt;span class="n"&gt;Row_format&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;Dynamic&lt;/span&gt;
              &lt;span class="k"&gt;Rows&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="n"&gt;Avg_row_length&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
       &lt;span class="n"&gt;Data_length&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;16384&lt;/span&gt;
   &lt;span class="n"&gt;Max_data_length&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
      &lt;span class="n"&gt;Index_length&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
         &lt;span class="n"&gt;Data_free&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="n"&gt;Auto_increment&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;NULL&lt;/span&gt;
       &lt;span class="n"&gt;Create_time&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2021&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;02&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;18&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;18&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;28&lt;/span&gt;
       &lt;span class="n"&gt;Update_time&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;NULL&lt;/span&gt;
        &lt;span class="n"&gt;Check_time&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;NULL&lt;/span&gt;
         &lt;span class="k"&gt;Collation&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;utf8mb4_0900_ai_ci&lt;/span&gt;
          &lt;span class="n"&gt;Checksum&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;NULL&lt;/span&gt;
    &lt;span class="n"&gt;Create_options&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; 
           &lt;span class="k"&gt;Comment&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;从 INFORMATION_SCHEMA.INNODB_TABLES 中获取信息:&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt;
  &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;INFORMATION_SCHEMA&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;INNODB_TABLES&lt;/span&gt; &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;NAME&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'test/t1'&lt;/span&gt; &lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="k"&gt;G&lt;/span&gt;
 &lt;span class="o"&gt;***************************&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="k"&gt;row&lt;/span&gt; &lt;span class="o"&gt;***************************&lt;/span&gt;
      &lt;span class="n"&gt;TABLE_ID&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1144&lt;/span&gt;
          &lt;span class="n"&gt;NAME&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;t1&lt;/span&gt;
          &lt;span class="n"&gt;FLAG&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;33&lt;/span&gt;
        &lt;span class="n"&gt;N_COLS&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;
         &lt;span class="k"&gt;SPACE&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;
    &lt;span class="n"&gt;ROW_FORMAT&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;Dynamic&lt;/span&gt;
 &lt;span class="n"&gt;ZIP_PAGE_SIZE&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="n"&gt;SPACE_TYPE&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Single&lt;/span&gt;
  &lt;span class="n"&gt;INSTANT_COLS&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="在其他目录中存储-数据即-外部创建表"&gt;在其他目录中存储 数据：（即 外部创建表）&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Using the DATA DIRECTORY Clause： 在 create table syntax 中 可以 添加  DATA DIRECTORY 来制定数据的存储目录&lt;/li&gt;
  &lt;li&gt;Using TABLESPACE Clause: 在create table syntax 中添加 TABLESPACE = innodb_file_per_table 配合 data dictory 使用&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;示例：&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt;&lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;USE&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;Database&lt;/span&gt; &lt;span class="n"&gt;changed&lt;/span&gt;

&lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;TABLE&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c1&lt;/span&gt; &lt;span class="nb"&gt;INT&lt;/span&gt; &lt;span class="k"&gt;PRIMARY&lt;/span&gt; &lt;span class="k"&gt;KEY&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;DATA&lt;/span&gt; &lt;span class="n"&gt;DIRECTORY&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'/external/directory'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="n"&gt;MySQL&lt;/span&gt; &lt;span class="n"&gt;creates&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="k"&gt;table&lt;/span&gt;&lt;span class="s1"&gt;'s data file in a schema directory
# under the external directory

shell&amp;gt; cd /external/directory/test
shell&amp;gt; ls
t1.ibd
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="导入-innodb-表"&gt;导入 InnoDB 表：&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;可能应用的场景有：
    &lt;ol&gt;
      &lt;li&gt;利用 线上 的数据做报表，而不像 增加额外的负担 在线上 2） 复制数据给 replica server 3） 从backup 上恢复 表 4）&lt;/li&gt;
      &lt;li&gt;比import a dump file 更快的 移动数据 的方法&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;先决条件
    &lt;ol&gt;
      &lt;li&gt;innodb_file_per_table  变量 必须是打开的&lt;/li&gt;
      &lt;li&gt;source server &amp;amp; desitnation server  的 page size of tablespace 配置必须相同，  innodb_page_size  变量控制&lt;/li&gt;
      &lt;li&gt;foreign key 的关系， 如果 导出表 有 foreign key，  在 执行 discard talbespace 之前， 则 需要 foreign_key_checks 需要关闭， 还需要导出所有外键 关联的表，因为ALTER TABLE … IMPORT TABLESPACE不会对导入的数据实施外键约束。 为此 需要 停止更新 相关的表， 提交所有 transaction， 获取表 的 S锁，然后执行 export 操作&lt;/li&gt;
      &lt;li&gt;导出导入 的mysql version  必须兼容&lt;/li&gt;
      &lt;li&gt;导出导入server 的 data directory 必须 相同, 导致 schema mismatch error&lt;/li&gt;
      &lt;li&gt;导出导入server 的 ROW_FORMAT 需要相同, 导致 schema mismatch errorgg&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;示例
    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;在 destination server 上 创建表， schema 需要与 source server 表的 syntax 相同&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt; &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;USE&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;TABLE&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c1&lt;/span&gt; &lt;span class="nb"&gt;INT&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;ENGINE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;INNODB&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;      &lt;/li&gt;
      &lt;li&gt;在destination server 上， 执行 discard tablespace 命令
        &lt;ul&gt;
          &lt;li&gt;table 将会 上 X 锁&lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;tablespace 与table 分离&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt; &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;ALTER&lt;/span&gt; &lt;span class="k"&gt;TABLE&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="n"&gt;DISCARD&lt;/span&gt; &lt;span class="n"&gt;TABLESPACE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;在source server 上 执行 flush tables … for export， 执行之后 只能允许 读表请求， 将产生 .cfg, .ibd文件
        &lt;ul&gt;
          &lt;li&gt;导出的table 将会上S锁， 并将更新 flush 到disk&lt;/li&gt;
          &lt;li&gt;停止 purge thread&lt;/li&gt;
          &lt;li&gt;Dirty page sync to disk&lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;table metadata write to .cfg file&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt; &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;USE&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;FLUSH&lt;/span&gt; &lt;span class="n"&gt;TABLES&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="k"&gt;FOR&lt;/span&gt; &lt;span class="n"&gt;EXPORT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

 &lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="err"&gt;可能看到的&lt;/span&gt; &lt;span class="err"&gt;输出为&lt;/span&gt;
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Note&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Sync&lt;/span&gt; &lt;span class="k"&gt;to&lt;/span&gt; &lt;span class="n"&gt;disk&lt;/span&gt; &lt;span class="k"&gt;of&lt;/span&gt; &lt;span class="s1"&gt;'"test"."t1"'&lt;/span&gt; &lt;span class="n"&gt;started&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Note&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Stopping&lt;/span&gt; &lt;span class="n"&gt;purge&lt;/span&gt;
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Note&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Writing&lt;/span&gt; &lt;span class="k"&gt;table&lt;/span&gt; &lt;span class="n"&gt;metadata&lt;/span&gt; &lt;span class="k"&gt;to&lt;/span&gt; &lt;span class="s1"&gt;'./test/t1.cfg'&lt;/span&gt;
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Note&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;Table&lt;/span&gt; &lt;span class="s1"&gt;'"test"."t1"'&lt;/span&gt; &lt;span class="n"&gt;flushed&lt;/span&gt; &lt;span class="k"&gt;to&lt;/span&gt; &lt;span class="n"&gt;disk&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;复制数据：&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt; &lt;span class="n"&gt;shell&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;scp&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="k"&gt;to&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;datadir&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="n"&gt;ibd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;cfg&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt; &lt;span class="n"&gt;destination&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="k"&gt;to&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;datadir&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;      &lt;/li&gt;
      &lt;li&gt;在 source server 上执行 unlock tables
        &lt;ul&gt;
          &lt;li&gt;删除 .cfg 文件&lt;/li&gt;
          &lt;li&gt;table上的S锁 被释放&lt;/li&gt;
          &lt;li&gt;purge thread 被重启&lt;/li&gt;
        &lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt;  &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;USE&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;UNLOCK&lt;/span&gt; &lt;span class="n"&gt;TABLES&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="err"&gt;可能的输出&lt;/span&gt;&lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="err"&gt;为&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Note&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Deleting&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;meta&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;data&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="s1"&gt;'./test/t1.cfg'&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Note&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Resuming&lt;/span&gt; &lt;span class="n"&gt;purge&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
      &lt;li&gt;在 destination server 上import tablespace
        &lt;ul&gt;
          &lt;li&gt;每个 tablespace page 会被 校验是否正确&lt;/li&gt;
          &lt;li&gt;The space ID and log sequence numbers (LSNs) on each page are updated.&lt;/li&gt;
          &lt;li&gt;Flags are validated and LSN updated for the header page.&lt;/li&gt;
          &lt;li&gt;Btree pages are updated.&lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;The page state is set to dirty so that it is written to disk.&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt; &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;USE&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;ALTER&lt;/span&gt; &lt;span class="k"&gt;TABLE&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="n"&gt;IMPORT&lt;/span&gt; &lt;span class="n"&gt;TABLESPACE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

 &lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="err"&gt;可能输出&lt;/span&gt; &lt;span class="n"&gt;log&lt;/span&gt; &lt;span class="err"&gt;为：&lt;/span&gt;

 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Note&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Importing&lt;/span&gt; &lt;span class="n"&gt;tablespace&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="k"&gt;table&lt;/span&gt; &lt;span class="s1"&gt;'test/t1'&lt;/span&gt; &lt;span class="n"&gt;that&lt;/span&gt; &lt;span class="n"&gt;was&lt;/span&gt; &lt;span class="n"&gt;exported&lt;/span&gt;
 &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="k"&gt;host&lt;/span&gt; &lt;span class="s1"&gt;'host_name'&lt;/span&gt;
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Note&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Phase&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="k"&gt;Update&lt;/span&gt; &lt;span class="k"&gt;all&lt;/span&gt; &lt;span class="n"&gt;pages&lt;/span&gt;
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Note&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Sync&lt;/span&gt; &lt;span class="k"&gt;to&lt;/span&gt; &lt;span class="n"&gt;disk&lt;/span&gt;
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Note&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Sync&lt;/span&gt; &lt;span class="k"&gt;to&lt;/span&gt; &lt;span class="n"&gt;disk&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;done&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Note&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Phase&lt;/span&gt; &lt;span class="n"&gt;III&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;Flush&lt;/span&gt; &lt;span class="n"&gt;changes&lt;/span&gt; &lt;span class="k"&gt;to&lt;/span&gt; &lt;span class="n"&gt;disk&lt;/span&gt;
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Note&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Phase&lt;/span&gt; &lt;span class="n"&gt;IV&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;Flush&lt;/span&gt; &lt;span class="n"&gt;complete&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="auto_increment-在innodb-中的处理方式"&gt;AUTO_INCREMENT 在InnoDB 中的处理方式&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在表中 添加 AUTO_INCREMENT 字段， 是InnoDB 提高性能 与 稳定性的一种方式， 为了有效利用 AUTO_INCREMENT ， 必须将 AUTO_INCREMENT 字段设为索引， 以便 执行 select max(col) 以获得 最大值，&lt;/li&gt;
  &lt;li&gt;AUTO_INCREMENT 锁的 集中方式，其中的区别 以及 每种对 replic 的影响&lt;/li&gt;
  &lt;li&gt;数据插入的集中方式： 所有生成 新row的 语句， 包括 insert, insert .. select, replace, replace .. select, load data 包含
    &lt;ol&gt;
      &lt;li&gt;simple-insert: 可以预先知道 插入 行数 的 insert 语句，比如简单的单行， 多行 insert&lt;/li&gt;
      &lt;li&gt;bulk-insert: 插入行数未知  的语句，比如： insert .. select ,replace .. select, load data 语句&lt;/li&gt;
      &lt;li&gt;mixed-mode insert: 指定 auto_increment 数值的 insert 语句 或者  INSERT … ON DUPLICATE KEY UPDATE 等复杂的 语句，这些语句可能不会使用 auto_increment 分配的数值 比如：&lt;/li&gt;
    &lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt;   &lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'a'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'b'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'c'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'d'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
  &lt;li&gt;innodb_autoinc_lock_mode 可能的模式有： 0 (traditional), 1(consecutive), 2(interleaved) Mysql 8.0 默认为 interleaved 模式， 8.0 之前 默认为 consecutive 模式
    &lt;h5 id="lock-mode-的变化-反映了-mysql-从--基于语句-replica-转变到-基于-row-replica-的转变-基于语句复制-需要-一个-consecutive-的lock-mode--来确保-auto-increment-数值的-可以预测-可重复-性-因为-在replic时候-同步的是-sql-执行语句只有这样才能够保证-replic与-master-server-的数据一致性-而基于-row-replica-对于-语句的执行顺序并不敏感"&gt;lock mode 的变化 反映了 Mysql 从  基于语句 replica 转变到 基于 row replica 的转变。 基于语句复制 需要 一个 consecutive 的lock mode  来确保 auto-increment 数值的 可以预测 可重复 性 （因为 在replic时候， 同步的是 sql 执行语句，只有这样才能够保证 replic与 master server 的数据一致性）， 而基于 row replica 对于 语句的执行顺序并不敏感&lt;/h5&gt;
    &lt;ol&gt;
      &lt;li&gt;traditional: 该种模式下， 所有的inert like 语句 斗殴需要获取 一个特殊的 table-level  auto-inc lock， 该锁 需要把持到 语句的结束（非 transaction 结束） 来 保证 auto-increment 数值 的可重复性 与 可预见性， 同时保证了  auto-increment 字段数值的 连续性。 假设在 基于 语句 的复制模式中， 这意味着 sql语句 replic 到 replica server上的时候，将产生 与 source server上 完全相同的数值。 如果 让 多个 insert 语句 交替执行，则将导致 结果 不可重现， 即 replica server 与 source server数据 并不相同。 下面示例：&lt;/li&gt;
    &lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt;  &lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;TABLE&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;c1&lt;/span&gt; &lt;span class="nb"&gt;INT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;11&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;NOT&lt;/span&gt; &lt;span class="k"&gt;NULL&lt;/span&gt; &lt;span class="n"&gt;AUTO_INCREMENT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;c2&lt;/span&gt; &lt;span class="nb"&gt;VARCHAR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;DEFAULT&lt;/span&gt; &lt;span class="k"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="k"&gt;PRIMARY&lt;/span&gt; &lt;span class="k"&gt;KEY&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;ENGINE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="c1"&gt;----------&lt;/span&gt;
  &lt;span class="n"&gt;Tx1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt; &lt;span class="k"&gt;rows&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;another&lt;/span&gt; &lt;span class="k"&gt;table&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;
  &lt;span class="n"&gt;Tx2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'xxx'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;


  &lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt; &lt;span class="err"&gt;并不能知道&lt;/span&gt; &lt;span class="n"&gt;Tx1&lt;/span&gt; &lt;span class="err"&gt;中到底有多少数据&lt;/span&gt; &lt;span class="err"&gt;需要插入，&lt;/span&gt; &lt;span class="err"&gt;使用&lt;/span&gt; &lt;span class="err"&gt;一个&lt;/span&gt; &lt;span class="k"&gt;table&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;level&lt;/span&gt; &lt;span class="err"&gt;的&lt;/span&gt;&lt;span class="k"&gt;lock&lt;/span&gt; &lt;span class="err"&gt;，可以&lt;/span&gt; &lt;span class="err"&gt;使&lt;/span&gt; &lt;span class="err"&gt;在同一时间&lt;/span&gt; &lt;span class="err"&gt;只执行&lt;/span&gt; &lt;span class="err"&gt;一个&lt;/span&gt; &lt;span class="k"&gt;sql&lt;/span&gt; &lt;span class="err"&gt;语句。&lt;/span&gt; &lt;span class="err"&gt;所以&lt;/span&gt; &lt;span class="err"&gt;当在&lt;/span&gt; &lt;span class="n"&gt;replica&lt;/span&gt; &lt;span class="n"&gt;server&lt;/span&gt; &lt;span class="err"&gt;上&lt;/span&gt; &lt;span class="err"&gt;使用&lt;/span&gt; &lt;span class="err"&gt;基于&lt;/span&gt;  &lt;span class="nb"&gt;binary&lt;/span&gt; &lt;span class="n"&gt;log&lt;/span&gt; &lt;span class="err"&gt;重放&lt;/span&gt; &lt;span class="k"&gt;sql&lt;/span&gt; &lt;span class="err"&gt;语句时候，无论是&lt;/span&gt;&lt;span class="n"&gt;Tx1&lt;/span&gt; &lt;span class="err"&gt;与&lt;/span&gt; &lt;span class="n"&gt;Tx2&lt;/span&gt; &lt;span class="err"&gt;谁先执行，&lt;/span&gt; &lt;span class="err"&gt;都会产生相同的结果。当然&lt;/span&gt; &lt;span class="err"&gt;一个&lt;/span&gt;&lt;span class="k"&gt;table&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;level&lt;/span&gt;&lt;span class="err"&gt;的&lt;/span&gt;&lt;span class="k"&gt;lock&lt;/span&gt; &lt;span class="err"&gt;必然会限制&lt;/span&gt; &lt;span class="err"&gt;并发&lt;/span&gt; &lt;span class="err"&gt;与&lt;/span&gt; &lt;span class="err"&gt;可伸缩性&lt;/span&gt; &lt;span class="err"&gt;的发挥&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;consecutive mode: 在该种模式下，
    &lt;ul&gt;
      &lt;li&gt;“bulk inserts” 使用特殊的 AUTO-INC table level lock 并一直把持到 语句的最后。该类规则将 应用到 所有 的 insert ..select, replace .. select, load data 的语句中，同一时间 只有 一个把持 AUTO-INC 的语句 能够执行，&lt;/li&gt;
      &lt;li&gt;“simple inserts”: 因为可以预先知道插入的数量， 可以使用 特殊的 轻量级 X锁（只在auto-increment 分配阶段 保持），来避免  table-level AUTO-INC 锁。如果存在 其他的 transaction 持有 table-level 的 AUTO-INC lock 则 需要等待 该 transaction 完成&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;”mixed-mode inserts“: 分配的数值增量 要大于 插入的行数， 自动分配的数值 也是连续的。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;简单的说， consecutive lock mode 下， 在 保证 基于语句的 replic 正确下，提高了 并发与可伸缩性， 完美兼容 tranditional mode&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;interleaved mode: 不使用 table-level auto-inc lock， 而且可以同时执行多个insert 语句， 是最快的，可伸缩 的 lock 模式， 但是对于 基于语句 复制的 server来说 并不安全。 在这种锁定模式下，保证auto-increment column 是唯一的，并且在所有同时执行的“类似INSERT”语句中单调递增。 但是，由于多个语句可以同时生成数字（也就是说，在语句之间交错分配数字），因此为任何给定语句插入的行生成的值可能不是连续的。即： 在 simple insert 语句中， auto-increment 中的column是连续的， mixed-mode insert 与 bulk insert 中 可能存在 gap&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;auto-increment gap: 自动增量间隙
    &lt;ul&gt;
      &lt;li&gt;在所有的lock mode下： 如果事务发生回滚，则分配给该 transaction 的数值 就丢失了，该值 将不会被重用，因为表中的 auto-increment column 数值 可能存在 gap&lt;/li&gt;
      &lt;li&gt;批量插入： 在 traditional 或者 consecutive 模式下 任何插入 都不会产生 gap，因为批量插入 都需要获得 table-level 的 auto-inr lock 并保持到 活动结束。 在 interleaved 下，”bulk-insert” 可能产生gap。在 consecutive 或者 interleaved 模式下， 在连续的语句之间可能会出现gap，因为对于批量插入，可能不知道每个语句所需的自动递增值的确切数量，并且可能会高估。( 这里面 是不是描述有问题？ 因为已经在前面说了， tranditional or consecutive 模式下 批量插入并不会产生gap， 这里又说会有， 为什么？ &lt;a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html"&gt;文档在此&lt;/a&gt;)&lt;/li&gt;
      &lt;li&gt;mixed mode insert 在各种不同mode下产生的结果： 最近产生的sequence number  is 100：&lt;/li&gt;
    &lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt;    &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;TABLE&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;c1&lt;/span&gt; &lt;span class="nb"&gt;INT&lt;/span&gt; &lt;span class="nb"&gt;UNSIGNED&lt;/span&gt; &lt;span class="k"&gt;NOT&lt;/span&gt; &lt;span class="k"&gt;NULL&lt;/span&gt; &lt;span class="n"&gt;AUTO_INCREMENT&lt;/span&gt; &lt;span class="k"&gt;PRIMARY&lt;/span&gt; &lt;span class="k"&gt;KEY&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
    &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt; &lt;span class="nb"&gt;CHAR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;ENGINE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;INNODB&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

    &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'a'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'b'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'c'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'d'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="k"&gt;lock&lt;/span&gt; &lt;span class="k"&gt;mode&lt;/span&gt; &lt;span class="err"&gt;为&lt;/span&gt; &lt;span class="n"&gt;traditional&lt;/span&gt; &lt;span class="err"&gt;时候，&lt;/span&gt; &lt;span class="err"&gt;执行插入操作&lt;/span&gt;
    &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt; &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="k"&gt;ORDER&lt;/span&gt; &lt;span class="k"&gt;BY&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
     &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="c1"&gt;-----+------+&lt;/span&gt;
     &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;c1&lt;/span&gt;  &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt;   &lt;span class="o"&gt;|&lt;/span&gt;
     &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="c1"&gt;-----+------+&lt;/span&gt;
     &lt;span class="o"&gt;|&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
     &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;101&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
     &lt;span class="o"&gt;|&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="k"&gt;c&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
     &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;102&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
     &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="c1"&gt;-----+------+&lt;/span&gt;

    &lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="k"&gt;lock&lt;/span&gt; &lt;span class="k"&gt;mode&lt;/span&gt; &lt;span class="err"&gt;为&lt;/span&gt; &lt;span class="n"&gt;consecutive&lt;/span&gt; &lt;span class="err"&gt;时候，&lt;/span&gt; &lt;span class="err"&gt;执行插入操作&lt;/span&gt;   

        &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt; &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="k"&gt;ORDER&lt;/span&gt; &lt;span class="k"&gt;BY&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="c1"&gt;-----+------+&lt;/span&gt;
    &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;c1&lt;/span&gt;  &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt;   &lt;span class="o"&gt;|&lt;/span&gt;
    &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="c1"&gt;-----+------+&lt;/span&gt;
    &lt;span class="o"&gt;|&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
    &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;101&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
    &lt;span class="o"&gt;|&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="k"&gt;c&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
    &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;102&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
    &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="c1"&gt;-----+------+&lt;/span&gt;


    &lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="k"&gt;lock&lt;/span&gt; &lt;span class="k"&gt;mode&lt;/span&gt; &lt;span class="err"&gt;为&lt;/span&gt; &lt;span class="n"&gt;interleaved&lt;/span&gt; &lt;span class="err"&gt;时候，&lt;/span&gt; &lt;span class="err"&gt;执行插入操作&lt;/span&gt; 

     &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt; &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="k"&gt;ORDER&lt;/span&gt; &lt;span class="k"&gt;BY&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
     &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="c1"&gt;-----+------+&lt;/span&gt;
     &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;c1&lt;/span&gt;  &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt;   &lt;span class="o"&gt;|&lt;/span&gt;
     &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="c1"&gt;-----+------+&lt;/span&gt;
     &lt;span class="o"&gt;|&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
     &lt;span class="o"&gt;|&lt;/span&gt;   &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
     &lt;span class="o"&gt;|&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="k"&gt;c&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
     &lt;span class="o"&gt;|&lt;/span&gt;   &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
     &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="c1"&gt;-----+------+    &lt;/span&gt;

     &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="err"&gt;代表&lt;/span&gt; &lt;span class="err"&gt;唯一，但是并不能够确定的数值&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;InnoDB AUTO_INCREMENT Counter 的初始化：&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;mysql 5.7 auto-increment 的counter 存储在 main memory not disk， 所以 当server 重启，将执行  类似  SELECT MAX(ai_col) FROM table_name FOR UPDATE; 来 进行 counter 的初始化&lt;/li&gt;
  &lt;li&gt;MySQL 8.0 之后，行为发生了改变， 目前最大的 auto-increment counter 数值 被写入到了 redo log， server 重启直接从 disk 进行初始化counter&lt;/li&gt;
  &lt;li&gt;所以， 5.7 之后，如果transaction 发生rollback之后，重启server， 会出现rollback的 auto-increment id 被重复使用的问题，而 8.0 的server，则不会 重用 id， 因为 其将 counter 写入到了 disk中&lt;/li&gt;
  &lt;li&gt;auto_increment_increment 设定 auto-increment 的起始点， 默认为1， auto_increment_increment 设置 增量 默认为 1&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="index-没个-innodb-表-都有一个-特殊的index-称为-聚簇索引-用来保存-row-data-通常-聚簇索引-与-primary-key主键-同意-为了-请求获得-更好的性能-理解-innodb-如何使用-聚簇索引-来-进行优化-查询和-dml-操作-是非常重要-的"&gt;index: 没个 InnoDB 表， 都有一个 特殊的index 称为 聚簇索引， 用来保存 row data， 通常 聚簇索引 与 primary key(主键) 同意， 为了 请求获得 更好的性能， 理解 InnoDB 如何使用 聚簇索引 来 进行优化 查询，和 DML 操作 是非常重要 的&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;当你定义table 的Primary key时， InnoDB 用它作为聚簇索引， 如果没有 逻辑上的 唯一 非空 作为主键的情况下， 可以添加一个 auto-increment column 作为 主键&lt;/li&gt;
  &lt;li&gt;如果没有为 table 设定 Primary key（ 主键） 时， InnoDB 使用第一个 Unique &amp;amp; 所有column not null 的index 作为聚簇索引&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果table 没有 Primary key 和 合适的Unique index， 则 InnoDB 生成一个隐藏的名称为 GEN_CLUST_INDEX 的聚簇索引， 该字段为 6-byte 的单调递增&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;聚簇索引 如何 加快查询：
    &lt;blockquote&gt;
      &lt;p&gt;Accessing a row through the clustered index is fast because the index search leads directly to the page that contains the row data. If a table is large, the clustered index architecture often saves a disk I/O operation when compared to storage organizations that store row data using a different page from the index record.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;二级索引 是如何关联到 聚簇索引的： 二级索引定义为： 除 聚簇索引之外的索引&lt;/li&gt;
  &lt;li&gt;二级索引的每个条目（记录） 中 都包含 主键 + 二级索引 包含的column，InnoDB 使用 包含的主键 来 在聚簇索引中进行查找&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;所以 如果聚簇索引 很大的话，将加大 二级索引 的空间占用&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;InnoDB index 的物理结构：&lt;/li&gt;
  &lt;li&gt;InnoDB 所以为B-tree， 索引记录 存储在 B-tree 的 页子 page 中， 默认的 index page 大小为 16KB， 可以通过   innodb_page_size  进行设定&lt;/li&gt;
  &lt;li&gt;当插入 新纪录 到 聚簇索引时， InnoDB 尝试留下  1/16 的 空间 来满足 未来的insert update。 如果数据时按照 顺序插入的，则 index page 将占用 15/16 空间， 如果数据按照 random 顺序插入的，则可能 占用 1/2 - 15/16， innodb_fill_factor  用来控制 空间占用百分比&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果InnoDB 索引页的占用率下降到 MERGE_THRESHOLD(默认为50%) 时， InnoDB 将尝试 收缩索引 以 释放页面&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href="https://dev.mysql.com/doc/refman/8.0/en/sorted-index-builds.html"&gt;Sorted index builde&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="the-system-tablespace"&gt;The System Tablespace:&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;change buffer 在 disk 上存储到 system tablespace, 如果在system tablespace 而非 file-per-table 或者 general tablespace 则 其中还包含 table 和 index data的数据。 8.0之前 还存储 doublewrite buffer， innodb data dictionary， 8.0之后 则分开存储&lt;/li&gt;
  &lt;li&gt;system tablespace 可以有多个 data 文件， 默认的 一个 ibddata1 在 data directory中，&lt;/li&gt;
  &lt;li&gt;tablespace 的数量 与 大小 在 启动项 innodb_data_file_path  进行设定&lt;/li&gt;
  &lt;li&gt;可以进行调整，&lt;a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-system-tablespace.html"&gt;文档在此&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="file-per-table-tablespace-包含-table中的-data-和-index存储在系统中-单个文件中"&gt;File-Per-Table Tablespace: 包含 table中的 data 和 index，存储在系统中 单个文件中&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;innodb_file_per_table 控制开关， 默认为 打开状态。关闭将导致 InnoDB 存储table 数据到 system tablespace 中&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;file-per-table tablespace 在mysql 的 data directory(DATA DIRECTORY 可以在create table syntax 中指定) 目录下 存储 table_name.idb ，下面为示例：&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt;&lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;USE&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;TABLE&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
   &lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="nb"&gt;INT&lt;/span&gt; &lt;span class="k"&gt;PRIMARY&lt;/span&gt; &lt;span class="k"&gt;KEY&lt;/span&gt; &lt;span class="n"&gt;AUTO_INCREMENT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
   &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="nb"&gt;VARCHAR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;ENGINE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;shell&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="k"&gt;to&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="k"&gt;data&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;
&lt;span class="n"&gt;shell&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;ls&lt;/span&gt;
&lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ibd&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/li&gt;
  &lt;li&gt;File-per-table 的优势：
    &lt;ol&gt;
      &lt;li&gt;当 发生drop file， table_name.idb 直接被删掉， 存储空间 可以快速的归还给操作系统&lt;/li&gt;
      &lt;li&gt;Truncate table 表现的比较好&lt;/li&gt;
      &lt;li&gt;可以将 data directory 指定到 单独的设备上&lt;/li&gt;
      &lt;li&gt;创建在 改 tablespace 的table， 支持 dynamic compressed 存储格式(System tablespace 不支持)&lt;/li&gt;
      &lt;li&gt;比较容易恢复和 备份&lt;/li&gt;
      &lt;li&gt;允许单独监控 操作系统的 文件系统&lt;/li&gt;
      &lt;li&gt;减少空间限制&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="general-tablespace-通用-tablespace"&gt;General Tablespace： 通用 Tablespace&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;使用create  tablespace 创建的 共享的 tablespace, 其属性 是 file-per-tablespace 与 system tablespace 的结合。 可以 像 file-per-table tablespace 一样 指定目录存储 general tablespace， 想system tablespace 一样 存储多个 table 在一个文件中， 并可以支持 所有的存储类型。&lt;/li&gt;
  &lt;li&gt;下面是 使用 General Tablespace 的方法：&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;创建&lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt;&lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="n"&gt;TABLESPACE&lt;/span&gt; &lt;span class="n"&gt;tablespace_name&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;ADD&lt;/span&gt; &lt;span class="n"&gt;DATAFILE&lt;/span&gt; &lt;span class="s1"&gt;'file_name'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;FILE_BLOCK_SIZE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ENGINE&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;engine_name&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  

&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="err"&gt;可以&lt;/span&gt; &lt;span class="err"&gt;使用&lt;/span&gt; &lt;span class="err"&gt;变量&lt;/span&gt; &lt;span class="n"&gt;innodb_directories&lt;/span&gt;  &lt;span class="err"&gt;控制&lt;/span&gt; &lt;span class="k"&gt;general&lt;/span&gt; &lt;span class="n"&gt;tablespace&lt;/span&gt; &lt;span class="err"&gt;的存储目录，&lt;/span&gt; 
&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="n"&gt;ts1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;idb&lt;/span&gt; &lt;span class="err"&gt;为相对&lt;/span&gt; &lt;span class="n"&gt;innodb_directories&lt;/span&gt; &lt;span class="err"&gt;目录&lt;/span&gt;
&lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="n"&gt;TABLESPACE&lt;/span&gt; &lt;span class="nv"&gt;`ts1`&lt;/span&gt; &lt;span class="k"&gt;ADD&lt;/span&gt; &lt;span class="n"&gt;DATAFILE&lt;/span&gt; &lt;span class="s1"&gt;'ts1.ibd'&lt;/span&gt; &lt;span class="n"&gt;Engine&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="err"&gt;也可以执行全路径&lt;/span&gt;
&lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="n"&gt;TABLESPACE&lt;/span&gt; &lt;span class="nv"&gt;`ts1`&lt;/span&gt; &lt;span class="k"&gt;ADD&lt;/span&gt; &lt;span class="n"&gt;DATAFILE&lt;/span&gt; &lt;span class="s1"&gt;'/my/tablespace/directory/ts1.ibd'&lt;/span&gt; &lt;span class="n"&gt;Engine&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;使用： 添加table 到 general tablespace:&lt;br /&gt;
  ```sql&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;mysql&amp;gt; CREATE TABLE t1 (c1 INT PRIMARY KEY) TABLESPACE ts1;&lt;br /&gt;
  mysql&amp;gt; ALTER TABLE t2 TABLESPACE ts1;&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;  
   * 使用alter table 可以将table 的tablespace 在各个 tablespace 中进行转换： general tablespace为具体的create tablespace 的名字， file-per-table名称为 innodb_file_per_table， system tablespace 为innodb_system； 如下： 
   
   ```sql
   
   
   ALTER TABLE tbl_name TABLESPACE [=] tablespace_name;
   
   ALTER TABLE tbl_name TABLESPACE [=] innodb_system;
   
   ALTER TABLE tbl_name TABLESPACE [=] innodb_file_per_table;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;重命名tablespace： ALTER TABLESPACE s1 RENAME TO s2;， 重命名操作不能发生在 lock tables， flush tables 作用期间&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;删掉 tablespace： 在tablespace中的所有table 都必须删除掉，才能够成功的 drop tablespace&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt;   
    &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="n"&gt;Use&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;query&lt;/span&gt; &lt;span class="k"&gt;similar&lt;/span&gt; &lt;span class="k"&gt;to&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;following&lt;/span&gt; &lt;span class="k"&gt;to&lt;/span&gt; &lt;span class="n"&gt;identify&lt;/span&gt; &lt;span class="n"&gt;tables&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;general&lt;/span&gt; &lt;span class="n"&gt;tablespace&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; 
     &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NAME&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="n"&gt;space_name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NAME&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="k"&gt;table_name&lt;/span&gt; &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;INFORMATION_SCHEMA&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;INNODB_TABLESPACES&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
          &lt;span class="n"&gt;INFORMATION_SCHEMA&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;INNODB_TABLES&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;SPACE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;SPACE&lt;/span&gt; &lt;span class="k"&gt;AND&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NAME&lt;/span&gt; &lt;span class="k"&gt;LIKE&lt;/span&gt; &lt;span class="s1"&gt;'ts1'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="c1"&gt;------------+------------+&lt;/span&gt;
   &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;space_name&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="k"&gt;table_name&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
   &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="c1"&gt;------------+------------+&lt;/span&gt;
   &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ts1&lt;/span&gt;        &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;t1&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
   &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ts1&lt;/span&gt;        &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;t2&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
   &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ts1&lt;/span&gt;        &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;t3&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
   &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="c1"&gt;------------+------------+&lt;/span&gt;

   &lt;span class="k"&gt;DROP&lt;/span&gt; &lt;span class="n"&gt;TABLESPACE&lt;/span&gt; &lt;span class="n"&gt;ts1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href="https://dev.mysql.com/doc/refman/8.0/en/general-tablespaces.html"&gt;文档在此&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Undo tablespace: 用于保存undo log 的地方， undo log 产生于 insert, update, delete, 等DML 操作， 用于 事务回滚， consistent reading 等&lt;/li&gt;
  &lt;li&gt;默认的undo tablespace 存储在 mysql data dir 中， 可以使用 innodb_undo_directory  进行控制， 默认的 tablespace 文件为  undo_001 , undo_002， 对应的 tablespace名称 为 innodb_undo_001, innodb_undo_002&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-undo-tablespaces.html"&gt;文档在此&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;undo tablespace 作为一个系统使用的tablespace 一样可以允许创建，删除， 但是与 应系统性能表现相关， 比较重要&lt;/li&gt;
&lt;/ul&gt;

</content>
  </entry>
  <entry>
    <title>Redis Client conection</title>
    <link rel="alternate" href="http://geniousbar.github.io/2021/02/21/redis/"/>
    <id>http://geniousbar.github.io/2021/02/21/redis/</id>
    <published>2021-02-21T00:00:00+00:00</published>
    <updated>2021-04-20T08:07:49+00:00</updated>
    <summary type="html">&lt;h2 id="redis-建立链接过程"&gt;Redis 建立链接过程&lt;/h2&gt;
&lt;p&gt;&lt;img src="../../../../images/redis-a3bef2b1.png" alt="redis" /&gt;&lt;/p&gt;
</summary>
    <content type="html">&lt;h2 id="redis-建立链接过程"&gt;Redis 建立链接过程&lt;/h2&gt;
&lt;p&gt;&lt;img src="../../../../images/redis-a3bef2b1.png" alt="redis" /&gt;&lt;/p&gt;
</content>
  </entry>
</feed>
