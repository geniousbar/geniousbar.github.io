<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>日常学习</title>
  <id>http://geniousbar.github.io</id>
  <link href="http://geniousbar.github.io"/>
  <link href="http://geniousbar.github.io/feed.xml" rel="self"/>
  <updated>2017-06-26T08:00:00+08:00</updated>
  <author>
    <name>geniousbar</name>
  </author>
  <entry>
    <title>高性能Mysql</title>
    <link rel="alternate" href="http://geniousbar.github.io/2017/06/26/mysql/"/>
    <id>http://geniousbar.github.io/2017/06/26/mysql/</id>
    <published>2017-06-26T08:00:00+08:00</published>
    <updated>2017-06-28T17:57:00+08:00</updated>
    <summary type="html">&lt;h2 id="mysql-性能优化"&gt;Mysql 性能优化&lt;/h2&gt;

&lt;h3 id="mysql-架构"&gt;mysql 架构&lt;/h3&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;  客户端 ---&amp;gt; 连接/线程处理 ----&amp;gt; 查询缓存
                |               ^
                |               |
                |               |
                |------------&amp;gt; 解析器 ---------&amp;gt; 优化器 ------&amp;gt; 存储引擎
                ( 第一层)      (第...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</summary>
    <content type="html">&lt;h2 id="mysql-性能优化"&gt;Mysql 性能优化&lt;/h2&gt;

&lt;h3 id="mysql-架构"&gt;mysql 架构&lt;/h3&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;  客户端 ---&amp;gt; 连接/线程处理 ----&amp;gt; 查询缓存
                |               ^
                |               |
                |               |
                |------------&amp;gt; 解析器 ---------&amp;gt; 优化器 ------&amp;gt; 存储引擎
                ( 第一层)      (第二层)          (     第三层          )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;使用用户名，密码，安全套接字ssl，方式连接&lt;/li&gt;
  &lt;li&gt;优化执行： 优化器，会解析查询。包括，创建内部解析树，决定表的查询顺序，选择合适的索引等，explaiin，优化器并不关心表的存储引擎，而是隔离！，但是存储引擎对于查询优化是有影响的。优化器会请求存储引擎提供容量、操作的开销信息等，进行优化.&lt;/li&gt;
  &lt;li&gt;并发控制， 读写锁（共享锁、排它锁），锁的粒度（表锁、行级锁、）, 事务： 原子性、一致性、哥理性、持久性，事务日志，通过日志恢复错误的崩溃. 在innoDb中显示的使用所，没有必要，还会严重影响性能。&lt;/li&gt;
  &lt;li&gt;存储引擎： Engine: InnoDB, MyISAM(不支持事务、行级锁) 、Archive, Blackhole, CSV, Memory&lt;/li&gt;
  &lt;li&gt;引擎选择： 除非需要用到某些InnoDB不具备的特性，并且没有其他办法可以代替，否则都应该优先选择InnoDB引擎，例如使用全文索引，有限使用InnoDB+Sphinx，而不是支持全文所以的MyISAM, 考虑因素： 事务、备份、崩溃恢复&lt;/li&gt;
  &lt;li&gt;大数据量： InnoDB 数据量在 3-5TB，10TB以上，需要建立数据仓库， Infobright是比较成功的mysql数据仓库反感， TokuDB也可以&lt;/li&gt;
  &lt;li&gt;存储引擎的转换： alter table, 导出导入， 创建与查询， create table innodb_table like myisam_table; alter table innodb_table ENGINE=InnoDB; insert into innodb_table select * from myisam_table&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="基准测试"&gt;基准测试&lt;/h3&gt;
&lt;p&gt;todo&lt;/p&gt;

&lt;h3 id="服务器性能剖析"&gt;服务器性能剖析&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;通常为三个问题： 确认服务器是否达到了性能最佳的状态、找出某条语句为什么执行不够快、诊断造成用户卡顿的某些间歇性 性能故障&lt;/li&gt;
  &lt;li&gt;性能剖析， 测量服务器的时间花费在那里&lt;/li&gt;
  &lt;li&gt;性能定义为： 完成某件任务所需要的时间而不是资源来测量性能。数据库服务器的目的是执行sql，所以关注的任务是查询或者语句。一个陷阱是：资源是用来消耗并且用来工作的。所以有时候消耗更多的资源能够加快查询速度，查询的响应速度更能够提现升级后的性能是不是更好。&lt;/li&gt;
  &lt;li&gt;所以如果目标是降低响应时间，那么就需要先搞清楚时间话费在哪里，无法测量就无法有效的优化，所以第一步是： 测量时间花费在什么地方。&lt;/li&gt;
  &lt;li&gt;完成任务所需要的时间： 执行时间+等待时间。 而等待时间则的测量比较复杂，可能由其他系统间接导致。基于执行时间的分析研究的是什么任务的执行时间最长，等待的分析：判断任务在什么地方被阻塞的时间最长.&lt;/li&gt;
  &lt;li&gt;性能剖析： 1： 测量任务所花费的时间， 2：统计排序， 性能剖析报告会列出所有的任务列表，列出，任务名、任务的执行时间，任务的消耗时间，占比等。&lt;/li&gt;
  &lt;li&gt;show status, 大部分结果只是一个计数器， FLUSH STATUS; select * from users; SHOW STATUS WHERE Variable_name LIKE ‘Handler%’ OR Variable_name LIKE ‘Create%’&lt;/li&gt;
  &lt;li&gt;慢查询日志:&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="schema-与数据类型优化"&gt;Schema 与数据类型优化&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;schema 原则： 1： 更小的通常更好（更小的通常意味着占用更小的磁盘、内存）， 2：简单就好, 简单的数据类型耗费更少的CPU周期，（应该是用mysql内奸的数据类型而不是字符串保存日期和时间， 另一个则是使用整行，保存ip）, 3:  避免NULL，通常最好指定列为NOT NULL，查询中包含null对于mysql来说更难优化，尽量不要在NUll的列上建立索引。&lt;/li&gt;
  &lt;li&gt;varchar（变长） char (固定长度), 最好的策略是，只分配真正需要的空间&lt;/li&gt;
  &lt;li&gt;使用枚举代替 字符串类型，枚举类型的数据结构非常紧凑，可以节省大量的空间。&lt;br /&gt;
    * 缺点: 不能够随意改变，对于未来会改变的字符串，不太适合。不建议选用。&lt;br /&gt;
    * 排序可以使用FIELD函数进行。&lt;/li&gt;
  &lt;li&gt;日期和时间类型： DATETIME， 与时区无关，使用8个字节的存储空间。 TIMESTAMP： 格林尼治标准时间， 处理时区，使用4个字节。默认not NULL&lt;/li&gt;
  &lt;li&gt;选择标志符, 标识符可能与其他值进行比较，例如关联操作，标识列可能在另在的表中作为外键使用。所以为标识列选择数据类型时，应该选择跟关联表中对应的列一样的类型。所以不进需要卡绿存储类型，还需要考虑mysql对这种类型怎样执行计算和比较。在可满足的范围的需求，并且预留未来增长空间的前提下，应该选用最小的数据类型，&lt;br /&gt;
    * 整数类型： 通常是最好的选择&lt;br /&gt;
    * 字符串类型： 如果可能，应该避免使用字符串作为标识列，1，消耗空间，比数字类型慢，2.对于md5， sha1,uuid类型产生的字符串，会导致insert以及select语句变得慢。因为插入值会随机的写入到索引的不同位置，所以insert慢，select慢，是因为逻辑上相邻的行，会分不在磁盘、内存的不同地方，随机值导致缓存的效果也会很差，因为会导致缓存赖以工作的局部性原理失效。UUID，应该移除「-」符号, 对比sha1，虽然分布也不均匀，但是还有有一定顺序。&lt;br /&gt;
    * 所以按照这样的说法，一些，需要处理id的地方，比如用户的主键，直接使用integer，可以另外设定一个字段展示。&lt;br /&gt;
    * 特殊数据类型： IP v4地址， 人们经常石永红varchar(15)来保存，然而它是32位无符号正数，不是字符串， INET_ATON, INET_NTOA&lt;br /&gt;
    * 为了提升读查询的速度，需要建立一些额外的索引，增加冗余列，增加了写的负担，需要额外的维护任务，但是读操作提醒了。这是常见的技巧&lt;/li&gt;
  &lt;li&gt;alert table 执行大部分修改表结构的惭怍方法是： 使用新的数据结构创建一个空表，从旧的表中查询所有数据插入到新表，然后删除旧表。这样的操作可能需要花费很长时间，如果内存不足而且表又很大，很多索引的情况下尤其如此。&lt;br /&gt;
    * 下面的一些操作，是可能不需要重建表的， 而是直接修改.frm文件&lt;br /&gt;
    * 移除 一个列的 auto_increment操作&lt;br /&gt;
    * 增加、移除、或者更改 ENUM， SET敞亮，&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="创建高性能的索引"&gt;创建高性能的索引&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;索引对于良好的性能非常关键，尤其是当表中的数据量越来越大时。索引优化应该是针对查询性能优化最有效的手段了，索引能够情谊的讲查询性能提高到几个数量级。&lt;/li&gt;
  &lt;li&gt;索引类型：索引是在存储引擎而不是在服务层实现的，所以并没有统一的索引标准，&lt;br /&gt;
    * B-Tree, 人们多半讨论的是B-Tree索引，但是存储引擎依然使用的是不同的结构， InnoDB使用的为B+Tree， B-Tree对索引列是顺序组织的，适合范围查找，限制： 如果不是按照所以的声明顺序的最左列开始查找，则无法使用索引，不能跳过中间索引，所以：可能需要使用相同的列，但是不同顺序的索引满足查询要求。&lt;br /&gt;
    * 哈希索引： 将所有索引生成哈希码&lt;/li&gt;
  &lt;li&gt;索引的优点：&lt;br /&gt;
    * 大大减少了服务器需要扫描的数据量&lt;br /&gt;
    * 可以帮助服务器避免排序和临时表&lt;br /&gt;
    * 可以将随机io变味顺序io&lt;/li&gt;
  &lt;li&gt;高性能索引策略, 正确的创建和使用索引是实现高性能查询的基础。&lt;/li&gt;
  &lt;li&gt;索引策略：&lt;br /&gt;
    * 前缀索引和索引选择性， varchar类型的列，需要使用前缀索引，&lt;br /&gt;
    * 把where条件中的列都加上索引是错误的！。&lt;br /&gt;
    * 多个列独立的建立索引大部分情况下都不能提高查询性能。&lt;br /&gt;
    * 选择合适的索引顺序。 B-Tree中索引的顺序意味着所以首先按照最左列进行排序， 其次是第二列，将选择最高的列，放在索引前面。&lt;br /&gt;
    * 聚簇索引：主键中为B-Tree， 其他索引中，为B-tree，但是叶子节点中存储的为主键， 通过主键在次查询到具体数据.&lt;br /&gt;
    * 在InnoDB中按照主键顺序的插入行，最好避免随机，会带来没必要的分页存储。大量的数据插入可能会导致AUTO_INCREMENT锁竞争，可以秀发Innodb_autoin_lock_mode中的配置。&lt;br /&gt;
    * 使用索引扫描来做排序， 通过排序操作，活着按照索引顺序排序, explain出来 type为index， 则说明使用了索引排序&lt;br /&gt;
    * 删除冗余和重复索引&lt;br /&gt;
    * 删除未使用的索引&lt;br /&gt;
    * 索引会有效的减少需要lock的数据，&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="查询性能优化"&gt;查询性能优化&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;大部分性能底下的查询都可以通过减少访问的数据量的方式进行&lt;/li&gt;
  &lt;li&gt;是否扫描额外的数据：1：响应时间， 2： 扫描的行数， 3：返回的行数&lt;/li&gt;
  &lt;li&gt;explain 类型，有： 全表扫描， 碎银扫描， 范围扫描， 唯一索引查询，常熟引用&lt;/li&gt;
  &lt;li&gt;发现扫描大量数据但是返回很少的行的情况的优化方法：&lt;br /&gt;
    * 使用索引， 将需要的列，放入到索引中&lt;br /&gt;
    * 改变库表的结构，例如使用单独的汇总表&lt;/li&gt;
  &lt;li&gt;重构查询：&lt;br /&gt;
    *  切分查询，例如，删除数据，分散的删除数据， 而不是一次性删除&lt;br /&gt;
    * 分解关联查询： 简单的， 可以对没一个表进行查询，然后将结果在应用程序中，进行关联， 几个有点： 1：缓存的效果v更高， 2：查询分解后，减少锁的竞争。 3：查询效率提升（单个查询）， 4： 减少冗余记录的查询&lt;/li&gt;
  &lt;li&gt;查询执行基础：&lt;br /&gt;
    * 客户端、服务器通信协议，任何时刻都只有一个人在掌控球。一旦客户端发送了请求，能做的事情，就只有等待结果。&lt;br /&gt;
    * mysql的连接（线程）的状态有： sleep, query, locked, analyzing and statistics, cpoying to tmp table, sorting result, sending data&lt;br /&gt;
    *  排序优化：加索引&lt;br /&gt;
    * 在同一个表上查询和更新： 借助临时表&lt;br /&gt;
    * 关联查询： 确保On 中的列上有索引， 只需要在关联顺序中的第二个表的对应列上创建索引&lt;br /&gt;
    * 优化limit：一般会加上合适的order by语句， 如果有索引，效率会非常不错。 2： 大偏移量问题： 限制&lt;/li&gt;
&lt;/ol&gt;
</content>
  </entry>
  <entry>
    <title>Principles of economics</title>
    <link rel="alternate" href="http://geniousbar.github.io/2017/06/25/economy-learn/"/>
    <id>http://geniousbar.github.io/2017/06/25/economy-learn/</id>
    <published>2017-06-25T08:00:00+08:00</published>
    <updated>2017-06-26T17:15:50+08:00</updated>
    <summary type="html">&lt;h2 id="经济学原理微观经济学"&gt;经济学原理(微观经济学)&lt;/h2&gt;

&lt;h3 id="经济学十大原理"&gt;经济学十大原理&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
  &lt;li&gt;人们面临权衡取舍&lt;br&gt;
社会面临着在　效率公平 之间的权衡取舍&lt;/li&gt;
  &lt;li&gt;机会成本(某种东西的成本是为了得到他所放弃的东西), 比如时间，资源&lt;/li&gt;
  &lt;li&gt;理性人考虑边际效应&lt;/li&gt;
  &lt;li&gt;人们会对激励作出反应&lt;br&gt;
整个经济学的内容可以简单的概括为: “人们会对激励作出反应，其余内容则是对内容的解释”&lt;/li&gt;
  &lt;li&gt;贸易可以是每个人的状态都变得更好&lt;/li&gt;
  &lt;li&gt;市场通常是组织经济活动的一种好方法&lt;/li&gt;
  &lt;li&gt;政府有时可以改善市场结果&lt;br&gt;
政府干预经济１：促进效率或者公平，　２：市场失灵，　３：设计良好...&lt;/li&gt;
&lt;/ul&gt;</summary>
    <content type="html">&lt;h2 id="经济学原理微观经济学"&gt;经济学原理(微观经济学)&lt;/h2&gt;

&lt;h3 id="经济学十大原理"&gt;经济学十大原理&lt;/h3&gt;
&lt;hr /&gt;
&lt;ul&gt;
  &lt;li&gt;人们面临权衡取舍&lt;br /&gt;
社会面临着在　效率公平 之间的权衡取舍&lt;/li&gt;
  &lt;li&gt;机会成本(某种东西的成本是为了得到他所放弃的东西), 比如时间，资源&lt;/li&gt;
  &lt;li&gt;理性人考虑边际效应&lt;/li&gt;
  &lt;li&gt;人们会对激励作出反应&lt;br /&gt;
整个经济学的内容可以简单的概括为: “人们会对激励作出反应，其余内容则是对内容的解释”&lt;/li&gt;
  &lt;li&gt;贸易可以是每个人的状态都变得更好&lt;/li&gt;
  &lt;li&gt;市场通常是组织经济活动的一种好方法&lt;/li&gt;
  &lt;li&gt;政府有时可以改善市场结果&lt;br /&gt;
政府干预经济１：促进效率或者公平，　２：市场失灵，　３：设计良好的公共政策促进经经济效率&lt;/li&gt;
  &lt;li&gt;一国的生活水平取决与它生产物品与服务的能力&lt;/li&gt;
  &lt;li&gt;社会面临着通货膨胀与失业之间的短期权衡取舍
    &lt;blockquote&gt;

      &lt;p&gt;政府发行了过多的货币时候，物价上升&lt;br /&gt;
  经济中的货币量增加刺激了社会的整体指出水平，从而增加了对物品与服务的需求&lt;br /&gt;
  需求的增加随着时间的退役，会引起企业提高物价，但同时，它也激励着企业雇佣更多的工人，并生产更多的物品与服务&lt;br /&gt;
  雇佣工人意味着更少的失业&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="微观经济学"&gt;微观经济学&lt;/h4&gt;
&lt;p&gt;微观经济学与宏观经济学是密切相关的：由于整体经济的变动是千百万个人的决策，所以不考虑相关的微观经济学而去理解宏观经济学的发展是不可能的。但是，确实是两个不同的领域，每个领域都有自己的独特分析方法与模型。&lt;/p&gt;

&lt;h4 id="经济学家意见分歧的原因"&gt;经济学家意见分歧的原因:&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;经济学家可能对世界如何运行的不同实证理论的正确性看法不一致&lt;/li&gt;
  &lt;li&gt;经济学家可能有不同的价值观，因此对政策所努力实现的目标有不同的观点&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="图形分析工具存在的问题"&gt;图形分析工具存在的问题:&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;在研究两个变量之间的关系时，要保持其他条件不变是很困难的，可能存在忽略的重要的变量&lt;/li&gt;
  &lt;li&gt;反向因果关系（假设的影响关系方向可能不正确）变量先动是确定因果关系的简单方法，但是存在一个缺陷，人们对未来的预期改变自己的行为，而不是现状。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id="相互依存与贸易的好处"&gt;相互依存与贸易的好处&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;当每个人有各自的优势时候，能够以更加低廉的成本生产产品的时候，双方合作更加具有优势，扩大了生产边界&lt;/li&gt;
  &lt;li&gt;当一方存在全部的绝对优势的时候，就是说，一方在生产各个产品的时候都更具有效率，双方合作仍然能够扩大生产边界，可以用 &lt;strong&gt;比较优势&lt;/strong&gt; 来解释&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;对比较优势的解释示例:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Rose 生产１单位牛肉需要２０分钟，生产１单位土豆需要１０分钟&lt;br /&gt;
  Frank生产１单位牛肉需要６０分钟，生产１单位土豆需要１５分钟。&lt;br /&gt;
  比较来看Rose的生产效率更高，在各个产品的生产上具有绝对优势。&lt;br /&gt;
  但是：机会成本是不同的，考虑Rose花费１０分钟生产１单位土豆时候，可以用１０分钟生产1/2单位牛肉，所以１单位土豆对应的机会成本是1/2牛肉。对应的，　Frank的情况，则是，使用１５分钟生产１单位土豆，可以用生产1/4单位的牛肉&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style="text-align: left"&gt; &lt;/th&gt;
      &lt;th style="text-align: left"&gt;１单位你肉的机会成本&lt;/th&gt;
      &lt;th style="text-align: left"&gt;　１单位土豆的机会成本&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style="text-align: left"&gt;Frank&lt;/td&gt;
      &lt;td style="text-align: left"&gt;４单位土豆&lt;/td&gt;
      &lt;td style="text-align: left"&gt;　1/4单位牛肉&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style="text-align: left"&gt;Rose&lt;/td&gt;
      &lt;td style="text-align: left"&gt;2单位土豆&lt;/td&gt;
      &lt;td style="text-align: left"&gt;1/2单位牛肉&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;机会成本：为了得到某样东西所放弃的. 就是比较优势的计算方式所在， Frank　生产１单位牛肉所对应的机会成本是４单位的土豆，想对应的Rose则为２单位的土豆，隐含的机会成本更小，更加具有比较优势。而且生产土豆的机会成本与生产牛肉的机会成本成倒数关系。&lt;br /&gt;
  所以，无论一个人在各个方面都具有绝对优势，但是却无法在各个方面都具有比较优势。&lt;br /&gt;
  Frank使用土豆交换Rose的牛肉，假如是１单位牛肉对应３单位土豆的话,每个人都会以小于各自的机会成本获取产品。&lt;br /&gt;
  所以合作依存，交易会促进各自的生活状况。以更加高校的方式生产。当然其中隐含的条件是，能够存在一个合理的交换代价，比如上面的1/3都会低于对方的机会成本，从而促进合作，但是什么条件下会以1/3的代价进行交换呢？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;结论：专业化和贸易的好处并不是基于绝对优势的，而是基于比较优势。贸易可以使社会上每个人收益，因为他使人们可以从事他们具有 &lt;strong&gt;比较优势&lt;/strong&gt; 的活动&lt;br /&gt;
　问题：比较优、贸易促使每个人的状况变得更好。但是如何促进贸易的形成呢？如何使1/3的交易达成呢？答案是需求与供给的力量，促进资源配置&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id="市场如何运行"&gt;市场如何运行&lt;/h3&gt;
&lt;hr /&gt;

&lt;h4 id="供给与需求的市场力量"&gt;供给与需求的市场力量&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;如果你想知道一个事件或政策如何影响经济，应该先考虑如何影响供给和需求&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id="需求"&gt;需求&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;竞争市场，描述许多买者与卖者并且每一个人对市场价格的影响都是微乎其微的市场.市场还分为一些，垄断集团，半垄断&lt;/li&gt;
  &lt;li&gt;需求定理，其他条件不变，一种物品价格上升，对该物品的需求量减少，一个物品价格下降，对该物品的需求量增加．&lt;/li&gt;
  &lt;li&gt;影响需求曲线的因素：
    &lt;ul&gt;
      &lt;li&gt;当收入减少，如果一种物品的需求量减少，这种物品是正常物品，收入减少，需求量增加，物品为低档物品，例如收入减少，大家更愿意乘坐公交车出行&lt;/li&gt;
      &lt;li&gt;物品之间关联：一种物品价格下降引起另一种物品需求减少时，两种物品被成为替代品．而引起需求增加，称为互补品．&lt;/li&gt;
      &lt;li&gt;预期：人们不按照现状行事，而是按照预期．预期收入更多，会减少储蓄．&lt;/li&gt;
      &lt;li&gt;买者的数量：需求量&lt;/li&gt;
      &lt;li&gt;总结，　&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id="供给"&gt;供给&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;供给定理：　其他条件不变时候：一种物品价格上升，该物品供给量增加，　物品价格下降，供给量减少．&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;供给影响因素：
    &lt;ul&gt;
      &lt;li&gt;投入品价格: 企业成本,与生产该物品所用的投入品的价格&lt;/li&gt;
      &lt;li&gt;技术,技术的提高可以降低生产成本&lt;/li&gt;
      &lt;li&gt;预期，如果预期产品价格上升，厂家会提高市场供给&lt;/li&gt;
      &lt;li&gt;卖者数量&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id="均衡"&gt;均衡&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;供给曲线与需求曲线相交的点，为市场的均衡点，此时的价格为均衡价格，数量为均衡数量。均衡价格也被成为出清价格.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;供求定理：任何一种物品的价格都会自发调整，是该物品的供给与需求达到平衡.&lt;/li&gt;
  &lt;li&gt;分析均衡变动的三个步骤：
    &lt;ul&gt;
      &lt;li&gt;第一我们确定该事件是使供给曲线移动还是需求曲线移动。&lt;/li&gt;
      &lt;li&gt;确定曲线向右移动还是向左移动。&lt;/li&gt;
      &lt;li&gt;使用供求图说明这种移动将如何改变均衡价格和均衡数量。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;示例：
    &lt;ul&gt;
      &lt;li&gt;天气炎热通过改变人们对冰激凌的爱好而影响需求曲线。&lt;/li&gt;
      &lt;li&gt;天气炎热促进人们想吃更多的冰激凌，冰激凌的需求增加了，需求曲线向右移动。&lt;/li&gt;
      &lt;li&gt;新的均衡下，冰激凌的价格提高，供给增加。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id="需求的弹性"&gt;需求的弹性&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;一个物品的需求量对价格的反映很大，则是物品的需求是富有弹性的，对价格变化很小，则是缺乏弹性的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;控制因素
    &lt;ol&gt;
      &lt;li&gt;相似代替品的可获得行&lt;/li&gt;
      &lt;li&gt;必需品与奢侈品（商品属性）&lt;/li&gt;
      &lt;li&gt;市场的定义，狭义的市场还是广义的市场，狭义的市场更容易寻找到代替品。所以狭义的市场的需求弹性往往大于广义市场的需求弹性&lt;/li&gt;
      &lt;li&gt;物品的需求往往长期内更富有弹性(市场滞后吗？)，油价的上涨往往在长期内更具有影响意义。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;弹性计算：　需求弹性　＝　需求量变动百分比 / 价格变动百分比&lt;/li&gt;
  &lt;li&gt;规律：　
    &lt;ol&gt;
      &lt;li&gt;当需求缺乏弹性，价格和总收益，同方向变化，价格上升，总收益增加。&lt;/li&gt;
      &lt;li&gt;当需求富有弹性，价格和总收益，反方向变化，价格上升，总收益减少。&lt;/li&gt;
      &lt;li&gt;如果需求是单位弹性的,(等于１), 当价格变动时，总收益不变。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;####　供给弹性&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;如果供给量对价格的反映很大，则物品的供给是富有弹性的，对价格变化很小，则是缺乏弹性的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;控制因素:
    &lt;ul&gt;
      &lt;li&gt;卖者改变他们所生产的物品的灵活性。&lt;/li&gt;
      &lt;li&gt;供给在长期中的弹性通常大于短期。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;弹性计算：　供给需求　＝　供给量变动百分比 / 价格变动百分比&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id="案例"&gt;案例&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;农业的好消息可能对农民来说是个坏消息吗？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假设有研究技术能够大量的提高农作物的产量，  想象一下这对农民是好是坏呢？&lt;br /&gt;
  分析：由于新的技术提高了生产产量，所以农民可以在现有的价格下提高更多的食物产量。供给曲线向右移动，价格下降，因为食物是缺乏弹性的，总收益随着产品的价格同步移动，所以总收益下降。农民得到更少的钱，这里中分析，基本排除供给弹性，因为供给基本没有弹性，只有长期中供给才富有弹性。&lt;br /&gt;
  真是的情况是：&lt;br /&gt;
      上面的分析，解释了过去一个世纪以来的美国经济的一个巨大变化，两百多年前，大部分美国人居住在农村，对农业生产的了解是相当原始的。以至于我们大多数人不得不从事农业，以生产足够的食物来养活全国的人口。但随着时间的推移，农业的技术进步增加了每个农民所能生产的食物量，由于食物的需求缺乏弹性，这种食物的供给增加导致了农业收益的减少，进而鼓励人们更多的离开农业。促进了城镇化。&lt;/p&gt;

&lt;h3 id="供给需求与政府政策"&gt;供给、需求与政府政策&lt;/h3&gt;
&lt;hr /&gt;

&lt;h4 id="价格控制价格上限价格下限"&gt;价格控制（价格上限、价格下限）&lt;/h4&gt;

&lt;p&gt;价格上限造成了稀缺物品。造成了无效率的分配。&lt;br /&gt;
住房的租金控制，同样的造成了短缺。造成了供给的稀缺，需求的增加。但是可以通过相关法律保障，住房者的相关权益，给供给端正面反馈等。&lt;/p&gt;

&lt;p&gt;关于控制价格：实际上决策者进行价格控制是因为他们认为市场是不公平的。价格控制往往是想帮助穷人。例如租金控制法的目的是使每一个人住的其房子，但是价格控制往往损害了那些想要帮助的人，最低工资法会增加一些工人的收入，但是也使其他工人成为失业者。可以使用除价格控制之外的方法来帮助需要帮助的人，例如，政府可以通过给贫困用户补助住房基金来提高他们的生活质量，这种措施并没有减少住房的供给量。&lt;/p&gt;

&lt;h4 id="税收"&gt;税收&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;无论是想卖者征收税收还是向买者征收，都是同样的效果。１：抑制了市场活动２:买家卖家共同承担税收的费用。&lt;/li&gt;
  &lt;li&gt;税收归宿：&lt;strong&gt;税收负担更多的落在缺乏弹性的市场一方身上&lt;/strong&gt;。在本质上，弹性衡量在条件变得不利时候，卖者或者买者离开市场的意愿。需求弹性小意味着没有更多的代替品，供给弹性小，意味着卖者对生产某种商品没有适当的代替品，适当代替品较少的一方更不愿意离开市场，从而负担更多的税收。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id="市场和福利"&gt;市场和福利&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;支付意愿：一个买者愿意支付的最大价格&lt;/li&gt;
  &lt;li&gt;消费者剩余: Jhon 花费80买了心里价格１００的东西，产生了２０的消费者剩余。&lt;/li&gt;
  &lt;li&gt;生产者剩余：买价减去生产成本&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;结论：供给曲线、需求曲线的交叉点，为市场消费剩余的最大点。&lt;br /&gt;
   税收收入减少了，无所谓的市场福利，造成了无谓损失。并扭曲的市场结果。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id="国际贸易"&gt;国际贸易&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;更有效率的分配物品，每个国家更嫩专注于生产比较成本低的产品&lt;/li&gt;
  &lt;li&gt;增加了物品的多样性&lt;/li&gt;
  &lt;li&gt;通过规模经济降低了生产成本&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;增加了竞争&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;工作岗位论&lt;/li&gt;
  &lt;li&gt;国家安全论&lt;/li&gt;
  &lt;li&gt;幼稚产业论&lt;/li&gt;
  &lt;li&gt;不公平竞争论&lt;/li&gt;
&lt;/ol&gt;
</content>
  </entry>
  <entry>
    <title>Linux service</title>
    <link rel="alternate" href="http://geniousbar.github.io/2017/06/22/linux-service/"/>
    <id>http://geniousbar.github.io/2017/06/22/linux-service/</id>
    <published>2017-06-22T08:00:00+08:00</published>
    <updated>2017-06-23T19:31:48+08:00</updated>
    <summary type="html">&lt;h2 id="linux-service"&gt;linux service&lt;/h2&gt;

&lt;h4 id="service"&gt;service&lt;/h4&gt;
&lt;blockquote&gt;

  &lt;p&gt;简单的说,系统为了某些功能必须要提供一些服务 (丌讳是系统本身还是网络方面),这个服务就称为 service 。 但是 service 的提供总是需要程序的运作吧!否则如何执行呢?所以达成这个 service 的程序我们就称呼他为 daemon 啰&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;super daemon,
    &lt;ul&gt;
      &lt;li&gt;multi-threaded  多线程,&lt;/li&gt;
      &lt;li&gt;single-threaded 单线程,&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;stand...&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    <content type="html">&lt;h2 id="linux-service"&gt;linux service&lt;/h2&gt;

&lt;h4 id="service"&gt;service&lt;/h4&gt;
&lt;blockquote&gt;

  &lt;p&gt;简单的说,系统为了某些功能必须要提供一些服务 (丌讳是系统本身还是网络方面),这个服务就称为 service 。 但是 service 的提供总是需要程序的运作吧!否则如何执行呢?所以达成这个 service 的程序我们就称呼他为 daemon 啰&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;super daemon,
    &lt;ul&gt;
      &lt;li&gt;multi-threaded  多线程,&lt;/li&gt;
      &lt;li&gt;single-threaded 单线程,&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;stand alone, 可以单独启动服务， 优点， 存在内存中只许的提供服务&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;工作形态类型
    &lt;ul&gt;
      &lt;li&gt;signal-control, 有需求进来，就处理&lt;/li&gt;
      &lt;li&gt;interval-control, 定期执行，处理&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;因为daemon 的程序启动需要考虑很多东西， 判断环境，配置参数等， 所以， 系统提供一些 脚本命令提供执行
    &lt;ul&gt;
      &lt;li&gt;启动脚本配置 /etc/init.d/*&lt;/li&gt;
      &lt;li&gt;服务初始化环境配置: /etc/sysconfig/*, 比如 /etc/sysconfig/network&lt;/li&gt;
      &lt;li&gt;super daemon配置文件: /etc/xinetd.conf, /etc/xinetd.d/*,&lt;/li&gt;
      &lt;li&gt;各服务的配置文件: /etc/*&lt;/li&gt;
      &lt;li&gt;各服务产生的数据库: /var/lib/*&lt;/li&gt;
      &lt;li&gt;服务pid记录处： /var/run/*&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;service命令, 简单的分析 service后面的参数， 然后传达到/etc/init.d/中， 完成&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;[ ] xinetd 服务管理吗？centos中的统一服务管理?&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="总结"&gt;总结&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;服务 (daemon) 主要可以分为 stand alone (服务可单独吪劢) 及 super daemon (透过 xinetd 统一管理的服务) 两种。&lt;/li&gt;
  &lt;li&gt;super daemon 由亍是经过一个统一的 xinetd 来管理,因此可以具有类似防火墙管理功能。此外,管理的联机机 制又可以分为 multi-threaded 及 single-threaded。&lt;/li&gt;
  &lt;li&gt;启动daemon 的程序通常最末会加上一个 d ,例如 sshd, vsftpd, httpd 等&lt;/li&gt;
  &lt;li&gt;stand alone daemon 吪劢的脚本放置到 /etc/init.d/ 这个目录中,super daemon 的配置文件在 /etc/xinetd.d/*&lt;br /&gt;
内, 而启动的方式则为 /etc/init.d/xientd restart&lt;/li&gt;
  &lt;li&gt;立即启动 stand alone daemon 的方法亦可以使用 service 这个挃令&lt;/li&gt;
  &lt;li&gt;Super daemon 的配置文件 /etc/xinetd.conf ,个别 daemon 配置文件则在 /etc/xinetd.d/* 内。在配置文件内, 还可以讴定联机客户端的联机不否, 具有类似防火墙的功能喔。&lt;/li&gt;
  &lt;li&gt;若想要统一管理防火墙的功能,可以透过 /etc/hosts.{allow,deny} ,若有安装 TCP Wrappers 时,还能够使用额外的 spawn 功能等&lt;/li&gt;
  &lt;li&gt;若想要讴定开机时吪劢某个服务时,可以透过 chkconfig, ntsysv 等挃令。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="linux-package-manger"&gt;Linux package manger&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style="text-align: left"&gt; &lt;/th&gt;
      &lt;th style="text-align: left"&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style="text-align: left"&gt;/etc&lt;/td&gt;
      &lt;td style="text-align: left"&gt;几乎所有的配置文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style="text-align: left"&gt;/usr/bin&lt;/td&gt;
      &lt;td style="text-align: left"&gt;一些可执行文件档案&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style="text-align: left"&gt;/usr/lib&lt;/td&gt;
      &lt;td style="text-align: left"&gt;一些程序使用的动态函数库&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style="text-align: left"&gt;/usr/share/doc&lt;/td&gt;
      &lt;td style="text-align: left"&gt;一些基本的软件使用手册&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style="text-align: left"&gt;/usr/share/man&lt;/td&gt;
      &lt;td style="text-align: left"&gt;一些man page档案&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</content>
  </entry>
  <entry>
    <title>Linux process</title>
    <link rel="alternate" href="http://geniousbar.github.io/2017/06/22/linux-process/"/>
    <id>http://geniousbar.github.io/2017/06/22/linux-process/</id>
    <published>2017-06-22T08:00:00+08:00</published>
    <updated>2017-06-22T18:53:53+08:00</updated>
    <summary type="html">&lt;h2 id="linux-process"&gt;linux process&lt;/h2&gt;

&lt;h5 id="程序"&gt;程序&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;触发任何一个事件，系统会将他定义为一个程序，赋予PID，根据调用用户与相关属性关系，赋予PID相关的有效的权限设定， 在系统上进行的动作就与这个权限相关&lt;/li&gt;
  &lt;li&gt;shell是一个程序， 执行bash， 与内核交互&lt;/li&gt;
  &lt;li&gt;fork and exec, fork, 父进程 到子进程， 赋予子进程新的PID， PPID=父进程， exec 程序实体&lt;/li&gt;
  &lt;li&gt;crontab, atd, syslog, 为常驻进程
    &lt;h4 id="工作管理"&gt;工作管理&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;background job...&lt;/li&gt;
&lt;/ul&gt;</summary>
    <content type="html">&lt;h2 id="linux-process"&gt;linux process&lt;/h2&gt;

&lt;h5 id="程序"&gt;程序&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;触发任何一个事件，系统会将他定义为一个程序，赋予PID，根据调用用户与相关属性关系，赋予PID相关的有效的权限设定， 在系统上进行的动作就与这个权限相关&lt;/li&gt;
  &lt;li&gt;shell是一个程序， 执行bash， 与内核交互&lt;/li&gt;
  &lt;li&gt;fork and exec, fork, 父进程 到子进程， 赋予子进程新的PID， PPID=父进程， exec 程序实体&lt;/li&gt;
  &lt;li&gt;crontab, atd, syslog, 为常驻进程
    &lt;h4 id="工作管理"&gt;工作管理&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;background job, foreground job&lt;/li&gt;
  &lt;li&gt;background job 中 的限制
    &lt;ol&gt;
      &lt;li&gt;为当前bash的子进程&lt;/li&gt;
      &lt;li&gt;可以自行运作，无法使用ctrl+c终止， 只能使用fg/bg&lt;/li&gt;
      &lt;li&gt;不能够与终端交互&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;丢到背景执行 &amp;amp; tar -zpcf /tmp/etc.tar.gz /etc &amp;amp;&lt;/li&gt;
  &lt;li&gt;ctrl+z 讲当前工作丢到背景执行 并暂停, 例如 vi ~/.bashrc&lt;/li&gt;
  &lt;li&gt;jobs 查询背景执行工作状态 -l 列表， -r running的工作， -s stop 的工作&lt;/li&gt;
  &lt;li&gt;fg jobnunber， 将背景执行转移到前景执行&lt;/li&gt;
  &lt;li&gt;bg jobnunber， 将前景执行转移背景执行&lt;/li&gt;
  &lt;li&gt;kill -signal %jobnumber&lt;/li&gt;
  &lt;li&gt;ps aux(系统所有程序), -lA(同aux) axjf（连同程序树状态）&lt;/li&gt;
  &lt;li&gt;ps -l 仅查找bash相关程序, 列表中个个字段的含义 F, (process flags),4 为root， 1为此进程fork的， S(state)， R running， S sleep, D 不可唤醒状态, T 停止状态， Z 僵尸状态, UID/PID,PPID(parent pid), PRI/NI(priority/nice) 程序的优先级&lt;/li&gt;
  &lt;li&gt;top, 动态查看程序的变化，-p pid -d 几秒刷新&lt;/li&gt;
  &lt;li&gt;pstree -p pid, -u process 所属帐号&lt;/li&gt;
  &lt;li&gt;kill 中signal, kill -signal PID
    &lt;ul&gt;
      &lt;li&gt;1, SIGHUP, 重新读取配置文件，重新启动&lt;/li&gt;
      &lt;li&gt;2, SIGINT, 终止程序&lt;/li&gt;
      &lt;li&gt;9, SIGKILL 强制终止&lt;/li&gt;
      &lt;li&gt;15, SIGTERM 正常结束程序&lt;/li&gt;
      &lt;li&gt;17, SIGSTOP，暂停程序的执行&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;程序中的优先级，sum = PRI + nice, pri为动态计算的， nice为人工指定，范围为(-20 - 19 )
    &lt;blockquote&gt;
      &lt;p&gt;nice -n command, renice number PID&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;free 查看内存使用情况,  free -b m(Mbytes) b(bytes), -t 显示swap总量(很有效率的使用没存， 比如使用大量buffer， cached)&lt;/li&gt;
  &lt;li&gt;uname 查看系统与核心相关程序&lt;/li&gt;
  &lt;li&gt;uptime, 观察系统启动时间与工作负载&lt;/li&gt;
  &lt;li&gt;netstat 追踪网络, -a（所有联机， 监听， socket列出来）, -t (tcp网络封包数据), -u（udp网络封包数据） -n port number， -l 列出正在监听的服务， -p pid&lt;/li&gt;
  &lt;li&gt;fuser:藉由档案(戒文件系统)找出正在使用该档案癿程序, 找出正在占用文件资源的程序，-u 列出使用者，-v 列出程序指令， -k， 住处pid，并试图发送SIGKILL信号， -i交互式发送信号&lt;/li&gt;
  &lt;li&gt;pidof -x 列出该program name的可能的PPID的pid（找出父进程关联的pid） program_name&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>Linux crontab</title>
    <link rel="alternate" href="http://geniousbar.github.io/2017/06/22/linux-crontab/"/>
    <id>http://geniousbar.github.io/2017/06/22/linux-crontab/</id>
    <published>2017-06-22T08:00:00+08:00</published>
    <updated>2017-06-22T16:10:19+08:00</updated>
    <summary type="html">&lt;h2 id="linux-crontab-例行性工作排程"&gt;linux crontab （例行性工作排程）&lt;/h2&gt;

&lt;h5 id="at"&gt;at&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;执行一次就结束的程序指令&lt;/li&gt;
  &lt;li&gt;开启 /etc/init.d/atd restart&lt;/li&gt;
  &lt;li&gt;at任务记录在 /var/spool/at/中&lt;/li&gt;
  &lt;li&gt;权限 /etc/at.allow, /etc/at.deny, 规则： 1. 先寻找at.allow，写入这个文档的使用者才能使用，没有写入的不能使用 2. 寻找 /etc/at.deny， 写入文档的不能使用， 没有写入的可以使用, 3.两个文档都不存在的，只有root可以使用。&lt;/li&gt;
  &lt;li&gt;按照...&lt;/li&gt;
&lt;/ul&gt;</summary>
    <content type="html">&lt;h2 id="linux-crontab-例行性工作排程"&gt;linux crontab （例行性工作排程）&lt;/h2&gt;

&lt;h5 id="at"&gt;at&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;执行一次就结束的程序指令&lt;/li&gt;
  &lt;li&gt;开启 /etc/init.d/atd restart&lt;/li&gt;
  &lt;li&gt;at任务记录在 /var/spool/at/中&lt;/li&gt;
  &lt;li&gt;权限 /etc/at.allow, /etc/at.deny, 规则： 1. 先寻找at.allow，写入这个文档的使用者才能使用，没有写入的不能使用 2. 寻找 /etc/at.deny， 写入文档的不能使用， 没有写入的可以使用, 3.两个文档都不存在的，只有root可以使用。&lt;/li&gt;
  &lt;li&gt;按照上面规则，所以如果是所以使用者都可以使用话，简历空的at.deny就可以了&lt;/li&gt;
  &lt;li&gt;at -l（列出用户的at排程）, -d （取消）, -c （列出id的实际工作内容）&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;任务管理， atrm id， 移除任务, 等同于 at -d&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;  &lt;span class="c"&gt;#设定范例&lt;/span&gt;
  at HH:MM YYYY-MM-DD
  at HH:MM[am|pm]
  at now + numbers &lt;span class="o"&gt;[&lt;/span&gt;minutes | hours | days | weeks]
  at now + 5 minutes
  &lt;span class="c"&gt;#进入编辑窗口&lt;/span&gt;
  ctrl + d 结束
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id="crontab"&gt;crontab&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;周期性执行任务&lt;/li&gt;
  &lt;li&gt;crontab -u 只有root才能使用， 帮助其他用户管理任务, -e 编辑， -l 查阅， -r 移除所有工作&lt;/li&gt;
  &lt;li&gt;分中， 小时， 日期， 月份， 周， 指令（分时日月周）&lt;/li&gt;
  &lt;li&gt;* 任何时候&lt;/li&gt;
  &lt;li&gt;, 分割枚举&lt;/li&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;时间范围&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;/n， 每隔n个单位&lt;/li&gt;
  &lt;li&gt;crontab 每分钟读取， 所以只需要编辑， /etc/crontab 文件即可&lt;/li&gt;
  &lt;li&gt;如果在大量的crontab时候，出现分配不均，（认为被集中执行）, 则可以，使用分割枚举的方法， 将任务排开，充分利用资源&lt;/li&gt;
  &lt;li&gt;可以在命令中进行，输出的重定向，例如， /dev/null&lt;/li&gt;
  &lt;li&gt;run-parts, /usr/bin/run-parts, 定期执行script文件&lt;/li&gt;
  &lt;li&gt;/var/log/cron中为crontab的log文件&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;anacron 是可以自动自动检查timestap日志，并将因为开关机导致没有执行的crontab重新执行的程序， 但是需要按照天，月来进行任务排期，&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;  &lt;span class="c"&gt;# run-parts&lt;/span&gt;
  01 &lt;span class="k"&gt;*&lt;/span&gt; &lt;span class="k"&gt;*&lt;/span&gt; &lt;span class="k"&gt;*&lt;/span&gt; &lt;span class="k"&gt;*&lt;/span&gt; root
  02 4 &lt;span class="k"&gt;*&lt;/span&gt; &lt;span class="k"&gt;*&lt;/span&gt; &lt;span class="k"&gt;*&lt;/span&gt; root
  22 4 &lt;span class="k"&gt;*&lt;/span&gt; &lt;span class="k"&gt;*&lt;/span&gt; 0 root
  42 4 1 &lt;span class="k"&gt;*&lt;/span&gt; &lt;span class="k"&gt;*&lt;/span&gt; root 分时日月周执行者身仹 挃令串
  root run-parts /etc/cron.hourly &amp;lt;&lt;span class="o"&gt;==&lt;/span&gt;每小时 run-parts /etc/cron.daily &amp;lt;&lt;span class="o"&gt;==&lt;/span&gt;每天
  root run-parts /etc/cron.weekly &amp;lt;&lt;span class="o"&gt;==&lt;/span&gt;每周日 run-parts /etc/cron.monthly &amp;lt;&lt;span class="o"&gt;==&lt;/span&gt;每个月 1 号
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id="系统性常见周期任务"&gt;系统性常见周期任务&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;登录档的轮替， log rotate&lt;/li&gt;
  &lt;li&gt;登录文件分析, logwatch&lt;/li&gt;
  &lt;li&gt;locate数据库更新&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>Linux Relearn</title>
    <link rel="alternate" href="http://geniousbar.github.io/2017/06/19/linux-relearn/"/>
    <id>http://geniousbar.github.io/2017/06/19/linux-relearn/</id>
    <published>2017-06-19T08:00:00+08:00</published>
    <updated>2017-06-26T10:26:05+08:00</updated>
    <summary type="html">&lt;h2 id="linux-bash"&gt;linux bash&lt;/h2&gt;

&lt;h4 id="常用命令"&gt;常用命令&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;history, alias, type, 变量，echo, unset, env, declare, set, read, array&lt;/li&gt;
  &lt;li&gt;系统变量， HOME, SHELL, HISISIZE, PATH, LANG, RANDOM, $, $?, OSTYPE, HOSTTYPE, MACHTYPE,&lt;/li&gt;
  &lt;li&gt;read, read -p ‘please enter you name’ -t 100 name&lt;/li&gt;
  &lt;li&gt;declare, declare -a...&lt;/li&gt;
&lt;/ul&gt;</summary>
    <content type="html">&lt;h2 id="linux-bash"&gt;linux bash&lt;/h2&gt;

&lt;h4 id="常用命令"&gt;常用命令&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;history, alias, type, 变量，echo, unset, env, declare, set, read, array&lt;/li&gt;
  &lt;li&gt;系统变量， HOME, SHELL, HISISIZE, PATH, LANG, RANDOM, $, $?, OSTYPE, HOSTTYPE, MACHTYPE,&lt;/li&gt;
  &lt;li&gt;read, read -p ‘please enter you name’ -t 100 name&lt;/li&gt;
  &lt;li&gt;declare, declare -a(array) ary; declear (-i) integer, declear -x(设定为幻境变量), declare -r (read only); ary[1]=’xx’ 从1开始，而非从0开始&lt;/li&gt;
  &lt;li&gt;ulimit 用于限制用户的系统资源，可以打开的档案数量， cpu时间， 内存总量等&lt;/li&gt;
  &lt;li&gt;alias, unalias,  alias rm=’rm i’&lt;/li&gt;
  &lt;li&gt;history 10&lt;/li&gt;
  &lt;li&gt;指定的搜索顺序， type -a ls, 1. 以相对/绝对路径执行挃令,例如『/bin/ls』戒『./ls』; 2. 由alias找刡该挃令杢执行; 3. 由bash内建癿(builtin)挃令杢执行; 4. 透过$PATH这个发量癿顺序搜寻刡癿第一个挃令杢执行。&lt;/li&gt;
  &lt;li&gt;bash 的登录欢迎信息， /etc/issue, /etc/motd, /etc/issue.net, 远程sshd登录，可以配置/etc/ssh/sshd_config 来决定， 读取文件&lt;/li&gt;
  &lt;li&gt;bash 的配置文件， login 读取文件顺序， 1. /etc/profile, 2. ~/.bash_profie, ~/.bash_login, ~/.profile , 其中2中三选一， 按照顺序那个文件存在读取那个文件 1。中不要改动比较重要， 1中会另外呼入 /etc/profile.d/*.sh 文件夹夏的所有文件， /etc/profile.d/lang.sh 会呼入/etc/sysconfig/i18n文件, /etc/skel/.bashrc 文件是 ~/.bashrc 的备份文件&lt;/li&gt;
  &lt;li&gt;source=. 可以source ~/.bash_profile 或者 . ~/.bash_profile&lt;/li&gt;
  &lt;li&gt;~/.bash_history, ~/.bash_logout&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;输入输出流管理：&lt;/p&gt;

    &lt;blockquote&gt;

      &lt;ol&gt;
        &lt;li&gt;标准输入 (stdin):代码为0,使用&amp;lt;戒«;&lt;/li&gt;
        &lt;li&gt;标准输出 (stdout):代码为1,使用&amp;gt;戒»;&lt;/li&gt;
        &lt;li&gt;标准错诨输出(stderr):代码为2,使用2&amp;gt;戒2»;&lt;br /&gt;
 find /home -name .bashrc &amp;gt; list_right 2&amp;gt; list_error&lt;br /&gt;
 /dev/null 垃圾桶黑洞装置不特殊写法&lt;br /&gt;
 find /home -name .bashrc &amp;gt; list 2&amp;gt;&amp;amp;1 同时写入一个文件中，不能写成 &amp;gt; list 2&amp;gt; list会导致同时吸入问津啊，顺序发生错乱&lt;br /&gt;
 command1 &amp;amp;&amp;amp; command2 || command3&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;cut; cut -d ‘:’ -f 2 $PATH; 通过分隔符裁剪，取特定位置的数值&lt;/li&gt;
  &lt;li&gt;expand -t 4 file_name, 将tab转换成4个空格&lt;/li&gt;
  &lt;li&gt;split -b 10m file 将文件切分成10m大小&lt;/li&gt;
  &lt;li&gt;xargs, sort, uniq&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="总结"&gt;总结&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;由于核心在内存中是受保护,因此我们必须要透过 Shell将我们输入命令传给 Kernel 沟通&lt;/li&gt;
  &lt;li&gt;用户默认登入去的shell记录于的最后一个字段&lt;/li&gt;
  &lt;li&gt;bash 主要功能有： 工作控制，前景背景控制，程序脚本化(job control, foreground, background)&lt;/li&gt;
  &lt;li&gt;type, which&lt;/li&gt;
  &lt;li&gt;locale 查询目前语言系材料， /etc/sysconfig/i18n&lt;/li&gt;
  &lt;li&gt;read可以回去用户输入，交互&lt;/li&gt;
  &lt;li&gt;ulimit限制用户系统资源&lt;/li&gt;
  &lt;li&gt;bash 非为login shell， non-login shell， login shell主要读取 /etc/profile, ~/.bash_profile, non-login shell 仅读取 ~/.bashrc&lt;/li&gt;
  &lt;li&gt;命令集， cut, grep, sort, wc, uniq, tee, tr, col, join, paste, expand, split, xargs&lt;/li&gt;
  &lt;li&gt;shell中的提示字符， 修改PSI变量&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;登录欢迎信息，在 /etc/issue, /etc/motd&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;变量：&lt;/p&gt;

    &lt;blockquote&gt;

      &lt;p&gt;name=file_name&lt;br /&gt;
  name=’file name is –’&lt;br /&gt;
  name=”$name”:suffix; name=${name}:suffix;&lt;br /&gt;
  name=$(uname -r); name=&lt;code&gt;unname -r&lt;/code&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
</feed>
