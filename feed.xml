<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>日常学习</title>
  <id>http://geniousbar.github.io</id>
  <link href="http://geniousbar.github.io"/>
  <link href="http://geniousbar.github.io/feed.xml" rel="self"/>
  <updated>2018-12-30T08:00:00+08:00</updated>
  <author>
    <name>geniousbar</name>
  </author>
  <entry>
    <title>linux-interface-04</title>
    <link rel="alternate" href="http://geniousbar.github.io/2018/12/30/linx-interface-04/"/>
    <id>http://geniousbar.github.io/2018/12/30/linx-interface-04/</id>
    <published>2018-12-30T08:00:00+08:00</published>
    <updated>2019-01-13T21:43:25+08:00</updated>
    <summary type="html">&lt;h2 id="the-linux-programming-interface"&gt;The linux programming interface&lt;/h2&gt;

&lt;h3 id="文件io-通用的io模型"&gt;文件IO 通用的IO模型&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;文件描述符： 一个非负整数，来指代打开的文件，其中包括： 管道FIFO socket，终端 设备 普通文件&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;标准文件描述符:&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style="text-align: left"&gt;文件描述符&lt;/th&gt;
          &lt;th style="text-align: left"&gt;用途&lt;/th&gt;
          &lt;th style="text-align: left"&gt;名称&lt;/th&gt;
          &lt;th style="text-align: left"&gt;stdio&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style="text-align: left"&gt;0&lt;/td&gt;
     ...&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    <content type="html">&lt;h2 id="the-linux-programming-interface"&gt;The linux programming interface&lt;/h2&gt;

&lt;h3 id="文件io-通用的io模型"&gt;文件IO 通用的IO模型&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;文件描述符： 一个非负整数，来指代打开的文件，其中包括： 管道FIFO socket，终端 设备 普通文件&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;标准文件描述符:&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style="text-align: left"&gt;文件描述符&lt;/th&gt;
          &lt;th style="text-align: left"&gt;用途&lt;/th&gt;
          &lt;th style="text-align: left"&gt;名称&lt;/th&gt;
          &lt;th style="text-align: left"&gt;stdio&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style="text-align: left"&gt;0&lt;/td&gt;
          &lt;td style="text-align: left"&gt;标准输入&lt;/td&gt;
          &lt;td style="text-align: left"&gt;STDIN_FILENO&lt;/td&gt;
          &lt;td style="text-align: left"&gt;stdin&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style="text-align: left"&gt;1&lt;/td&gt;
          &lt;td style="text-align: left"&gt;标准输出&lt;/td&gt;
          &lt;td style="text-align: left"&gt;STDOUt_FILENO&lt;/td&gt;
          &lt;td style="text-align: left"&gt;stdout&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style="text-align: left"&gt;2&lt;/td&gt;
          &lt;td style="text-align: left"&gt;标准错误&lt;/td&gt;
          &lt;td style="text-align: left"&gt;StDERR_FILENO&lt;/td&gt;
          &lt;td style="text-align: left"&gt;stderr&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;主要的系统调用&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;open(pathname, flags, mode) open创建新文件时候， 即 flags 中包含 O_creat 标志，mode制定了文件的访问权限。flags还有许多的可选参数， 包括O_APPEND, O_ASYNC等等。&lt;/li&gt;
      &lt;li&gt;read(fd, buffere, count), read 调用成功返回 实际读取的字节数， 如果遇到文件结束EOF 则返回0， 出席那错误 -1， 一次read 可能返回的 字节数可能小于count， fd为文件时候， 可能是文件靠近结尾，（所以文件尾部时候是不是小于count还是一个0？），fd为其他类型时候， socket， 终端，例如在终端遇到\n read调用就会结束。在有需要注意， C语言， 如果输入缓冲区， buffere 需要一个表示终止的空字符串，需要自己显示添加&lt;/li&gt;
      &lt;li&gt;write(fd, buffer, count), write 为将buffer中的数据写入fd中，error 返回-1， 其他返回写入的字节数， 写入字节数可能小于count （进程资源对文件大小的限制，磁盘满等， 造成部分写），write成功并不能保证已经写入到文件中，而是高速缓冲区，系统会缓存磁盘IO。&lt;/li&gt;
      &lt;li&gt;close(fd) close error -1，success 0， 文件属于有限资源，文件描述符关闭失败可能导致一个进程将资源消耗殆尽。编写长期运行的程序，比如网络服务器显得尤为重要。所以，总是显式的关闭文件描述符。&lt;/li&gt;
      &lt;li&gt;lseek(fd, offset, whence) 改变文件偏移量。文件偏移量是下一个read， write 等的起始点。文件打开指向文件头，read, write 自动调整偏移量. whence 可选参数为 SEEK_SET, SEEK_CUR, SEEK_END, 分表表示offset的基准坐标 为 文件开始头部， 当前偏移量， 文件末尾。 offset 可以为负数 表示，向前偏移多少。调用成功返回移动之后的偏移量。可以使offset为0 来获取当前偏移量。lseek并不适合所有类型的文件，应用与管道， FIFO, socket或者终端，调用将会失败， errno 被设定为ESPIPE.&lt;/li&gt;
      &lt;li&gt;ioctl(fd, request, ….args) 对为纳入标准IO模型的所有设备和文件操作而言，ioctl系统调用是个万金油&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;/proc/PID/fdinfo 目录下，可以获取系统任一进程中文件描述符的相关信息。针对进程中的每一个已打开的文件描述符，该目录下都有对应的文件， 以对应的文件描述符的数值命名，其中文件中的pos为文件偏移量， flags字段 则为一个八进制数, 其格式形如&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;   pos:  0
   flags: 02
   mnt_id: 9
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;p&gt;&lt;em&gt;文件空洞，在 文件结尾+ offset的位置写入数据，会发生什么情况，文件结尾开始到offset 中会产生空洞。文件空洞的特点在于它并不占用磁盘空间，只有当空洞中有数据写入时候，才会分配磁盘空间。 编程角度看读取空洞返回0。空间的存在，造成 文件名义上的大小可能要比其占用的磁盘存储总量要大，当空洞被写入文件时候，内和为其分配存储空间，磁盘可用空间减少。&lt;/em&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="深入探究文件io"&gt;深入探究文件IO&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;原子操作： 将某一系统调用所要完成的各个动作作为不可中断的操作，一次性加以完成, 是许多系统调用的以正确完成的必要条件&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;竞争状态是这样一种情形：操作共享资源的两个进程或线程，结果取决于 一个无法预期的顺序，即这些进程获取CPU使用权的先后相对顺序&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;open, 保证进程是打开文件的创建者，对文件是否存在的检查和创建文件属于同一原子操作。 flags: O_CREAT&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;fcntl: fcntl(fd, cmd,…) 该调用对一个打开的文件描述符执行一系列控制操作。用途之一: 对一个打开的文件， 获取或修改其访问模式和状态标志。通过open也可以设定，所以fcntl针对已经打开的文件描述符，1）文件不是由调用程序打开的， 2）通过open之外的系统调用获取的， 比如pipe，socket， 等。 示例代码&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight c"&gt;&lt;code&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;flags&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;accessMode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="n"&gt;flags&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fcntl&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;F_GETFL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 获取flags
&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;flags&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="n"&gt;errExit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"fcntl"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
 &lt;span class="n"&gt;flags&lt;/span&gt; &lt;span class="o"&gt;|=&lt;/span&gt; &lt;span class="n"&gt;O_APPEND&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// operate flags
&lt;/span&gt; &lt;span class="n"&gt;fcntl&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;F_SETFL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;flags&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;// set flags   
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;p&gt;因为 O_RDONLY, OWRONLY, O_RDWR, 因为历史原因，数值为0,1,2所以不能简单的使用 &amp;amp; 来判断是否存在对应的标记位， 如下为正确的做法&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight c"&gt;&lt;code&gt;  &lt;span class="n"&gt;accessmode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;flags&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;O_ACCMODE&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;accessmode&lt;/span&gt; &lt;span class="o"&gt;===&lt;/span&gt; &lt;span class="n"&gt;O_WRONLY&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;accessMode&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;O_RDWR&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;accessmode&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;O_RDONLY&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="n"&gt;prinf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"xx"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/li&gt;
  &lt;li&gt;文件描述符与文件的关系&lt;/li&gt;
  &lt;li&gt;结构
    &lt;ul&gt;
      &lt;li&gt;进程级别的文件描述符，记录的标志有 close-on-exec, 并指向到系统级 文件表&lt;/li&gt;
      &lt;li&gt;系统级 文件表： 记录了: 文件偏移量， 打开文件的状态标记（open flags）, 文件访问模式，与信号驱动IO相关的g设地年， 对该文件I-node对象的引用&lt;/li&gt;
      &lt;li&gt;文件系统的i-node表: 文件类型，一个指针，指向该文件所持有的锁列表， 文件的各种属性（包括文件大小， 已经时间戳）。 区分与磁盘中的i-node，这里是内存的i-node， 访问文件时候，会在内存中为i-node创建一个副本，其中记录了引用i-node的打开文句柄的数量，以及所在设备的主从设备等。
        &lt;ul&gt;
          &lt;li&gt;[ ] 添加指向 csapp的图片&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;文件设计的这些特点，可以产生如下的总结：
    &lt;ol&gt;
      &lt;li&gt;两个不同文件描述符， 若指向同一个文件句柄(系统及的文件表)将共享同一个文集偏移量。通过其中一个更改偏移量，另外一个可以观察到该变化，无论两个描述符在不同进程还是统一进程，亦或线程。&lt;/li&gt;
      &lt;li&gt;fcntl 操作的作用域 同 1相同&lt;/li&gt;
      &lt;li&gt;对应的 文件描述符的 close-on-exec 因为存储在进程级别， 所以并不会影响到其他进程。&lt;/li&gt;
      &lt;li&gt;cat log.log &amp;gt; result.log 2&amp;gt;&amp;amp;1 shell通过复制 文件描述符2实现了标准错误的重定向操作。因为描述符2同1指向同一个文件句柄，所以输出不会产生覆盖彼此的问题。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;复制文件描述符
    &lt;ul&gt;
      &lt;li&gt;dup(int oldfd), 复制一个打开的文件描述符oldfd， 并返回一个新的描述符， 两者指向同一个文件句柄，系统保证新描述符一定是编号值最低的未用的文件描述符。意味着dup(1)会产生3&lt;/li&gt;
      &lt;li&gt;dup2(oldfd, newfd)： 系统调用会创建oldfd的副本，编号由newfd决定， 如果newfd已经打开，会先将其关闭，然后返回newfd指定的编号的文件描述符。（所以dup2(调用了那个接口，来产生特定编号的文件描述符。)） 但是dup2关闭newfd时候会忽略错误， 所以 最好手动关闭newfd,&lt;/li&gt;
      &lt;li&gt;pread, pwrite(fd, buf, count, offset)： 区别于 read, write的地方在于， pread, pwrite 会在指定的offset进行操作，并且不会改变文件的偏移量。这些特性是的 使得在多线程应用非常便利，多个进程可以同时操作同一个描述符。而不会互相影响。如果使用lseek， read调用引起竞争状态。使得编写正确的IO代码变得困难。&lt;/li&gt;
      &lt;li&gt;分散输入和集中输出, (scatter-gather IO), readv, writev&lt;/li&gt;
      &lt;li&gt;截断: truncate(char * pathname, length), ftruncate(fd, length): 若文件长度&amp;gt; length 丢弃超出部分， &amp;lt; length, 将在文件尾部添加一系列空字节或者文件空洞(版本实现比一样吗？)其中 truncat 通过字符串指定名字但是依然需要文件的写权限。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;非阻塞IO： 1) open 指定 O_NONBLOCK, 2） socket因为无法通过open来获取文件描述符， 所以需要使用fcntl来启动非阻塞标志。&lt;/li&gt;
  &lt;li&gt;-【】大文件&lt;/li&gt;
  &lt;li&gt;/dev/fd: 是一个连接到 /proc/PID/fd 目录的一个符号连接， 该目录中的每一个目录都连接到 /proc/PID/fd中的目录，一一对应&lt;/li&gt;
  &lt;li&gt;临时文件：mkstemp(char * template), tmpfile(): 打开文件使用了O_EXCL 以保证独占使用文件。两者区别在于 mkstemp()之后需要unlink(char* template), 在close(fd) 之后自动删除， tmpfile 则无需调用unlink, close之后 自动删除（内部自动调用unlink）&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="进程"&gt;进程&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;进程 是可执行程序的实例&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;进程号 和 父进程号： 每个进程都有一个PID， 唯一标识 某个进程，除了少数(init PID 为1) 之外，多数程序与运行该程序的进程PID没有固定关系。 linux内核限制 进程号小于 32767,当进程号达到这个限制时候，内核将重置进程号计数器，重新从最小的整数开始分配。（进程号计数器会重置为 300， 因为 低于此数值的进程号 为系统进程和守护进程 长期占用， 关于最大进程号 默认上限是 32767,, 但是可以通过更改 /proc/sys/kernel/pid_max 来进行更改=最大值+1， 64位最大进程号为2 22次方 为什么？）getppid可以获取进程的父PID， 可以通过pstree， 来查看家族树。&lt;/li&gt;
  &lt;li&gt;命令行参数 argc, argv：argc 表示命令行参数的个数，argv 是一个指向 命令行参数的指针数组，每一个参数指向一个以null结尾的字符串。其中argv[0] 包含了 调用程序的名称。可以为一个程序创建多个连接，然后argv[0]的名字是不同的。&lt;/li&gt;
  &lt;li&gt;环境列表： 每个进程都有与之相关的字符串数组成为环境列表(envoriment list), 每个字符串都以 name=value 的形式定义。常常将name称为环境变量。新创建进程会继承父进程的环境副本，因为获得是副本，随意之后父子环境信息个不相关。
    &lt;ul&gt;
      &lt;li&gt;export NAME=value: 将NAME变量添加到shell环境中, 此后这个shell所创建的进程中都存在变量NAME&lt;/li&gt;
      &lt;li&gt;NAME=value programe: 在应用程序 programe的环境变量中添加一个变量值，但是不影响shell&lt;/li&gt;
      &lt;li&gt;printenv： 显示当前的环境列表&lt;/li&gt;
      &lt;li&gt;/proc/PID/environ: 文件显示编号为PID的进程的环境列表&lt;/li&gt;
      &lt;li&gt;getenv(char *name): 获取环境变量的数值(value), 不存在返回NULL&lt;/li&gt;
      &lt;li&gt;putenv(char *string): 添加一个 name=value 形式字符串的环境变量，失败返回非0值。一位内putenv 添加到environ变量的是一个指针，而不是string 的副本，所以不应该在栈上分配&lt;/li&gt;
      &lt;li&gt;setenv(char * name, char *value, overwrite): 该函数会复制 name, value。函数会自动拼接=号，overwrite ！= 0 总会写入， overwrite = 0时，存在则不写入，不存在写入&lt;/li&gt;
      &lt;li&gt;unsetenv&lt;/li&gt;
      &lt;li&gt;clearenv&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ABI, 应用程序二进制接口，一套规则。 规定了二进制可执行文件在运行时应该如何与某些服务（诸如内核或函数库所提供的服务）交换信息， ABI特别规定了使用那些寄存器和栈地址交换信息以及所交换数值的含义，一旦针对某个特定ABI进行了编译，其二进制可执行文件应该能在ABI相同的任何系统上运行。与之想法，标准化的API仅能通过编译源代码来保证应用程序的可移植性。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="内存分配"&gt;内存分配&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;在堆上分配内存， 进程呢个可以通过增加堆的大小来分配内存， 堆就是一段长度可变的连续的虚拟内存，初始于 进程未初始化的数据段末尾，随着内存的分配和释放而增减。通常将堆当前内存边界成为 program break
    &lt;ul&gt;
      &lt;li&gt;brk(vodi * end_data_segment), sbrk(int increment), 两个系统调用可以改变 program break 的位置， 位置调升以后，程序可以访问新分配区域内的任何内存地址。内核会在进程首次访问新分配的地址时，会自动分配实际的物理内存页。brk 直接改变 program break 的地址， sbrk 增量的改变 break 地址， 在原有的 break 地址上 增加increment 的空间，函数返回之前的break地址，也就是新分配的地址空间的起始处，sbrk(0) 返回现有的 program break 地址。&lt;/li&gt;
      &lt;li&gt;malloc(size_t size), free(void * ptr)： 库函数(建立在系统调用， brk, sbrk的基础上封装而成)，比较与系统调用， 库函数拥有不少的优点， 明显的有 &lt;strong&gt;允许随意的释放内存块，他们被维护于一张空闲的内存列表中，在后续的内存分配调用时候循环使用&lt;/strong&gt;,
        &lt;ol&gt;
          &lt;li&gt;malloc: 分配成功返回void* 类型指针， 因为void类型所以可以随意使用， 调用失败可能是因为program break 已经触顶，（已经没有堆空间可以分配） 则返回NULL， 虽然出错的概率很小，但是依然需要进行错误检查。&lt;/li&gt;
          &lt;li&gt;free： 函数释放ptr所指向的内存块，一般情况下， free并不会降低 program break 的位置， 而是将该内存块放入到空闲的内存列表中，以便供后续的malloc使用。有如下的好处， 1）尽量的减少了 sbrk的系统调用此处&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;调用free还是不呢？: 当进程终止时， 所有的内存都会返回给操作系统，基于内存的这一自动释放机制，对于那些分配内存并持续使用的程序而言，可以忽略free，因为在多次调用free时候不但消耗大量的cpu时间，还是使代码趋向于复杂。&lt;/li&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;malloc, free 的实现: 数据结构为 双向链表， len&lt;/td&gt;
              &lt;td&gt;pre&lt;/td&gt;
              &lt;td&gt;next&lt;/td&gt;
              &lt;td&gt;space&lt;/td&gt;
              &lt;td&gt;其中len 表示该空闲内存块 的大小， pre,next 为双向链表指针，指向上一个下一个空闲内存块， space为空闲内存&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
        &lt;ol&gt;
          &lt;li&gt;malloc(size_t size) 会扫描空闲链表，以找到适合大小的内存块
            &lt;ul&gt;
              &lt;li&gt;空闲链表中的len == size 时，则直接返回给z调用者&lt;/li&gt;
              &lt;li&gt;len &amp;gt; size: 对其切割（将会出现一个合适大小的内存块+一个空闲的内存块）&lt;/li&gt;
              &lt;li&gt;len &amp;lt; size: 没有找到符合要求的内存块时，调用sbrk 重新分配适合的内存块（为了更少的系统调用sbrk, 通常mallock 会以更大的increment 调用sbrk ）&lt;/li&gt;
              &lt;li&gt;更新 空闲块链表&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;free(void * ptr) : free函数通过 ptr 内存块中 len来知道内存块大小，然后加入到 空闲块链表中。&lt;/li&gt;
          &lt;li&gt;因为free， malloc的实现导致， 1）ptr指针需要完全正确，以避免对空闲链表的错误操作。（非malloc返回的指针，绝不能调用free）， 2）不能重复释放同一个指针&lt;/li&gt;
          &lt;li&gt;除了mallock, C函数库还提供了其他的 内存分配算法版本的 内存分配函数实现。 calloc, realloc, memalign, posix_memalign, alloca（该函数从栈上分配内存，因为栈的特殊性使其有两个特点 1）只有当调用函数的位于顶部时候可用 2）不需要free， 因为函数返回时代码会重置栈指针。）&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="用户和组"&gt;用户和组&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;每个用户都存在唯一的UID， 并可以归属于多个GID&lt;/li&gt;
  &lt;li&gt;UID， GID 的主要用途有 1）确定各种系统资源的所有权， 2）对进程的操作资源的权限加以控制&lt;/li&gt;
  &lt;li&gt;/et/passwd, 用于记录用户相关的UID， home, shell etc等。 /etc/shadow 维护对应UID的加密密码。组文件 /etc/group, 维护GID， 以及对应的用户列表，&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="进程凭证"&gt;进程凭证&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;每个进程都有一套数字表示UID和GID 具体如下：
    &lt;ol&gt;
      &lt;li&gt;real user id, real group id, 实际用户id，实际组id， 确定了进程所属的用户和组，作为登陆过程之一，登陆shell 从/etc/passwd中读取相应用户密码记录的3，4字段，设定为其实际用户id &amp;amp; 组id，当创建进程时，将从父进程中继承这些&lt;/li&gt;
      &lt;li&gt;effective user id, effective group id, 有效用户id， 有效组id。 系统通常通过结合有效用户id，组id 连同辅助组id 来授予进程权限。&lt;/li&gt;
      &lt;li&gt;saved user id, saved group id, 保存的用户id， 保存的组id&lt;/li&gt;
      &lt;li&gt;file-system user id, file-system group id, 文件系统用户id， 文件系统组id&lt;/li&gt;
      &lt;li&gt;辅助组id&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;set-user-id, set-group-id 程序， set-user-id 程序会将进程的有效用户id设为可执行文件的用户id， 从而获得不具备的权限。set-group-id 程序有类似的效果。可执行文件拥有两个特别的权限位 set-user-id和set-group-id位，（实际上所有文件都有，只有可执行文件比较有用）ls -l program, x 变成 代表 拥有set-user-id or set-group-id. 当运行set-user-id程序时候，内核会将进程的有效用户id变为可执行文件的用户id， set-group-id 执行类似的操作。 linux系统中常用的passwd, mount, unmount, wall(用户向tty组下所有终端写入消息)等都为set-user-id程序(set-user-id-root 来特指 root用户所拥有的 set-user-id 程序)&lt;/li&gt;
  &lt;li&gt;保存用户id(saved-user-id) 当执行程序时，会发生如下事情：
    &lt;ol&gt;
      &lt;li&gt;可执行文件的set-user-id权限位开启，将进程等的有效用户id 设定为 可执行文件的属主，未设定则进程有效用户id不变&lt;/li&gt;
      &lt;li&gt;复制 有效id 到 set-user-id&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;有不少的系统调用，允许将set-user-id 程序的有效用户id在实际用户id和保存set-user-id之间切换。对于与执行文件用户id相关的任何权限，程序能够随时在两种状态间切换。&lt;/li&gt;
  &lt;li&gt;文件系统用户id： 在进行linux中 打开文件、改变文件属主 、修改文件权限之类的文件操作时，决定其操作权限的是 文件系统用户id， 而非 有效用户id。通常 文件系统用户id和组id都等于相应的有效用户和组id， 并且只要有效用户id发生变化，相应的文件系统用户id也会发生变化，只有linux特有的两个系统调用setfsuid(), setfsgid()才能刻意的制造出 文件系统用户id 不等于 有效用户id。因此   大部分情况下，可以忽视文件系统用户id，等同于检查 有效用户id&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;[ ] 完成对应的系统调用&lt;/li&gt;
  &lt;li&gt;[ ] 如何在进程中调用 特权程序?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="时间"&gt;时间&lt;/h2&gt;
&lt;p&gt;大多数计算机体系结构都内置有硬件始终，是的内核得以计算真实时间和进程时间。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;日历时间: Unix 系统内部对时间的表示，以 Epoch以来的秒数来度量（UTC 时间）。存储于time_t类型的变量中。（time_t是一个有符号整数 理论上当前许多的32位unix系统都面临着一个2038 的理论问题，如果执行的计算工作涉及到未来时间，那么在2038年问题都会出现，事实上在此之前所有的unix系统可能都已经升级到了64位系统，然而32位嵌入式系统的寿命要长的多，依然面临着这个问题）
    &lt;ul&gt;
      &lt;li&gt;gettimeofday(timeval *tv, timezone *tz): struct timeval { time_t tv_sec; suseconds_t tv_usec;} 其中 tv_usec提供了微秒级别的精度，参数tz是一个历史产物，应该总为NULL，&lt;/li&gt;
      &lt;li&gt;time_t time(time_t *timep): 函数有两种方式返回同样的结果， UTC秒数， timep 不为NULL，将秒数放在timep 的指针中， timep NULL返回一个数值&lt;/li&gt;
      &lt;li&gt;时间转换函数： 类型包含如下 time_t， 打印格式， 分解时间(即是： struct tm {int tm_sec; int tm_min; int tm_hour; int tm_mday; int tm_year; int tm_mon; etc})， 转换函数即是 用来在上面的类型中 进行转换的函数，方便使用。其中包括， strftime, mktime, gmtime, localtime 等。&lt;/li&gt;
      &lt;li&gt;时区： 时区信息被系统使用标准格式保存于文件中。 /usr/share/zoneinfo, 该目录中的每个文件都包含了一个特定国家或地区的时区制度，系统的本地时间在 /etc/localtime 中定义，通常链接到 /usr/share/zoneinfo中的一个文件。使用TZ环境变量来为一个程序指定时区，其值为 “:“ + 时区名称组成的字符串。设定时区会自动影响到 ctime, locatime, mktime, strftime 等，&lt;/li&gt;
      &lt;li&gt;setlocale(int category, char * locale) : 设定和查询程序的当前地区, category 可选项为 表中的数值 + LC_ALL, LANG, LANGUAGE, 其中，LC_ALL 为设定所有值而准备， LANG为设定所有为明确指定的变量而准备. setlocale 参数中的locale可以为 “”空字符串，表示可以从环境变量中却的地区的设定， 大部分的程序代码 setlocale(LC_ALL, “”) 来使用程序中的环境变量设定地区，如果调用被省略，这些环境变量将不会对程序的地区设定生效。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;文件名&lt;/td&gt;
          &lt;td&gt;目的&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;LC_TYPE&lt;/td&gt;
          &lt;td&gt;包含字符分类以及大小写转换规则&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;LC_COLLATE&lt;/td&gt;
          &lt;td&gt;包含针对一字符集的排序规则&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;LC_MONETARY&lt;/td&gt;
          &lt;td&gt;对货币格式化规则&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;LC_NUMERIC&lt;/td&gt;
          &lt;td&gt;对货币意外的数字格式化规则&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;LC_TIME&lt;/td&gt;
          &lt;td&gt;对日期和时间的格式化规则&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;LC_MESSAGES&lt;/td&gt;
          &lt;td&gt;针对肯定和否定响应，就格式以及数值做了规定&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;进程时间:&lt;br /&gt;
&lt;strong&gt;软件时钟： 进程时间受限于 系统软件时钟的分辨率，度量单位 为jiffies（定义在内核代码中的常量HZ, jiffies 为1s内 cpu增加的记数，100HZ(jiffies) 时候， 1 jiffies(hz) 的时间为10毫秒）这是内核按照round-robin的分时调度算法分配cpu进程的单位。因为CPU 的速度大大提高，2.6.0的内核时钟速度已经提高了1000hz， 更高的分辨率意味着更高的时间精度，然而并非可以任意的提高时钟频率，因为每个时钟中断都对耗费少量的CPU时间&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;用户CPU时间： 在用户模式下执行所花费的时间数量&lt;/li&gt;
      &lt;li&gt;系统CCPU时间： 在内核模式中执行所花费的时间数量&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="系统和进程信息"&gt;系统和进程信息&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;为了提供简单的方法来访问内核信息， 现在的UNIX实现提供了一个/proc 虚拟文件系统（并非存储于磁盘上，恶热是内核在进程访问信息时候动态生成的），其中包含了各种用于展示内核信息的文件。并允许进程通过常规的IO系统调用来访问，有些还可以对信息进行修改。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;/proc/PID： 内核提供了对应PID进程的目录结构，&lt;/p&gt;

    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;文件&lt;/td&gt;
          &lt;td&gt;描述&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;cmdline&lt;/td&gt;
          &lt;td&gt;以 \0分割的命令行参数&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;cwd&lt;/td&gt;
          &lt;td&gt;指向当前工作目录的符号连接&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;Environ&lt;/td&gt;
          &lt;td&gt;NAME=value 键值对的环境列表&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;exe&lt;/td&gt;
          &lt;td&gt;指向正在执行文件的符号连接&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;fd&lt;/td&gt;
          &lt;td&gt;文件目录包含了指向由进程打开文件的符号连接&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;maps&lt;/td&gt;
          &lt;td&gt;内存映射&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;mem&lt;/td&gt;
          &lt;td&gt;进程虚拟内存&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;mounts&lt;/td&gt;
          &lt;td&gt;进程的安装点&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;root&lt;/td&gt;
          &lt;td&gt;指向根目录的符号链接&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;status&lt;/td&gt;
          &lt;td&gt;各类信息&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;/proc/PID/fd： 目录 为进程打开的每个文件描述符都包含了一个符号连接，每个符号连接的名称都与描述符的数值向匹配（/proc/pid/1 为 标准输出）， 任何进程都可以使用符号连接 /proc/self 来访问自己的/proc/PID 目录&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;/proc 目录下的系统信息:&lt;/p&gt;

    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;目录&lt;/td&gt;
          &lt;td&gt;描述&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;/proc/net&lt;/td&gt;
          &lt;td&gt;网路和套接字的状态信息&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;/proc/sys/fs/&lt;/td&gt;
          &lt;td&gt;文件系统相关的设定&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;/proc/sys/kernel/&lt;/td&gt;
          &lt;td&gt;各种常规的内核设定&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;/proc/sys/net&lt;/td&gt;
          &lt;td&gt;网络和套接字设定&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;/proc/sys/vm/&lt;/td&gt;
          &lt;td&gt;内存管理设定&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;uname(utsname * utsbuf): 系统调用返回主机系统的标识信息&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="文件io缓冲"&gt;文件IO缓冲&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;出于效率的考虑， 系统IO调用，以及 函数库IO函数，都在文件IO操作中对数据进行了缓冲&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>linux-interface-02</title>
    <link rel="alternate" href="http://geniousbar.github.io/2018/12/06/linux-interface-02/"/>
    <id>http://geniousbar.github.io/2018/12/06/linux-interface-02/</id>
    <published>2018-12-06T08:00:00+08:00</published>
    <updated>2018-12-31T15:41:43+08:00</updated>
    <summary type="html">&lt;h2 id="the-linux-programming-interface"&gt;The linux programming interface&lt;/h2&gt;

&lt;h2 id="系统编程概念"&gt;系统编程概念&lt;/h2&gt;

&lt;p&gt;无论何时，执行了系统调用或者库函数，检查调用的返回状态以确定调用是否成功,是一条编程铁律。(消灭nil就好了)&lt;/p&gt;

&lt;h3 id="系统调用"&gt;系统调用&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;借助这一机制，进程可以请求内核以自己的名义去执行动作，以API 的形式，内核提供一系列服务供程序访问。（创建进程， IIO操作等）可以参考 csapp中的 异常控制流章节。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;系统调用有以下特征：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;系统调用将CPU 从用户态切换到 内核态，以便CPU访问受保护的内存等（越过...&lt;/li&gt;
&lt;/ol&gt;</summary>
    <content type="html">&lt;h2 id="the-linux-programming-interface"&gt;The linux programming interface&lt;/h2&gt;

&lt;h2 id="系统编程概念"&gt;系统编程概念&lt;/h2&gt;

&lt;p&gt;无论何时，执行了系统调用或者库函数，检查调用的返回状态以确定调用是否成功,是一条编程铁律。(消灭nil就好了)&lt;/p&gt;

&lt;h3 id="系统调用"&gt;系统调用&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;借助这一机制，进程可以请求内核以自己的名义去执行动作，以API 的形式，内核提供一系列服务供程序访问。（创建进程， IIO操作等）可以参考 csapp中的 异常控制流章节。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;系统调用有以下特征：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;系统调用将CPU 从用户态切换到 内核态，以便CPU访问受保护的内存等（越过保护机制）&lt;/li&gt;
  &lt;li&gt;系统调用的组成是固定的。每个系统调用都由一个唯一的数字来标识。（程序通过名称标识系统调用，对编号方案无需关心）&lt;/li&gt;
  &lt;li&gt;每个系统调用都有一套对应的参数，对用户态内核态的参数传递有一定规范&lt;br /&gt;
  下面是一个系统调用的示例：&lt;/li&gt;
  &lt;li&gt;应用程序调用C语言的函数库中的外壳（wrapper） 函数，来发起系统调用&lt;/li&gt;
  &lt;li&gt;外壳函数保证所有的系统调用参数可用，并将参数复制到寄存器&lt;/li&gt;
  &lt;li&gt;外壳函数会将系统调用编号复制到%eax中，用于区分不同的系统调用&lt;/li&gt;
  &lt;li&gt;外壳函数执行一条中断机器指令，引发CPU从用户态切换到内核态，并执行 todo&lt;/li&gt;
  &lt;li&gt;内核调用 system_call 来处理中断，&lt;br /&gt;
    1) 在内核栈中保存寄存器数值&lt;br /&gt;
    2）验证 系统调用的 编号有效性&lt;br /&gt;
    3) 通过系统调用编号 发现对应的系统调用服务例程，检查参数的有效性，执行对应的代码逻辑。最后将结果状态返回给system_call&lt;br /&gt;
    4) 从内核栈中回复各个寄存器值，并将系统调用返回值置于栈中&lt;br /&gt;
    5) 返回值外壳函数，通知讲CPU切换到用户态&lt;/li&gt;
  &lt;li&gt;系统调用的服务例程返回值代表调用有误， 外壳函数会使用该值设定全局变量errno。外壳函数会返回到调用程序，并返回一个整数，标志系统调用是否成功。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="库函数"&gt;库函数&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;库函数 的设计 是为了提供比底层系统 调用更为方便的调用接口,例如 printf函数 可提供格式化输出和数据缓存， 而write 系统调用只能输出 字节块， malloc, free 函数包装了 内存的释放和分配工作&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id="处理错误"&gt;处理错误&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;几乎所有的 系统调用都会返回某种类型的错误,用以表明 调用成功与否，要了解是否调用成功则必须坚持对状态进行检查。若调用失败则必须采取相应的行动，至少应该输出错误。 不检查状态，少写几行代码，听起来很诱人。实际上却会浪费掉大把的程序调试时间&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;这段陈述适用于 任何领域的编程工作， 简单的就是 人们常讲的 nil是一个百万的设计错误 一样。nil让他们忽略对他的检查，因为假定 变量不是nil的代码很清爽，可以减少很多的if判断，造成了nil是一个非常常见，频率高的错误。 那么正确的设计应该是什么样子呢？ 答案或许是Option + 强制类型（弱类型语言不必要了，因为没有人可以阻止你不检查错误）&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;系统错误处理&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;通常返回值为-1 表示出错，系统调用失败后， 会将全局变量设定 errno 设定为一个正值来标记具体错误。但是如果系统调用和库函数成功，errno并不会被重置为0，所以单独的检查errno的设定来判断错误是错误的，因为可能是上个调用错误设定的数值。少数系统调用 在调用成功后(getpriority)依然返回-1， 要判断此类错误需要调用前将errno 设定为0， 然后根据errno判断是否错误。&lt;br /&gt;
 打印错误， perror(“string”), char *strerror(int errorcode), strerror返回的字符串 指针是静态分配的，后续的调用会覆盖之前的调用。两个函数都是 locale-sensitive 语言环境敏感型，所以现实的是本地语言。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;库函数的错误处理&lt;br /&gt;
&lt;strong&gt;不同的库函数在调用发生错误时候，返沪的数据类型和数值也各不相同，可以划分为几个类型:&lt;/strong&gt;&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;同系统调用完全相同, (remove 会调用unlink 或者rmdir)&lt;/li&gt;
      &lt;li&gt;出错时会返回-1之外的其他值，然后设定errno表明出错的具体情况 (fopen 出错返回 NULL 指针，同时设定errno)&lt;/li&gt;
      &lt;li&gt;根本不使用errno&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</content>
  </entry>
  <entry>
    <title>linux-interface</title>
    <link rel="alternate" href="http://geniousbar.github.io/2018/11/11/linux-interface/"/>
    <id>http://geniousbar.github.io/2018/11/11/linux-interface/</id>
    <published>2018-11-11T08:00:00+08:00</published>
    <updated>2018-12-05T14:56:41+08:00</updated>
    <summary type="html">&lt;h2 id="the-linux-programming-interface"&gt;The linux programming interface&lt;/h2&gt;

&lt;h2 id="基本概念"&gt;基本概念&lt;/h2&gt;

&lt;h3 id="内核"&gt;内核&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;通常的定义，1）完整的软件包， 这包括用来管理计算机资源的核心软件 以及附带的标准软件工具（shell，图形用户界面， 文件工具）2) 狭义的层面，是指管理和分配计算机资源的核心软件&lt;/li&gt;
  &lt;li&gt;职责: 1）进程调度， 2）内存管理， 3）文件系统， 4）创建和终止进程， 5）设备管理， 6）联网， 7）提供系统调用的编程接口&lt;/li&gt;
  &lt;li&gt;内核态、用户态: 区分态的原因： 1）只有cpu处于内核态的时候，才能执行某些...&lt;/li&gt;
&lt;/ol&gt;</summary>
    <content type="html">&lt;h2 id="the-linux-programming-interface"&gt;The linux programming interface&lt;/h2&gt;

&lt;h2 id="基本概念"&gt;基本概念&lt;/h2&gt;

&lt;h3 id="内核"&gt;内核&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;通常的定义，1）完整的软件包， 这包括用来管理计算机资源的核心软件 以及附带的标准软件工具（shell，图形用户界面， 文件工具）2) 狭义的层面，是指管理和分配计算机资源的核心软件&lt;/li&gt;
  &lt;li&gt;职责: 1）进程调度， 2）内存管理， 3）文件系统， 4）创建和终止进程， 5）设备管理， 6）联网， 7）提供系统调用的编程接口&lt;/li&gt;
  &lt;li&gt;内核态、用户态: 区分态的原因： 1）只有cpu处于内核态的时候，才能执行某些命令， 例如 halt etc， 2）区分进程以及内核，能够让开发者 以面向进程的方式来编写 软件。 通过进程隔离 硬件计算机资源&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="用户和组"&gt;用户和组&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;用户, 唯一的登录名和与之对应的整数型用户ID， 系统密码文件 /etc/passwd,为每个用户记录一行， 包含信息主要有: 组 ID， 主目录， 登录shell&lt;/li&gt;
  &lt;li&gt;组, 系统组文件 /etc/group, 包含信息主要有: 组名， 组 ID， 用户列表&lt;/li&gt;
  &lt;li&gt;超级用户， ID 为 0，可以不受系统权限检查之上。 可以访问系统的所有文件， 能发送信号给其他用户的进程&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="单根目录层级目录链接文件"&gt;单根目录层级、目录、链接、文件&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;内核维护者一套单根目录结构， 放置系统的所有文件， /根目录 图 &lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;文件类型: 1） 普通文件， 2）设备， 3）管道， 4）套接字， 5）目录以及符号链接&lt;/li&gt;
  &lt;li&gt;路径和链接(hard link)， 一个文件可以有多个链接，目录可以包含 文件 + 目录， 每个目录至少有两个链接， .和..  指向目录自身的链接，已经指向上级目录的链接，根目录 “/”，的..指向自身&lt;/li&gt;
  &lt;li&gt;符号链接(soft link), 普通链接（hard link）的内容为 文件名+指针 的一条记录， 符号链接则是： 经过特殊标记的文件， 文件 + 目标文件字符串。多数情况下， 系统调用到了 路径名，如果是符号链接的情况下， 内核会自动 以符号链接 所指向的文件名来替换符号链接。递归的进行解析，为了防止循环解析， 内核对解析次数进行了限制。&lt;/li&gt;
  &lt;li&gt;文件名， 文件名应该避免以-字符串开头，避免 误认为命令选项开关&lt;/li&gt;
  &lt;li&gt;路径名： 绝对路径, 相对路径（定义了相对于进程当前工作目录的文件位置）当前工作目录（每个进程都有一个当前工作目录， 也是进程解释相对路径名的参照点， 进程的当前工作目录继承自 父进程， 相对登录shell来说 其初始当前工作目录为 密码文件 /et/passwd 中指定的，可以使用cd 改变）&lt;/li&gt;
  &lt;li&gt;文件的所有权：系统将用户分为3类， 文件的属主、文件属组成员、其他用户， 目录也可以设定所有权，但是意义有所不同，读写 允许列出目录内容， 写 允许对目录内容更改， 执行 允许对目录文件进行访问&lt;/li&gt;
  &lt;li&gt;文件IO模型， 同一套系统调用（open、read、write、close等）所执行的IO操作，可以应用于所有文件类型， 本质而言， 内核只提供一种文件类型， 字节流序列&lt;/li&gt;
  &lt;li&gt;文件描述符： 非负整数，来指代 打开的 文件。通常shell启动的进程会继承 3个已经打开的文件描述符， 0 为标准输入， 1 标准输出， 2 标准错误。在stdio函数库中， 分别与 stdin, stdout, stderr一一对应&lt;/li&gt;
  &lt;li&gt;stdio 函数库: C 语言标准库的IO函数，例如fopen， fclose， printf 等，注意stdio 函数建立在 系统调用write， open close read之上&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="进程"&gt;进程&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;进程是 正在执行的 程序实例， 执行程序时，内核会将程序代码再入到 虚拟内存， 为程序变量 分配空间，建立内核记账结构，用以记录进城有关的各种信息（PID， 状态）&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;进程的内存布局， 逻辑上： 文本， 数据，堆，栈&lt;/li&gt;
  &lt;li&gt;创建和执行程序， fork， 子进程会从父进程继承数据段、栈、堆 的副本，修改其内容，不会影响父进程。文本段则为父子进程共享。子进程要么继续执行父进程代码，要么执行execve 去加载一个全新的程序，execve会销毁现有的文本段、数据段、堆、栈，根据程序的代码重新创建并替换他们&lt;/li&gt;
  &lt;li&gt;Pid &amp;amp;&amp;amp; PPID: PPID 为父进程PID&lt;/li&gt;
  &lt;li&gt;进程终止和终止状态：两种方式杀死进程：1）exit() 系统调用请求退出， 2）向进程传递信号，将其杀死。无论那种方式进程退出，都会生成 『终止状态』一个非负数 小整数。可供父进程的wait 系统调用检测。exit()可以传递参数设定 终止状态， 信号杀死进程，则由信号类型设定进程的终止状态。， 0表示 功成身退， 非0 表示错误&lt;/li&gt;
  &lt;li&gt;进程标识：1）真实用户ID， 组ID，子进程继承父进程的 这些ID。登录shell，从/etc/passwd 中获取真实用户ID， 2）有效用户ID 组ID， 进程在访问受保护资源时候，会使用这两个ID来确定权限。3）补充组，用来表示进程所属的额外组。&lt;/li&gt;
  &lt;li&gt;init 进程： 所有进程之父，相应的程序文件为/sbin/init, 并且以root权限运行，只有关闭系统才能杀死该进程。&lt;/li&gt;
  &lt;li&gt;守护进程：特殊用途的进程。特征， 1）守护进程通常在系统引导时启动， 直至系统关闭。2）在后台运行，无控制端 供其读取或者写入数据。（例如syslogd， httpd）&lt;/li&gt;
  &lt;li&gt;环境列表： 每个进程都有一份环境列表。fork创建的新进程会继承父进程的环境列表。这为父子进程 提供了一种通讯机制。进程调用fork， exec 可以通过环境列表来控制程序 行为。&lt;/li&gt;
  &lt;li&gt;资源限制：分为两类， soft limit, hard limit, 非特权进程调整 soft limit 只能在 0 - hard limit 之间， hard limit 只能调低。fork同样会继承父进程的limit&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="进程间通信及同步"&gt;进程间通信及同步&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;信号: 表示事件的发生&lt;/li&gt;
  &lt;li&gt;管道: shell 中的 |， 以及FIFO&lt;/li&gt;
  &lt;li&gt;套接字: socket&lt;/li&gt;
  &lt;li&gt;文件锁&lt;/li&gt;
  &lt;li&gt;消息队列: 用于在进程间交换消息&lt;/li&gt;
  &lt;li&gt;信号量: 用于同步&lt;/li&gt;
  &lt;li&gt;共享内存: 允许两个及以上的进程共享同一块内存， 当进程改变了共享内存的内容时候， 其他进程会了解这一变化。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="信号"&gt;信号&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;软中断， 进程受到信号，意味着事件、错误异常的发生。信号类型有很多，采用不同的整数进行区分。以SIGxxxx的形式进行命名。&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;信号产生的情况有：
    &lt;ol&gt;
      &lt;li&gt;用户键入中断Ctrl-C&lt;/li&gt;
      &lt;li&gt;进程的子进程之一终止&lt;/li&gt;
      &lt;li&gt;进程设定的定时器 已到期&lt;/li&gt;
      &lt;li&gt;etc …&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;信号处理：
    &lt;ol&gt;
      &lt;li&gt;信号从产生到送到期间，出去挂起状态。系统通常会在进程下次获得调度时，将挂起信号 送达。如果进程在运行中，则会立即将信号送达。&lt;/li&gt;
      &lt;li&gt;进程可以选择 接受、屏蔽信号。如果送达的信号处于屏蔽信号，此信号将一直挂起，直到 程序解除对信号的屏蔽&lt;/li&gt;
      &lt;li&gt;收到信号的动作有： 1）忽略信号、默认动作、设定自己的信号处理器， 2）被信号杀死， 3）挂起，之后使用专门的信号 唤醒&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>redis-rb</title>
    <link rel="alternate" href="http://geniousbar.github.io/2018/09/16/redis-rb/"/>
    <id>http://geniousbar.github.io/2018/09/16/redis-rb/</id>
    <published>2018-09-16T08:00:00+08:00</published>
    <updated>2018-11-09T09:07:10+08:00</updated>
    <summary type="html">&lt;h2 id="redis-rb-为ruby-连接redis的客户端"&gt;redis-rb 为ruby 连接redis的客户端&lt;/h2&gt;

&lt;h4 id="项目结构"&gt;项目结构&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;项目本身依赖于 hiredis，而hiredis 本身是一个redis client c的包装。并没有搞懂为什么需要依赖redis client&lt;/li&gt;
  &lt;li&gt;项目目录结构如下&lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;  /lib
    |---- redis.rb
    |---- /Redis
          |---- connection.rb
          |---- errors.rb
          |---- pipeline.rb...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</summary>
    <content type="html">&lt;h2 id="redis-rb-为ruby-连接redis的客户端"&gt;redis-rb 为ruby 连接redis的客户端&lt;/h2&gt;

&lt;h4 id="项目结构"&gt;项目结构&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;项目本身依赖于 hiredis，而hiredis 本身是一个redis client c的包装。并没有搞懂为什么需要依赖redis client&lt;/li&gt;
  &lt;li&gt;项目目录结构如下&lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;  /lib
    |---- redis.rb
    |---- /Redis
          |---- connection.rb
          |---- errors.rb
          |---- pipeline.rb
          |---- subscribe.rb
          |---- cluster.rb
          |---- hash_ring.rb
          |---- distributed.rb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;redis.set(key, value) 大概的调用栈如下&lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight ruby"&gt;&lt;code&gt;    &lt;span class="n"&gt;redis&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;Redis&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;host: &lt;/span&gt;&lt;span class="s2"&gt;"127.0.0.1"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;port: &lt;/span&gt;&lt;span class="mi"&gt;6379&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;db: &lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;redis&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'counter'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'name'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nb"&gt;p&lt;/span&gt; &lt;span class="n"&gt;redis&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'counter'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;  Redis.new
    |--- @original_client = Client.new(options) # options config
            |--- Redis::Client#initialize
                    |--- Connector.new(options)

  Redis#set
    |--- synchronize { |client| client.call([:set, key, value.to_s]) }
            |--- mon_synchronize { yield(@client) } # Moniter.mon_synchronize Enters exclusive section and executes the block
                    |--- client.call([:set, key, value.to_s])
                          |--- Redis::Client#call(command)
                                    |--- reply = process([command]) { read }
                                          |---
                                          ensure_connected { commands.each { |command| write(command) } ; yield }                                           
                                                    |--- write,         connection.write(command)
                                              |--- connect; yield
                                    |--- yield reply
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;pipeline 的实现
  Redis#pipelined
    |---
      synchronize do |client|
        begin
          original, @client = @client, Pipeline.new
          yield(self)
          original.call_pipeline(@client)
        ensure
          @client = original
        end
      end
 &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Pipeline 的 实现比较有意思， Pipeline.new一个对象，来代替@client， Pipeline必然实现了一个call接口（代替真实的client，来将commands收集起来）,yield 将现有的代码在Pipeline中调用了一遍。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;其中， 1. client.call, client.process, ensure_connected 保证连接，write 为 connection.write(仅仅是socket.write command build 的方式要特殊一点，[item.bytesize + item].join(“\r\n”) ), 2. 其中使用了大量的block， yield， ruby 特性来实现 传递函数调用，看起来比较费劲，如果统一成 lambda 可能会更好一点, 3. Moniter 是新见的，用来处理多线程的协调问题。在Client 中@pid的 用处没有见到用处， 使用代码建立redis连接之后， fork执行代码并没有产生@pid不一致的问题。4. redis new时候如果存在db ！=0 的情况，调用call 之后，使用 write command来选中 配置的 db&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;[TODO]&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;[@pid] 的问题&lt;/li&gt;
  &lt;li&gt;[Moniter]  的问题&lt;/li&gt;
  &lt;li&gt;[EM] 依赖&lt;/li&gt;
  &lt;li&gt;[eval] 依赖&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>计算机程序的构造和解释</title>
    <link rel="alternate" href="http://geniousbar.github.io/2018/03/20/sicp/"/>
    <id>http://geniousbar.github.io/2018/03/20/sicp/</id>
    <published>2018-03-20T08:00:00+08:00</published>
    <updated>2018-09-13T12:37:09+08:00</updated>
    <summary type="html">&lt;p&gt;计算机程序的构造和解释&lt;br&gt;
    ———&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;序
---------
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;关注程序的创建、执行和研究。使用Lisp方言书写&lt;br&gt;
本书中讨论的各种问题主要涉及到： 人的大脑，计算机程序的集合，以及计算机本身。每一个计算机程序都是现实中的或者精神中的某个过程的一个模型。通过人的头脑孵化出来，这种过程出现在人们的经验或者思维中。很少能够通过程序将这种过程模拟到永远令人满意的程度。 因为这个原因，程序也在不断的演化。当我们对模型的认识更深入、更扩大，更广泛时，我们就会修改程序。直到达到一中亚稳定状态。...&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    <content type="html">&lt;p&gt;计算机程序的构造和解释&lt;br /&gt;
    ———&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;序
---------
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;关注程序的创建、执行和研究。使用Lisp方言书写&lt;br /&gt;
本书中讨论的各种问题主要涉及到： 人的大脑，计算机程序的集合，以及计算机本身。每一个计算机程序都是现实中的或者精神中的某个过程的一个模型。通过人的头脑孵化出来，这种过程出现在人们的经验或者思维中。很少能够通过程序将这种过程模拟到永远令人满意的程度。 因为这个原因，程序也在不断的演化。当我们对模型的认识更深入、更扩大，更广泛时，我们就会修改程序。直到达到一中亚稳定状态。而在这时，程序中有会出现一个需要我们为之奋斗的模型。计算机程序设计领域之所以令人兴奋的源泉，就在于他所引起的连绵不绝的发现。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;组织技术&lt;br /&gt;
 一致性和正确性在程序变得更大更复杂的时候，非常值得怀疑了。很少能够看到有关大型程序正确性的完全形式化的论述。&lt;br /&gt;
 组织技术: 是理解 程序设计这种具有设计、创造性的事业中 的本质。&lt;br /&gt;
 因为大的程序是从小的东西成长起来的。所以，开发一个标准化的程序结构的武器库，并保证其中每种结构的正确性。再通过组织技术，将这些结构组合成更大的结构。这些都是至关重要的。发现并掌握这种强有力的组织技术，将提升我们构造大型重要程序的能力,反过来，因为构造大型程序的费力，导致我们去发明新的方法，来减轻构造大型程序的沉重负担。&lt;/p&gt;

    &lt;p&gt;在任何非常大的程序设计工作中，一个非常有用的组织原则就是 通过发明新语言， 去控制和隔离作业模块之间的信息流动。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;算法&lt;br /&gt;
  执行了某个精确函数的程序 我们称为算法。 特别需要关注的两个参数是：执行的事件、对数据存储的需要。 程序员应该追求好的算法&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="前言"&gt;前言&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;计算机语言不仅仅是让计算机执行操作的一种形式，更重要的是，他是一种表述有关方法学的思想的形式化媒介。&lt;/li&gt;
  &lt;li&gt;所以， 程序是写给人读的，然后才是去执行&lt;/li&gt;
  &lt;li&gt;最基本的材料不是 特定程序的语法，不是某种巧妙的算法。而是一些能够用于控制大型软件系统的智力复杂性的技术。（创建抽象去控制复杂性，通过建立约定的界面，以便能够用一种 混合与匹配的方式组合在一起， 建立一些新的语言去描述各种设计，每种语言强调设计中的一个特定方面并降低其他方面的重要性，以控制复杂度）&lt;/li&gt;
  &lt;li&gt;计算机科学并不是一种科学，而且其重要性也与计算机本身并无太大关系。计算机革命是有关我们如何去思考的方式，以及我们如何去表达自己思考的一个革命。这其中最基本的东西是，过程性认知论的现象，就是如何从一种命令式的观点去研究知识的结构，这是一种与经典数学领域总所采用的更具有说明性的观点完全不同。数学为精准处理 “是什么的” 提供了一种框架，而计算则为精准处理“怎样做” 的概念提供了一种框架。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="过程构造抽象"&gt;过程构造抽象&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;心智活动主要表现如下三个方面
    &lt;ol&gt;
      &lt;li&gt;将若干简单的认识组合为一个复杂的认识，由此产生出复杂的认识&lt;/li&gt;
      &lt;li&gt;将两个认识放在一起做对照，不管他们如何简单或者复杂。这样做并不将他们合二为一，由此得到的有关他们相互关系的认知。&lt;/li&gt;
      &lt;li&gt;将有关认识与那些实际中和他们同在懂得所有其他的认识隔离开，这就是抽象。所有具有普遍性的认识都是这样得到的&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;计算过程的Lisp描述， 本身又可以作为Lisp的数据来表示和操作。现在的语言都在填平 『被动的数据』和『主动的过程』之间的传统划分，（划分是什么？）能够将过程表示为数据的能力，Lisp的这种能力使Lisp成为编写那些必须将其他程序当做数据去操作的程序的最佳语言，比如： 计算机语言的解释器和编译器。 macro&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;程序设计的基本元素
    &lt;ul&gt;
      &lt;li&gt;语言提供的将简单的认识组合起来成为更复杂认识 三种机制：
        &lt;ol&gt;
          &lt;li&gt;基本表达形式: 组成语言的最小单位，个体&lt;/li&gt;
          &lt;li&gt;组合的方法： 通过他们可以将简单的组合成为复杂的&lt;/li&gt;
          &lt;li&gt;抽象的方法：通过他们将复杂对象命名，并将他们作为单元去使用&lt;br /&gt;
  程序中需要处理 过程和数据两种元素，数据是一种我们需要去处理的东西，过程就是我们操作数据的规则的描述。 任何语言都需要 能够表述基本的数据和基本的的过程，还需要提供对过程和数据进行抽象组合的方法。&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;具体语言的实现：
        &lt;ol&gt;
          &lt;li&gt;表达式&lt;br /&gt;
  (操作符 参数1 参数2)&lt;br /&gt;
  解释器总是按照  从终端读入一个表达式，对这个表达式求值，而后打印出得到的结果，称为读入—求值—打印 的循环， REPL&lt;/li&gt;
          &lt;li&gt;命名&lt;br /&gt;
  (define radius 10)&lt;br /&gt;
  创建名字–对象的关联。 鼓励人们采用递增的方式去开发和调试程序。其中需要注意的是，其中隐含着 环境的概念，其中保持着 名字—值的关联&lt;br /&gt;
  环境在确定表达式中各个符号的意义是十分重要的，如果没有相关环境的任何信息，那么说表达式(+ x 1) 是没有任何意义的。因为需要环境提供x的意义。环境是具有普遍性的概念。他为求值过程提供了一种上下文。对我们理解程序的执行起着重要的作用。&lt;/li&gt;
          &lt;li&gt;组合式的求值
            &lt;ol&gt;
              &lt;li&gt;求值该组合式的各个子表达式&lt;/li&gt;
              &lt;li&gt;将作为最左表达式的值的那个过程应用与相应的实际参数。所谓实际参数就是各个子表达式的求值结果&lt;br /&gt;
   为了实现对一个组合式的求值过程， 我们必须先对组合式里的每个元素执行同样的求值过程。 因此，在性质上，这一求值过程是递归的。&lt;/li&gt;
              &lt;li&gt;反复的执行第一步骤，最终会到达求值中的一个点，在这里遇到的不是组合式而是基本表达式。例如内部运算符或者其他名字
                &lt;ul&gt;
                  &lt;li&gt;数的值就是他们所表示的数值&lt;/li&gt;
                  &lt;li&gt;内部运算符 的值就是能完成相应操作的机器指令序列， fun&lt;/li&gt;
                  &lt;li&gt;其他名字的值就是在环境中关联与这一名字的那个对象， 变量&lt;br /&gt;
   &lt;em&gt; 可以将第二种情况看做最后一种情况的特殊情况，像 +， - 等，相应的指令序列就是与之关联的值&lt;/em&gt;&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;特殊形式&lt;br /&gt;
  (define x 3) 并不是一个组合式，一般性的求值规则的这种例外称为 特殊形式。各种不同类型的表达式（有着不同的求值规则） 组成了程序设计语言的语法形式。&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight scheme"&gt;&lt;code&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="p"&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;p&gt;条件表达式， 谓词 并不是普通的过程（表达式不一定都需要求值）&lt;br /&gt;
  (if &lt;predicate&gt; &lt;consequent&gt; &lt;alternative&gt;)
  (cond (&lt;p1&gt; &lt;e1&gt;)
   (&lt;p2&gt; &lt;e2&gt;)
   ...
   (&lt;pn&gt; &lt;en&gt;))&lt;/en&gt;&lt;/pn&gt;&lt;/e2&gt;&lt;/p2&gt;&lt;/e1&gt;&lt;/p1&gt;&lt;/alternative&gt;&lt;/consequent&gt;&lt;/predicate&gt;&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;代换模型
            &lt;ul&gt;
              &lt;li&gt;组合式的求值递归过程&lt;/li&gt;
              &lt;li&gt;正则序求值： 完全展开而后归约&lt;/li&gt;
              &lt;li&gt;应用序求值： 先求值参数而后应用&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;过程
    &lt;ul&gt;
      &lt;li&gt;形式参数， 约束变量、自由变量: 在过程体中扮演者一种非常特殊的角色，形式参数的具体名字是什么，完全没有关系，这样的名字称为。 一个过程的定义约束了他所有的形式参数，如果一个变量不是被约束的，我们就称他为自由的。一个名字的定义被约束于的那一个表达式称为这个名字的作用域， 所以在过程的定义中，被声明的为形式参数的那些约束变量，就以这个过程的体作为他们的作用域。&lt;/li&gt;
      &lt;li&gt;块结构:
&lt;div class="highlight"&gt;&lt;pre class="highlight scheme"&gt;&lt;code&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sqrt-iter&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;good-enough?&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nv"&gt;guess&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sqrt-iter&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;improve&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;good-enough?&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;abs&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;square&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="mf"&gt;0.001&lt;/span&gt; &lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;improve&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;average&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;/&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;sqrt&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sqrt-iter&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sqrt-iter&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;good-enough?&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nv"&gt;guess&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sqrt-iter&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;improve&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;



&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;sqrt&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sqrt-iter&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;good-enough?&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="nv"&gt;guess&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sqrt-iter&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;improve&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;good-enough?&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;abs&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;square&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="mf"&gt;0.001&lt;/span&gt; &lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;improve&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;average&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;/&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sqrt-iter&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;sqrt&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sqrt-iter&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;good-enough?&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="nv"&gt;guess&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sqrt-iter&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;improve&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;good-enough?&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;abs&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;square&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt; &lt;span class="mf"&gt;0.001&lt;/span&gt; &lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;improve&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;average&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;/&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sqrt-iter&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
        &lt;p&gt;这种嵌套的定义称为 块结构， 是最简单的名字包装问题的一种正确方式。这其中还有一种简化的方法，因为所有的辅助过程定义放到内部，x在sqrt内部是受约束的。过程good-enough， improve都定义在sqrt利民啊，也就是说显示的将x传递来传递去没有必要了，我们让x作为内部定义中的自有变量。sqrt被调用时，x就确定了。这种方式称为词法作用域。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;过程与他们所产生的计算&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;线性的迭代和递归
&lt;div class="highlight"&gt;&lt;pre class="highlight scheme"&gt;&lt;code&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;factorial&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="mi"&gt;1&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;factorial&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;

 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;factorial&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;fact-iter&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;fact-iter&lt;/span&gt; &lt;span class="nv"&gt;product&lt;/span&gt; &lt;span class="nv"&gt;conter&lt;/span&gt; &lt;span class="nv"&gt;max-count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;counter&lt;/span&gt; &lt;span class="nv"&gt;max-count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="nv"&gt;product&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;fact-iter&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="nv"&gt;counter&lt;/span&gt; &lt;span class="nv"&gt;product&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="nv"&gt;counter&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="nv"&gt;max-count&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;p&gt;第一个为递归计算过程， 代换模型展开的形状是一个先逐步展开而后收缩的形状。收缩阶段为这些运算的实际执行。这种类似性的计算过程由一个推迟执行的运算链条刻画&lt;br /&gt;
 第二个为线性递归计算过程，解释器只需要维护函数调用的参数，就可完成函数调用。&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;过程的计算过程和形式:
            &lt;ul&gt;
              &lt;li&gt;过程形式： 过程的书写形式&lt;/li&gt;
              &lt;li&gt;计算过程： 过程的计算过程&lt;/li&gt;
              &lt;li&gt;迭代计算过程： 在计算过程中的任何一点，程序的变量都提供了一个有关计算状态的完整描述。在任何时刻计算停下来，都可以提供参数来重新计算，&lt;/li&gt;
              &lt;li&gt;递归过程： 论述的是一个语法形式上的。说明这个过程的定义中，调用了自己。&lt;/li&gt;
              &lt;li&gt;递归计算过程： 函数的计算过程的进展方式。而不是过程上的语法形式上的书写，他们隐含着一些信息，有解释器维持，来指明所推迟的运算形成的链条中的位置。这一计算处在何处，这个链条越长，所需要保存的信息也就越多。&lt;/li&gt;
              &lt;li&gt;为什么需要区分 计算过程和形式过程？ 大部分语言的实践设计中，对任何递归过程的解释，所消耗的存储量总与过程调用的数目成正比，即便他所描述的计算过程是迭代的。作为这是一事实的后果就是—特殊的循环结构： for, while等。scheme 能够将形式上的递归而计算过程为递归形式，依然能够在常数空间上运行，这种实现为： 尾递归。&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ol&gt;

        &lt;p&gt;&lt;em&gt; fact-iter 递归过程讲产生迭代的计算过程， 因为展开的计算过程上确实是迭代的，其中的状态由三个变量保持。解释器没有额外的隐含的状态保存。&lt;/em&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;scheme相关
    &lt;ul&gt;
      &lt;li&gt;命名&lt;br /&gt;
 （define &lt;name&gt; &amp;lt;body&amp;gt;）&lt;/name&gt;&lt;/li&gt;
      &lt;li&gt;条件表达式和谓词&lt;br /&gt;
 (cond (&lt;p1&gt; &lt;e1&gt;)
   (&lt;p2&gt; &lt;e2&gt;)
   ...
   (&lt;pn&gt; &lt;en&gt;))
 (if &lt;predicate&gt; &lt;consequent&gt; &lt;alternative&gt;)
 (and &lt;e1&gt; ..... &lt;en&gt;)
 (or &lt;e1&gt; ..... &lt;en&gt;)
 (not &lt;e1&gt;)
 and or 不是普通的过程, 其中的参数不一定都会求值，not 是过程&lt;/e1&gt;&lt;/en&gt;&lt;/e1&gt;&lt;/en&gt;&lt;/e1&gt;&lt;/alternative&gt;&lt;/consequent&gt;&lt;/predicate&gt;&lt;/en&gt;&lt;/pn&gt;&lt;/e2&gt;&lt;/p2&gt;&lt;/e1&gt;&lt;/p1&gt;&lt;/li&gt;
      &lt;li&gt;高阶函数: 函数作为参数, 函数作为返回值&lt;/li&gt;
    &lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight scheme"&gt;&lt;code&gt;   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sum&lt;/span&gt; &lt;span class="nv"&gt;term&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;next&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="mi"&gt;0&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;term&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sum&lt;/span&gt; &lt;span class="nv"&gt;term&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;next&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;next&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;     * lambda  (lambda &amp;lt;parameters&amp;gt; &amp;lt;body&amp;gt;)  (lambda (x) (* x x x))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="构造数据抽象复合数据"&gt;构造数据抽象（复合数据）&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;语言所包含的将数据对象组合起来的，形成 复合数据的方式。提高 设计的模块性，是我们得以在 比语言提供的基本数据对象更高的概念层次上。处理与数据有关的各种问题。&lt;br /&gt;
复合数据能够将处理数据对象的表示部分，与 处理数据对象的使用部分相互隔离开来，这种技术具有一般性，形成了一种成为数据抽象的强有力的设计方法学。数据抽象技术能够是程序更容易设计，维护和修改。&lt;/li&gt;
  &lt;li&gt;形成复合数据的关键在于，程序设计语言提供的某种黏合剂，他们可以用于把一些数据对象组合起来，形成更复杂的数据对象，1）过程 2）闭包，用于组合数据对象的黏合剂同样适用于复合数据对象 3）符号表达式&lt;/li&gt;
  &lt;li&gt;数据导向型程序设计&lt;/li&gt;
  &lt;li&gt;数据抽象的基本思想： 设法构造出一些使用复合数据的对象的程序，使他们就像是在“抽象数据”上操作一样，我们的程序使用复合数据的方式应该是这样的：除了完成当前工作的必要东西之外，他们不对数据做任何的假设。同时，一种具体的数据表示的定义，也应该跟程序中使用数据的方式无关。这要求在我们的系统里面需要一组过程： 选择函数、构造函数。&lt;/li&gt;
  &lt;li&gt;按愿望思维方式，（从上倒下） 是一种强有力的设计方法，其中不会设计到细节，只是思考整体的数据使用方法。（复合数据结构的操作界面）&lt;/li&gt;
  &lt;li&gt;序对: cons, car, cdr 从序对 构造起来的数据对象成为表结构的数据&lt;/li&gt;
  &lt;li&gt;数据抽象的基本思想就是： 为每一类数据对象标识出 一组操作。是的对这类数据对象的所有操作都可以基于他们表述，而且在操作这些数据对象时也只使用他们。&lt;/li&gt;
  &lt;li&gt;形象化的表示了 有理数 系统的结构， 其中的水平线表示抽象屏障，他们呢隔离了系统中的不同的层次，在每一层上，这些屏障都把使用数据抽象的程序与实现数据抽象的程序隔离开来，使得有理数 的程序有理数实现提供的函数完成对有理数的操作，而这些函数又是基于构造函数和选择函数make-rat, numer denom 实现的。而make-rat等函数又是基于序对实现的。有关序对实现的细节与有理数的其余部分都完全没有u关系。每一层次中的过程构成了所定义的抽象屏障的界面，联系起来系统中的不同层次.&lt;/li&gt;
  &lt;li&gt;数据意味着什么： 我们总可以将数据定义为一组适当的选择函数和构造函数，其中这些过程必须满足某些必要条件。 （试着将这些条件放到程序中，面向对象，编译类型语言的语法检查，是不是都在某种程度上实现这些检测）&lt;br /&gt;
序对的概念，我们只需要定义，z = (cons x y)，那么 car(z) == x (cdr z) == y, 意味着，任何满足这三个条件的函数都可以作为实现。
&lt;div class="highlight"&gt;&lt;pre class="highlight scheme"&gt;&lt;code&gt;    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;dispatch&lt;/span&gt; &lt;span class="nv"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;m&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                 &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;m&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;error&lt;/span&gt; &lt;span class="s"&gt;"error argument "&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;z&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;z&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;z&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;z&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
  &lt;li&gt;序对 (cons a b) cons的闭包性质是非常重要的，某种组合数据对象的操作满足闭包性质，就是说，通过他组合起来的对象得到的结果本身还可以通过同样的操作再次进行组合。闭包性质是一种组合功能的关键所在。&lt;/li&gt;
  &lt;li&gt;序列的表示： (cons 1 (cons 2 (cons 3 nil))) (list 1 2 3)&lt;/li&gt;
  &lt;li&gt;map&lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight scheme"&gt;&lt;code&gt;        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;scale-list&lt;/span&gt; &lt;span class="nv"&gt;items&lt;/span&gt; &lt;span class="nv"&gt;factor&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;null?&lt;/span&gt; &lt;span class="nv"&gt;items&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;items&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;factor&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;scale-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;items&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;factor&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;scale-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="nv"&gt;proc&lt;/span&gt; &lt;span class="nv"&gt;items&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;null?&lt;/span&gt; &lt;span class="nv"&gt;items&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;proc&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;items&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="nv"&gt;proc&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;items&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;


&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;scale-list&lt;/span&gt; &lt;span class="nv"&gt;items&lt;/span&gt; &lt;span class="nv"&gt;factor&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
       &lt;span class="nv"&gt;items&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;map 不仅仅是一种模式，更重要的建立起了一种高级抽象。在scale-list 原来的设计中，更多的注意力放在了， 循环递归的结构中，而通过map定义的scale-list 则忽略了这种细节层面的情况，强调是表到表的缩放，这两种形式上的差异并不在于计算机会执行不同的计算过程，而在于我们对这同一种过程的不同思考方式。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>格雷厄姆之道</title>
    <link rel="alternate" href="http://geniousbar.github.io/2018/01/04/benjamin-graham/"/>
    <id>http://geniousbar.github.io/2018/01/04/benjamin-graham/</id>
    <published>2018-01-04T08:00:00+08:00</published>
    <updated>2018-09-05T09:23:15+08:00</updated>
    <summary type="html">&lt;h2 id="格雷厄姆之道如何在中国实践价值投资"&gt;格雷厄姆之道（如何在中国实践价值投资）&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;现在已然衰朽者， 将来可能重放异彩；现在备受青睐者，，将来却可能日渐衰朽。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id="原理"&gt;原理&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;价值投资：
    &lt;blockquote&gt;
      &lt;p&gt;价值投资不会让你一夜暴富，但它可以在保证本金安全的前提下让你的财产增值&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;价值投资：用远低于公司内在价值的价格购买该公司的股票&lt;/li&gt;
      &lt;li&gt;金融思维和商业思维： 商业思维 这个公司值多少钱，股票价格 = 公司价格 / 股票数量。 金融思维： 股票价格 = 每股收益 * 市盈率（PE）金融...&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    <content type="html">&lt;h2 id="格雷厄姆之道如何在中国实践价值投资"&gt;格雷厄姆之道（如何在中国实践价值投资）&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;现在已然衰朽者， 将来可能重放异彩；现在备受青睐者，，将来却可能日渐衰朽。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id="原理"&gt;原理&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;价值投资：
    &lt;blockquote&gt;
      &lt;p&gt;价值投资不会让你一夜暴富，但它可以在保证本金安全的前提下让你的财产增值&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;价值投资：用远低于公司内在价值的价格购买该公司的股票&lt;/li&gt;
      &lt;li&gt;金融思维和商业思维： 商业思维 这个公司值多少钱，股票价格 = 公司价格 / 股票数量。 金融思维： 股票价格 = 每股收益 * 市盈率（PE）金融思维中 &lt;strong&gt;每股收益 在决定股票价格时候占了大部分比重。而市盈率本身也很大程度上是由收益趋势外推决定的&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;金融思维的弊端：
        &lt;ol&gt;
          &lt;li&gt;采用正常的商业思维， 并购一家公司要对 &lt;strong&gt;资产和收益&lt;/strong&gt; 进行双重考量，双重考量要比单一强调收益的评估方式更可靠。&lt;/li&gt;
          &lt;li&gt;与资产相比，每股收益的变化更加剧烈，这样在股票估值时候，就包含了一个被夸大的不稳定性。&lt;/li&gt;
          &lt;li&gt;每股收益很容易被人为的操控&lt;/li&gt;
          &lt;li&gt;市盈率 跟 每股收益 相关性比较大，所以导致，每股价格 严重相关 每股收益&lt;/li&gt;
        &lt;/ol&gt;

        &lt;blockquote&gt;
          &lt;p&gt;要想在一生中获得投资的成功，并不需要顶尖的智商、超凡的商业智慧或内幕消息，而是需要一个稳妥的知识体系作为决策的基础。并且有能力控制自己的情绪，使其不会对这种体系造成侵蚀（比如达里奥的模型系统，决策系统，都在某一个方面上在避免情绪决策，贪婪和恐惧很容易影响人的判断能力）&lt;br /&gt;
  杰出的收益 = 投资方面的知识和努力 * 股票市场的愚蠢程度&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;市场波动、估值、安全边际
    &lt;ul&gt;
      &lt;li&gt;了解市场，需要对不同的证券在不同条件下的表现有足够的认识 (忘掉过去的人，容易重蹈覆辙， 比如后面不同的资本结构， 不同的行业性质都会在相同的条件下有不同的反应)&lt;/li&gt;
      &lt;li&gt;安全边际： 是价值投资的核心思想。安全边际就是证券的市场价格低于证券内在价值的差额。充足的安全边际 可以帮助投资人在犯错误的情况下依然保证本金的安全。安全边际越大投资就越安全。未来的潜在收益就更高&lt;/li&gt;
      &lt;li&gt;投资原则： 股价应该是内在价值的三分之二&lt;/li&gt;
      &lt;li&gt;足够的安全边际，不仅可以赚取 公司价值增长的钱，还有 股票价值回归的钱&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;内在价值：
    &lt;ul&gt;
      &lt;li&gt;一个大概的估算价格范围&lt;/li&gt;
      &lt;li&gt;股价偏离内在价值的原因: 股市给股票定价的过程就是市场心里变化的过程。而市场心里变化的过程通常是不合逻辑的。&lt;/li&gt;
      &lt;li&gt;股票价值回归： 股票市场短期是一个投票机，长期来看，却是一个称重器。
&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;   又一个投资人死了，去见上帝，求上帝安排他到天堂去。
   上帝说： 『天堂里都是你们这些高投资的，都满了，只有地狱还有空位』
   投资人说： 『那麻烦你跟他们说一句： 地狱了发现了石油』
   过了一阵， 天堂里的人都开始往地狱里跑。
   上帝对投资人说： 『你可以搬到天堂里了，他们都下地狱了』
   投资人说：『不行，我也得去地狱看看，万一是真的呢』
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="估值"&gt;估值&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;资产
    &lt;ul&gt;
      &lt;li&gt;资产至少同收益同样重要      (资产要比收益稳定的多, 收益确实很重要，市场也在不断进行收益预测，但是，就算是能够准确的预测下一年的收益，也很难判断 这个盈利预期 是否已经体现在当前的价格中了 priced-in)&lt;/li&gt;
      &lt;li&gt;市净率 = 每股股价 / 每股净资产，   股票价格低于每股有形资产账面价值 的 2/3， 不管什么股票，都不应该以两倍市净率买入&lt;/li&gt;
      &lt;li&gt;流动资产价值 = 流动资产 - 所有负债,     现金资产价值 = 现金资产 - 所有负债。    股票价格 低于 流动资产价值 的2/3&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;收益：
    &lt;ul&gt;
      &lt;li&gt;市盈率（PE） = 每股价格 / 每股收益,     市盈率越高 表示股票卖的越贵， 以当前股价买入股票，回本需要更长的时间。&lt;/li&gt;
      &lt;li&gt;盈利率 = 1 / 市盈率 = 每股收益  / 每股股价,     盈利率至少为长期AAA（国债）级债券收益率的2倍。&lt;/li&gt;
      &lt;li&gt;股价和股息： 股息收益率应该为AAA债券级的2/3 （对股息发放的形式和方法，需要补充）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;盈利能力
    &lt;ul&gt;
      &lt;li&gt;盈利能力： 过十年的年度盈利增长率至少为 7%&lt;/li&gt;
      &lt;li&gt;收益质量：需要的是实实在在的赚钱，而不是靠会计手段赚钱。不能单一看利润表，必须要用资产负债表对利润表进行审核，来发现公司当年收益对公司财务状况的真正影响。&lt;/li&gt;
      &lt;li&gt;未来收益：投机者和投资者都是以未来收益而非过去收益作为投资基础，但是投资者对未来的收益分析需要有理有据，并且尽量保守&lt;/li&gt;
      &lt;li&gt;不要关注某一年的利润，而是公司正常情况下的盈利能力，&lt;/li&gt;
      &lt;li&gt;折旧和摊销费用： 需要特别关注，他们不代表当前相应的现金支出。而是代表因为损耗原因，引起的固定资产和资本资产价值的减少。折旧是针对固定资产而言，摊销是对无形资产而言。&lt;/li&gt;
      &lt;li&gt;归属母公司利润 / 总股本 = 每股收益&lt;/li&gt;
      &lt;li&gt;在过去十年间经营状况波动巨大的情况下，收益一直表现稳定&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;财务状况：
    &lt;ul&gt;
      &lt;li&gt;营运资金 = 流动资产 - 流动负债,      流动比率 = 流动资产/流动负债,      速冻比率 = (流动资产 - 存货) / 流动负债&lt;/li&gt;
      &lt;li&gt;流动资产 至少为 流动负债 的2倍&lt;/li&gt;
      &lt;li&gt;不包括存货的流动资产 至少等于 流动负债（速动比率大于1）&lt;/li&gt;
      &lt;li&gt;总负债小于股东权益&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;股票划分标准：
    &lt;ul&gt;
      &lt;li&gt;市盈率 在 20倍 以上， 也就是盈利率低于 5% 的成长股&lt;/li&gt;
      &lt;li&gt;市盈率 在 7-20 之间，也就是盈利率 在5% - 15% 之间的股票&lt;/li&gt;
      &lt;li&gt;市盈率在7倍一下，也就是盈利率高于15%，但是不受欢迎的股票&lt;/li&gt;
      &lt;li&gt;第一个是首市场热捧的高成长性股票，第三组股票体现了人们对其前景的悲观预期。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;同质性行业和异质性行业：
    &lt;ul&gt;
      &lt;li&gt;同质性行业： 未来的发展变化影响到所有的公司： 全行业一荣俱荣一损俱损， 比如： 铁路、电力、热力、煤炭、棉花等。&lt;/li&gt;
      &lt;li&gt;异质性行业： 行业各家公司宣传和销售各自的品牌，这样的行业一家公司的兴往往建立在牺牲竞争对手的利益的基础上。&lt;/li&gt;
      &lt;li&gt;越是异质性行业，对定性分析的要求就越高。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;定性分析： 是对公司的业务性质和前景、管理层能力、未来收益的趋势、业务的内在稳定性等统计数据无法表达的因素进行分析。有一点非常重要，&lt;strong&gt;对公司的数据进行定量分析，只有得到定性分析的支持时才可靠&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;标准
    &lt;ul&gt;
      &lt;li&gt;估价是否被低估
        &lt;ul&gt;
          &lt;li&gt;盈利率 至少为 长期AAA级债券收益率 的2倍&lt;/li&gt;
          &lt;li&gt;市盈率位于最低的10%的区间内 (市盈率（PE） = 每股价格 / 每股收益 )&lt;/li&gt;
          &lt;li&gt;股息收益率 至少是 长期AAA级债券 的收益的2/3&lt;/li&gt;
          &lt;li&gt;股票价格 低于 每股有形资产账面价值 的2/3&lt;/li&gt;
          &lt;li&gt;股票价格 低于 流动资产价值 的2/3&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;盈利的标准：
        &lt;ul&gt;
          &lt;li&gt;前十年 的年度盈利增长率至少为7%&lt;/li&gt;
          &lt;li&gt;在过去十年，年度盈利下跌幅度 超过5%的期间不能超过2年&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;财务安全状况：
        &lt;ul&gt;
          &lt;li&gt;流动资产至少为流动负债的2倍&lt;/li&gt;
          &lt;li&gt;债务股本比低于1&lt;/li&gt;
          &lt;li&gt;总负债低于流动资产价值的2倍&lt;/li&gt;
          &lt;li&gt;平均收益和市场价格之间的比率令人满意财务状况足够稳健，营运资金充足&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="投资组合管理"&gt;投资组合管理&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;买入
    &lt;ol&gt;
      &lt;li&gt;价值投资有效的两个原因： 1. 他始终关注者价值和价格之间的联系。 2. 他利用了人性的弱点。&lt;/li&gt;
      &lt;li&gt;市场（人性）的弱点：
        &lt;ul&gt;
          &lt;li&gt;对当前收益的夸大，这个特定为我们不断的带来投资机会， 逆向做，&lt;/li&gt;
          &lt;li&gt;股息变化夸大&lt;/li&gt;
          &lt;li&gt;诉讼夸大&lt;/li&gt;
          &lt;li&gt;合并分拆夸大&lt;/li&gt;
          &lt;li&gt;趋势外推（错误、简单的认为 现有趋势，会继续发展下去）然而经验表明 这只是例外情况&lt;/li&gt;
          &lt;li&gt;冷门股的市场行为： 热门股票的股价几乎总是对其收益变化迅速做出反应。而冷门股 则可能远远滞后于 收益变化
            &lt;blockquote&gt;
              &lt;p&gt;你可以想象自己正在戏院看戏，当所有人都在安静的看戏时，你觉得很精彩，你第一个起来故障。你在做着与大众主题意见相反的事情，所以价值投资理论很简单。但是做起来却非常困难（克服从众心理） 1. 必须正确思考，2. 必须独立思考，需要回归基本常识，弄清楚股票，而不是每天上下波动的数字。&lt;/p&gt;
            &lt;/blockquote&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;持有：
    &lt;ol&gt;
      &lt;li&gt;第一次买入计划的 50%&lt;/li&gt;
      &lt;li&gt;股价下跌后，做更多的研究，如果买入的决定是正确的，我们会更多的买入，这也是价值投资困难的地方，大多数人无法坚持运用价值投资的原因，在于，当买入股票时，股价肯能继续下跌，这样会严重影响情绪，甚至导致做出错误的判断。&lt;/li&gt;
      &lt;li&gt;持股时间： 3，4，5年&lt;/li&gt;
      &lt;li&gt;换股： 不会&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;卖出&lt;br /&gt;
卖出的东西，总是让别人觉得有利可图，这样别人才会买，不要等到股价已经被高估了，就有风险了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="投资方法"&gt;投资方法&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;简易策略&lt;br /&gt;
    * 购买管理费用极低的指数基金&lt;br /&gt;
    * 定期定额投资指数基金&lt;/li&gt;
  &lt;li&gt;债股平衡： 5 ：5， 2.5 ：7.5&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="总结"&gt;总结&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;投资、投机的区别
    &lt;blockquote&gt;
      &lt;p&gt;投资活动和投机活动都必经受未来的检测。&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;投资: 1. 防范未来可能的风险 2. 不会建立在对未来的预测上  (投资 不会依靠预测未来牟利，如果未来能够改善，这当然很好，但投资不会建立在对未来的预测上)&lt;/li&gt;
      &lt;li&gt;投机: 总是建立在对未来的基础上, 股票投机 主要就是这样一个活动，即A想要弄清楚B、C、D 可能会怎么想， 而B、C、D也在做同样的事情。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;相对于看K线图炒股，价值投资有什么优势吗？
    &lt;ul&gt;
      &lt;li&gt;价值投资可以通过坚持安全边际的原则，即使判断错误，交易结果依然可以令人满意。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;几乎所有的技术分析&lt;/strong&gt; 都采用这样的原则： 根据市场上涨而买入，同时根据市场下跌而卖出。这种方法是与正常的合乎逻辑的商业逻辑是背道而驰的，所以很难在股市获得成功。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;有可能通过各种经济因素进行市场分析吗？&lt;br /&gt;
  在经济领域并&lt;strong&gt;不存在真正可靠的预测方法&lt;/strong&gt;（达里奥似乎在这方面做的不错）&lt;/li&gt;
  &lt;li&gt;基于股票近期前景的预期进行投资可行吗？&lt;br /&gt;
  我必须坦率的说，你通过掷硬币的方式预测和从华尔街专家的预测结果差不多。为什么呢？我的解释是， 华尔街每个人都很聪明，无论他们已经知道什么，都已经很大程度上反应到了股价上了，而股票的未来走势是由他们不知道的事情来决定的。首先： 有关于下一年收益的预测是错误的。其次： 即使预测正确，股票当前价格也有可能已经体现了市场对该公司的预期，甚至已经过度体现了。&lt;/li&gt;
  &lt;li&gt;买入创业项目新股票可行吗？&lt;br /&gt;
  新上市的股票没有历史数据做定量分析，而且股票价格都不太便宜。只有极少数上市的公司，价格足够便宜，但这样的情况很少见。&lt;/li&gt;
  &lt;li&gt;高价买入成长股可行吗？&lt;br /&gt;
  大部分投机者都自认为是成长型投资者，而我发现这群人的投资失败率非常高，成长股收益不及预期下跌时，代表市场情绪的市盈率也会降低，这样对股价就造成了双杀，价值股本身留有安全边际，市场对价值股的收益期望值比较低，市盈率本来就很低，当价值股的收益不及预期时，价值股的波动幅度不会想成长股那样大。&lt;/li&gt;
  &lt;li&gt;低价股的算数优势&lt;br /&gt;
  低价股蕴含的机会要远大于高价股，预期收益相同的情况下，应该购买价格更低的股票。&lt;/li&gt;
  &lt;li&gt;大公司与小公司
    &lt;ul&gt;
      &lt;li&gt;好公司：
        &lt;ol&gt;
          &lt;li&gt;行业内领先，令人满意的盈利&lt;/li&gt;
          &lt;li&gt;资金雄厚的公司，普遍认为其未来收益成长前景很好&lt;/li&gt;
          &lt;li&gt;优势： 比起二三流的公司来说，领先公司对于经济萧条的抵抗能力更强，起恢复盈利的能力也更强&lt;/li&gt;
          &lt;li&gt;缺点： 其本身的规模会阻碍其进一步增长， 2. 投资的高回报率容易收到新加入竞争和监管的冲击 3. 龙头股具有无常性。&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;成功的小规模公司，可以实现比大规模公司更加显著的成长。
        &lt;blockquote&gt;
          &lt;p&gt;大多数人通过对公司未来发展前景的判断，试图找到类似的潜在成长股，甚至不惜高价购买这样的股票。而不是在前景普通的股票中寻找廉价股的投资机会。 实战经验是我们更请来在前景普通的股票中寻找廉价股票的投资方是，只要我们 推测未来时保持谨慎的态度，并在市场整体高估时适度离场。这种在前景普通的股票中寻找廉价股的投资方式去的陈工的概率往往更大。&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;我们有可能抓住股价波动的反转点吗？&lt;br /&gt;
  试图抓住股价波动的反转点是不切实际的，这样的愿望是很难实现的。他们会在短暂的成功后以全盘失败而告终。&lt;/li&gt;
  &lt;li&gt;只有承担高风险，才能获得高收益吗？&lt;br /&gt;
  &lt;strong&gt;收益并不总是与风险成正比&lt;/strong&gt;，投资者的目标收益是由能够为投资付出的智慧决定的。&lt;/li&gt;
  &lt;li&gt;什么是风险？&lt;br /&gt;
  有效市场理论将风险等同于短期股价波动。这个理论假设的前提是错误的，结论也必然是错误的。&lt;br /&gt;
  &lt;strong&gt;风险的真正定义式亏损的可能性&lt;/strong&gt;。真正应该关注的风险是公司的基本商业价值，公司的生意是否能够创造价值，不仅仅是股东，还有客户。看公司是否创造新的财富来增加他们的价值，这些都与股价的短期波动没有任何的关系。&lt;/li&gt;
  &lt;li&gt;证券分析中的主要障碍有哪些呢？
    &lt;ul&gt;
      &lt;li&gt;数据不足或者不够准确， 大多数的数据错误都来自于会计造假&lt;/li&gt;
      &lt;li&gt;未来的不确定性。 未来的变化往往是不可预测的，我们分析中假定 公司过去的记录至少对未来能够起到指示作用。 对这一前提的怀疑越多，分析的价值也就越低。 所以这种分析方法应用于 稳定特性的行业比富于变化的行业更加有用。在比较正常的一般情况下比在充满变化的不确定的情况下更加有用。&lt;/li&gt;
      &lt;li&gt;市场的非理性行为。 这有可能造成价值回归的迟缓。在价值回归之前，可能新的决定因素会出现。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</content>
  </entry>
</feed>
