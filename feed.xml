<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>日常学习</title>
  <id>http://geniousbar.github.io</id>
  <link href="http://geniousbar.github.io"/>
  <link href="http://geniousbar.github.io/feed.xml" rel="self"/>
  <updated>2019-01-14T08:00:00+08:00</updated>
  <author>
    <name>geniousbar</name>
  </author>
  <entry>
    <title>linux-interface-socket</title>
    <link rel="alternate" href="http://geniousbar.github.io/2019/01/14/linux-interface-socket/"/>
    <id>http://geniousbar.github.io/2019/01/14/linux-interface-socket/</id>
    <published>2019-01-14T08:00:00+08:00</published>
    <updated>2019-01-26T19:02:05+08:00</updated>
    <summary type="html">&lt;h2 id="the-linux-programming-interface"&gt;The linux programming interface&lt;/h2&gt;

&lt;h3 id="socket"&gt;Socket&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;socket是一种IPC方法， 它允许位于同意主机或者网络连接的不同主机 上的应用程序之间交换数据(第一个被广泛接收的socket API 实现于 1983年，现在这组API 已经被移植到了大部分的计算机系统上)&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;57 介绍UNIX domain socket， 允许同一主机上的系统上的应用程序之间通讯。 58 介绍TCP/IP之间联网协议的关键特性。， 59 描述internet domain socket...&lt;/li&gt;
&lt;/ol&gt;</summary>
    <content type="html">&lt;h2 id="the-linux-programming-interface"&gt;The linux programming interface&lt;/h2&gt;

&lt;h3 id="socket"&gt;Socket&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;socket是一种IPC方法， 它允许位于同意主机或者网络连接的不同主机 上的应用程序之间交换数据(第一个被广泛接收的socket API 实现于 1983年，现在这组API 已经被移植到了大部分的计算机系统上)&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;57 介绍UNIX domain socket， 允许同一主机上的系统上的应用程序之间通讯。 58 介绍TCP/IP之间联网协议的关键特性。， 59 描述internet domain socket, 允许位于不同主机上的应用程序通过一个TCP/IP王璐进行通讯， 60 讨论socket的服务设计， 61： 介绍一些高级主题， 包括socket IO的， TCP协议的细节信息，已经socket选项来获取修改socket的各种特性。&lt;/li&gt;
  &lt;li&gt;socket(domain, type, protocol): 系统调用
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;domain: 1） 识别 socket 地址的格式， 2） 确定范围， 实在同一个主机上的不同应用程序还是， 在一个网络上的不同主机&lt;/p&gt;

        &lt;table&gt;
          &lt;thead&gt;
            &lt;tr&gt;
              &lt;th style="text-align: left"&gt;DOMAIN&lt;/th&gt;
              &lt;th style="text-align: left"&gt;执行的通讯&lt;/th&gt;
              &lt;th style="text-align: left"&gt;应用程序间的通讯&lt;/th&gt;
              &lt;th style="text-align: left"&gt;地址格式&lt;/th&gt;
              &lt;th style="text-align: left"&gt;地址结构&lt;/th&gt;
            &lt;/tr&gt;
          &lt;/thead&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td style="text-align: left"&gt;AF_UNIX&lt;/td&gt;
              &lt;td style="text-align: left"&gt;内核中&lt;/td&gt;
              &lt;td style="text-align: left"&gt;同一主机&lt;/td&gt;
              &lt;td style="text-align: left"&gt;路径名&lt;/td&gt;
              &lt;td style="text-align: left"&gt;sockaddr_un&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td style="text-align: left"&gt;AF_INET&lt;/td&gt;
              &lt;td style="text-align: left"&gt;通过IPv4&lt;/td&gt;
              &lt;td style="text-align: left"&gt;IPv4 连接起来的网络&lt;/td&gt;
              &lt;td style="text-align: left"&gt;32为IPoe 地址+ 16位端口号&lt;/td&gt;
              &lt;td style="text-align: left"&gt;sockaddr_in&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td style="text-align: left"&gt;AF_INET6&lt;/td&gt;
              &lt;td style="text-align: left"&gt;通过IPv6&lt;/td&gt;
              &lt;td style="text-align: left"&gt;IPv6 连接起来的网络&lt;/td&gt;
              &lt;td style="text-align: left"&gt;128为IP地址+ 16位端口号&lt;/td&gt;
              &lt;td style="text-align: left"&gt;sockaddr_in6&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;type: sock_stream, sock_dgram&lt;/p&gt;

        &lt;table&gt;
          &lt;thead&gt;
            &lt;tr&gt;
              &lt;th style="text-align: left"&gt;属性&lt;/th&gt;
              &lt;th style="text-align: left"&gt;流(SOCK_STREAM)&lt;/th&gt;
              &lt;th style="text-align: left"&gt;数据包 (SOCK_DGRAM)&lt;/th&gt;
            &lt;/tr&gt;
          &lt;/thead&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td style="text-align: left"&gt;可靠的传输?&lt;/td&gt;
              &lt;td style="text-align: left"&gt;是&lt;/td&gt;
              &lt;td style="text-align: left"&gt;否&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td style="text-align: left"&gt;边界消息保留?&lt;/td&gt;
              &lt;td style="text-align: left"&gt;否&lt;/td&gt;
              &lt;td style="text-align: left"&gt;是&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td style="text-align: left"&gt;面向连接？&lt;/td&gt;
              &lt;td style="text-align: left"&gt;是&lt;/td&gt;
              &lt;td style="text-align: left"&gt;否&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
      &lt;li&gt;流: 提供了一个可靠的双向的字节流的通讯通道。 (因为需要一对 相互连接的socket，因为被称为面向连接的socket）其中：
        &lt;ol&gt;
          &lt;li&gt;可靠的： 表示可以保证发送者传输的数据会完整的传递到接收者应用程序 （假设接收者发送者应用程序不会崩溃）&lt;/li&gt;
          &lt;li&gt;双向的： 数据可以在socket 之间的任意方向上传输&lt;/li&gt;
          &lt;li&gt;字节流： 表示与管道一样不存在 消息边界的概念&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;数据报 socket： 允许数据以 数据报的消息形式进行交换， 在数据报socket中， 消息边界得到了保留，但是数据传输是不可靠的，消息的到达顺序 可能是无需的、重复的、或者根本无法到达的。数据包socket是一个更一般的无连接socket概念的一个示例， 与流socket连接，一个数据报 socket 在使用时候，无需与另一个socket 连接，现在internet domain 中， 数据包socket使用了UDP（用户数据报协议）, 而流socket 则使用了TCP（传输控制协议）（是否意味着更多的协议的存在？）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;socket 相关的系统调用：
    &lt;ul&gt;
      &lt;li&gt;socket(int domain, int type, int protocol): 其中domain， type 在上面有所描述。protocol 总是为0， 在一些socket类型中会使用非0数值，socket成功后会返回一个socket的文件描述符&lt;/li&gt;
      &lt;li&gt;bind(int sockfd, struct sockaddr * addr, socklen_t addrlen): sockfd 为 socket调用返回的文件描述符，addr 为socket绑定到的地址结构指针，结构详细取决于 socket domain, addrlen 为结构地址大小。一般来讲服务器会将socket 绑定到一个 约定的地址上。&lt;/li&gt;
      &lt;li&gt;listen(int sockfd, int backlog): 系统调用将会sockfd设定为 『被动』， 接收主动连接的请求。 backlog 用于 设定 服务器端 保持等待连接的数量。（在backlog之内的连接会立即成功，等待accept， 更多的连接会阻塞一直到有等待中的连接被accept并冲等待连接中删除掉）（backlog的限制在sys/socket.h 中的 somaxconn 常量设定， linux中 这个常量设定为128,从内核 2.4.25起 linux允许在运行时通过 特有的/proc/sys/net/core/somaxconn 文件来调整这个限制）&lt;/li&gt;
      &lt;li&gt;accept(int sockfd, struct sockaddr * addr, socklen_t * addrlen): 系统调用在 sockfd 的文件描述符 引用的监听流socket上接收一个接入连接。如果在调用accpet时不存在 未决 的连接，那么调用就会阻塞直到 有连接请求为止。参数 addr, addrlen, 会返回连接socket 的地址信息。理解accept 的关键点在于
        &lt;ul&gt;
          &lt;li&gt;accept 会创建一个新的scoket， 这个socket与执行connect的客户端scoket进行连接。&lt;/li&gt;
          &lt;li&gt;accpet调用返回的结果是 已连接的 socket文件描述符，监听 socketfd 会保持打开状态。并可以接收后续连接。&lt;/li&gt;
          &lt;li&gt;典型的 服务器应用 会创建一个 监听socketfd， 将其绑定到一个约定的地址上。然后 accept 该socketfd 上 的连接 来处理所有的客户端请求。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;connect(int sockfd, struct sockaddr * addr, scoklen_t addrlen): 系统调用将sockfd 主动连接到 地址addr 指定的监听socket上。如果连接失败，标准的可以移植的方法为，关闭socket，创建一个新的socket，并重新连接&lt;br /&gt;
&lt;img src="../../../../images/pending_socket-84aa5943.png" alt="udp" /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;流 socket 提供了一个在两个端点之间 一个双向通信的通道，流socket IO 上的操作与 管道 IO的操作类似
    &lt;ul&gt;
      &lt;li&gt;可以使用 read， write，因为socket是双向的，所以两端都可以使用&lt;/li&gt;
      &lt;li&gt;socket可以使用close来关闭，之后对应的另一端的socket 在读取数据时候会收到文件结束的标志，如果进行写入 会收到一个SIGPIPE的信号，并且系统调用会返回一个EPIPE的错误。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;数据报 socket(SOCK_DGRAM):
    &lt;ol&gt;
      &lt;li&gt;socket 系统调用创建一个邮箱，&lt;/li&gt;
      &lt;li&gt;bind 到一个约定的地址上， 来允许 一个应用程序发送数据报 到这里，一般来讲， 一个服务器会将其socket 绑定到一个地址上，客户端会向改地址发送一个数据报 来发起通讯 （在一个domain 特别是UNIX domain 中，客服端想接收到服务器发送来的数据报的话，也需要bind到一个地址上）&lt;/li&gt;
      &lt;li&gt;sendto(int sockfd, void * buffer, size_t length, int flags, sockaddr * dest_addr, socklen_t addrlen): 用来发送一个数据报, flags 用来控制一些socket的特性，dest_addr置顶了目标接收者的socket地址,&lt;/li&gt;
      &lt;li&gt;recvfrom(int sockfd, void * buffer, size_t length, int flags, sockaddr * src_addr, socklen_t addrlen): 用来接收数据报，在没有数据报时候会阻塞应用。由于recvfrom允许获取发送者的地址，因为可以发送一个响应（这在 发送者的socket没有绑定到一个地址上是有用的，正如bind中的描述所说，unix domain中也需要 客服端 来bind一个地址，才能接收到服务器的响应）其中 src_addr 用来获取发送数据报的远程socket地址，如果并不关心发送者的地址，可以传递NULL，length 数值 用来限制recvfrom获取的数据大小，如果超过length，则会进行截断。（使用recvmsg 则可以找出被截断的数据报）&lt;/li&gt;
      &lt;li&gt;数据报通讯无法保证 数据报 接收的顺序，甚至无法保证数据是到达的 或者是 多次到达&lt;/li&gt;
      &lt;li&gt;connect： 尽管数据报socket是无连接的，但是依然可以使用connect调用
        &lt;ul&gt;
          &lt;li&gt;发送者 socket connect之后，数据报的发送可以使用write来完成，而无需使用sendto，并每次传递addr地址。&lt;/li&gt;
          &lt;li&gt;接收者 socket connect之后，只能接收由对等的socket 发送的数据报&lt;/li&gt;
          &lt;li&gt;数据报socket connect的明显优势在于 可以使用更简单的IO 系统调用，在一些TCP/IP实践中，将一个数据报的socket连接到一个对等socket（connect）能够带来性能上的提升&lt;br /&gt;
   &lt;img src="../../../../images/udp_socket-cce037cc.png" alt="udp" /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="socket-unix-domain"&gt;Socket: Unix domain&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Unix domain socket address:&lt;br /&gt;
 unix domain socket的地址以路径名来表示，其中sun_path 的大小，早期为 108, 104，现在的一般为 92，可移植的需要小一些，应该使用strncpy 以避免缓冲区溢出问题，使用 路径名 初始化 sun_path 来初始化 socket address&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight c"&gt;&lt;code&gt;   &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;sockaddr_un&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
     &lt;span class="n"&gt;sa_family_t&lt;/span&gt; &lt;span class="n"&gt;sun_family&lt;/span&gt;
     &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;sun_path&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;108&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
   &lt;span class="p"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;ul&gt;
      &lt;li&gt;当绑定 UNIX domain socket 时， bind会在 文件系统中创建一个条目， 文件的所有权会根据文件的创建规则来确定，并标记为一个socket， ls -l 第一列 为s， stat()返回的结构中st_mode字段中的文件类型部分为 S_IFSOCK，&lt;/li&gt;
      &lt;li&gt;无法将一个socket绑定到 现有的路径名上。&lt;/li&gt;
      &lt;li&gt;通常将一个socket绑定到绝对路径上&lt;/li&gt;
      &lt;li&gt;一个socket只能绑定到一个路径名上，相应的一个路径名只能被一个socket绑定&lt;/li&gt;
      &lt;li&gt;无法使用open打开一个socket&lt;/li&gt;
      &lt;li&gt;不在需要socket时，使用unlink 来删除其路径&lt;/li&gt;
      &lt;li&gt;示例中通常将socket绑定到/tmp目录下，这并不是一个好的设计，在现实中不要这么做，因为/tmp 此类公共可写的目录中创建文件会导致安全问题，所以应该将socket绑定到一个有安全措施的绝对路径上&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;socketpair(int domain, int type, int protocol, int sockfd[2]): 该系统调用 用于创建一对 互相连接的socket，
    &lt;ul&gt;
      &lt;li&gt;只能用在UNIX domain中(也就是说 domain 必须指定为 AF_UNIX) type 可以为sock_dgram, sock_stream, protocol必须为0，&lt;/li&gt;
      &lt;li&gt;sockfd 数组返回了 引用这两个相互连接的socket文件描述符。type 为sock_stream 相当于创建了一个双向管道，一般来讲 socket对的使用方式与管道的使用方式类似，在调用完socketpair()之后，可以fork出一个子进程，然后子父进程可以通过这一对socket来进行IPC了。&lt;/li&gt;
      &lt;li&gt;与 手动闯将一对相互连接的socket的做法的优势： socketpair 创建的socket不会绑定到任意的地址上（即其他方式的socket创建都需要bind 到一个地址上）这样就能避免安全问题，因为这一对socket对其他进程是不可见的&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;linux 抽象socket 命名空间&lt;br /&gt;
  &lt;strong&gt;所谓的抽象命名空间 是linux特有的特性。他允许将一个UNIX domain socket绑定到一个名字上但不会在文件系统上创建该名字&lt;/strong&gt; 优势有：
    &lt;ul&gt;
      &lt;li&gt;无需担心与文件系统中的既有名字冲突&lt;/li&gt;
      &lt;li&gt;没有必要在使用完一个socket之后，删除socket路径名，当socket被关闭之后会自动删除这个抽象名&lt;/li&gt;
      &lt;li&gt;无需为socket创建一个文件系统路径名了&lt;/li&gt;
      &lt;li&gt;创建一个抽象的绑定，只需要将sun_path字段的第一个字节指定为null，用于区分抽象socket 与传统的UNIX domain socket&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="tcpip-网络基础"&gt;TCP/IP 网络基础&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;一个联网协议是定了如何在一个网络上传输信息的一组规则，网络协议通常会被组织成一系列的层，其中每一层都构建于下一层之上并提供特性以供上层使用。TCP/IP 协议套件 是一个封层联网协议。包括因特网协议（IP）和魏雨琦上层的各个协议层。 TCP 为传输层控制协议&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;封装协议的特点有：
    &lt;ol&gt;
      &lt;li&gt;透明： 每一个协议层都对上层 隐藏下层的操作和复杂性。 入一个使用TCP的应用程序只需要使用标准的socket API并清楚自己在使用 一项可靠的字节流传输服务，而无需理解TCP操作的细节。（严格来说 这个标准并不总是正确，应用程序偶尔也需要弄清楚 底层传输协议的操作细节）&lt;/li&gt;
      &lt;li&gt;封装： 是分层连网协议中的一个重要的原则。关键概念： 底层会将从高层向底层传递的信息 当成不透明的数据进行处理。并不会尝试对高哦曾发送过来的信息进行解释。只会 将这些信息 添加自身这一层所使用的头信息，并传递到下一层。当数据从底层传递到高层时，会进行一个逆向的解包过程。&lt;br /&gt;
 &lt;img src="../../../../images/tcp_ip_protocol-1d996324.png" alt="tcp_ip_protocol" /&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;数据链路层： 传输数据， 数据链路层需要将上层传递过来的数据报封装进 被称为帧的一个一个单元，其中每帧都会包含一个头，包含了目标地址和帧的大小。数据链路层在物理连接上 传输帧并处理来自接收者的确认。这一层可能进行 错误检测、重传、以及流量控制。一些数据链层还会将大的网络报分割成多个帧并在接收者端对这些帧进行重传。应用程序编程的角度通常可以忽略 数据链路层，因为所有的通讯细节都是由 驱动和硬件来处理的。有关IP的讨论中， 数据链路层中比较重要的一个特点是最大传输单元(MTU)MTU是该层 所能传输的帧大小的上限， 不同的数据链路层MTU是不同的(netstat -i )&lt;/li&gt;
  &lt;li&gt;网络层IP&lt;br /&gt;
  网络层的、关注的为 如何将包 从愿主几发送到目标主机， 这一层执行的任务如下：
    &lt;ul&gt;
      &lt;li&gt;将数据分解成足够小的片段一变数据链路层进行传输&lt;/li&gt;
      &lt;li&gt;在因特网上路由数据&lt;/li&gt;
      &lt;li&gt;为传输层提供服务&lt;/li&gt;
      &lt;li&gt;在TCP/IP 协议套件中， 网路层主要的协议是IP， 存在IPv4, IPv6版本。一个IP数据报包含了一个头，起大小范围为20字节到60字节，这个包中包含了的目标主机的地址，以及包的源地址。这样就可以在网络上讲这个数据报路由到目标地址了、以及接收方直到数据报的源头了。&lt;/li&gt;
      &lt;li&gt;IP 是无连接协议、不可靠的协。 尽可能的将数据报从发送者传给接收者。当并不保证数据报到达的顺序以是否重传，甚至是否达到等。IP 也没有提供数据恢复。TCP/IP 的可靠性是通过使用一个可靠的TCP （传输层他协议）来保证的。&lt;/li&gt;
      &lt;li&gt;IP 路径MTU： 原主机到目标主机之间的路径上的所有数据链路层的最小MTU （通常以太网的MTU 最小）当一个数据报的大小大鱼MTU时， IP会将数据报分段（分解成一个大小适合在网络上传输的单元， 这些分段在达到最终目标地址之后会被重组成原始的数据报）， IP分段的发生对高层协议层是透明的，一般来讲并不希望发生这种事情。这里的问题在于IP并不进行重传，所以只有在所有分段到达目标之后才能对数据报进行重组，导致如果其中一些分段丢失可能导致整个数据报的失败，一些情况下会导致极高的丢包率（比如UDP并不会进行重传）或者降低传输速率（进行重传的TCP） 现在TCP实现采用了一些算法（路径MTU发现，这个是不是很简单的获取 IP的路径MTU？）并根据该值对传递给IP 的数据进行分解，来防止IP层对数据报进程分解。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;传输层
    &lt;ol&gt;
      &lt;li&gt;端口号： 传输层协议的任务是向位于不同主机的上的应用程序提供端到端 通讯服务，所以传输层需要才用一种方法来区分一个主机上的应用程序，端口号的工作就是如此。（16位）&lt;/li&gt;
      &lt;li&gt;UDP（用户数据报协议）： 仅仅在IP上增加了： 1） 端口号， 2）进行检测传数据错误的 数据校验和， 因为IP是无连接的，而UCP并没有进行 可靠性的保证，所以UCP 具有同IP一样的特性&lt;/li&gt;
      &lt;li&gt;TCP（传输控制协议）： TCP 在两个端点之间提供了可靠的、面向连接的、双响字节流通信通道。通过如下几个方面来保证：
        &lt;ul&gt;
          &lt;li&gt;建立连接： 在连接期间，即 对交换数据 的通讯参数进行协商&lt;/li&gt;
          &lt;li&gt;将数据打包成分段： 将数据分解成段(使单个IP数据报封装成为可能，从而避免 IP层面 进行拆解）每个段都包含一个校验和，并使用单个IP进行传输，从而能够检出数据报的错误。&lt;/li&gt;
          &lt;li&gt;确认、重传、超时： 一个TCP段无错的到达接收方，接收方会向发送者发送确认请求，如果报发生错误，接收方丢弃即可。发送方 在发送每一个分段时会启用一个定时器，在定时器超时时没有收到确认。那么就重传这个分段 （由于所使用的网络以及当前的流量负载会影响 传输一个分段和接收其确认 所需要的时间，所以 TCP采用了� 一个算法来动态的调整 重传超时时间（RTO） 的大小。接收者可能不会立即发送确认，而是等待几毫秒 来观察是否可以将 确认塞进接收者返回给发送者的响应中（因为相应是接收者发送给接收者的，并不需要传递确认信息）来减少一个TCP段的发送，从而降低网络中的包的数量。这个称为 延迟ACK 技术）&lt;/li&gt;
          &lt;li&gt;排序： TCP连接中的每个分段都会分配到一个逻辑号。这个数字指出了该分段在 该连接 的数据流中的位置（连接中的两个流都有各自的序号计数系统）序号的作用有： 1）这个序号可以保证TCP分段能够以正确的顺序在接收者进行组装， 然后以字节流的形式传送给应用层 2）接收者 发送给发送者 使用序号来标识出收到了那个TCP分段 3）接收者可以去除重复的分段信息。(一个流的初始序列ISN， 不是从0开始的，而是通过一个算法来生成的，该算法会递增分配给后续的TCP链接的ISN（防止前后的多个连接中 序号重复混淆的情况发生）)&lt;/li&gt;
          &lt;li&gt;流量控制： 防止一个快速的发送者压垮一个慢速的接收者： 如何实现： 接收TCP 需要为进入的数据维护一个缓冲区（每个TCP在建立连接时候，都会告知其缓冲区大小）当从发送TCP端收到数据时会将数据放入到缓冲区中。当应用层读取数据时会从缓冲区中删除数据， 在每个确认中，接收者会通知发送者 其缓冲区的可用空间，TCP流量控制算法 采用了 滑动窗口算法，来允许包含N个字节的窗口大小的 未确认段 同时在 发送者与接收者之间传递，接收端的缓冲区被充满，那么窗口就会关闭，发送端就会停止传输数据。&lt;br /&gt;
   &lt;img src="../../../../images/tcp_protocol-08a9fb04.png" alt="tcp_protocol" /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;RFC（请求注解）： 是由 国际互联网学会赞助的RFC编辑组织发布的，描述互联网标准的RFC是由互联网工程任务组资助开发的， 互联网工程任务组 是一个由 网络设计师、操作员、厂商以及研究人员组成的社区，主要关注互联网的发展和平稳运行。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="服务器设计"&gt;服务器设计&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;迭代型： 服务器每次只处理一个客户端，只有当完全处理完一个客户端的请求后，才会去处理下一个客户端&lt;/li&gt;
  &lt;li&gt;并发型： 能够同时处理多个客户端的请求。 本章主要放在并发型服务器的传统设计方法：针对每个新的客户端连接, 创建一个新的子进程来处理，每个服务器子进程执行完所有服务于单个客户端的任务后就终止。因此可以同时处理多个客户端。
    &lt;ul&gt;
      &lt;li&gt;由于 服务器为每个客户端连接创建一个子进程，需要保证不会出现僵尸进程，所以需要为信号SIGCHLD 安装信号处理器。&lt;/li&gt;
      &lt;li&gt;主进程 主要由for 循环组成。在循环中accept 链接，然后fork 创建子进程， 在子进程中 调用hanldeRequest来处理客户端。（现实世界中，需要限制 服务器创建子进程的数量，大量的子进程会使系统变的不可用。）&lt;/li&gt;
      &lt;li&gt;每次fork后，监听套接字和连接套接字都在子进程中得到了复制。父进程 关闭 连接套接字， 子进程关闭 监听套接字。（如果父进程没有关闭 连接套接字的话 那么连接套接字永远不会被关闭，从而导致文件描述符被用完。监听套接字并不会这样，因为子进程 结束之后会释放所有的文件描述符）&lt;/li&gt;
      &lt;li&gt;每个子进程处理完客户端之后，终止&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;并发型服务器的其他设计：
    &lt;ul&gt;
      &lt;li&gt;预先创建进程或线程：
        &lt;ol&gt;
          &lt;li&gt;服务器在启动阶段就立刻 预先创建好一定数量的 子进程， 而不是针对一个新的客户端来创建 一个子进程。这些子进程构成了一个 服务池&lt;/li&gt;
          &lt;li&gt;每个子进程一次只处理一个客户端，在处理完之后，子进程并不终止，而是获取下一个待处理的客户端继续处理。&lt;/li&gt;
          &lt;li&gt;主进程需要仔细的管理子进程，并可以相应的根据负载来调节子进程的数量大小，此外， 子进程需要遵循某些协议，是的他们是以 独占 的方式来处理一个客户端的 连接套接字的。在大多数的UNIX实现中，让子进程 在监听套接字上调用accept即可，（即是： 主进程先创建 监听套接字，子进程在每个fork之后 继续使用套接字 并 accept，因为accept调用是一个原子化的操作，所以当客户端连接 到来时，之后一个子进程能够完成 accept调用。负载则由系统进行调度）&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;单个进程中处理多个客户端： 必须能够允许单个进程同时监听多个文件描述符上 IO事件 （IO多路复用， 信号驱动IO， epoll），单进程服务器需要做一些通常由内核来处理的调度任务。在 进程服务池 的设计中，我们可以依靠内核来确保每个服务器进程 能够公平的访问服务器主机的资源。但是当使用 单个进程处理多个客户端的方案时，服务器进程必须自行确保一个或多个 客户端不会霸占服务器，而使 其他的客户端处于饥饿状态&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;服务器集群：
    &lt;ul&gt;
      &lt;li&gt;DNS 轮询负载共享：一个地区的域名权威服务器将同一个域名映射到多个IP地址上（即 多个服务器共享统一域名）后续对DNS服务器的域名解析请求将以 循环轮转的方式返回这些IP地址，优势是成本低，存在的问题有：客户端 DNS缓存、 没有任何机制来达到良好的负载均衡、高可用 的机制 以及 无法确保同一个客户端的请求都到达同一台服务器（所以存在状态的服务器 需要在多个机器之间共享状态 这个特性成为 服务器亲和力）&lt;/li&gt;
      &lt;li&gt;负载均衡(server load balancing): 由一台负载均衡服务器将客户端的请求路由到服务器集群中的一个，这消除了 远端DNS 缓存所引起的问题。因为服务器集群只对外传递一个IP地址。负载均衡服务器会 结合一些算法来衡量或计算服务器负载 并智能化的 将负载分发到 集群中的各个成员上，可能还会提供对服务器亲和力的支持&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;inted 守护进程：
    &lt;ol&gt;
      &lt;li&gt;守护进程 inetd 被设计为用来消除运行大量非 常用服务器进程的需要，inetd 优势有：
        &lt;ol&gt;
          &lt;li&gt;预期为每个服务运行一个单独的守护进程，现在只用一个进程 inetd 守护进程，就可以监视一组指定的套接字端口，并按照需要启动其服务，因为可以降低系统进程的运行数量&lt;/li&gt;
          &lt;li&gt;inetd 简化了 启动服务的编程工作。&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;inetd 进程：
        &lt;ol&gt;
          &lt;li&gt;读取 /etc/inetd.conf 文件，对于其中的每项服务，创建一个 恰当类型的套接字，然后绑定到指定的端口上，其中每个TCP套接字 都会通过listen 允许客户端请求连接&lt;/li&gt;
          &lt;li&gt;通过select调用， inetd 对前一步中创建的所有的套接字进行监听，看是否有数据报或者连接请求 进来&lt;/li&gt;
          &lt;li&gt;select 进入阻塞状态： 直到一个UDP 数据报到来或 TCP 监听套接字 收到连接请求。TCP 会进行accept&lt;/li&gt;
          &lt;li&gt;启动套接字对应的服务，inetd 调用fork创建 一个新进程，然后调用exec 启动服务器程序，执行exec前，子进程执行如下步骤：这里面 子进程 代表的是 inetd 守护进程的标准执行过程, 所以需要执行步骤2，方便exec启动的服务器程序 使用标准文件描述符来 对客户端进行通讯
            &lt;ol&gt;
              &lt;li&gt;关闭从父进程继承的所有文件描述符，除了 用于监听的套接字&lt;/li&gt;
              &lt;li&gt;在文件描述符0，1，2上复制套接字文件描述符，并关闭套接字文件描述符本身，完成这一步之后，启动服务器进程就能通过 这三个标准 文件描述符 同套接字 通讯了&lt;/li&gt;
              &lt;li&gt;为启动的服务器进程设定用户、组ID （可选，通过/etc/inetd.conf 配置）&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
          &lt;li&gt;如果是TCP套接字，则关闭连接套接字&lt;/li&gt;
          &lt;li&gt;返回到 第 2步骤，继续执行&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;/etc/inetd.conf 配置文件：&lt;/p&gt;

        &lt;table&gt;
          &lt;thead&gt;
            &lt;tr&gt;
              &lt;th style="text-align: left"&gt;service name&lt;/th&gt;
              &lt;th style="text-align: left"&gt;socket type&lt;/th&gt;
              &lt;th style="text-align: left"&gt;protocol&lt;/th&gt;
              &lt;th style="text-align: left"&gt;flags&lt;/th&gt;
              &lt;th style="text-align: left"&gt;login name&lt;/th&gt;
              &lt;th style="text-align: left"&gt;server program&lt;/th&gt;
              &lt;th style="text-align: left"&gt;server program argument&lt;/th&gt;
            &lt;/tr&gt;
          &lt;/thead&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td style="text-align: left"&gt;ftp&lt;/td&gt;
              &lt;td style="text-align: left"&gt;stream&lt;/td&gt;
              &lt;td style="text-align: left"&gt;tcp&lt;/td&gt;
              &lt;td style="text-align: left"&gt;nowait&lt;/td&gt;
              &lt;td style="text-align: left"&gt;root&lt;/td&gt;
              &lt;td style="text-align: left"&gt;/usr/sbin/tcpd&lt;/td&gt;
              &lt;td style="text-align: left"&gt;in.ftpd&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td style="text-align: left"&gt;telnet&lt;/td&gt;
              &lt;td style="text-align: left"&gt;stream&lt;/td&gt;
              &lt;td style="text-align: left"&gt;tcp&lt;/td&gt;
              &lt;td style="text-align: left"&gt;nowait&lt;/td&gt;
              &lt;td style="text-align: left"&gt;root&lt;/td&gt;
              &lt;td style="text-align: left"&gt;/usr/sbin/tcpd&lt;/td&gt;
              &lt;td style="text-align: left"&gt;in.telnetd&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td style="text-align: left"&gt;login&lt;/td&gt;
              &lt;td style="text-align: left"&gt;stream&lt;/td&gt;
              &lt;td style="text-align: left"&gt;tcp&lt;/td&gt;
              &lt;td style="text-align: left"&gt;nowait&lt;/td&gt;
              &lt;td style="text-align: left"&gt;root&lt;/td&gt;
              &lt;td style="text-align: left"&gt;/usr/sbin/tcpd&lt;/td&gt;
              &lt;td style="text-align: left"&gt;in.rlogind&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
    &lt;/ol&gt;

    &lt;ul&gt;
      &lt;li&gt;service name (服务名称)： 该字段为服务名称，结合 protocol 就可以通过查找 /etc/services 文件以确定 inted 问该服务监听的 端口号&lt;/li&gt;
      &lt;li&gt;socket type (套接字类型)： stream, or dgram&lt;/li&gt;
      &lt;li&gt;protocol(协议)： 该字段指定了 这个套接字所使用的协议，这个字段 可以包含文件 /etc/protocols 中所列出的任何的 internet 协议&lt;/li&gt;
      &lt;li&gt;flags：
        &lt;ul&gt;
          &lt;li&gt;wait or nowait 字段表明 由 inetd 启动的服务器 是否会接管 用于该服务的 监听套接字。 wait 表明 启动的服务器 需要管理 该监听套接字，inetd 将该套接字从它所监视的文件描述符列表中移除, 直到这个服务器程序退出为止。&lt;/li&gt;
          &lt;li&gt;inetd 调用的 TCP 服务器通常被设计为 只处理一个单独的客户端连接，处理完后就终止， 把监听其他链接的任务留给inetd, 对于这样的服务器， flags字段应为 nowait, 相反 如果是被执行的服务器进程 来接受连接（accept）的话，那么该字段为wait, 此时inetd 不会去接受连接，而是将监听套接字 作为 文件描述符0 传递给 服务器进程。对于大部分的UDP 服务器， flags字段需要设定为wait， 由 inetd 调用的UDP 服务器设定为 读取并处理所有套接字上未完成的数据报，然后终止（通常需要一些超时机制）wait 可以组织 inetd在套接字上做select，会导致inetd 同 UDP 服务器程序之间，产生竞争条件，如果inetd 赢了，会启动一个新的 UDP 服务器实例&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;login name(登录名) ：该字段为 /etc/passwd 中的用户名组成部分，还可以在其后 添加 “:” + /etc/group 中的组名称， 这些确定了运行的服务器程序的用户ID和组ID， 因为inetd为 root 方式运行，所以 子进程同样可以是 特权进程。 因此可以在需要时 通过调用setuid, setgid 来修改进程凭证&lt;/li&gt;
      &lt;li&gt;serever program (服务器程序)： 指定了 被执行程序的服务器程序路径&lt;/li&gt;
      &lt;li&gt;server program argument(服务器 程序参数)： 该字段指定了 一个或多个参数， 参数之间由 空格符分隔，当执行服务器程序时，这些参数就作为程序的参数列表&lt;/li&gt;
      &lt;li&gt;inetd 作为一个提高效率的机制，本身就实现了一些简单的服务，而无需单独的 服务器程序编码来完成任务， UDP， TCP 的echo 服务就是由inetd 来实现的一个例子。编辑修改 /etc/inetd.conf 之后，需要 killall -HUP inetd 发送SIGHUP信号来重新读取配置文件&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</content>
  </entry>
  <entry>
    <title>linux-interface-04</title>
    <link rel="alternate" href="http://geniousbar.github.io/2018/12/30/linx-interface-04/"/>
    <id>http://geniousbar.github.io/2018/12/30/linx-interface-04/</id>
    <published>2018-12-30T08:00:00+08:00</published>
    <updated>2019-01-13T21:43:25+08:00</updated>
    <summary type="html">&lt;h2 id="the-linux-programming-interface"&gt;The linux programming interface&lt;/h2&gt;

&lt;h3 id="文件io-通用的io模型"&gt;文件IO 通用的IO模型&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;文件描述符： 一个非负整数，来指代打开的文件，其中包括： 管道FIFO socket，终端 设备 普通文件&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;标准文件描述符:&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style="text-align: left"&gt;文件描述符&lt;/th&gt;
          &lt;th style="text-align: left"&gt;用途&lt;/th&gt;
          &lt;th style="text-align: left"&gt;名称&lt;/th&gt;
          &lt;th style="text-align: left"&gt;stdio&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style="text-align: left"&gt;0&lt;/td&gt;
     ...&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    <content type="html">&lt;h2 id="the-linux-programming-interface"&gt;The linux programming interface&lt;/h2&gt;

&lt;h3 id="文件io-通用的io模型"&gt;文件IO 通用的IO模型&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;文件描述符： 一个非负整数，来指代打开的文件，其中包括： 管道FIFO socket，终端 设备 普通文件&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;标准文件描述符:&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style="text-align: left"&gt;文件描述符&lt;/th&gt;
          &lt;th style="text-align: left"&gt;用途&lt;/th&gt;
          &lt;th style="text-align: left"&gt;名称&lt;/th&gt;
          &lt;th style="text-align: left"&gt;stdio&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style="text-align: left"&gt;0&lt;/td&gt;
          &lt;td style="text-align: left"&gt;标准输入&lt;/td&gt;
          &lt;td style="text-align: left"&gt;STDIN_FILENO&lt;/td&gt;
          &lt;td style="text-align: left"&gt;stdin&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style="text-align: left"&gt;1&lt;/td&gt;
          &lt;td style="text-align: left"&gt;标准输出&lt;/td&gt;
          &lt;td style="text-align: left"&gt;STDOUt_FILENO&lt;/td&gt;
          &lt;td style="text-align: left"&gt;stdout&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style="text-align: left"&gt;2&lt;/td&gt;
          &lt;td style="text-align: left"&gt;标准错误&lt;/td&gt;
          &lt;td style="text-align: left"&gt;StDERR_FILENO&lt;/td&gt;
          &lt;td style="text-align: left"&gt;stderr&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;主要的系统调用&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;open(pathname, flags, mode) open创建新文件时候， 即 flags 中包含 O_creat 标志，mode制定了文件的访问权限。flags还有许多的可选参数， 包括O_APPEND, O_ASYNC等等。&lt;/li&gt;
      &lt;li&gt;read(fd, buffere, count), read 调用成功返回 实际读取的字节数， 如果遇到文件结束EOF 则返回0， 出席那错误 -1， 一次read 可能返回的 字节数可能小于count， fd为文件时候， 可能是文件靠近结尾，（所以文件尾部时候是不是小于count还是一个0？），fd为其他类型时候， socket， 终端，例如在终端遇到\n read调用就会结束。在有需要注意， C语言， 如果输入缓冲区， buffere 需要一个表示终止的空字符串，需要自己显示添加&lt;/li&gt;
      &lt;li&gt;write(fd, buffer, count), write 为将buffer中的数据写入fd中，error 返回-1， 其他返回写入的字节数， 写入字节数可能小于count （进程资源对文件大小的限制，磁盘满等， 造成部分写），write成功并不能保证已经写入到文件中，而是高速缓冲区，系统会缓存磁盘IO。&lt;/li&gt;
      &lt;li&gt;close(fd) close error -1，success 0， 文件属于有限资源，文件描述符关闭失败可能导致一个进程将资源消耗殆尽。编写长期运行的程序，比如网络服务器显得尤为重要。所以，总是显式的关闭文件描述符。&lt;/li&gt;
      &lt;li&gt;lseek(fd, offset, whence) 改变文件偏移量。文件偏移量是下一个read， write 等的起始点。文件打开指向文件头，read, write 自动调整偏移量. whence 可选参数为 SEEK_SET, SEEK_CUR, SEEK_END, 分表表示offset的基准坐标 为 文件开始头部， 当前偏移量， 文件末尾。 offset 可以为负数 表示，向前偏移多少。调用成功返回移动之后的偏移量。可以使offset为0 来获取当前偏移量。lseek并不适合所有类型的文件，应用与管道， FIFO, socket或者终端，调用将会失败， errno 被设定为ESPIPE.&lt;/li&gt;
      &lt;li&gt;ioctl(fd, request, ….args) 对为纳入标准IO模型的所有设备和文件操作而言，ioctl系统调用是个万金油&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;/proc/PID/fdinfo 目录下，可以获取系统任一进程中文件描述符的相关信息。针对进程中的每一个已打开的文件描述符，该目录下都有对应的文件， 以对应的文件描述符的数值命名，其中文件中的pos为文件偏移量， flags字段 则为一个八进制数, 其格式形如&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;   pos:  0
   flags: 02
   mnt_id: 9
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;p&gt;&lt;em&gt;文件空洞，在 文件结尾+ offset的位置写入数据，会发生什么情况，文件结尾开始到offset 中会产生空洞。文件空洞的特点在于它并不占用磁盘空间，只有当空洞中有数据写入时候，才会分配磁盘空间。 编程角度看读取空洞返回0。空间的存在，造成 文件名义上的大小可能要比其占用的磁盘存储总量要大，当空洞被写入文件时候，内和为其分配存储空间，磁盘可用空间减少。&lt;/em&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="深入探究文件io"&gt;深入探究文件IO&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;原子操作： 将某一系统调用所要完成的各个动作作为不可中断的操作，一次性加以完成, 是许多系统调用的以正确完成的必要条件&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;竞争状态是这样一种情形：操作共享资源的两个进程或线程，结果取决于 一个无法预期的顺序，即这些进程获取CPU使用权的先后相对顺序&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;open, 保证进程是打开文件的创建者，对文件是否存在的检查和创建文件属于同一原子操作。 flags: O_CREAT&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;fcntl: fcntl(fd, cmd,…) 该调用对一个打开的文件描述符执行一系列控制操作。用途之一: 对一个打开的文件， 获取或修改其访问模式和状态标志。通过open也可以设定，所以fcntl针对已经打开的文件描述符，1）文件不是由调用程序打开的， 2）通过open之外的系统调用获取的， 比如pipe，socket， 等。 示例代码&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight c"&gt;&lt;code&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;flags&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;accessMode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="n"&gt;flags&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fcntl&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;F_GETFL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 获取flags
&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;flags&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="n"&gt;errExit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"fcntl"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
 &lt;span class="n"&gt;flags&lt;/span&gt; &lt;span class="o"&gt;|=&lt;/span&gt; &lt;span class="n"&gt;O_APPEND&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// operate flags
&lt;/span&gt; &lt;span class="n"&gt;fcntl&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;F_SETFL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;flags&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;// set flags   
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;p&gt;因为 O_RDONLY, OWRONLY, O_RDWR, 因为历史原因，数值为0,1,2所以不能简单的使用 &amp;amp; 来判断是否存在对应的标记位， 如下为正确的做法&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight c"&gt;&lt;code&gt;  &lt;span class="n"&gt;accessmode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;flags&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;O_ACCMODE&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;accessmode&lt;/span&gt; &lt;span class="o"&gt;===&lt;/span&gt; &lt;span class="n"&gt;O_WRONLY&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;accessMode&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;O_RDWR&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;accessmode&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;O_RDONLY&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="n"&gt;prinf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"xx"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/li&gt;
  &lt;li&gt;文件描述符与文件的关系&lt;/li&gt;
  &lt;li&gt;结构
    &lt;ul&gt;
      &lt;li&gt;进程级别的文件描述符，记录的标志有 close-on-exec, 并指向到系统级 文件表&lt;/li&gt;
      &lt;li&gt;系统级 文件表： 记录了: 文件偏移量， 打开文件的状态标记（open flags）, 文件访问模式，与信号驱动IO相关的g设地年， 对该文件I-node对象的引用&lt;/li&gt;
      &lt;li&gt;文件系统的i-node表: 文件类型，一个指针，指向该文件所持有的锁列表， 文件的各种属性（包括文件大小， 已经时间戳）。 区分与磁盘中的i-node，这里是内存的i-node， 访问文件时候，会在内存中为i-node创建一个副本，其中记录了引用i-node的打开文句柄的数量，以及所在设备的主从设备等。
        &lt;ul&gt;
          &lt;li&gt;[ ] 添加指向 csapp的图片&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;文件设计的这些特点，可以产生如下的总结：
    &lt;ol&gt;
      &lt;li&gt;两个不同文件描述符， 若指向同一个文件句柄(系统及的文件表)将共享同一个文集偏移量。通过其中一个更改偏移量，另外一个可以观察到该变化，无论两个描述符在不同进程还是统一进程，亦或线程。&lt;/li&gt;
      &lt;li&gt;fcntl 操作的作用域 同 1相同&lt;/li&gt;
      &lt;li&gt;对应的 文件描述符的 close-on-exec 因为存储在进程级别， 所以并不会影响到其他进程。&lt;/li&gt;
      &lt;li&gt;cat log.log &amp;gt; result.log 2&amp;gt;&amp;amp;1 shell通过复制 文件描述符2实现了标准错误的重定向操作。因为描述符2同1指向同一个文件句柄，所以输出不会产生覆盖彼此的问题。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;复制文件描述符
    &lt;ul&gt;
      &lt;li&gt;dup(int oldfd), 复制一个打开的文件描述符oldfd， 并返回一个新的描述符， 两者指向同一个文件句柄，系统保证新描述符一定是编号值最低的未用的文件描述符。意味着dup(1)会产生3&lt;/li&gt;
      &lt;li&gt;dup2(oldfd, newfd)： 系统调用会创建oldfd的副本，编号由newfd决定， 如果newfd已经打开，会先将其关闭，然后返回newfd指定的编号的文件描述符。（所以dup2(调用了那个接口，来产生特定编号的文件描述符。)） 但是dup2关闭newfd时候会忽略错误， 所以 最好手动关闭newfd,&lt;/li&gt;
      &lt;li&gt;pread, pwrite(fd, buf, count, offset)： 区别于 read, write的地方在于， pread, pwrite 会在指定的offset进行操作，并且不会改变文件的偏移量。这些特性是的 使得在多线程应用非常便利，多个进程可以同时操作同一个描述符。而不会互相影响。如果使用lseek， read调用引起竞争状态。使得编写正确的IO代码变得困难。&lt;/li&gt;
      &lt;li&gt;分散输入和集中输出, (scatter-gather IO), readv, writev&lt;/li&gt;
      &lt;li&gt;截断: truncate(char * pathname, length), ftruncate(fd, length): 若文件长度&amp;gt; length 丢弃超出部分， &amp;lt; length, 将在文件尾部添加一系列空字节或者文件空洞(版本实现比一样吗？)其中 truncat 通过字符串指定名字但是依然需要文件的写权限。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;非阻塞IO： 1) open 指定 O_NONBLOCK, 2） socket因为无法通过open来获取文件描述符， 所以需要使用fcntl来启动非阻塞标志。&lt;/li&gt;
  &lt;li&gt;-【】大文件&lt;/li&gt;
  &lt;li&gt;/dev/fd: 是一个连接到 /proc/PID/fd 目录的一个符号连接， 该目录中的每一个目录都连接到 /proc/PID/fd中的目录，一一对应&lt;/li&gt;
  &lt;li&gt;临时文件：mkstemp(char * template), tmpfile(): 打开文件使用了O_EXCL 以保证独占使用文件。两者区别在于 mkstemp()之后需要unlink(char* template), 在close(fd) 之后自动删除， tmpfile 则无需调用unlink, close之后 自动删除（内部自动调用unlink）&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="进程"&gt;进程&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;进程 是可执行程序的实例&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;进程号 和 父进程号： 每个进程都有一个PID， 唯一标识 某个进程，除了少数(init PID 为1) 之外，多数程序与运行该程序的进程PID没有固定关系。 linux内核限制 进程号小于 32767,当进程号达到这个限制时候，内核将重置进程号计数器，重新从最小的整数开始分配。（进程号计数器会重置为 300， 因为 低于此数值的进程号 为系统进程和守护进程 长期占用， 关于最大进程号 默认上限是 32767,, 但是可以通过更改 /proc/sys/kernel/pid_max 来进行更改=最大值+1， 64位最大进程号为2 22次方 为什么？）getppid可以获取进程的父PID， 可以通过pstree， 来查看家族树。&lt;/li&gt;
  &lt;li&gt;命令行参数 argc, argv：argc 表示命令行参数的个数，argv 是一个指向 命令行参数的指针数组，每一个参数指向一个以null结尾的字符串。其中argv[0] 包含了 调用程序的名称。可以为一个程序创建多个连接，然后argv[0]的名字是不同的。&lt;/li&gt;
  &lt;li&gt;环境列表： 每个进程都有与之相关的字符串数组成为环境列表(envoriment list), 每个字符串都以 name=value 的形式定义。常常将name称为环境变量。新创建进程会继承父进程的环境副本，因为获得是副本，随意之后父子环境信息个不相关。
    &lt;ul&gt;
      &lt;li&gt;export NAME=value: 将NAME变量添加到shell环境中, 此后这个shell所创建的进程中都存在变量NAME&lt;/li&gt;
      &lt;li&gt;NAME=value programe: 在应用程序 programe的环境变量中添加一个变量值，但是不影响shell&lt;/li&gt;
      &lt;li&gt;printenv： 显示当前的环境列表&lt;/li&gt;
      &lt;li&gt;/proc/PID/environ: 文件显示编号为PID的进程的环境列表&lt;/li&gt;
      &lt;li&gt;getenv(char *name): 获取环境变量的数值(value), 不存在返回NULL&lt;/li&gt;
      &lt;li&gt;putenv(char *string): 添加一个 name=value 形式字符串的环境变量，失败返回非0值。一位内putenv 添加到environ变量的是一个指针，而不是string 的副本，所以不应该在栈上分配&lt;/li&gt;
      &lt;li&gt;setenv(char * name, char *value, overwrite): 该函数会复制 name, value。函数会自动拼接=号，overwrite ！= 0 总会写入， overwrite = 0时，存在则不写入，不存在写入&lt;/li&gt;
      &lt;li&gt;unsetenv&lt;/li&gt;
      &lt;li&gt;clearenv&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ABI, 应用程序二进制接口，一套规则。 规定了二进制可执行文件在运行时应该如何与某些服务（诸如内核或函数库所提供的服务）交换信息， ABI特别规定了使用那些寄存器和栈地址交换信息以及所交换数值的含义，一旦针对某个特定ABI进行了编译，其二进制可执行文件应该能在ABI相同的任何系统上运行。与之想法，标准化的API仅能通过编译源代码来保证应用程序的可移植性。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="内存分配"&gt;内存分配&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;在堆上分配内存， 进程呢个可以通过增加堆的大小来分配内存， 堆就是一段长度可变的连续的虚拟内存，初始于 进程未初始化的数据段末尾，随着内存的分配和释放而增减。通常将堆当前内存边界成为 program break
    &lt;ul&gt;
      &lt;li&gt;brk(vodi * end_data_segment), sbrk(int increment), 两个系统调用可以改变 program break 的位置， 位置调升以后，程序可以访问新分配区域内的任何内存地址。内核会在进程首次访问新分配的地址时，会自动分配实际的物理内存页。brk 直接改变 program break 的地址， sbrk 增量的改变 break 地址， 在原有的 break 地址上 增加increment 的空间，函数返回之前的break地址，也就是新分配的地址空间的起始处，sbrk(0) 返回现有的 program break 地址。&lt;/li&gt;
      &lt;li&gt;malloc(size_t size), free(void * ptr)： 库函数(建立在系统调用， brk, sbrk的基础上封装而成)，比较与系统调用， 库函数拥有不少的优点， 明显的有 &lt;strong&gt;允许随意的释放内存块，他们被维护于一张空闲的内存列表中，在后续的内存分配调用时候循环使用&lt;/strong&gt;,
        &lt;ol&gt;
          &lt;li&gt;malloc: 分配成功返回void* 类型指针， 因为void类型所以可以随意使用， 调用失败可能是因为program break 已经触顶，（已经没有堆空间可以分配） 则返回NULL， 虽然出错的概率很小，但是依然需要进行错误检查。&lt;/li&gt;
          &lt;li&gt;free： 函数释放ptr所指向的内存块，一般情况下， free并不会降低 program break 的位置， 而是将该内存块放入到空闲的内存列表中，以便供后续的malloc使用。有如下的好处， 1）尽量的减少了 sbrk的系统调用此处&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;调用free还是不呢？: 当进程终止时， 所有的内存都会返回给操作系统，基于内存的这一自动释放机制，对于那些分配内存并持续使用的程序而言，可以忽略free，因为在多次调用free时候不但消耗大量的cpu时间，还是使代码趋向于复杂。&lt;/li&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;malloc, free 的实现: 数据结构为 双向链表， len&lt;/td&gt;
              &lt;td&gt;pre&lt;/td&gt;
              &lt;td&gt;next&lt;/td&gt;
              &lt;td&gt;space&lt;/td&gt;
              &lt;td&gt;其中len 表示该空闲内存块 的大小， pre,next 为双向链表指针，指向上一个下一个空闲内存块， space为空闲内存&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
        &lt;ol&gt;
          &lt;li&gt;malloc(size_t size) 会扫描空闲链表，以找到适合大小的内存块
            &lt;ul&gt;
              &lt;li&gt;空闲链表中的len == size 时，则直接返回给z调用者&lt;/li&gt;
              &lt;li&gt;len &amp;gt; size: 对其切割（将会出现一个合适大小的内存块+一个空闲的内存块）&lt;/li&gt;
              &lt;li&gt;len &amp;lt; size: 没有找到符合要求的内存块时，调用sbrk 重新分配适合的内存块（为了更少的系统调用sbrk, 通常mallock 会以更大的increment 调用sbrk ）&lt;/li&gt;
              &lt;li&gt;更新 空闲块链表&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;free(void * ptr) : free函数通过 ptr 内存块中 len来知道内存块大小，然后加入到 空闲块链表中。&lt;/li&gt;
          &lt;li&gt;因为free， malloc的实现导致， 1）ptr指针需要完全正确，以避免对空闲链表的错误操作。（非malloc返回的指针，绝不能调用free）， 2）不能重复释放同一个指针&lt;/li&gt;
          &lt;li&gt;除了mallock, C函数库还提供了其他的 内存分配算法版本的 内存分配函数实现。 calloc, realloc, memalign, posix_memalign, alloca（该函数从栈上分配内存，因为栈的特殊性使其有两个特点 1）只有当调用函数的位于顶部时候可用 2）不需要free， 因为函数返回时代码会重置栈指针。）&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="用户和组"&gt;用户和组&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;每个用户都存在唯一的UID， 并可以归属于多个GID&lt;/li&gt;
  &lt;li&gt;UID， GID 的主要用途有 1）确定各种系统资源的所有权， 2）对进程的操作资源的权限加以控制&lt;/li&gt;
  &lt;li&gt;/et/passwd, 用于记录用户相关的UID， home, shell etc等。 /etc/shadow 维护对应UID的加密密码。组文件 /etc/group, 维护GID， 以及对应的用户列表，&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="进程凭证"&gt;进程凭证&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;每个进程都有一套数字表示UID和GID 具体如下：
    &lt;ol&gt;
      &lt;li&gt;real user id, real group id, 实际用户id，实际组id， 确定了进程所属的用户和组，作为登陆过程之一，登陆shell 从/etc/passwd中读取相应用户密码记录的3，4字段，设定为其实际用户id &amp;amp; 组id，当创建进程时，将从父进程中继承这些&lt;/li&gt;
      &lt;li&gt;effective user id, effective group id, 有效用户id， 有效组id。 系统通常通过结合有效用户id，组id 连同辅助组id 来授予进程权限。&lt;/li&gt;
      &lt;li&gt;saved user id, saved group id, 保存的用户id， 保存的组id&lt;/li&gt;
      &lt;li&gt;file-system user id, file-system group id, 文件系统用户id， 文件系统组id&lt;/li&gt;
      &lt;li&gt;辅助组id&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;set-user-id, set-group-id 程序， set-user-id 程序会将进程的有效用户id设为可执行文件的用户id， 从而获得不具备的权限。set-group-id 程序有类似的效果。可执行文件拥有两个特别的权限位 set-user-id和set-group-id位，（实际上所有文件都有，只有可执行文件比较有用）ls -l program, x 变成 代表 拥有set-user-id or set-group-id. 当运行set-user-id程序时候，内核会将进程的有效用户id变为可执行文件的用户id， set-group-id 执行类似的操作。 linux系统中常用的passwd, mount, unmount, wall(用户向tty组下所有终端写入消息)等都为set-user-id程序(set-user-id-root 来特指 root用户所拥有的 set-user-id 程序)&lt;/li&gt;
  &lt;li&gt;保存用户id(saved-user-id) 当执行程序时，会发生如下事情：
    &lt;ol&gt;
      &lt;li&gt;可执行文件的set-user-id权限位开启，将进程等的有效用户id 设定为 可执行文件的属主，未设定则进程有效用户id不变&lt;/li&gt;
      &lt;li&gt;复制 有效id 到 set-user-id&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;有不少的系统调用，允许将set-user-id 程序的有效用户id在实际用户id和保存set-user-id之间切换。对于与执行文件用户id相关的任何权限，程序能够随时在两种状态间切换。&lt;/li&gt;
  &lt;li&gt;文件系统用户id： 在进行linux中 打开文件、改变文件属主 、修改文件权限之类的文件操作时，决定其操作权限的是 文件系统用户id， 而非 有效用户id。通常 文件系统用户id和组id都等于相应的有效用户和组id， 并且只要有效用户id发生变化，相应的文件系统用户id也会发生变化，只有linux特有的两个系统调用setfsuid(), setfsgid()才能刻意的制造出 文件系统用户id 不等于 有效用户id。因此   大部分情况下，可以忽视文件系统用户id，等同于检查 有效用户id&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;[ ] 完成对应的系统调用&lt;/li&gt;
  &lt;li&gt;[ ] 如何在进程中调用 特权程序?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="时间"&gt;时间&lt;/h2&gt;
&lt;p&gt;大多数计算机体系结构都内置有硬件始终，是的内核得以计算真实时间和进程时间。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;日历时间: Unix 系统内部对时间的表示，以 Epoch以来的秒数来度量（UTC 时间）。存储于time_t类型的变量中。（time_t是一个有符号整数 理论上当前许多的32位unix系统都面临着一个2038 的理论问题，如果执行的计算工作涉及到未来时间，那么在2038年问题都会出现，事实上在此之前所有的unix系统可能都已经升级到了64位系统，然而32位嵌入式系统的寿命要长的多，依然面临着这个问题）
    &lt;ul&gt;
      &lt;li&gt;gettimeofday(timeval *tv, timezone *tz): struct timeval { time_t tv_sec; suseconds_t tv_usec;} 其中 tv_usec提供了微秒级别的精度，参数tz是一个历史产物，应该总为NULL，&lt;/li&gt;
      &lt;li&gt;time_t time(time_t *timep): 函数有两种方式返回同样的结果， UTC秒数， timep 不为NULL，将秒数放在timep 的指针中， timep NULL返回一个数值&lt;/li&gt;
      &lt;li&gt;时间转换函数： 类型包含如下 time_t， 打印格式， 分解时间(即是： struct tm {int tm_sec; int tm_min; int tm_hour; int tm_mday; int tm_year; int tm_mon; etc})， 转换函数即是 用来在上面的类型中 进行转换的函数，方便使用。其中包括， strftime, mktime, gmtime, localtime 等。&lt;/li&gt;
      &lt;li&gt;时区： 时区信息被系统使用标准格式保存于文件中。 /usr/share/zoneinfo, 该目录中的每个文件都包含了一个特定国家或地区的时区制度，系统的本地时间在 /etc/localtime 中定义，通常链接到 /usr/share/zoneinfo中的一个文件。使用TZ环境变量来为一个程序指定时区，其值为 “:“ + 时区名称组成的字符串。设定时区会自动影响到 ctime, locatime, mktime, strftime 等，&lt;/li&gt;
      &lt;li&gt;setlocale(int category, char * locale) : 设定和查询程序的当前地区, category 可选项为 表中的数值 + LC_ALL, LANG, LANGUAGE, 其中，LC_ALL 为设定所有值而准备， LANG为设定所有为明确指定的变量而准备. setlocale 参数中的locale可以为 “”空字符串，表示可以从环境变量中却的地区的设定， 大部分的程序代码 setlocale(LC_ALL, “”) 来使用程序中的环境变量设定地区，如果调用被省略，这些环境变量将不会对程序的地区设定生效。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;文件名&lt;/td&gt;
          &lt;td&gt;目的&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;LC_TYPE&lt;/td&gt;
          &lt;td&gt;包含字符分类以及大小写转换规则&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;LC_COLLATE&lt;/td&gt;
          &lt;td&gt;包含针对一字符集的排序规则&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;LC_MONETARY&lt;/td&gt;
          &lt;td&gt;对货币格式化规则&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;LC_NUMERIC&lt;/td&gt;
          &lt;td&gt;对货币意外的数字格式化规则&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;LC_TIME&lt;/td&gt;
          &lt;td&gt;对日期和时间的格式化规则&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;LC_MESSAGES&lt;/td&gt;
          &lt;td&gt;针对肯定和否定响应，就格式以及数值做了规定&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;进程时间:&lt;br /&gt;
&lt;strong&gt;软件时钟： 进程时间受限于 系统软件时钟的分辨率，度量单位 为jiffies（定义在内核代码中的常量HZ, jiffies 为1s内 cpu增加的记数，100HZ(jiffies) 时候， 1 jiffies(hz) 的时间为10毫秒）这是内核按照round-robin的分时调度算法分配cpu进程的单位。因为CPU 的速度大大提高，2.6.0的内核时钟速度已经提高了1000hz， 更高的分辨率意味着更高的时间精度，然而并非可以任意的提高时钟频率，因为每个时钟中断都对耗费少量的CPU时间&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;用户CPU时间： 在用户模式下执行所花费的时间数量&lt;/li&gt;
      &lt;li&gt;系统CCPU时间： 在内核模式中执行所花费的时间数量&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="系统和进程信息"&gt;系统和进程信息&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;为了提供简单的方法来访问内核信息， 现在的UNIX实现提供了一个/proc 虚拟文件系统（并非存储于磁盘上，恶热是内核在进程访问信息时候动态生成的），其中包含了各种用于展示内核信息的文件。并允许进程通过常规的IO系统调用来访问，有些还可以对信息进行修改。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;/proc/PID： 内核提供了对应PID进程的目录结构，&lt;/p&gt;

    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;文件&lt;/td&gt;
          &lt;td&gt;描述&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;cmdline&lt;/td&gt;
          &lt;td&gt;以 \0分割的命令行参数&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;cwd&lt;/td&gt;
          &lt;td&gt;指向当前工作目录的符号连接&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;Environ&lt;/td&gt;
          &lt;td&gt;NAME=value 键值对的环境列表&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;exe&lt;/td&gt;
          &lt;td&gt;指向正在执行文件的符号连接&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;fd&lt;/td&gt;
          &lt;td&gt;文件目录包含了指向由进程打开文件的符号连接&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;maps&lt;/td&gt;
          &lt;td&gt;内存映射&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;mem&lt;/td&gt;
          &lt;td&gt;进程虚拟内存&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;mounts&lt;/td&gt;
          &lt;td&gt;进程的安装点&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;root&lt;/td&gt;
          &lt;td&gt;指向根目录的符号链接&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;status&lt;/td&gt;
          &lt;td&gt;各类信息&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;/proc/PID/fd： 目录 为进程打开的每个文件描述符都包含了一个符号连接，每个符号连接的名称都与描述符的数值向匹配（/proc/pid/1 为 标准输出）， 任何进程都可以使用符号连接 /proc/self 来访问自己的/proc/PID 目录&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;/proc 目录下的系统信息:&lt;/p&gt;

    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;目录&lt;/td&gt;
          &lt;td&gt;描述&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;/proc/net&lt;/td&gt;
          &lt;td&gt;网路和套接字的状态信息&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;/proc/sys/fs/&lt;/td&gt;
          &lt;td&gt;文件系统相关的设定&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;/proc/sys/kernel/&lt;/td&gt;
          &lt;td&gt;各种常规的内核设定&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;/proc/sys/net&lt;/td&gt;
          &lt;td&gt;网络和套接字设定&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;/proc/sys/vm/&lt;/td&gt;
          &lt;td&gt;内存管理设定&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;uname(utsname * utsbuf): 系统调用返回主机系统的标识信息&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="文件io缓冲"&gt;文件IO缓冲&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;出于效率的考虑， 系统IO调用，以及 函数库IO函数，都在文件IO操作中对数据进行了缓冲&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>linux-interface-02</title>
    <link rel="alternate" href="http://geniousbar.github.io/2018/12/06/linux-interface-02/"/>
    <id>http://geniousbar.github.io/2018/12/06/linux-interface-02/</id>
    <published>2018-12-06T08:00:00+08:00</published>
    <updated>2018-12-31T15:41:43+08:00</updated>
    <summary type="html">&lt;h2 id="the-linux-programming-interface"&gt;The linux programming interface&lt;/h2&gt;

&lt;h2 id="系统编程概念"&gt;系统编程概念&lt;/h2&gt;

&lt;p&gt;无论何时，执行了系统调用或者库函数，检查调用的返回状态以确定调用是否成功,是一条编程铁律。(消灭nil就好了)&lt;/p&gt;

&lt;h3 id="系统调用"&gt;系统调用&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;借助这一机制，进程可以请求内核以自己的名义去执行动作，以API 的形式，内核提供一系列服务供程序访问。（创建进程， IIO操作等）可以参考 csapp中的 异常控制流章节。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;系统调用有以下特征：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;系统调用将CPU 从用户态切换到 内核态，以便CPU访问受保护的内存等（越过...&lt;/li&gt;
&lt;/ol&gt;</summary>
    <content type="html">&lt;h2 id="the-linux-programming-interface"&gt;The linux programming interface&lt;/h2&gt;

&lt;h2 id="系统编程概念"&gt;系统编程概念&lt;/h2&gt;

&lt;p&gt;无论何时，执行了系统调用或者库函数，检查调用的返回状态以确定调用是否成功,是一条编程铁律。(消灭nil就好了)&lt;/p&gt;

&lt;h3 id="系统调用"&gt;系统调用&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;借助这一机制，进程可以请求内核以自己的名义去执行动作，以API 的形式，内核提供一系列服务供程序访问。（创建进程， IIO操作等）可以参考 csapp中的 异常控制流章节。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;系统调用有以下特征：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;系统调用将CPU 从用户态切换到 内核态，以便CPU访问受保护的内存等（越过保护机制）&lt;/li&gt;
  &lt;li&gt;系统调用的组成是固定的。每个系统调用都由一个唯一的数字来标识。（程序通过名称标识系统调用，对编号方案无需关心）&lt;/li&gt;
  &lt;li&gt;每个系统调用都有一套对应的参数，对用户态内核态的参数传递有一定规范&lt;br /&gt;
  下面是一个系统调用的示例：&lt;/li&gt;
  &lt;li&gt;应用程序调用C语言的函数库中的外壳（wrapper） 函数，来发起系统调用&lt;/li&gt;
  &lt;li&gt;外壳函数保证所有的系统调用参数可用，并将参数复制到寄存器&lt;/li&gt;
  &lt;li&gt;外壳函数会将系统调用编号复制到%eax中，用于区分不同的系统调用&lt;/li&gt;
  &lt;li&gt;外壳函数执行一条中断机器指令，引发CPU从用户态切换到内核态，并执行 todo&lt;/li&gt;
  &lt;li&gt;内核调用 system_call 来处理中断，&lt;br /&gt;
    1) 在内核栈中保存寄存器数值&lt;br /&gt;
    2）验证 系统调用的 编号有效性&lt;br /&gt;
    3) 通过系统调用编号 发现对应的系统调用服务例程，检查参数的有效性，执行对应的代码逻辑。最后将结果状态返回给system_call&lt;br /&gt;
    4) 从内核栈中回复各个寄存器值，并将系统调用返回值置于栈中&lt;br /&gt;
    5) 返回值外壳函数，通知讲CPU切换到用户态&lt;/li&gt;
  &lt;li&gt;系统调用的服务例程返回值代表调用有误， 外壳函数会使用该值设定全局变量errno。外壳函数会返回到调用程序，并返回一个整数，标志系统调用是否成功。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="库函数"&gt;库函数&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;库函数 的设计 是为了提供比底层系统 调用更为方便的调用接口,例如 printf函数 可提供格式化输出和数据缓存， 而write 系统调用只能输出 字节块， malloc, free 函数包装了 内存的释放和分配工作&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id="处理错误"&gt;处理错误&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;几乎所有的 系统调用都会返回某种类型的错误,用以表明 调用成功与否，要了解是否调用成功则必须坚持对状态进行检查。若调用失败则必须采取相应的行动，至少应该输出错误。 不检查状态，少写几行代码，听起来很诱人。实际上却会浪费掉大把的程序调试时间&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;这段陈述适用于 任何领域的编程工作， 简单的就是 人们常讲的 nil是一个百万的设计错误 一样。nil让他们忽略对他的检查，因为假定 变量不是nil的代码很清爽，可以减少很多的if判断，造成了nil是一个非常常见，频率高的错误。 那么正确的设计应该是什么样子呢？ 答案或许是Option + 强制类型（弱类型语言不必要了，因为没有人可以阻止你不检查错误）&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;系统错误处理&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;通常返回值为-1 表示出错，系统调用失败后， 会将全局变量设定 errno 设定为一个正值来标记具体错误。但是如果系统调用和库函数成功，errno并不会被重置为0，所以单独的检查errno的设定来判断错误是错误的，因为可能是上个调用错误设定的数值。少数系统调用 在调用成功后(getpriority)依然返回-1， 要判断此类错误需要调用前将errno 设定为0， 然后根据errno判断是否错误。&lt;br /&gt;
 打印错误， perror(“string”), char *strerror(int errorcode), strerror返回的字符串 指针是静态分配的，后续的调用会覆盖之前的调用。两个函数都是 locale-sensitive 语言环境敏感型，所以现实的是本地语言。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;库函数的错误处理&lt;br /&gt;
&lt;strong&gt;不同的库函数在调用发生错误时候，返沪的数据类型和数值也各不相同，可以划分为几个类型:&lt;/strong&gt;&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;同系统调用完全相同, (remove 会调用unlink 或者rmdir)&lt;/li&gt;
      &lt;li&gt;出错时会返回-1之外的其他值，然后设定errno表明出错的具体情况 (fopen 出错返回 NULL 指针，同时设定errno)&lt;/li&gt;
      &lt;li&gt;根本不使用errno&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</content>
  </entry>
  <entry>
    <title>linux-interface</title>
    <link rel="alternate" href="http://geniousbar.github.io/2018/11/11/linux-interface/"/>
    <id>http://geniousbar.github.io/2018/11/11/linux-interface/</id>
    <published>2018-11-11T08:00:00+08:00</published>
    <updated>2018-12-05T14:56:41+08:00</updated>
    <summary type="html">&lt;h2 id="the-linux-programming-interface"&gt;The linux programming interface&lt;/h2&gt;

&lt;h2 id="基本概念"&gt;基本概念&lt;/h2&gt;

&lt;h3 id="内核"&gt;内核&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;通常的定义，1）完整的软件包， 这包括用来管理计算机资源的核心软件 以及附带的标准软件工具（shell，图形用户界面， 文件工具）2) 狭义的层面，是指管理和分配计算机资源的核心软件&lt;/li&gt;
  &lt;li&gt;职责: 1）进程调度， 2）内存管理， 3）文件系统， 4）创建和终止进程， 5）设备管理， 6）联网， 7）提供系统调用的编程接口&lt;/li&gt;
  &lt;li&gt;内核态、用户态: 区分态的原因： 1）只有cpu处于内核态的时候，才能执行某些...&lt;/li&gt;
&lt;/ol&gt;</summary>
    <content type="html">&lt;h2 id="the-linux-programming-interface"&gt;The linux programming interface&lt;/h2&gt;

&lt;h2 id="基本概念"&gt;基本概念&lt;/h2&gt;

&lt;h3 id="内核"&gt;内核&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;通常的定义，1）完整的软件包， 这包括用来管理计算机资源的核心软件 以及附带的标准软件工具（shell，图形用户界面， 文件工具）2) 狭义的层面，是指管理和分配计算机资源的核心软件&lt;/li&gt;
  &lt;li&gt;职责: 1）进程调度， 2）内存管理， 3）文件系统， 4）创建和终止进程， 5）设备管理， 6）联网， 7）提供系统调用的编程接口&lt;/li&gt;
  &lt;li&gt;内核态、用户态: 区分态的原因： 1）只有cpu处于内核态的时候，才能执行某些命令， 例如 halt etc， 2）区分进程以及内核，能够让开发者 以面向进程的方式来编写 软件。 通过进程隔离 硬件计算机资源&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="用户和组"&gt;用户和组&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;用户, 唯一的登录名和与之对应的整数型用户ID， 系统密码文件 /etc/passwd,为每个用户记录一行， 包含信息主要有: 组 ID， 主目录， 登录shell&lt;/li&gt;
  &lt;li&gt;组, 系统组文件 /etc/group, 包含信息主要有: 组名， 组 ID， 用户列表&lt;/li&gt;
  &lt;li&gt;超级用户， ID 为 0，可以不受系统权限检查之上。 可以访问系统的所有文件， 能发送信号给其他用户的进程&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="单根目录层级目录链接文件"&gt;单根目录层级、目录、链接、文件&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;内核维护者一套单根目录结构， 放置系统的所有文件， /根目录 图 &lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;文件类型: 1） 普通文件， 2）设备， 3）管道， 4）套接字， 5）目录以及符号链接&lt;/li&gt;
  &lt;li&gt;路径和链接(hard link)， 一个文件可以有多个链接，目录可以包含 文件 + 目录， 每个目录至少有两个链接， .和..  指向目录自身的链接，已经指向上级目录的链接，根目录 “/”，的..指向自身&lt;/li&gt;
  &lt;li&gt;符号链接(soft link), 普通链接（hard link）的内容为 文件名+指针 的一条记录， 符号链接则是： 经过特殊标记的文件， 文件 + 目标文件字符串。多数情况下， 系统调用到了 路径名，如果是符号链接的情况下， 内核会自动 以符号链接 所指向的文件名来替换符号链接。递归的进行解析，为了防止循环解析， 内核对解析次数进行了限制。&lt;/li&gt;
  &lt;li&gt;文件名， 文件名应该避免以-字符串开头，避免 误认为命令选项开关&lt;/li&gt;
  &lt;li&gt;路径名： 绝对路径, 相对路径（定义了相对于进程当前工作目录的文件位置）当前工作目录（每个进程都有一个当前工作目录， 也是进程解释相对路径名的参照点， 进程的当前工作目录继承自 父进程， 相对登录shell来说 其初始当前工作目录为 密码文件 /et/passwd 中指定的，可以使用cd 改变）&lt;/li&gt;
  &lt;li&gt;文件的所有权：系统将用户分为3类， 文件的属主、文件属组成员、其他用户， 目录也可以设定所有权，但是意义有所不同，读写 允许列出目录内容， 写 允许对目录内容更改， 执行 允许对目录文件进行访问&lt;/li&gt;
  &lt;li&gt;文件IO模型， 同一套系统调用（open、read、write、close等）所执行的IO操作，可以应用于所有文件类型， 本质而言， 内核只提供一种文件类型， 字节流序列&lt;/li&gt;
  &lt;li&gt;文件描述符： 非负整数，来指代 打开的 文件。通常shell启动的进程会继承 3个已经打开的文件描述符， 0 为标准输入， 1 标准输出， 2 标准错误。在stdio函数库中， 分别与 stdin, stdout, stderr一一对应&lt;/li&gt;
  &lt;li&gt;stdio 函数库: C 语言标准库的IO函数，例如fopen， fclose， printf 等，注意stdio 函数建立在 系统调用write， open close read之上&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="进程"&gt;进程&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;进程是 正在执行的 程序实例， 执行程序时，内核会将程序代码再入到 虚拟内存， 为程序变量 分配空间，建立内核记账结构，用以记录进城有关的各种信息（PID， 状态）&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;进程的内存布局， 逻辑上： 文本， 数据，堆，栈&lt;/li&gt;
  &lt;li&gt;创建和执行程序， fork， 子进程会从父进程继承数据段、栈、堆 的副本，修改其内容，不会影响父进程。文本段则为父子进程共享。子进程要么继续执行父进程代码，要么执行execve 去加载一个全新的程序，execve会销毁现有的文本段、数据段、堆、栈，根据程序的代码重新创建并替换他们&lt;/li&gt;
  &lt;li&gt;Pid &amp;amp;&amp;amp; PPID: PPID 为父进程PID&lt;/li&gt;
  &lt;li&gt;进程终止和终止状态：两种方式杀死进程：1）exit() 系统调用请求退出， 2）向进程传递信号，将其杀死。无论那种方式进程退出，都会生成 『终止状态』一个非负数 小整数。可供父进程的wait 系统调用检测。exit()可以传递参数设定 终止状态， 信号杀死进程，则由信号类型设定进程的终止状态。， 0表示 功成身退， 非0 表示错误&lt;/li&gt;
  &lt;li&gt;进程标识：1）真实用户ID， 组ID，子进程继承父进程的 这些ID。登录shell，从/etc/passwd 中获取真实用户ID， 2）有效用户ID 组ID， 进程在访问受保护资源时候，会使用这两个ID来确定权限。3）补充组，用来表示进程所属的额外组。&lt;/li&gt;
  &lt;li&gt;init 进程： 所有进程之父，相应的程序文件为/sbin/init, 并且以root权限运行，只有关闭系统才能杀死该进程。&lt;/li&gt;
  &lt;li&gt;守护进程：特殊用途的进程。特征， 1）守护进程通常在系统引导时启动， 直至系统关闭。2）在后台运行，无控制端 供其读取或者写入数据。（例如syslogd， httpd）&lt;/li&gt;
  &lt;li&gt;环境列表： 每个进程都有一份环境列表。fork创建的新进程会继承父进程的环境列表。这为父子进程 提供了一种通讯机制。进程调用fork， exec 可以通过环境列表来控制程序 行为。&lt;/li&gt;
  &lt;li&gt;资源限制：分为两类， soft limit, hard limit, 非特权进程调整 soft limit 只能在 0 - hard limit 之间， hard limit 只能调低。fork同样会继承父进程的limit&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="进程间通信及同步"&gt;进程间通信及同步&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;信号: 表示事件的发生&lt;/li&gt;
  &lt;li&gt;管道: shell 中的 |， 以及FIFO&lt;/li&gt;
  &lt;li&gt;套接字: socket&lt;/li&gt;
  &lt;li&gt;文件锁&lt;/li&gt;
  &lt;li&gt;消息队列: 用于在进程间交换消息&lt;/li&gt;
  &lt;li&gt;信号量: 用于同步&lt;/li&gt;
  &lt;li&gt;共享内存: 允许两个及以上的进程共享同一块内存， 当进程改变了共享内存的内容时候， 其他进程会了解这一变化。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="信号"&gt;信号&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;软中断， 进程受到信号，意味着事件、错误异常的发生。信号类型有很多，采用不同的整数进行区分。以SIGxxxx的形式进行命名。&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;信号产生的情况有：
    &lt;ol&gt;
      &lt;li&gt;用户键入中断Ctrl-C&lt;/li&gt;
      &lt;li&gt;进程的子进程之一终止&lt;/li&gt;
      &lt;li&gt;进程设定的定时器 已到期&lt;/li&gt;
      &lt;li&gt;etc …&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;信号处理：
    &lt;ol&gt;
      &lt;li&gt;信号从产生到送到期间，出去挂起状态。系统通常会在进程下次获得调度时，将挂起信号 送达。如果进程在运行中，则会立即将信号送达。&lt;/li&gt;
      &lt;li&gt;进程可以选择 接受、屏蔽信号。如果送达的信号处于屏蔽信号，此信号将一直挂起，直到 程序解除对信号的屏蔽&lt;/li&gt;
      &lt;li&gt;收到信号的动作有： 1）忽略信号、默认动作、设定自己的信号处理器， 2）被信号杀死， 3）挂起，之后使用专门的信号 唤醒&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>redis-rb</title>
    <link rel="alternate" href="http://geniousbar.github.io/2018/09/16/redis-rb/"/>
    <id>http://geniousbar.github.io/2018/09/16/redis-rb/</id>
    <published>2018-09-16T08:00:00+08:00</published>
    <updated>2018-11-09T09:07:10+08:00</updated>
    <summary type="html">&lt;h2 id="redis-rb-为ruby-连接redis的客户端"&gt;redis-rb 为ruby 连接redis的客户端&lt;/h2&gt;

&lt;h4 id="项目结构"&gt;项目结构&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;项目本身依赖于 hiredis，而hiredis 本身是一个redis client c的包装。并没有搞懂为什么需要依赖redis client&lt;/li&gt;
  &lt;li&gt;项目目录结构如下&lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;  /lib
    |---- redis.rb
    |---- /Redis
          |---- connection.rb
          |---- errors.rb
          |---- pipeline.rb...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</summary>
    <content type="html">&lt;h2 id="redis-rb-为ruby-连接redis的客户端"&gt;redis-rb 为ruby 连接redis的客户端&lt;/h2&gt;

&lt;h4 id="项目结构"&gt;项目结构&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;项目本身依赖于 hiredis，而hiredis 本身是一个redis client c的包装。并没有搞懂为什么需要依赖redis client&lt;/li&gt;
  &lt;li&gt;项目目录结构如下&lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;  /lib
    |---- redis.rb
    |---- /Redis
          |---- connection.rb
          |---- errors.rb
          |---- pipeline.rb
          |---- subscribe.rb
          |---- cluster.rb
          |---- hash_ring.rb
          |---- distributed.rb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;redis.set(key, value) 大概的调用栈如下&lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight ruby"&gt;&lt;code&gt;    &lt;span class="n"&gt;redis&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;Redis&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;host: &lt;/span&gt;&lt;span class="s2"&gt;"127.0.0.1"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;port: &lt;/span&gt;&lt;span class="mi"&gt;6379&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;db: &lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;redis&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'counter'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'name'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nb"&gt;p&lt;/span&gt; &lt;span class="n"&gt;redis&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'counter'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;  Redis.new
    |--- @original_client = Client.new(options) # options config
            |--- Redis::Client#initialize
                    |--- Connector.new(options)

  Redis#set
    |--- synchronize { |client| client.call([:set, key, value.to_s]) }
            |--- mon_synchronize { yield(@client) } # Moniter.mon_synchronize Enters exclusive section and executes the block
                    |--- client.call([:set, key, value.to_s])
                          |--- Redis::Client#call(command)
                                    |--- reply = process([command]) { read }
                                          |---
                                          ensure_connected { commands.each { |command| write(command) } ; yield }                                           
                                                    |--- write,         connection.write(command)
                                              |--- connect; yield
                                    |--- yield reply
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;pipeline 的实现
  Redis#pipelined
    |---
      synchronize do |client|
        begin
          original, @client = @client, Pipeline.new
          yield(self)
          original.call_pipeline(@client)
        ensure
          @client = original
        end
      end
 &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Pipeline 的 实现比较有意思， Pipeline.new一个对象，来代替@client， Pipeline必然实现了一个call接口（代替真实的client，来将commands收集起来）,yield 将现有的代码在Pipeline中调用了一遍。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;其中， 1. client.call, client.process, ensure_connected 保证连接，write 为 connection.write(仅仅是socket.write command build 的方式要特殊一点，[item.bytesize + item].join(“\r\n”) ), 2. 其中使用了大量的block， yield， ruby 特性来实现 传递函数调用，看起来比较费劲，如果统一成 lambda 可能会更好一点, 3. Moniter 是新见的，用来处理多线程的协调问题。在Client 中@pid的 用处没有见到用处， 使用代码建立redis连接之后， fork执行代码并没有产生@pid不一致的问题。4. redis new时候如果存在db ！=0 的情况，调用call 之后，使用 write command来选中 配置的 db&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;[TODO]&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;[@pid] 的问题&lt;/li&gt;
  &lt;li&gt;[Moniter]  的问题&lt;/li&gt;
  &lt;li&gt;[EM] 依赖&lt;/li&gt;
  &lt;li&gt;[eval] 依赖&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>计算机程序的构造和解释</title>
    <link rel="alternate" href="http://geniousbar.github.io/2018/03/20/sicp/"/>
    <id>http://geniousbar.github.io/2018/03/20/sicp/</id>
    <published>2018-03-20T08:00:00+08:00</published>
    <updated>2018-09-13T12:37:09+08:00</updated>
    <summary type="html">&lt;p&gt;计算机程序的构造和解释&lt;br&gt;
    ———&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;序
---------
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;关注程序的创建、执行和研究。使用Lisp方言书写&lt;br&gt;
本书中讨论的各种问题主要涉及到： 人的大脑，计算机程序的集合，以及计算机本身。每一个计算机程序都是现实中的或者精神中的某个过程的一个模型。通过人的头脑孵化出来，这种过程出现在人们的经验或者思维中。很少能够通过程序将这种过程模拟到永远令人满意的程度。 因为这个原因，程序也在不断的演化。当我们对模型的认识更深入、更扩大，更广泛时，我们就会修改程序。直到达到一中亚稳定状态。...&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    <content type="html">&lt;p&gt;计算机程序的构造和解释&lt;br /&gt;
    ———&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;序
---------
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;关注程序的创建、执行和研究。使用Lisp方言书写&lt;br /&gt;
本书中讨论的各种问题主要涉及到： 人的大脑，计算机程序的集合，以及计算机本身。每一个计算机程序都是现实中的或者精神中的某个过程的一个模型。通过人的头脑孵化出来，这种过程出现在人们的经验或者思维中。很少能够通过程序将这种过程模拟到永远令人满意的程度。 因为这个原因，程序也在不断的演化。当我们对模型的认识更深入、更扩大，更广泛时，我们就会修改程序。直到达到一中亚稳定状态。而在这时，程序中有会出现一个需要我们为之奋斗的模型。计算机程序设计领域之所以令人兴奋的源泉，就在于他所引起的连绵不绝的发现。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;组织技术&lt;br /&gt;
 一致性和正确性在程序变得更大更复杂的时候，非常值得怀疑了。很少能够看到有关大型程序正确性的完全形式化的论述。&lt;br /&gt;
 组织技术: 是理解 程序设计这种具有设计、创造性的事业中 的本质。&lt;br /&gt;
 因为大的程序是从小的东西成长起来的。所以，开发一个标准化的程序结构的武器库，并保证其中每种结构的正确性。再通过组织技术，将这些结构组合成更大的结构。这些都是至关重要的。发现并掌握这种强有力的组织技术，将提升我们构造大型重要程序的能力,反过来，因为构造大型程序的费力，导致我们去发明新的方法，来减轻构造大型程序的沉重负担。&lt;/p&gt;

    &lt;p&gt;在任何非常大的程序设计工作中，一个非常有用的组织原则就是 通过发明新语言， 去控制和隔离作业模块之间的信息流动。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;算法&lt;br /&gt;
  执行了某个精确函数的程序 我们称为算法。 特别需要关注的两个参数是：执行的事件、对数据存储的需要。 程序员应该追求好的算法&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="前言"&gt;前言&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;计算机语言不仅仅是让计算机执行操作的一种形式，更重要的是，他是一种表述有关方法学的思想的形式化媒介。&lt;/li&gt;
  &lt;li&gt;所以， 程序是写给人读的，然后才是去执行&lt;/li&gt;
  &lt;li&gt;最基本的材料不是 特定程序的语法，不是某种巧妙的算法。而是一些能够用于控制大型软件系统的智力复杂性的技术。（创建抽象去控制复杂性，通过建立约定的界面，以便能够用一种 混合与匹配的方式组合在一起， 建立一些新的语言去描述各种设计，每种语言强调设计中的一个特定方面并降低其他方面的重要性，以控制复杂度）&lt;/li&gt;
  &lt;li&gt;计算机科学并不是一种科学，而且其重要性也与计算机本身并无太大关系。计算机革命是有关我们如何去思考的方式，以及我们如何去表达自己思考的一个革命。这其中最基本的东西是，过程性认知论的现象，就是如何从一种命令式的观点去研究知识的结构，这是一种与经典数学领域总所采用的更具有说明性的观点完全不同。数学为精准处理 “是什么的” 提供了一种框架，而计算则为精准处理“怎样做” 的概念提供了一种框架。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="过程构造抽象"&gt;过程构造抽象&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;心智活动主要表现如下三个方面
    &lt;ol&gt;
      &lt;li&gt;将若干简单的认识组合为一个复杂的认识，由此产生出复杂的认识&lt;/li&gt;
      &lt;li&gt;将两个认识放在一起做对照，不管他们如何简单或者复杂。这样做并不将他们合二为一，由此得到的有关他们相互关系的认知。&lt;/li&gt;
      &lt;li&gt;将有关认识与那些实际中和他们同在懂得所有其他的认识隔离开，这就是抽象。所有具有普遍性的认识都是这样得到的&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;计算过程的Lisp描述， 本身又可以作为Lisp的数据来表示和操作。现在的语言都在填平 『被动的数据』和『主动的过程』之间的传统划分，（划分是什么？）能够将过程表示为数据的能力，Lisp的这种能力使Lisp成为编写那些必须将其他程序当做数据去操作的程序的最佳语言，比如： 计算机语言的解释器和编译器。 macro&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;程序设计的基本元素
    &lt;ul&gt;
      &lt;li&gt;语言提供的将简单的认识组合起来成为更复杂认识 三种机制：
        &lt;ol&gt;
          &lt;li&gt;基本表达形式: 组成语言的最小单位，个体&lt;/li&gt;
          &lt;li&gt;组合的方法： 通过他们可以将简单的组合成为复杂的&lt;/li&gt;
          &lt;li&gt;抽象的方法：通过他们将复杂对象命名，并将他们作为单元去使用&lt;br /&gt;
  程序中需要处理 过程和数据两种元素，数据是一种我们需要去处理的东西，过程就是我们操作数据的规则的描述。 任何语言都需要 能够表述基本的数据和基本的的过程，还需要提供对过程和数据进行抽象组合的方法。&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;具体语言的实现：
        &lt;ol&gt;
          &lt;li&gt;表达式&lt;br /&gt;
  (操作符 参数1 参数2)&lt;br /&gt;
  解释器总是按照  从终端读入一个表达式，对这个表达式求值，而后打印出得到的结果，称为读入—求值—打印 的循环， REPL&lt;/li&gt;
          &lt;li&gt;命名&lt;br /&gt;
  (define radius 10)&lt;br /&gt;
  创建名字–对象的关联。 鼓励人们采用递增的方式去开发和调试程序。其中需要注意的是，其中隐含着 环境的概念，其中保持着 名字—值的关联&lt;br /&gt;
  环境在确定表达式中各个符号的意义是十分重要的，如果没有相关环境的任何信息，那么说表达式(+ x 1) 是没有任何意义的。因为需要环境提供x的意义。环境是具有普遍性的概念。他为求值过程提供了一种上下文。对我们理解程序的执行起着重要的作用。&lt;/li&gt;
          &lt;li&gt;组合式的求值
            &lt;ol&gt;
              &lt;li&gt;求值该组合式的各个子表达式&lt;/li&gt;
              &lt;li&gt;将作为最左表达式的值的那个过程应用与相应的实际参数。所谓实际参数就是各个子表达式的求值结果&lt;br /&gt;
   为了实现对一个组合式的求值过程， 我们必须先对组合式里的每个元素执行同样的求值过程。 因此，在性质上，这一求值过程是递归的。&lt;/li&gt;
              &lt;li&gt;反复的执行第一步骤，最终会到达求值中的一个点，在这里遇到的不是组合式而是基本表达式。例如内部运算符或者其他名字
                &lt;ul&gt;
                  &lt;li&gt;数的值就是他们所表示的数值&lt;/li&gt;
                  &lt;li&gt;内部运算符 的值就是能完成相应操作的机器指令序列， fun&lt;/li&gt;
                  &lt;li&gt;其他名字的值就是在环境中关联与这一名字的那个对象， 变量&lt;br /&gt;
   &lt;em&gt; 可以将第二种情况看做最后一种情况的特殊情况，像 +， - 等，相应的指令序列就是与之关联的值&lt;/em&gt;&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;特殊形式&lt;br /&gt;
  (define x 3) 并不是一个组合式，一般性的求值规则的这种例外称为 特殊形式。各种不同类型的表达式（有着不同的求值规则） 组成了程序设计语言的语法形式。&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight scheme"&gt;&lt;code&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="p"&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;p&gt;条件表达式， 谓词 并不是普通的过程（表达式不一定都需要求值）&lt;br /&gt;
  (if &lt;predicate&gt; &lt;consequent&gt; &lt;alternative&gt;)
  (cond (&lt;p1&gt; &lt;e1&gt;)
   (&lt;p2&gt; &lt;e2&gt;)
   ...
   (&lt;pn&gt; &lt;en&gt;))&lt;/en&gt;&lt;/pn&gt;&lt;/e2&gt;&lt;/p2&gt;&lt;/e1&gt;&lt;/p1&gt;&lt;/alternative&gt;&lt;/consequent&gt;&lt;/predicate&gt;&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;代换模型
            &lt;ul&gt;
              &lt;li&gt;组合式的求值递归过程&lt;/li&gt;
              &lt;li&gt;正则序求值： 完全展开而后归约&lt;/li&gt;
              &lt;li&gt;应用序求值： 先求值参数而后应用&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;过程
    &lt;ul&gt;
      &lt;li&gt;形式参数， 约束变量、自由变量: 在过程体中扮演者一种非常特殊的角色，形式参数的具体名字是什么，完全没有关系，这样的名字称为。 一个过程的定义约束了他所有的形式参数，如果一个变量不是被约束的，我们就称他为自由的。一个名字的定义被约束于的那一个表达式称为这个名字的作用域， 所以在过程的定义中，被声明的为形式参数的那些约束变量，就以这个过程的体作为他们的作用域。&lt;/li&gt;
      &lt;li&gt;块结构:
&lt;div class="highlight"&gt;&lt;pre class="highlight scheme"&gt;&lt;code&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sqrt-iter&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;good-enough?&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nv"&gt;guess&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sqrt-iter&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;improve&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;good-enough?&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;abs&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;square&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="mf"&gt;0.001&lt;/span&gt; &lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;improve&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;average&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;/&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;sqrt&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sqrt-iter&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sqrt-iter&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;good-enough?&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nv"&gt;guess&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sqrt-iter&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;improve&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;



&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;sqrt&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sqrt-iter&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;good-enough?&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="nv"&gt;guess&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sqrt-iter&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;improve&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;good-enough?&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;abs&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;square&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="mf"&gt;0.001&lt;/span&gt; &lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;improve&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;average&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;/&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sqrt-iter&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;sqrt&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sqrt-iter&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;good-enough?&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="nv"&gt;guess&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sqrt-iter&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;improve&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;good-enough?&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;abs&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;square&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt; &lt;span class="mf"&gt;0.001&lt;/span&gt; &lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;improve&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;average&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;/&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sqrt-iter&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
        &lt;p&gt;这种嵌套的定义称为 块结构， 是最简单的名字包装问题的一种正确方式。这其中还有一种简化的方法，因为所有的辅助过程定义放到内部，x在sqrt内部是受约束的。过程good-enough， improve都定义在sqrt利民啊，也就是说显示的将x传递来传递去没有必要了，我们让x作为内部定义中的自有变量。sqrt被调用时，x就确定了。这种方式称为词法作用域。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;过程与他们所产生的计算&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;线性的迭代和递归
&lt;div class="highlight"&gt;&lt;pre class="highlight scheme"&gt;&lt;code&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;factorial&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="mi"&gt;1&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;factorial&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;

 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;factorial&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;fact-iter&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;fact-iter&lt;/span&gt; &lt;span class="nv"&gt;product&lt;/span&gt; &lt;span class="nv"&gt;conter&lt;/span&gt; &lt;span class="nv"&gt;max-count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;counter&lt;/span&gt; &lt;span class="nv"&gt;max-count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="nv"&gt;product&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;fact-iter&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="nv"&gt;counter&lt;/span&gt; &lt;span class="nv"&gt;product&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="nv"&gt;counter&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="nv"&gt;max-count&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;p&gt;第一个为递归计算过程， 代换模型展开的形状是一个先逐步展开而后收缩的形状。收缩阶段为这些运算的实际执行。这种类似性的计算过程由一个推迟执行的运算链条刻画&lt;br /&gt;
 第二个为线性递归计算过程，解释器只需要维护函数调用的参数，就可完成函数调用。&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;过程的计算过程和形式:
            &lt;ul&gt;
              &lt;li&gt;过程形式： 过程的书写形式&lt;/li&gt;
              &lt;li&gt;计算过程： 过程的计算过程&lt;/li&gt;
              &lt;li&gt;迭代计算过程： 在计算过程中的任何一点，程序的变量都提供了一个有关计算状态的完整描述。在任何时刻计算停下来，都可以提供参数来重新计算，&lt;/li&gt;
              &lt;li&gt;递归过程： 论述的是一个语法形式上的。说明这个过程的定义中，调用了自己。&lt;/li&gt;
              &lt;li&gt;递归计算过程： 函数的计算过程的进展方式。而不是过程上的语法形式上的书写，他们隐含着一些信息，有解释器维持，来指明所推迟的运算形成的链条中的位置。这一计算处在何处，这个链条越长，所需要保存的信息也就越多。&lt;/li&gt;
              &lt;li&gt;为什么需要区分 计算过程和形式过程？ 大部分语言的实践设计中，对任何递归过程的解释，所消耗的存储量总与过程调用的数目成正比，即便他所描述的计算过程是迭代的。作为这是一事实的后果就是—特殊的循环结构： for, while等。scheme 能够将形式上的递归而计算过程为递归形式，依然能够在常数空间上运行，这种实现为： 尾递归。&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ol&gt;

        &lt;p&gt;&lt;em&gt; fact-iter 递归过程讲产生迭代的计算过程， 因为展开的计算过程上确实是迭代的，其中的状态由三个变量保持。解释器没有额外的隐含的状态保存。&lt;/em&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;scheme相关
    &lt;ul&gt;
      &lt;li&gt;命名&lt;br /&gt;
 （define &lt;name&gt; &amp;lt;body&amp;gt;）&lt;/name&gt;&lt;/li&gt;
      &lt;li&gt;条件表达式和谓词&lt;br /&gt;
 (cond (&lt;p1&gt; &lt;e1&gt;)
   (&lt;p2&gt; &lt;e2&gt;)
   ...
   (&lt;pn&gt; &lt;en&gt;))
 (if &lt;predicate&gt; &lt;consequent&gt; &lt;alternative&gt;)
 (and &lt;e1&gt; ..... &lt;en&gt;)
 (or &lt;e1&gt; ..... &lt;en&gt;)
 (not &lt;e1&gt;)
 and or 不是普通的过程, 其中的参数不一定都会求值，not 是过程&lt;/e1&gt;&lt;/en&gt;&lt;/e1&gt;&lt;/en&gt;&lt;/e1&gt;&lt;/alternative&gt;&lt;/consequent&gt;&lt;/predicate&gt;&lt;/en&gt;&lt;/pn&gt;&lt;/e2&gt;&lt;/p2&gt;&lt;/e1&gt;&lt;/p1&gt;&lt;/li&gt;
      &lt;li&gt;高阶函数: 函数作为参数, 函数作为返回值&lt;/li&gt;
    &lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight scheme"&gt;&lt;code&gt;   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sum&lt;/span&gt; &lt;span class="nv"&gt;term&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;next&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="mi"&gt;0&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;term&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sum&lt;/span&gt; &lt;span class="nv"&gt;term&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;next&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;next&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;     * lambda  (lambda &amp;lt;parameters&amp;gt; &amp;lt;body&amp;gt;)  (lambda (x) (* x x x))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="构造数据抽象复合数据"&gt;构造数据抽象（复合数据）&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;语言所包含的将数据对象组合起来的，形成 复合数据的方式。提高 设计的模块性，是我们得以在 比语言提供的基本数据对象更高的概念层次上。处理与数据有关的各种问题。&lt;br /&gt;
复合数据能够将处理数据对象的表示部分，与 处理数据对象的使用部分相互隔离开来，这种技术具有一般性，形成了一种成为数据抽象的强有力的设计方法学。数据抽象技术能够是程序更容易设计，维护和修改。&lt;/li&gt;
  &lt;li&gt;形成复合数据的关键在于，程序设计语言提供的某种黏合剂，他们可以用于把一些数据对象组合起来，形成更复杂的数据对象，1）过程 2）闭包，用于组合数据对象的黏合剂同样适用于复合数据对象 3）符号表达式&lt;/li&gt;
  &lt;li&gt;数据导向型程序设计&lt;/li&gt;
  &lt;li&gt;数据抽象的基本思想： 设法构造出一些使用复合数据的对象的程序，使他们就像是在“抽象数据”上操作一样，我们的程序使用复合数据的方式应该是这样的：除了完成当前工作的必要东西之外，他们不对数据做任何的假设。同时，一种具体的数据表示的定义，也应该跟程序中使用数据的方式无关。这要求在我们的系统里面需要一组过程： 选择函数、构造函数。&lt;/li&gt;
  &lt;li&gt;按愿望思维方式，（从上倒下） 是一种强有力的设计方法，其中不会设计到细节，只是思考整体的数据使用方法。（复合数据结构的操作界面）&lt;/li&gt;
  &lt;li&gt;序对: cons, car, cdr 从序对 构造起来的数据对象成为表结构的数据&lt;/li&gt;
  &lt;li&gt;数据抽象的基本思想就是： 为每一类数据对象标识出 一组操作。是的对这类数据对象的所有操作都可以基于他们表述，而且在操作这些数据对象时也只使用他们。&lt;/li&gt;
  &lt;li&gt;形象化的表示了 有理数 系统的结构， 其中的水平线表示抽象屏障，他们呢隔离了系统中的不同的层次，在每一层上，这些屏障都把使用数据抽象的程序与实现数据抽象的程序隔离开来，使得有理数 的程序有理数实现提供的函数完成对有理数的操作，而这些函数又是基于构造函数和选择函数make-rat, numer denom 实现的。而make-rat等函数又是基于序对实现的。有关序对实现的细节与有理数的其余部分都完全没有u关系。每一层次中的过程构成了所定义的抽象屏障的界面，联系起来系统中的不同层次.&lt;/li&gt;
  &lt;li&gt;数据意味着什么： 我们总可以将数据定义为一组适当的选择函数和构造函数，其中这些过程必须满足某些必要条件。 （试着将这些条件放到程序中，面向对象，编译类型语言的语法检查，是不是都在某种程度上实现这些检测）&lt;br /&gt;
序对的概念，我们只需要定义，z = (cons x y)，那么 car(z) == x (cdr z) == y, 意味着，任何满足这三个条件的函数都可以作为实现。
&lt;div class="highlight"&gt;&lt;pre class="highlight scheme"&gt;&lt;code&gt;    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;dispatch&lt;/span&gt; &lt;span class="nv"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;m&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                 &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;m&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;error&lt;/span&gt; &lt;span class="s"&gt;"error argument "&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;z&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;z&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;z&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;z&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
  &lt;li&gt;序对 (cons a b) cons的闭包性质是非常重要的，某种组合数据对象的操作满足闭包性质，就是说，通过他组合起来的对象得到的结果本身还可以通过同样的操作再次进行组合。闭包性质是一种组合功能的关键所在。&lt;/li&gt;
  &lt;li&gt;序列的表示： (cons 1 (cons 2 (cons 3 nil))) (list 1 2 3)&lt;/li&gt;
  &lt;li&gt;map&lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight scheme"&gt;&lt;code&gt;        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;scale-list&lt;/span&gt; &lt;span class="nv"&gt;items&lt;/span&gt; &lt;span class="nv"&gt;factor&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;null?&lt;/span&gt; &lt;span class="nv"&gt;items&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;items&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;factor&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;scale-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;items&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;factor&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;scale-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="nv"&gt;proc&lt;/span&gt; &lt;span class="nv"&gt;items&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;null?&lt;/span&gt; &lt;span class="nv"&gt;items&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;proc&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;items&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="nv"&gt;proc&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;items&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;


&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;scale-list&lt;/span&gt; &lt;span class="nv"&gt;items&lt;/span&gt; &lt;span class="nv"&gt;factor&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
       &lt;span class="nv"&gt;items&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;map 不仅仅是一种模式，更重要的建立起了一种高级抽象。在scale-list 原来的设计中，更多的注意力放在了， 循环递归的结构中，而通过map定义的scale-list 则忽略了这种细节层面的情况，强调是表到表的缩放，这两种形式上的差异并不在于计算机会执行不同的计算过程，而在于我们对这同一种过程的不同思考方式。&lt;/p&gt;
</content>
  </entry>
</feed>
