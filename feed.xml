<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>日常学习</title>
  <id>http://geniousbar.github.io</id>
  <link href="http://geniousbar.github.io"/>
  <link href="http://geniousbar.github.io/feed.xml" rel="self"/>
  <updated>2017-06-25T08:00:00+08:00</updated>
  <author>
    <name>geniousbar</name>
  </author>
  <entry>
    <title>Principles of economics</title>
    <link rel="alternate" href="http://geniousbar.github.io/2017/06/25/economy-learn/"/>
    <id>http://geniousbar.github.io/2017/06/25/economy-learn/</id>
    <published>2017-06-25T08:00:00+08:00</published>
    <updated>2017-06-26T11:43:16+08:00</updated>
    <summary type="html">&lt;h2 id="经济学原理微观经济学"&gt;经济学原理(微观经济学)&lt;/h2&gt;

&lt;h3 id="经济学十大原理"&gt;经济学十大原理&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
  &lt;li&gt;人们面临权衡取舍&lt;br&gt;
社会面临着在　效率公平 之间的权衡取舍&lt;/li&gt;
  &lt;li&gt;机会成本(某种东西的成本是为了得到他所放弃的东西), 比如时间，资源&lt;/li&gt;
  &lt;li&gt;理性人考虑边际效应&lt;/li&gt;
  &lt;li&gt;人们会对激励作出反应&lt;br&gt;
整个经济学的内容可以简单的概括为: “人们会对激励作出反应，其余内容则是对内容的解释”&lt;/li&gt;
  &lt;li&gt;贸易可以是每个人的状态都变得更好&lt;/li&gt;
  &lt;li&gt;市场通常是组织经济活动的一种好方法&lt;/li&gt;
  &lt;li&gt;政府有时可以改善市场结果&lt;br&gt;
政府干预经济１：促进效率或者公平，　２：市场失灵，　３：设计良好...&lt;/li&gt;
&lt;/ul&gt;</summary>
    <content type="html">&lt;h2 id="经济学原理微观经济学"&gt;经济学原理(微观经济学)&lt;/h2&gt;

&lt;h3 id="经济学十大原理"&gt;经济学十大原理&lt;/h3&gt;
&lt;hr /&gt;
&lt;ul&gt;
  &lt;li&gt;人们面临权衡取舍&lt;br /&gt;
社会面临着在　效率公平 之间的权衡取舍&lt;/li&gt;
  &lt;li&gt;机会成本(某种东西的成本是为了得到他所放弃的东西), 比如时间，资源&lt;/li&gt;
  &lt;li&gt;理性人考虑边际效应&lt;/li&gt;
  &lt;li&gt;人们会对激励作出反应&lt;br /&gt;
整个经济学的内容可以简单的概括为: “人们会对激励作出反应，其余内容则是对内容的解释”&lt;/li&gt;
  &lt;li&gt;贸易可以是每个人的状态都变得更好&lt;/li&gt;
  &lt;li&gt;市场通常是组织经济活动的一种好方法&lt;/li&gt;
  &lt;li&gt;政府有时可以改善市场结果&lt;br /&gt;
政府干预经济１：促进效率或者公平，　２：市场失灵，　３：设计良好的公共政策促进经经济效率&lt;/li&gt;
  &lt;li&gt;一国的生活水平取决与它生产物品与服务的能力&lt;/li&gt;
  &lt;li&gt;社会面临着通货膨胀与失业之间的短期权衡取舍
    &lt;blockquote&gt;

      &lt;p&gt;政府发行了过多的货币时候，物价上升&lt;br /&gt;
  经济中的货币量增加刺激了社会的整体指出水平，从而增加了对物品与服务的需求&lt;br /&gt;
  需求的增加随着时间的退役，会引起企业提高物价，但同时，它也激励着企业雇佣更多的工人，并生产更多的物品与服务&lt;br /&gt;
  雇佣工人意味着更少的失业&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="微观经济学"&gt;微观经济学&lt;/h4&gt;
&lt;p&gt;微观经济学与宏观经济学是密切相关的：由于整体经济的变动是千百万个人的决策，所以不考虑相关的微观经济学而去理解宏观经济学的发展是不可能的。但是，确实是两个不同的领域，每个领域都有自己的独特分析方法与模型。&lt;/p&gt;

&lt;h4 id="经济学家意见分歧的原因"&gt;经济学家意见分歧的原因:&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;经济学家可能对世界如何运行的不同实证理论的正确性看法不一致&lt;/li&gt;
  &lt;li&gt;经济学家可能有不同的价值观，因此对政策所努力实现的目标有不同的观点&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="图形分析工具存在的问题"&gt;图形分析工具存在的问题:&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;在研究两个变量之间的关系时，要保持其他条件不变是很困难的，可能存在忽略的重要的变量&lt;/li&gt;
  &lt;li&gt;反向因果关系（假设的影响关系方向可能不正确）变量先动是确定因果关系的简单方法，但是存在一个缺陷，人们对未来的预期改变自己的行为，而不是现状。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id="相互依存与贸易的好处"&gt;相互依存与贸易的好处&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;当每个人有各自的优势时候，能够以更加低廉的成本生产产品的时候，双方合作更加具有优势，扩大了生产边界&lt;/li&gt;
  &lt;li&gt;当一方存在全部的绝对优势的时候，就是说，一方在生产各个产品的时候都更具有效率，双方合作仍然能够扩大生产边界，可以用 &lt;strong&gt;比较优势&lt;/strong&gt; 来解释&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;对比较优势的解释示例:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Rose 生产１单位牛肉需要２０分钟，生产１单位土豆需要１０分钟&lt;br /&gt;
  Frank生产１单位牛肉需要６０分钟，生产１单位土豆需要１５分钟。&lt;br /&gt;
  比较来看Rose的生产效率更高，在各个产品的生产上具有绝对优势。&lt;br /&gt;
  但是：机会成本是不同的，考虑Rose花费１０分钟生产１单位土豆时候，可以用１０分钟生产1/2单位牛肉，所以１单位土豆对应的机会成本是1/2牛肉。对应的，　Frank的情况，则是，使用１５分钟生产１单位土豆，可以用生产1/4单位的牛肉&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style="text-align: left"&gt; &lt;/th&gt;
      &lt;th style="text-align: left"&gt;１单位你肉的机会成本&lt;/th&gt;
      &lt;th style="text-align: left"&gt;　１单位土豆的机会成本&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style="text-align: left"&gt;Frank&lt;/td&gt;
      &lt;td style="text-align: left"&gt;４单位土豆&lt;/td&gt;
      &lt;td style="text-align: left"&gt;　1/4单位牛肉&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style="text-align: left"&gt;Rose&lt;/td&gt;
      &lt;td style="text-align: left"&gt;2单位土豆&lt;/td&gt;
      &lt;td style="text-align: left"&gt;1/2单位牛肉&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;机会成本：为了得到某样东西所放弃的. 就是比较优势的计算方式所在， Frank　生产１单位牛肉所对应的机会成本是４单位的土豆，想对应的Rose则为２单位的土豆，隐含的机会成本更小，更加具有比较优势。而且生产土豆的机会成本与生产牛肉的机会成本成倒数关系。&lt;br /&gt;
  所以，无论一个人在各个方面都具有绝对优势，但是却无法在各个方面都具有比较优势。&lt;br /&gt;
  Frank使用土豆交换Rose的牛肉，假如是１单位牛肉对应３单位土豆的话,每个人都会以小于各自的机会成本获取产品。&lt;br /&gt;
  所以合作依存，交易会促进各自的生活状况。以更加高校的方式生产。当然其中隐含的条件是，能够存在一个合理的交换代价，比如上面的1/3都会低于对方的机会成本，从而促进合作，但是什么条件下会以1/3的代价进行交换呢？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;结论：专业化和贸易的好处并不是基于绝对优势的，而是基于比较优势。贸易可以使社会上每个人收益，因为他使人们可以从事他们具有 &lt;strong&gt;比较优势&lt;/strong&gt; 的活动&lt;br /&gt;
　问题：比较优、贸易促使每个人的状况变得更好。但是如何促进贸易的形成呢？如何使1/3的交易达成呢？答案是需求与供给的力量，促进资源配置&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id="市场如何运行"&gt;市场如何运行&lt;/h3&gt;
&lt;hr /&gt;

&lt;h4 id="供给与需求的市场力量"&gt;供给与需求的市场力量&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;如果你想知道一个事件或政策如何影响经济，应该先考虑如何影响供给和需求&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id="需求"&gt;需求&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;竞争市场，描述许多买者与卖者并且每一个人对市场价格的影响都是微乎其微的市场.市场还分为一些，垄断集团，半垄断&lt;/li&gt;
  &lt;li&gt;需求定理，其他条件不变，一种物品价格上升，对该物品的需求量减少，一个物品价格下降，对该物品的需求量增加．&lt;/li&gt;
  &lt;li&gt;影响需求曲线的因素：
    &lt;ul&gt;
      &lt;li&gt;当收入减少，如果一种物品的需求量减少，这种物品是正常物品，收入减少，需求量增加，物品为低档物品，例如收入减少，大家更愿意乘坐公交车出行&lt;/li&gt;
      &lt;li&gt;物品之间关联：一种物品价格下降引起另一种物品需求减少时，两种物品被成为替代品．而引起需求增加，称为互补品．&lt;/li&gt;
      &lt;li&gt;预期：人们不按照现状行事，而是按照预期．预期收入更多，会减少储蓄．&lt;/li&gt;
      &lt;li&gt;买者的数量：需求量&lt;/li&gt;
      &lt;li&gt;总结，　&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id="供给"&gt;供给&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;供给定理：　其他条件不变时候：一种物品价格上升，该物品供给量增加，　物品价格下降，供给量减少．&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;供给影响因素：
    &lt;ul&gt;
      &lt;li&gt;投入品价格: 企业成本,与生产该物品所用的投入品的价格&lt;/li&gt;
      &lt;li&gt;技术,技术的提高可以降低生产成本&lt;/li&gt;
      &lt;li&gt;预期，如果预期产品价格上升，厂家会提高市场供给&lt;/li&gt;
      &lt;li&gt;卖者数量&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id="均衡"&gt;均衡&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;供给曲线与需求曲线相交的点，为市场的均衡点，此时的价格为均衡价格，数量为均衡数量。均衡价格也被成为出清价格.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;供求定理：任何一种物品的价格都会自发调整，是该物品的供给与需求达到平衡.&lt;/li&gt;
  &lt;li&gt;分析均衡变动的三个步骤：
    &lt;ul&gt;
      &lt;li&gt;第一我们确定该事件是使供给曲线移动还是需求曲线移动。&lt;/li&gt;
      &lt;li&gt;确定曲线向右移动还是向左移动。&lt;/li&gt;
      &lt;li&gt;使用供求图说明这种移动将如何改变均衡价格和均衡数量。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;示例：
    &lt;ul&gt;
      &lt;li&gt;天气炎热通过改变人们对冰激凌的爱好而影响需求曲线。&lt;/li&gt;
      &lt;li&gt;天气炎热促进人们想吃更多的冰激凌，冰激凌的需求增加了，需求曲线向右移动。&lt;/li&gt;
      &lt;li&gt;新的均衡下，冰激凌的价格提高，供给增加。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id="需求的弹性"&gt;需求的弹性&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;一个物品的需求量对价格的反映很大，则是物品的需求是富有弹性的，对价格变化很小，则是缺乏弹性的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;控制因素
    &lt;ol&gt;
      &lt;li&gt;相似代替品的可获得行&lt;/li&gt;
      &lt;li&gt;必需品与奢侈品（商品属性）&lt;/li&gt;
      &lt;li&gt;市场的定义，狭义的市场还是广义的市场，狭义的市场更容易寻找到代替品。所以狭义的市场的需求弹性往往大于广义市场的需求弹性&lt;/li&gt;
      &lt;li&gt;物品的需求往往长期内更富有弹性(市场滞后吗？)，油价的上涨往往在长期内更具有影响意义。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;弹性计算：　需求弹性　＝　需求量变动百分比 / 价格变动百分比&lt;/li&gt;
  &lt;li&gt;规律：　
    &lt;ol&gt;
      &lt;li&gt;当需求缺乏弹性，价格和总收益，同方向变化，价格上升，总收益增加。&lt;/li&gt;
      &lt;li&gt;当需求富有弹性，价格和总收益，反方向变化，价格上升，总收益减少。&lt;/li&gt;
      &lt;li&gt;如果需求是单位弹性的,(等于１), 当价格变动时，总收益不变。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;####　供给弹性&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;如果供给量对价格的反映很大，则物品的供给是富有弹性的，对价格变化很小，则是缺乏弹性的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;控制因素:
    &lt;ul&gt;
      &lt;li&gt;卖者改变他们所生产的物品的灵活性。&lt;/li&gt;
      &lt;li&gt;供给在长期中的弹性通常大于短期。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;弹性计算：　供给需求　＝　供给量变动百分比 / 价格变动百分比&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id="案例"&gt;案例&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;农业的好消息可能对农民来说是个坏消息吗？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假设有研究技术能够大量的提高农作物的产量，  想象一下这对农民是好是坏呢？&lt;br /&gt;
  分析：由于新的技术提高了生产产量，所以农民可以在现有的价格下提高更多的食物产量。供给曲线向右移动，价格下降，因为食物是缺乏弹性的，总收益随着产品的价格同步移动，所以总收益下降。农民得到更少的钱，这里中分析，基本排除供给弹性，因为供给基本没有弹性，只有长期中供给才富有弹性。&lt;br /&gt;
  真是的情况是：&lt;br /&gt;
      上面的分析，解释了过去一个世纪以来的美国经济的一个巨大变化，两百多年前，大部分美国人居住在农村，对农业生产的了解是相当原始的。以至于我们大多数人不得不从事农业，以生产足够的食物来养活全国的人口。但随着时间的推移，农业的技术进步增加了每个农民所能生产的食物量，由于食物的需求缺乏弹性，这种食物的供给增加导致了农业收益的减少，进而鼓励人们更多的离开农业。促进了城镇化。&lt;/p&gt;

&lt;h3 id="供给需求与政府政策"&gt;供给、需求与政府政策&lt;/h3&gt;
&lt;hr /&gt;

&lt;h4 id="价格控制价格上限价格下限"&gt;价格控制（价格上限、价格下限）&lt;/h4&gt;

&lt;p&gt;价格上限造成了稀缺物品。造成了无效率的分配。&lt;br /&gt;
住房的租金控制，同样的造成了短缺。造成了供给的稀缺，需求的增加。但是可以通过相关法律保障，住房者的相关权益，给供给端正面反馈等。&lt;/p&gt;

&lt;p&gt;关于控制价格：实际上决策者进行价格控制是因为他们认为市场是不公平的。价格控制往往是想帮助穷人。例如租金控制法的目的是使每一个人住的其房子，但是价格控制往往损害了那些想要帮助的人，最低工资法会增加一些工人的收入，但是也使其他工人成为失业者。可以使用除价格控制之外的方法来帮助需要帮助的人，例如，政府可以通过给贫困用户补助住房基金来提高他们的生活质量，这种措施并没有减少住房的供给量。&lt;/p&gt;

&lt;h4 id="税收"&gt;税收&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;无论是想卖者征收税收还是向买者征收，都是同样的效果。１：抑制了市场活动２:买家卖家共同承担税收的费用。&lt;/li&gt;
  &lt;li&gt;税收归宿：&lt;strong&gt;税收负担更多的落在缺乏弹性的市场一方身上&lt;/strong&gt;。在本质上，弹性衡量在条件变得不利时候，卖者或者买者离开市场的意愿。需求弹性小意味着没有更多的代替品，供给弹性小，意味着卖者对生产某种商品没有适当的代替品，适当代替品较少的一方更不愿意离开市场，从而负担更多的税收。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id="市场和福利"&gt;市场和福利&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;支付意愿：一个买者愿意支付的最大价格&lt;/li&gt;
  &lt;li&gt;消费者剩余: Jhon 花费80买了心里价格１００的东西，产生了２０的消费者剩余。&lt;/li&gt;
  &lt;li&gt;生产者剩余：买价减去生产成本&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;结论：供给曲线、需求曲线的交叉点，为市场消费剩余的最大点。&lt;br /&gt;
   税收收入减少了，无所谓的市场福利，造成了无谓损失。并扭曲的市场结果。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id="国际贸易"&gt;国际贸易&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;更有效率的分配物品，每个国家更嫩专注于生产比较成本低的产品&lt;/li&gt;
  &lt;li&gt;增加了物品的多样性&lt;/li&gt;
  &lt;li&gt;通过规模经济降低了生产成本&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;增加了竞争&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;工作岗位论&lt;/li&gt;
  &lt;li&gt;国家安全论&lt;/li&gt;
  &lt;li&gt;幼稚产业论&lt;/li&gt;
  &lt;li&gt;不公平竞争论&lt;/li&gt;
&lt;/ol&gt;
</content>
  </entry>
  <entry>
    <title>Linux service</title>
    <link rel="alternate" href="http://geniousbar.github.io/2017/06/22/linux-service/"/>
    <id>http://geniousbar.github.io/2017/06/22/linux-service/</id>
    <published>2017-06-22T08:00:00+08:00</published>
    <updated>2017-06-23T19:31:48+08:00</updated>
    <summary type="html">&lt;h2 id="linux-service"&gt;linux service&lt;/h2&gt;

&lt;h4 id="service"&gt;service&lt;/h4&gt;
&lt;blockquote&gt;

  &lt;p&gt;简单的说,系统为了某些功能必须要提供一些服务 (丌讳是系统本身还是网络方面),这个服务就称为 service 。 但是 service 的提供总是需要程序的运作吧!否则如何执行呢?所以达成这个 service 的程序我们就称呼他为 daemon 啰&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;super daemon,
    &lt;ul&gt;
      &lt;li&gt;multi-threaded  多线程,&lt;/li&gt;
      &lt;li&gt;single-threaded 单线程,&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;stand...&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    <content type="html">&lt;h2 id="linux-service"&gt;linux service&lt;/h2&gt;

&lt;h4 id="service"&gt;service&lt;/h4&gt;
&lt;blockquote&gt;

  &lt;p&gt;简单的说,系统为了某些功能必须要提供一些服务 (丌讳是系统本身还是网络方面),这个服务就称为 service 。 但是 service 的提供总是需要程序的运作吧!否则如何执行呢?所以达成这个 service 的程序我们就称呼他为 daemon 啰&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;super daemon,
    &lt;ul&gt;
      &lt;li&gt;multi-threaded  多线程,&lt;/li&gt;
      &lt;li&gt;single-threaded 单线程,&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;stand alone, 可以单独启动服务， 优点， 存在内存中只许的提供服务&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;工作形态类型
    &lt;ul&gt;
      &lt;li&gt;signal-control, 有需求进来，就处理&lt;/li&gt;
      &lt;li&gt;interval-control, 定期执行，处理&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;因为daemon 的程序启动需要考虑很多东西， 判断环境，配置参数等， 所以， 系统提供一些 脚本命令提供执行
    &lt;ul&gt;
      &lt;li&gt;启动脚本配置 /etc/init.d/*&lt;/li&gt;
      &lt;li&gt;服务初始化环境配置: /etc/sysconfig/*, 比如 /etc/sysconfig/network&lt;/li&gt;
      &lt;li&gt;super daemon配置文件: /etc/xinetd.conf, /etc/xinetd.d/*,&lt;/li&gt;
      &lt;li&gt;各服务的配置文件: /etc/*&lt;/li&gt;
      &lt;li&gt;各服务产生的数据库: /var/lib/*&lt;/li&gt;
      &lt;li&gt;服务pid记录处： /var/run/*&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;service命令, 简单的分析 service后面的参数， 然后传达到/etc/init.d/中， 完成&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;[ ] xinetd 服务管理吗？centos中的统一服务管理?&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="总结"&gt;总结&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;服务 (daemon) 主要可以分为 stand alone (服务可单独吪劢) 及 super daemon (透过 xinetd 统一管理的服务) 两种。&lt;/li&gt;
  &lt;li&gt;super daemon 由亍是经过一个统一的 xinetd 来管理,因此可以具有类似防火墙管理功能。此外,管理的联机机 制又可以分为 multi-threaded 及 single-threaded。&lt;/li&gt;
  &lt;li&gt;启动daemon 的程序通常最末会加上一个 d ,例如 sshd, vsftpd, httpd 等&lt;/li&gt;
  &lt;li&gt;stand alone daemon 吪劢的脚本放置到 /etc/init.d/ 这个目录中,super daemon 的配置文件在 /etc/xinetd.d/*&lt;br /&gt;
内, 而启动的方式则为 /etc/init.d/xientd restart&lt;/li&gt;
  &lt;li&gt;立即启动 stand alone daemon 的方法亦可以使用 service 这个挃令&lt;/li&gt;
  &lt;li&gt;Super daemon 的配置文件 /etc/xinetd.conf ,个别 daemon 配置文件则在 /etc/xinetd.d/* 内。在配置文件内, 还可以讴定联机客户端的联机不否, 具有类似防火墙的功能喔。&lt;/li&gt;
  &lt;li&gt;若想要统一管理防火墙的功能,可以透过 /etc/hosts.{allow,deny} ,若有安装 TCP Wrappers 时,还能够使用额外的 spawn 功能等&lt;/li&gt;
  &lt;li&gt;若想要讴定开机时吪劢某个服务时,可以透过 chkconfig, ntsysv 等挃令。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="linux-package-manger"&gt;Linux package manger&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style="text-align: left"&gt; &lt;/th&gt;
      &lt;th style="text-align: left"&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style="text-align: left"&gt;/etc&lt;/td&gt;
      &lt;td style="text-align: left"&gt;几乎所有的配置文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style="text-align: left"&gt;/usr/bin&lt;/td&gt;
      &lt;td style="text-align: left"&gt;一些可执行文件档案&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style="text-align: left"&gt;/usr/lib&lt;/td&gt;
      &lt;td style="text-align: left"&gt;一些程序使用的动态函数库&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style="text-align: left"&gt;/usr/share/doc&lt;/td&gt;
      &lt;td style="text-align: left"&gt;一些基本的软件使用手册&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style="text-align: left"&gt;/usr/share/man&lt;/td&gt;
      &lt;td style="text-align: left"&gt;一些man page档案&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</content>
  </entry>
  <entry>
    <title>Linux process</title>
    <link rel="alternate" href="http://geniousbar.github.io/2017/06/22/linux-process/"/>
    <id>http://geniousbar.github.io/2017/06/22/linux-process/</id>
    <published>2017-06-22T08:00:00+08:00</published>
    <updated>2017-06-22T18:53:53+08:00</updated>
    <summary type="html">&lt;h2 id="linux-process"&gt;linux process&lt;/h2&gt;

&lt;h5 id="程序"&gt;程序&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;触发任何一个事件，系统会将他定义为一个程序，赋予PID，根据调用用户与相关属性关系，赋予PID相关的有效的权限设定， 在系统上进行的动作就与这个权限相关&lt;/li&gt;
  &lt;li&gt;shell是一个程序， 执行bash， 与内核交互&lt;/li&gt;
  &lt;li&gt;fork and exec, fork, 父进程 到子进程， 赋予子进程新的PID， PPID=父进程， exec 程序实体&lt;/li&gt;
  &lt;li&gt;crontab, atd, syslog, 为常驻进程
    &lt;h4 id="工作管理"&gt;工作管理&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;background job...&lt;/li&gt;
&lt;/ul&gt;</summary>
    <content type="html">&lt;h2 id="linux-process"&gt;linux process&lt;/h2&gt;

&lt;h5 id="程序"&gt;程序&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;触发任何一个事件，系统会将他定义为一个程序，赋予PID，根据调用用户与相关属性关系，赋予PID相关的有效的权限设定， 在系统上进行的动作就与这个权限相关&lt;/li&gt;
  &lt;li&gt;shell是一个程序， 执行bash， 与内核交互&lt;/li&gt;
  &lt;li&gt;fork and exec, fork, 父进程 到子进程， 赋予子进程新的PID， PPID=父进程， exec 程序实体&lt;/li&gt;
  &lt;li&gt;crontab, atd, syslog, 为常驻进程
    &lt;h4 id="工作管理"&gt;工作管理&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;background job, foreground job&lt;/li&gt;
  &lt;li&gt;background job 中 的限制
    &lt;ol&gt;
      &lt;li&gt;为当前bash的子进程&lt;/li&gt;
      &lt;li&gt;可以自行运作，无法使用ctrl+c终止， 只能使用fg/bg&lt;/li&gt;
      &lt;li&gt;不能够与终端交互&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;丢到背景执行 &amp;amp; tar -zpcf /tmp/etc.tar.gz /etc &amp;amp;&lt;/li&gt;
  &lt;li&gt;ctrl+z 讲当前工作丢到背景执行 并暂停, 例如 vi ~/.bashrc&lt;/li&gt;
  &lt;li&gt;jobs 查询背景执行工作状态 -l 列表， -r running的工作， -s stop 的工作&lt;/li&gt;
  &lt;li&gt;fg jobnunber， 将背景执行转移到前景执行&lt;/li&gt;
  &lt;li&gt;bg jobnunber， 将前景执行转移背景执行&lt;/li&gt;
  &lt;li&gt;kill -signal %jobnumber&lt;/li&gt;
  &lt;li&gt;ps aux(系统所有程序), -lA(同aux) axjf（连同程序树状态）&lt;/li&gt;
  &lt;li&gt;ps -l 仅查找bash相关程序, 列表中个个字段的含义 F, (process flags),4 为root， 1为此进程fork的， S(state)， R running， S sleep, D 不可唤醒状态, T 停止状态， Z 僵尸状态, UID/PID,PPID(parent pid), PRI/NI(priority/nice) 程序的优先级&lt;/li&gt;
  &lt;li&gt;top, 动态查看程序的变化，-p pid -d 几秒刷新&lt;/li&gt;
  &lt;li&gt;pstree -p pid, -u process 所属帐号&lt;/li&gt;
  &lt;li&gt;kill 中signal, kill -signal PID
    &lt;ul&gt;
      &lt;li&gt;1, SIGHUP, 重新读取配置文件，重新启动&lt;/li&gt;
      &lt;li&gt;2, SIGINT, 终止程序&lt;/li&gt;
      &lt;li&gt;9, SIGKILL 强制终止&lt;/li&gt;
      &lt;li&gt;15, SIGTERM 正常结束程序&lt;/li&gt;
      &lt;li&gt;17, SIGSTOP，暂停程序的执行&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;程序中的优先级，sum = PRI + nice, pri为动态计算的， nice为人工指定，范围为(-20 - 19 )
    &lt;blockquote&gt;
      &lt;p&gt;nice -n command, renice number PID&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;free 查看内存使用情况,  free -b m(Mbytes) b(bytes), -t 显示swap总量(很有效率的使用没存， 比如使用大量buffer， cached)&lt;/li&gt;
  &lt;li&gt;uname 查看系统与核心相关程序&lt;/li&gt;
  &lt;li&gt;uptime, 观察系统启动时间与工作负载&lt;/li&gt;
  &lt;li&gt;netstat 追踪网络, -a（所有联机， 监听， socket列出来）, -t (tcp网络封包数据), -u（udp网络封包数据） -n port number， -l 列出正在监听的服务， -p pid&lt;/li&gt;
  &lt;li&gt;fuser:藉由档案(戒文件系统)找出正在使用该档案癿程序, 找出正在占用文件资源的程序，-u 列出使用者，-v 列出程序指令， -k， 住处pid，并试图发送SIGKILL信号， -i交互式发送信号&lt;/li&gt;
  &lt;li&gt;pidof -x 列出该program name的可能的PPID的pid（找出父进程关联的pid） program_name&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>Linux crontab</title>
    <link rel="alternate" href="http://geniousbar.github.io/2017/06/22/linux-crontab/"/>
    <id>http://geniousbar.github.io/2017/06/22/linux-crontab/</id>
    <published>2017-06-22T08:00:00+08:00</published>
    <updated>2017-06-22T16:10:19+08:00</updated>
    <summary type="html">&lt;h2 id="linux-crontab-例行性工作排程"&gt;linux crontab （例行性工作排程）&lt;/h2&gt;

&lt;h5 id="at"&gt;at&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;执行一次就结束的程序指令&lt;/li&gt;
  &lt;li&gt;开启 /etc/init.d/atd restart&lt;/li&gt;
  &lt;li&gt;at任务记录在 /var/spool/at/中&lt;/li&gt;
  &lt;li&gt;权限 /etc/at.allow, /etc/at.deny, 规则： 1. 先寻找at.allow，写入这个文档的使用者才能使用，没有写入的不能使用 2. 寻找 /etc/at.deny， 写入文档的不能使用， 没有写入的可以使用, 3.两个文档都不存在的，只有root可以使用。&lt;/li&gt;
  &lt;li&gt;按照...&lt;/li&gt;
&lt;/ul&gt;</summary>
    <content type="html">&lt;h2 id="linux-crontab-例行性工作排程"&gt;linux crontab （例行性工作排程）&lt;/h2&gt;

&lt;h5 id="at"&gt;at&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;执行一次就结束的程序指令&lt;/li&gt;
  &lt;li&gt;开启 /etc/init.d/atd restart&lt;/li&gt;
  &lt;li&gt;at任务记录在 /var/spool/at/中&lt;/li&gt;
  &lt;li&gt;权限 /etc/at.allow, /etc/at.deny, 规则： 1. 先寻找at.allow，写入这个文档的使用者才能使用，没有写入的不能使用 2. 寻找 /etc/at.deny， 写入文档的不能使用， 没有写入的可以使用, 3.两个文档都不存在的，只有root可以使用。&lt;/li&gt;
  &lt;li&gt;按照上面规则，所以如果是所以使用者都可以使用话，简历空的at.deny就可以了&lt;/li&gt;
  &lt;li&gt;at -l（列出用户的at排程）, -d （取消）, -c （列出id的实际工作内容）&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;任务管理， atrm id， 移除任务, 等同于 at -d&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;  &lt;span class="c"&gt;#设定范例&lt;/span&gt;
  at HH:MM YYYY-MM-DD
  at HH:MM[am|pm]
  at now + numbers &lt;span class="o"&gt;[&lt;/span&gt;minutes | hours | days | weeks]
  at now + 5 minutes
  &lt;span class="c"&gt;#进入编辑窗口&lt;/span&gt;
  ctrl + d 结束
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id="crontab"&gt;crontab&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;周期性执行任务&lt;/li&gt;
  &lt;li&gt;crontab -u 只有root才能使用， 帮助其他用户管理任务, -e 编辑， -l 查阅， -r 移除所有工作&lt;/li&gt;
  &lt;li&gt;分中， 小时， 日期， 月份， 周， 指令（分时日月周）&lt;/li&gt;
  &lt;li&gt;* 任何时候&lt;/li&gt;
  &lt;li&gt;, 分割枚举&lt;/li&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;时间范围&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;/n， 每隔n个单位&lt;/li&gt;
  &lt;li&gt;crontab 每分钟读取， 所以只需要编辑， /etc/crontab 文件即可&lt;/li&gt;
  &lt;li&gt;如果在大量的crontab时候，出现分配不均，（认为被集中执行）, 则可以，使用分割枚举的方法， 将任务排开，充分利用资源&lt;/li&gt;
  &lt;li&gt;可以在命令中进行，输出的重定向，例如， /dev/null&lt;/li&gt;
  &lt;li&gt;run-parts, /usr/bin/run-parts, 定期执行script文件&lt;/li&gt;
  &lt;li&gt;/var/log/cron中为crontab的log文件&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;anacron 是可以自动自动检查timestap日志，并将因为开关机导致没有执行的crontab重新执行的程序， 但是需要按照天，月来进行任务排期，&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight shell"&gt;&lt;code&gt;  &lt;span class="c"&gt;# run-parts&lt;/span&gt;
  01 &lt;span class="k"&gt;*&lt;/span&gt; &lt;span class="k"&gt;*&lt;/span&gt; &lt;span class="k"&gt;*&lt;/span&gt; &lt;span class="k"&gt;*&lt;/span&gt; root
  02 4 &lt;span class="k"&gt;*&lt;/span&gt; &lt;span class="k"&gt;*&lt;/span&gt; &lt;span class="k"&gt;*&lt;/span&gt; root
  22 4 &lt;span class="k"&gt;*&lt;/span&gt; &lt;span class="k"&gt;*&lt;/span&gt; 0 root
  42 4 1 &lt;span class="k"&gt;*&lt;/span&gt; &lt;span class="k"&gt;*&lt;/span&gt; root 分时日月周执行者身仹 挃令串
  root run-parts /etc/cron.hourly &amp;lt;&lt;span class="o"&gt;==&lt;/span&gt;每小时 run-parts /etc/cron.daily &amp;lt;&lt;span class="o"&gt;==&lt;/span&gt;每天
  root run-parts /etc/cron.weekly &amp;lt;&lt;span class="o"&gt;==&lt;/span&gt;每周日 run-parts /etc/cron.monthly &amp;lt;&lt;span class="o"&gt;==&lt;/span&gt;每个月 1 号
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id="系统性常见周期任务"&gt;系统性常见周期任务&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;登录档的轮替， log rotate&lt;/li&gt;
  &lt;li&gt;登录文件分析, logwatch&lt;/li&gt;
  &lt;li&gt;locate数据库更新&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>Linux Relearn</title>
    <link rel="alternate" href="http://geniousbar.github.io/2017/06/19/linux-relearn/"/>
    <id>http://geniousbar.github.io/2017/06/19/linux-relearn/</id>
    <published>2017-06-19T08:00:00+08:00</published>
    <updated>2017-06-26T10:26:05+08:00</updated>
    <summary type="html">&lt;h2 id="linux-bash"&gt;linux bash&lt;/h2&gt;

&lt;h4 id="常用命令"&gt;常用命令&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;history, alias, type, 变量，echo, unset, env, declare, set, read, array&lt;/li&gt;
  &lt;li&gt;系统变量， HOME, SHELL, HISISIZE, PATH, LANG, RANDOM, $, $?, OSTYPE, HOSTTYPE, MACHTYPE,&lt;/li&gt;
  &lt;li&gt;read, read -p ‘please enter you name’ -t 100 name&lt;/li&gt;
  &lt;li&gt;declare, declare -a...&lt;/li&gt;
&lt;/ul&gt;</summary>
    <content type="html">&lt;h2 id="linux-bash"&gt;linux bash&lt;/h2&gt;

&lt;h4 id="常用命令"&gt;常用命令&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;history, alias, type, 变量，echo, unset, env, declare, set, read, array&lt;/li&gt;
  &lt;li&gt;系统变量， HOME, SHELL, HISISIZE, PATH, LANG, RANDOM, $, $?, OSTYPE, HOSTTYPE, MACHTYPE,&lt;/li&gt;
  &lt;li&gt;read, read -p ‘please enter you name’ -t 100 name&lt;/li&gt;
  &lt;li&gt;declare, declare -a(array) ary; declear (-i) integer, declear -x(设定为幻境变量), declare -r (read only); ary[1]=’xx’ 从1开始，而非从0开始&lt;/li&gt;
  &lt;li&gt;ulimit 用于限制用户的系统资源，可以打开的档案数量， cpu时间， 内存总量等&lt;/li&gt;
  &lt;li&gt;alias, unalias,  alias rm=’rm i’&lt;/li&gt;
  &lt;li&gt;history 10&lt;/li&gt;
  &lt;li&gt;指定的搜索顺序， type -a ls, 1. 以相对/绝对路径执行挃令,例如『/bin/ls』戒『./ls』; 2. 由alias找刡该挃令杢执行; 3. 由bash内建癿(builtin)挃令杢执行; 4. 透过$PATH这个发量癿顺序搜寻刡癿第一个挃令杢执行。&lt;/li&gt;
  &lt;li&gt;bash 的登录欢迎信息， /etc/issue, /etc/motd, /etc/issue.net, 远程sshd登录，可以配置/etc/ssh/sshd_config 来决定， 读取文件&lt;/li&gt;
  &lt;li&gt;bash 的配置文件， login 读取文件顺序， 1. /etc/profile, 2. ~/.bash_profie, ~/.bash_login, ~/.profile , 其中2中三选一， 按照顺序那个文件存在读取那个文件 1。中不要改动比较重要， 1中会另外呼入 /etc/profile.d/*.sh 文件夹夏的所有文件， /etc/profile.d/lang.sh 会呼入/etc/sysconfig/i18n文件, /etc/skel/.bashrc 文件是 ~/.bashrc 的备份文件&lt;/li&gt;
  &lt;li&gt;source=. 可以source ~/.bash_profile 或者 . ~/.bash_profile&lt;/li&gt;
  &lt;li&gt;~/.bash_history, ~/.bash_logout&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;输入输出流管理：&lt;/p&gt;

    &lt;blockquote&gt;

      &lt;ol&gt;
        &lt;li&gt;标准输入 (stdin):代码为0,使用&amp;lt;戒«;&lt;/li&gt;
        &lt;li&gt;标准输出 (stdout):代码为1,使用&amp;gt;戒»;&lt;/li&gt;
        &lt;li&gt;标准错诨输出(stderr):代码为2,使用2&amp;gt;戒2»;&lt;br /&gt;
 find /home -name .bashrc &amp;gt; list_right 2&amp;gt; list_error&lt;br /&gt;
 /dev/null 垃圾桶黑洞装置不特殊写法&lt;br /&gt;
 find /home -name .bashrc &amp;gt; list 2&amp;gt;&amp;amp;1 同时写入一个文件中，不能写成 &amp;gt; list 2&amp;gt; list会导致同时吸入问津啊，顺序发生错乱&lt;br /&gt;
 command1 &amp;amp;&amp;amp; command2 || command3&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;cut; cut -d ‘:’ -f 2 $PATH; 通过分隔符裁剪，取特定位置的数值&lt;/li&gt;
  &lt;li&gt;expand -t 4 file_name, 将tab转换成4个空格&lt;/li&gt;
  &lt;li&gt;split -b 10m file 将文件切分成10m大小&lt;/li&gt;
  &lt;li&gt;xargs, sort, uniq&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="总结"&gt;总结&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;由于核心在内存中是受保护,因此我们必须要透过 Shell将我们输入命令传给 Kernel 沟通&lt;/li&gt;
  &lt;li&gt;用户默认登入去的shell记录于的最后一个字段&lt;/li&gt;
  &lt;li&gt;bash 主要功能有： 工作控制，前景背景控制，程序脚本化(job control, foreground, background)&lt;/li&gt;
  &lt;li&gt;type, which&lt;/li&gt;
  &lt;li&gt;locale 查询目前语言系材料， /etc/sysconfig/i18n&lt;/li&gt;
  &lt;li&gt;read可以回去用户输入，交互&lt;/li&gt;
  &lt;li&gt;ulimit限制用户系统资源&lt;/li&gt;
  &lt;li&gt;bash 非为login shell， non-login shell， login shell主要读取 /etc/profile, ~/.bash_profile, non-login shell 仅读取 ~/.bashrc&lt;/li&gt;
  &lt;li&gt;命令集， cut, grep, sort, wc, uniq, tee, tr, col, join, paste, expand, split, xargs&lt;/li&gt;
  &lt;li&gt;shell中的提示字符， 修改PSI变量&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;登录欢迎信息，在 /etc/issue, /etc/motd&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;变量：&lt;/p&gt;

    &lt;blockquote&gt;

      &lt;p&gt;name=file_name&lt;br /&gt;
  name=’file name is –’&lt;br /&gt;
  name=”$name”:suffix; name=${name}:suffix;&lt;br /&gt;
  name=$(uname -r); name=&lt;code&gt;unname -r&lt;/code&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>Linux Shell</title>
    <link rel="alternate" href="http://geniousbar.github.io/2017/06/19/linux-relearn-shell/"/>
    <id>http://geniousbar.github.io/2017/06/19/linux-relearn-shell/</id>
    <published>2017-06-19T08:00:00+08:00</published>
    <updated>2017-06-26T10:26:05+08:00</updated>
    <summary type="html">&lt;h2 id="linux-shell"&gt;linux shell&lt;/h2&gt;

&lt;h4 id="常用命令"&gt;常用命令&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;history, alias, type, 变量，echo, unset, env, declare, set, read, array&lt;/li&gt;
  &lt;li&gt;系统变量， HOME, SHELL, HISISIZE, PATH, LANG, RANDOM, $, $?, OSTYPE, HOSTTYPE, MACHTYPE,&lt;/li&gt;
  &lt;li&gt;read, read -p ‘please enter you name’ -t 100 name&lt;/li&gt;
  &lt;li&gt;declare, declare ...&lt;/li&gt;
&lt;/ul&gt;</summary>
    <content type="html">&lt;h2 id="linux-shell"&gt;linux shell&lt;/h2&gt;

&lt;h4 id="常用命令"&gt;常用命令&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;history, alias, type, 变量，echo, unset, env, declare, set, read, array&lt;/li&gt;
  &lt;li&gt;系统变量， HOME, SHELL, HISISIZE, PATH, LANG, RANDOM, $, $?, OSTYPE, HOSTTYPE, MACHTYPE,&lt;/li&gt;
  &lt;li&gt;read, read -p ‘please enter you name’ -t 100 name&lt;/li&gt;
  &lt;li&gt;declare, declare -a(array) ary; declear (-i) integer, declear -x(设定为幻境变量), declare -r (read only); ary[1]=’xx’ 从1开始，而非从0开始&lt;/li&gt;
  &lt;li&gt;ulimit 用于限制用户的系统资源，可以打开的档案数量， cpu时间， 内存总量等&lt;/li&gt;
  &lt;li&gt;alias, unalias,  alias rm=’rm i’&lt;/li&gt;
  &lt;li&gt;history 10&lt;/li&gt;
  &lt;li&gt;指定的搜索顺序， type -a ls, 1. 以相对/绝对路径执行挃令,例如『/bin/ls』戒『./ls』; 2. 由alias找刡该挃令杢执行; 3. 由bash内建癿(builtin)挃令杢执行; 4. 透过$PATH这个发量癿顺序搜寻刡癿第一个挃令杢执行。&lt;/li&gt;
  &lt;li&gt;bash 的登录欢迎信息， /etc/issue, /etc/motd, /etc/issue.net, 远程sshd登录，可以配置/etc/ssh/sshd_config 来决定， 读取文件&lt;/li&gt;
  &lt;li&gt;bash 的配置文件， login 读取文件顺序， 1. /etc/profile, 2. ~/.bash_profie, ~/.bash_login, ~/.profile , 其中2中三选一， 按照顺序那个文件存在读取那个文件 1。中不要改动比较重要， 1中会另外呼入 /etc/profile.d/*.sh 文件夹夏的所有文件， /etc/profile.d/lang.sh 会呼入/etc/sysconfig/i18n文件, /etc/skel/.bashrc 文件是 ~/.bashrc 的备份文件&lt;/li&gt;
  &lt;li&gt;source=. 可以source ~/.bash_profile 或者 . ~/.bash_profile&lt;/li&gt;
  &lt;li&gt;~/.bash_history, ~/.bash_logout&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;输入输出流管理：&lt;/p&gt;

    &lt;blockquote&gt;

      &lt;ol&gt;
        &lt;li&gt;标准输入 (stdin):代码为0,使用&amp;lt;戒«;&lt;/li&gt;
        &lt;li&gt;标准输出 (stdout):代码为1,使用&amp;gt;戒»;&lt;/li&gt;
        &lt;li&gt;标准错诨输出(stderr):代码为2,使用2&amp;gt;戒2»;&lt;br /&gt;
 find /home -name .bashrc &amp;gt; list_right 2&amp;gt; list_error&lt;br /&gt;
 /dev/null 垃圾桶黑洞装置不特殊写法&lt;br /&gt;
 find /home -name .bashrc &amp;gt; list 2&amp;gt;&amp;amp;1 同时写入一个文件中，不能写成 &amp;gt; list 2&amp;gt; list会导致同时吸入问津啊，顺序发生错乱&lt;br /&gt;
 command1 &amp;amp;&amp;amp; command2 || command3&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;cut; cut -d ‘:’ -f 2 $PATH; 通过分隔符裁剪，取特定位置的数值&lt;/li&gt;
  &lt;li&gt;expand -t 4 file_name, 将tab转换成4个空格&lt;/li&gt;
  &lt;li&gt;split -b 10m file 将文件切分成10m大小&lt;/li&gt;
  &lt;li&gt;xargs, sort, uniq&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="总结"&gt;总结&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;由于核心在内存中是受保护,因此我们必须要透过 Shell将我们输入命令传给 Kernel 沟通&lt;/li&gt;
  &lt;li&gt;用户默认登入去的shell记录于的最后一个字段&lt;/li&gt;
  &lt;li&gt;bash 主要功能有： 工作控制，前景背景控制，程序脚本化(job control, foreground, background)&lt;/li&gt;
  &lt;li&gt;type, which&lt;/li&gt;
  &lt;li&gt;locale 查询目前语言系材料， /etc/sysconfig/i18n&lt;/li&gt;
  &lt;li&gt;read可以回去用户输入，交互&lt;/li&gt;
  &lt;li&gt;ulimit限制用户系统资源&lt;/li&gt;
  &lt;li&gt;bash 非为login shell， non-login shell， login shell主要读取 /etc/profile, ~/.bash_profile, non-login shell 仅读取 ~/.bashrc&lt;/li&gt;
  &lt;li&gt;命令集， cut, grep, sort, wc, uniq, tee, tr, col, join, paste, expand, split, xargs&lt;/li&gt;
  &lt;li&gt;shell中的提示字符， 修改PSI变量&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;登录欢迎信息，在 /etc/issue, /etc/motd&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;变量：&lt;/p&gt;

    &lt;blockquote&gt;

      &lt;p&gt;name=file_name&lt;br /&gt;
  name=’file name is –’&lt;br /&gt;
  name=”$name”:suffix; name=${name}:suffix;&lt;br /&gt;
  name=$(uname -r); name=&lt;code&gt;unname -r&lt;/code&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
</feed>
