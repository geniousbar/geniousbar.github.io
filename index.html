<!DOCTYPE html><html><head><meta charset="utf-8" /><meta content="IE=edge;chrome=1" http-equiv="X-UA-Compatible" /><meta content="initial-scale=1.0, user-scalable=no" name="viewport" /><title>日常学习</title><meta description="geniousbar 日常知识总结" /><link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/feed.xml" /><link href="stylesheets/style-198d4031.css" rel="stylesheet" type="text/css" /><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" /><link href="images/favicon-6c3f3d04.png" rel="icon" type="image/png" /><script src="javascripts/all-b3988275.js"></script></head><body><header><div class="top-menu"><div class="top-menu-wrapper"><div class="top-menu-list"><ul><li><a href="/">Home</a></li><li><a href="/archives/">Archives</a></li><li><a href="/tags/">Tags</a></li><li><a href="/by-year/">By Year</a></li><li id="wechat"><a href="#" onclick="toggleShowWechat()">Wechat</a></li></ul></div></div></div><div id="header-wechat-img"><img src="images/wechat_nasa-0d87c0dd.png" /></div><h1 class="logo"><a href="/" title="日常学习"><span class="logo-text">日常学习</span></a></h1></header><main><article>

<h1 class="article-title"><a href="/2024/03/13/rust-relearn/">rust relearn</a></h1><div class="posted-date-wrapper"><i class="fa fa-clock-o"></i><span class="posted-date">January 17, 2024</span></div><div class="tag-labels"><a href="/tags/rust/"></a></div><hr class="article-header-separator" /><p><a href="/rust/" title="rust">rust relearn</a></p>
<div class="read-more"><a href="/2024/03/13/rust-relearn/">Read More <i class="fa fa-angle-double-right"></i></a></div><hr class="article-separator" />

<h1 class="article-title"><a href="/2022/01/17/deep-rails-stack/">deep rails stack</a></h1><div class="posted-date-wrapper"><i class="fa fa-clock-o"></i><span class="posted-date">January 17, 2022</span></div><div class="tag-labels"><a href="/tags/rails/"><small class="tag-label">rails</small></a></div><hr class="article-header-separator" /><p><a href="/rails/" title="rails">deep rails stack</a></p>
<div class="read-more"><a href="/2022/01/17/deep-rails-stack/">Read More <i class="fa fa-angle-double-right"></i></a></div><hr class="article-separator" />

<h1 class="article-title"><a href="/2021/09/13/redis-all/">redis all</a></h1><div class="posted-date-wrapper"><i class="fa fa-clock-o"></i><span class="posted-date">September 13, 2021</span></div><div class="tag-labels"><a href="/tags/redis/"><small class="tag-label">redis</small></a><a href="/tags/linux/"><small class="tag-label">linux</small></a></div><hr class="article-header-separator" /><h2 id="redis-总结">redis 总结：</h2>

<blockquote>
  <p>redis 已经看了不少，也写了不少，但是总是 没有一篇文章能够将其贯穿起来。 发现并没有太好的形式 将其总结下来。 曾经使用调用栈的方式将 代码+文档的形式记录下来。但缺少足够的大局观，写大片的理论文章又缺少足够的细节。</p>
</blockquote>

<h3 id="redis-server-整体结构">Redis Server 整体结构：</h3>
<h4 id="serverc-中的-main-函数-userslishaohuadocumentsself_testredissrcserverc6063">server.c 中的 main 函数 /Users/lishaohua/Documents/self_test/redis/src/server.c::6063</h4>
<h5 id="initserverconfig-userslishaohuadocumentsself_testredissrcserverc2628--主要初始化-server的初始配置信息并没有读取-config-file-初始化-server-结构中的变量数值比如-aof_state-以及-初始化-command-table-redis-命令表-其中包含--命令字符串--函数指针--等">initServerConfig()...</h5><div class="read-more"><a href="/2021/09/13/redis-all/">Read More <i class="fa fa-angle-double-right"></i></a></div><hr class="article-separator" /><h1 class="article-title"><a href="/2021/06/30/rust-design-patterns/">rust 编码模式</a></h1><div class="posted-date-wrapper"><i class="fa fa-clock-o"></i><span class="posted-date">June 30, 2021</span></div><div class="tag-labels"><a href="/tags/rust/"><small class="tag-label">rust</small></a><a href="/tags/design/"><small class="tag-label">design</small></a></div><hr class="article-header-separator" /><h3 id="设计模式">设计模式</h3>
<ul>
  <li>Design Patterns: 是在编写软件时解决常见问题的方法。</li>
  <li>Anti-patterns: 反模式是解决这些相同常见问题的方法。 然而，虽然设计模式给我们带来了好处，但反模式却带来了更多的问题。</li>
  <li>idioms(惯用方法): 是编码时要遵循的准则。 它们是社区的社会规范。 你可以打破它们，但如果你这样做了，你应该有一个很好的理由。
    <h4 id="示例">示例：</h4>
  </li>
  <li>使用 borrowed type 作为 参数（为参数提供灵活）， 例如： &amp;str 替换 &amp;String...</li>
</ul><div class="read-more"><a href="/2021/06/30/rust-design-patterns/">Read More <i class="fa fa-angle-double-right"></i></a></div><hr class="article-separator" /><h1 class="article-title"><a href="/2021/05/25/current-os-virtual-memory/">现代操作系统  内存篇</a></h1><div class="posted-date-wrapper"><i class="fa fa-clock-o"></i><span class="posted-date">May 25, 2021</span></div><div class="tag-labels"><a href="/tags/os/"><small class="tag-label">os</small></a><a href="/tags/linux/"><small class="tag-label">linux</small></a></div><hr class="article-header-separator" /><h2 id="内存管理">内存管理</h2>

<blockquote>
  <p>因为： 不管存储器多大，程序都可以将其填满。<br>
所以： 分层存储器体系： 在这个体系中，存在 MB 的快速、昂贵、易失性的高速缓存，GB的速度价格适中的同样易失的内存 ，以及 TB的低速、廉价、非易失的磁盘存储。</p>
</blockquote>

<h3 id="操作系统的工作之一-就是-将层次存储系统体系-抽象成为一个-有用的模型-并管理这个抽象">操作系统的工作之一 就是 将层次存储系统体系 抽象成为一个 有用的模型 并管理这个抽象。</h3>

<p>分层存储器系统称为 存储管理系统：  他的任务是 有效的管理内存，即记录哪些 内存是正在使用的，哪些 是空闲的， 在进程需要时候为其分配内存 ，不需要时释放内存。</p>

<h3 id="探索-内存抽象方案">探...</h3><div class="read-more"><a href="/2021/05/25/current-os-virtual-memory/">Read More <i class="fa fa-angle-double-right"></i></a></div><hr class="article-separator" /><h1 class="article-title"><a href="/2021/05/24/current-os/">现代操作系统</a></h1><div class="posted-date-wrapper"><i class="fa fa-clock-o"></i><span class="posted-date">May 24, 2021</span></div><div class="tag-labels"><a href="/tags/os/"><small class="tag-label">os</small></a><a href="/tags/linux/"><small class="tag-label">linux</small></a></div><hr class="article-header-separator" /><h3 id="现代操作系统">现代操作系统：</h3>
<blockquote>
  <p>抽象是管理复杂性的关键， 好的抽象可以把一个 不可能管理的任务 分为 两个可管理的部件。 抽象的定义和实现 + 用这些抽象解决的问题。<br>
操作系统的任务 就是 创建好的抽象 并实现和管理它所创建的抽象对象。抽象内容是理解操作系统的关键。</p>
</blockquote>

<h4 id="作为资源管理者的操作系统">作为资源管理者的操作系统：</h4>

<h5 id="资源管理包括-以下两种不同方式实现-多路复用共享资源时间上-复用--空间上复用-">资源管理包括 以下两种不同方式实现 多路复用（共享）资源：时间上 复用 + 空间上复用 。</h5>

<ul>
  <li>
    <p>时间复用 例子 比如 打印机， 问题： 如何决定下一个执行哪个任务？ 以及 任务运行的时间</p>
...</li>
</ul><div class="read-more"><a href="/2021/05/24/current-os/">Read More <i class="fa fa-angle-double-right"></i></a></div><hr class="article-separator" /><h1 class="article-title"><a href="/2021/05/09/rust-async/">Rust Async</a></h1><div class="posted-date-wrapper"><i class="fa fa-clock-o"></i><span class="posted-date">May 09, 2021</span></div><div class="tag-labels"><a href="/tags/rust/"><small class="tag-label">rust</small></a><a href="/tags/async/"><small class="tag-label">async</small></a><a href="/tags/cocurrent/"><small class="tag-label">cocurrent</small></a></div><hr class="article-header-separator" /><h3 id="并发模型">并发模型</h3>
<ul>
  <li>
<strong>OS threads</strong>:  1) 不需要改变代码编码模式  2) 线程间 同步困难  3) 性能开销比较大， 线程池 可以一定程度上减少这些开销， 但是并不能够支撑起 庞大的IO 工作</li>
  <li>
<strong>事件驱动模型(Event-driven)</strong>： 结合callback, 性能非常好，但是 导致 非线性的控制流， Data flow and error propagation is often hard to follow.</li>
  <li>
<strong>协程(coroutines)</strong>： like thread， 不需...</li>
</ul><div class="read-more"><a href="/2021/05/09/rust-async/">Read More <i class="fa fa-angle-double-right"></i></a></div><hr class="article-separator" /><h1 class="article-title"><a href="/2021/04/11/mysql-relearn/">Mysql</a></h1><div class="posted-date-wrapper"><i class="fa fa-clock-o"></i><span class="posted-date">April 11, 2021</span></div><div class="tag-labels"><a href="/tags/mysql/"><small class="tag-label">mysql</small></a></div><hr class="article-header-separator" /><h2 id="mysql-relearn">Mysql Relearn</h2>
<h3 id="内存模型">内存模型：</h3>
<p><img src="images/innodb-change-buffer-5fbd1a84.png" alt="memory-cache"></p>
<ul>
  <li>Change BUffer： 缓存 不在Buffer pool 中的 索引页的变动， 变动 可能由 insert update， delete 等操作 导致， 将在以后 页面 被加载到 Buffer pool时 被合并
    <ul>
      <li>[image]</li>
      <li>不同于 聚簇索引， 普通的索引 通常是不唯一的，索引 的插入 删除 更新 通常是 random 的， 随后 将 change Buffer 的合并到 Buffer pool（当...</li>
</ul>
</li>
</ul><div class="read-more"><a href="/2021/04/11/mysql-relearn/">Read More <i class="fa fa-angle-double-right"></i></a></div><hr class="article-separator" /><h1 class="article-title"><a href="/2021/02/21/redis/">Redis Client conection</a></h1><div class="posted-date-wrapper"><i class="fa fa-clock-o"></i><span class="posted-date">February 21, 2021</span></div><div class="tag-labels"><a href="/tags/redis/"><small class="tag-label">redis</small></a></div><hr class="article-header-separator" /><h2 id="redis-建立链接过程">Redis 建立链接过程</h2>
<p><img src="images/redis-d67208d8.png" alt="redis" /></p>
<div class="read-more"><a href="/2021/02/21/redis/">Read More <i class="fa fa-angle-double-right"></i></a></div><hr class="article-separator" /><h1 class="article-title"><a href="/2021/02/20/rust-little-book/">Rust little book</a></h1><div class="posted-date-wrapper"><i class="fa fa-clock-o"></i><span class="posted-date">February 20, 2021</span></div><div class="tag-labels"><a href="/tags/rust/"><small class="tag-label">rust</small></a><a href="/tags/cargo/"><small class="tag-label">cargo</small></a><a href="/tags/rustup/"><small class="tag-label">rustup</small></a></div><hr class="article-header-separator" /><h2 id="rust-little-book">Rust little book</h2>

<h3 id="rustup--rust-complier-的管理工具-可以方便的切换-stable-beta-and-nightly">rustup:  rust complier 的管理工具， 可以方便的切换 stable, beta, and nightly</h3>
<h3 id="cargo-是rust的包管理工具-用来-下载-rust的依赖-编译-以及-分发-到-cratesio">cargo 是rust的包管理工具， 用来 下载 rust的依赖， 编译， 以及 分发 到 crates.io</h3>
<ul>
  <li>在安装 rust 之后， cargo 也会被自动安装上</li>
  <li>cargo 提供了一些有用的工具有:
    <ol>
      <li>cargo new package # default –bin 生成 可执行 program...</li>
</ol>
</li>
</ul><div class="read-more"><a href="/2021/02/20/rust-little-book/">Read More <i class="fa fa-angle-double-right"></i></a></div><hr class="article-separator" /><h1 class="article-title"><a href="/2021/02/19/link-compile/">link compile</a></h1><div class="posted-date-wrapper"><i class="fa fa-clock-o"></i><span class="posted-date">February 19, 2021</span></div><div class="tag-labels"><a href="/tags/linker-compile-gcc/"><small class="tag-label">linker compile gcc</small></a></div><hr class="article-header-separator" /><h2 id="link--compile">link &amp; compile</h2>

<h3 id="为什么c语言中的-header-file-h-一定需要-防止重复被include-呢-而为什么一定需要-header-file的存在呢">为什么c语言中的 header file *.h 一定需要 防止重复被include 呢？ 而为什么一定需要 header file的存在呢？</h3>
<ul>
  <li>header file 需要存在原因有： 1） .c 文件 变为可执行文件，需要 编译、链接 两个阶段， 而链接中 是可以将 不同的 类型编译过的文件进行 链接的。 随着程序的复杂， 比如 函数参数的 传递顺序等 原因导致，需要 程序调用者 知道 函数调用的结构， 所以 [[https://www.zhihu.com...</li>
</ul><div class="read-more"><a href="/2021/02/19/link-compile/">Read More <i class="fa fa-angle-double-right"></i></a></div><hr class="article-separator" /><div class="paginate-wrapper"><div class="next-page"><a href="/page/2/"><i class="fa fa-arrow-right"></i> Next Page</a></div></div><div class="page-number">Page 1 of 8</div></article></main><footer><div class="footer-wrapper"><div class="author"><div class="image-wrapper"><a href="/author/"><img alt="author" src="images/profile-1e71686a.png" /></a></div></div><div class="image-content"><img src="images/wechat_nasa-0d87c0dd.png" /></div><div class="copyright"><i class="fa fa-copyright"></i> 2022 <a href="/">日常学习</a> - geniousbar</div></div><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?b43ef53b285c49e1af0bd7080994c825";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script></footer></body></html>
