<!DOCTYPE html><html><head><meta charset="utf-8" /><meta content="IE=edge;chrome=1" http-equiv="X-UA-Compatible" /><meta content="initial-scale=1.0, user-scalable=no" name="viewport" /><title>日常学习</title><meta description="geniousbar 日常知识总结" /><link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/feed.xml" /><link href="../../stylesheets/style-32b4222b.css" rel="stylesheet" type="text/css" /><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" /><link href="../../images/favicon-6c3f3d04.png" rel="icon" type="image/png" /><script src="../../javascripts/all-b3988275.js"></script></head><body><header><div class="top-menu"><div class="top-menu-wrapper"><div class="top-menu-list"><ul><li><a href="/">Home</a></li><li><a href="/archives/">Archives</a></li><li><a href="/tags/">Tags</a></li><li><a href="/by-year/">By Year</a></li><li id="wechat"><a href="#" onclick="toggleShowWechat()">Wechat</a></li></ul></div></div></div><div id="header-wechat-img"><img src="../../images/wechat_nasa-0d87c0dd.png" /></div><h1 class="logo"><a href="/" title="日常学习"><span class="logo-text">日常学习</span></a></h1></header><main><article><h1 class="article-title"><a href="/2018/12/06/linux-interface-02/">linux-interface-02</a></h1><div class="posted-date-wrapper"><i class="fa fa-clock-o"></i><span class="posted-date">December 06, 2018</span></div><div class="tag-labels"><a href="/tags/linux/"><small class="tag-label">linux</small></a><a href="/tags/books/"><small class="tag-label">books</small></a></div><hr class="article-header-separator" /><h2 id="the-linux-programming-interface">The linux programming interface</h2>

<h2 id="系统编程概念">系统编程概念</h2>

<p>无论何时，执行了系统调用或者库函数，检查调用的返回状态以确定调用是否成功,是一条编程铁律。(消灭nil就好了)</p>

<h3 id="系统调用">系统调用</h3>
<blockquote>
  <p>借助这一机制，进程可以请求内核以自己的名义去执行动作，以API 的形式，内核提供一系列服务供程序访问。（创建进程， IIO操作等）可以参考 csapp中的 异常控制流章节。</p>
</blockquote>

<p>系统调用有以下特征：</p>
<ol>
  <li>系统调用将CPU 从用户态切换到 内核态，以便CPU访问受保护的内存等（越过...</li>
</ol><div class="read-more"><a href="/2018/12/06/linux-interface-02/">Read More <i class="fa fa-angle-double-right"></i></a></div><hr class="article-separator" /><h1 class="article-title"><a href="/2018/11/11/linux-interface/">linux-interface</a></h1><div class="posted-date-wrapper"><i class="fa fa-clock-o"></i><span class="posted-date">November 11, 2018</span></div><div class="tag-labels"><a href="/tags/linux/"><small class="tag-label">linux</small></a><a href="/tags/books/"><small class="tag-label">books</small></a></div><hr class="article-header-separator" /><h2 id="the-linux-programming-interface">The linux programming interface</h2>

<h2 id="基本概念">基本概念</h2>

<h3 id="内核">内核</h3>
<ol>
  <li>通常的定义，1）完整的软件包， 这包括用来管理计算机资源的核心软件 以及附带的标准软件工具（shell，图形用户界面， 文件工具）2) 狭义的层面，是指管理和分配计算机资源的核心软件</li>
  <li>职责: 1）进程调度， 2）内存管理， 3）文件系统， 4）创建和终止进程， 5）设备管理， 6）联网， 7）提供系统调用的编程接口</li>
  <li>内核态、用户态: 区分态的原因： 1）只有cpu处于内核态的时候，才能执行某些...</li>
</ol><div class="read-more"><a href="/2018/11/11/linux-interface/">Read More <i class="fa fa-angle-double-right"></i></a></div><hr class="article-separator" /><h1 class="article-title"><a href="/2018/09/16/redis-rb/">redis-rb</a></h1><div class="posted-date-wrapper"><i class="fa fa-clock-o"></i><span class="posted-date">September 16, 2018</span></div><div class="tag-labels"><a href="/tags/redis/"><small class="tag-label">redis</small></a><a href="/tags/ruby/"><small class="tag-label">ruby</small></a></div><hr class="article-header-separator" /><h2 id="redis-rb-为ruby-连接redis的客户端">redis-rb 为ruby 连接redis的客户端</h2>

<h4 id="项目结构">项目结构</h4>
<ol>
  <li>项目本身依赖于 hiredis，而hiredis 本身是一个redis client c的包装。并没有搞懂为什么需要依赖redis client</li>
  <li>项目目录结构如下</li>
</ol>

<div class="highlight"><pre class="highlight plaintext"><code>  /lib
    |---- redis.rb
    |---- /Redis
          |---- connection.rb
          |---- errors.rb
          |---- pipeline.rb...</code></pre></div><div class="read-more"><a href="/2018/09/16/redis-rb/">Read More <i class="fa fa-angle-double-right"></i></a></div><hr class="article-separator" /><h1 class="article-title"><a href="/2018/03/20/sicp/">计算机程序的构造和解释</a></h1><div class="posted-date-wrapper"><i class="fa fa-clock-o"></i><span class="posted-date">March 20, 2018</span></div><div class="tag-labels"><a href="/tags/sicp/"><small class="tag-label">SICP</small></a></div><hr class="article-header-separator" /><p>计算机程序的构造和解释<br>
    ———</p>

<div class="highlight"><pre class="highlight plaintext"><code>序
---------
</code></pre></div>
<blockquote>
  <p>关注程序的创建、执行和研究。使用Lisp方言书写<br>
本书中讨论的各种问题主要涉及到： 人的大脑，计算机程序的集合，以及计算机本身。每一个计算机程序都是现实中的或者精神中的某个过程的一个模型。通过人的头脑孵化出来，这种过程出现在人们的经验或者思维中。很少能够通过程序将这种过程模拟到永远令人满意的程度。 因为这个原因，程序也在不断的演化。当我们对模型的认识更深入、更扩大，更广泛时，我们就会修改程序。直到达到一中亚稳定状态。...</p>
</blockquote><div class="read-more"><a href="/2018/03/20/sicp/">Read More <i class="fa fa-angle-double-right"></i></a></div><hr class="article-separator" /><h1 class="article-title"><a href="/2018/01/04/benjamin-graham/">格雷厄姆之道</a></h1><div class="posted-date-wrapper"><i class="fa fa-clock-o"></i><span class="posted-date">January 04, 2018</span></div><div class="tag-labels"><a href="/tags/.html"><small class="tag-label">投资</small></a></div><hr class="article-header-separator" /><h2 id="格雷厄姆之道如何在中国实践价值投资">格雷厄姆之道（如何在中国实践价值投资）</h2>
<blockquote>
  <p>现在已然衰朽者， 将来可能重放异彩；现在备受青睐者，，将来却可能日渐衰朽。</p>
</blockquote>

<h2 id="原理">原理</h2>

<ol>
  <li>价值投资：
    <blockquote>
      <p>价值投资不会让你一夜暴富，但它可以在保证本金安全的前提下让你的财产增值</p>
    </blockquote>

    <ul>
      <li>价值投资：用远低于公司内在价值的价格购买该公司的股票</li>
      <li>金融思维和商业思维： 商业思维 这个公司值多少钱，股票价格 = 公司价格 / 股票数量。 金融思维： 股票价格 = 每股收益 * 市盈率（PE）金融...</li>
</ul>
</li>
</ol><div class="read-more"><a href="/2018/01/04/benjamin-graham/">Read More <i class="fa fa-angle-double-right"></i></a></div><hr class="article-separator" /><h1 class="article-title"><a href="/2017/12/02/csapp/">CSAPP(深入理解计算机系统)</a></h1><div class="posted-date-wrapper"><i class="fa fa-clock-o"></i><span class="posted-date">December 02, 2017</span></div><div class="tag-labels"><a href="/tags/csapp/"><small class="tag-label">csapp</small></a></div><hr class="article-header-separator" /><h2 id="计算机系统漫游">计算机系统漫游</h2>

<ol>
  <li>代码从文本到可执行文件的过程（c语言示例）：
    <ul>
      <li>预处理阶段，处理 #inlcude &lt;stadI/O.h&gt;， #define MAX 100</li>
      <li>编译阶段：将文本编译成汇编程序，hello.s</li>
      <li>汇编阶段：汇编器将上一步的程序翻译成机器指令。hello.o</li>
      <li>链接阶段就：hello 中调用的printf函数，而函数存在一个printf.o 单独的编译完成文件，需要以某种方式合并到hello.o 中。</li>
    </ul>
  </li>
 ...</ol><div class="read-more"><a href="/2017/12/02/csapp/">Read More <i class="fa fa-angle-double-right"></i></a></div><hr class="article-separator" /><h1 class="article-title"><a href="/2017/10/21/art_of_unix_programming/">Art of UNIX programming</a></h1><div class="posted-date-wrapper"><i class="fa fa-clock-o"></i><span class="posted-date">October 21, 2017</span></div><div class="tag-labels"><a href="/tags/unix/"><small class="tag-label">unix</small></a><a href="/tags/linx/"><small class="tag-label">linx</small></a><a href="/tags/art/"><small class="tag-label">art</small></a></div><hr class="article-header-separator" /><h2 id="the-art-of-unix-programming">The Art of unix programming</h2>

<h2 id="哲学">哲学</h2>
<h5 id="哲学基础">哲学基础：</h5>

<blockquote>
  <p>unix 哲学并不算是一种正规设计方法， 不打算从计算机科学的理论高度产生出完美的软件， 那些毫无动力、松松垮垮的，薪水微薄的程序员，能在短短期限内，如同神灵附体般的创造出稳定而又新颖的软件， 这只不过是经理人永远的梦呓罢了。  (社会经济学基础)<br>
   unix 哲学，是自下而上的，注重实效，立足于丰富的经验，你不会在正规的方法学和标准中找到她，她更接近与隐性的 半本能知识，UNIX 文化所传播的 专业经...</p>
</blockquote><div class="read-more"><a href="/2017/10/21/art_of_unix_programming/">Read More <i class="fa fa-angle-double-right"></i></a></div><hr class="article-separator" /><h1 class="article-title"><a href="/2017/09/02/css_the_definitive_guide/">Css The Definitive Guide</a></h1><div class="posted-date-wrapper"><i class="fa fa-clock-o"></i><span class="posted-date">September 02, 2017</span></div><div class="tag-labels"><a href="/tags/html/"><small class="tag-label">html</small></a><a href="/tags/css/"><small class="tag-label">css</small></a></div><hr class="article-header-separator" /><h2 id="the-definitive-guide-css">The Definitive Guide css</h2>

<h4 id="css-和-文档">css 和 文档</h4>
<div class="highlight"><pre class="highlight plaintext"><code>* 层叠： css中解决样式冲突的规则，称为层叠
* 元素：
  ```text
      替换、非替换元素
      替换元素： 用来替换元素的内容部分，并非由文档内容直接表示。&lt;img src='xxx'&gt; 标记片段中不包含任何具体内容，只有一个属性
      非替换元素：大多数元素都是非替换元素。
     元素显示角色：
     块级(block-level)，行内(inline-level)
     display...</code></pre></div><div class="read-more"><a href="/2017/09/02/css_the_definitive_guide/">Read More <i class="fa fa-angle-double-right"></i></a></div><hr class="article-separator" /><h1 class="article-title"><a href="/2017/08/24/phoenix_13_learn/">Phoenix 1.3</a></h1><div class="posted-date-wrapper"><i class="fa fa-clock-o"></i><span class="posted-date">August 24, 2017</span></div><div class="tag-labels"><a href="/tags/elixir/"><small class="tag-label">elixir</small></a><a href="/tags/phoenix/"><small class="tag-label">phoenix</small></a></div><hr class="article-header-separator" /><h2 id="phoenix-13-learn">Phoenix 1.3 learn</h2>

<h4 id="常用命令">常用命令</h4>

<div class="highlight"><pre class="highlight plaintext"><code>```
mix phx.new hello 
mix deps.get 
mix deps.compile 
iex -S mix phx.server 
mix ecto.create 
mix phx.server 


```

lib/hello_web 保存web相关的代码， 
```
|-- channels
|     |-- user_socket.ex
|-- controllers
|     |-- page_controller...</code></pre></div><div class="read-more"><a href="/2017/08/24/phoenix_13_learn/">Read More <i class="fa fa-angle-double-right"></i></a></div><hr class="article-separator" /><h1 class="article-title"><a href="/2017/08/07/phoenix-contexts/">Phoenix framework 1.3 context</a></h1><div class="posted-date-wrapper"><i class="fa fa-clock-o"></i><span class="posted-date">August 07, 2017</span></div><div class="tag-labels"><a href="/tags/phoenix/"><small class="tag-label">phoenix</small></a><a href="/tags/elixir/"><small class="tag-label">elixir</small></a><a href="/tags/desigin/"><small class="tag-label">desigin</small></a></div><hr class="article-header-separator" /><h2 id="design">Design</h2>

<h3 id="思考设计">思考设计</h3>

<p>context 是专门用来 组织、暴露 相关的功能的module。比如我们每次调用Elixir标准库 Logger.info, 其实是在接触不同的context， 在内部， Elixir Logger是由 诸如 Logger.Config. Logger.Backends 的module组成的， 但是我们从来不会直接跟这些module交互， 我们使用Logger context， 因为他组织并且暴露接口。<br>
  Phoenix 组织目录类似于其他的Elixir Project...</p><div class="read-more"><a href="/2017/08/07/phoenix-contexts/">Read More <i class="fa fa-angle-double-right"></i></a></div><hr class="article-separator" /><div class="paginate-wrapper"><div class="previous-page"><a href="/"><i class="fa fa-arrow-left"></i> Previous Page</a></div><div class="next-page"><a href="/page/3/"><i class="fa fa-arrow-right"></i> Next Page</a></div></div><div class="page-number">Page 2 of 6</div></article></main><footer><div class="footer-wrapper"><div class="author"><div class="image-wrapper"><a href="/author/"><img alt="author" src="../../images/profile-1e71686a.png" /></a></div></div><div class="image-content"><img src="../../images/wechat_nasa-0d87c0dd.png" /></div><div class="copyright"><i class="fa fa-copyright"></i> 2019 <a href="/">日常学习</a> - geniousbar</div></div><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?b43ef53b285c49e1af0bd7080994c825";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script></footer></body></html>