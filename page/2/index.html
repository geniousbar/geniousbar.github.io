<!DOCTYPE html><html><head><meta charset="utf-8" /><meta content="IE=edge;chrome=1" http-equiv="X-UA-Compatible" /><meta content="initial-scale=1.0, user-scalable=no" name="viewport" /><title>日常学习</title><meta description="geniousbar 日常知识总结" /><link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/feed.xml" /><link href="../../stylesheets/style-32b4222b.css" rel="stylesheet" type="text/css" /><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" /><link href="../../images/favicon-6c3f3d04.png" rel="icon" type="image/png" /><script src="../../javascripts/all-b3988275.js"></script></head><body><header><div class="top-menu"><div class="top-menu-wrapper"><div class="top-menu-list"><ul><li><a href="/">Home</a></li><li><a href="/archives/">Archives</a></li><li><a href="/tags/">Tags</a></li><li><a href="/by-year/">By Year</a></li><li id="wechat"><a href="#" onclick="toggleShowWechat()">Wechat</a></li></ul></div></div></div><div id="header-wechat-img"><img src="../../images/wechat_nasa-0d87c0dd.png" /></div><h1 class="logo"><a href="/" title="日常学习"><span class="logo-text">日常学习</span></a></h1></header><main><article><h1 class="article-title"><a href="/2019/02/05/fifo-pipe/">fifo-pipe</a></h1><div class="posted-date-wrapper"><i class="fa fa-clock-o"></i><span class="posted-date">February 05, 2019</span></div><div class="tag-labels"><a href="/tags/linux/"><small class="tag-label">linux</small></a><a href="/tags/books/"><small class="tag-label">books</small></a></div><hr class="article-header-separator" /><h2 id="the-linux-programming-interface">The linux programming interface</h2>

<h3 id="管道-fifo">管道, FIFO</h3>
<p>管道是UNIX系统上最古老的一种IPC方法，可以用来在相关进程间传递数据。FIFO 则是 管道 概念的一个变体, 区别在于 FIFO可以用于 任意进程间的通信</p>

<h4 id="管道">管道</h4>

<ol>
  <li>
    <p>shell命令中使用管道最为常见。比如 ls | wc -l, 示意图如下： 为执行该命令， shell创建了两个进程来分别执行ls、wc</p>
  </li>
  <li>管道的几个特征：
    <ol>
      <li>一个管道是一个字节流 （不存在消息...</li>
</ol>
</li>
</ol><div class="read-more"><a href="/2019/02/05/fifo-pipe/">Read More <i class="fa fa-angle-double-right"></i></a></div><hr class="article-separator" /><h1 class="article-title"><a href="/2019/01/14/linux-interface-socket/">linux-interface-socket</a></h1><div class="posted-date-wrapper"><i class="fa fa-clock-o"></i><span class="posted-date">January 14, 2019</span></div><div class="tag-labels"><a href="/tags/linux/"><small class="tag-label">linux</small></a><a href="/tags/books/"><small class="tag-label">books</small></a></div><hr class="article-header-separator" /><h2 id="the-linux-programming-interface">The linux programming interface</h2>
<!-- 1. 57 介绍UNIX domain socket， 允许同一主机上的系统上的应用程序之间通讯。 58 介绍TCP/IP之间联网协议的关键特性。， 59 描述internet domain socket, 允许位于不同主机上的应用程序通过一个TCP/IP王璐进行通讯， 60 讨论socket的服务设计， 61: 介绍一些高级主题， 包括socket IO的， TCP协议的细节信息，已经socket选项来获取修改socket的各种特性。 -->

<h3 id="socket">Socket</h3>
<p><strong>socket是一种IPC方法， 它允许位于同意主机或者网络连接的不同主机 上的应用程序之间交换数据(第一个被广泛接收的socket API 实现于 1983年，现在这组API 已经被移植到了大部分的计算机系统上)</strong></p>
<ol>
  <li>socket(domain, type, protocol): 系统调用
    <ul>
      <li>
        <p>domain: 1）识别 socket 地址的格式  2） 确定范围: 在同一...</p>
</li>
</ul>
</li>
</ol><div class="read-more"><a href="/2019/01/14/linux-interface-socket/">Read More <i class="fa fa-angle-double-right"></i></a></div><hr class="article-separator" /><h1 class="article-title"><a href="/2018/12/30/linux-interface-05/">linux-interface-05</a></h1><div class="posted-date-wrapper"><i class="fa fa-clock-o"></i><span class="posted-date">December 30, 2018</span></div><div class="tag-labels"><a href="/tags/linux/"><small class="tag-label">linux</small></a><a href="/tags/books/"><small class="tag-label">books</small></a></div><hr class="article-header-separator" /><h2 id="the-linux-programming-interface">The linux programming interface</h2>

<h3 id="深入探究文件io">深入探究文件IO</h3>
<hr>
<p><strong>原子操作： 将某一系统调用所要完成的各个动作作为不可中断的操作，一次性加以完成, 是许多系统调用的以正确完成的必要条件</strong><br>
<strong>竞争状态是这样一种情形：操作共享资源的两个进程或线程，结果取决于 一个无法预期的顺序，即这些进程获取CPU使用权的先后相对顺序</strong></p>

<ol>
  <li>open, 保证进程是打开文件的创建者，对文件是否存在的检查和创建文件属于同一原子操作。 flags: O_CREAT</li>
  <li>
    <p>fcntl: fcntl...</p>
</li>
</ol><div class="read-more"><a href="/2018/12/30/linux-interface-05/">Read More <i class="fa fa-angle-double-right"></i></a></div><hr class="article-separator" /><h1 class="article-title"><a href="/2018/12/30/linux-interface-07/">linux-interface-07</a></h1><div class="posted-date-wrapper"><i class="fa fa-clock-o"></i><span class="posted-date">December 30, 2018</span></div><div class="tag-labels"><a href="/tags/linux/"><small class="tag-label">linux</small></a><a href="/tags/books/"><small class="tag-label">books</small></a></div><hr class="article-header-separator" /><h2 id="the-linux-programming-interface">The linux programming interface</h2>

<h2 id="内存分配">内存分配</h2>
<ol>
  <li>在堆上分配内存， 进程可以通过增加堆的大小来分配内存， 堆就是一段长度可变的连续的虚拟内存，初始于 进程未初始化的数据段末尾，随着内存的分配和释放而增减。通常将堆当前内存边界成为 program break
    <ul>
      <li>brk(vodi * end_data_segment), sbrk(int increment), 两个系统调用可以改变 program break 的位置， 位置调升以后，程序可...</li>
</ul>
</li>
</ol><div class="read-more"><a href="/2018/12/30/linux-interface-07/">Read More <i class="fa fa-angle-double-right"></i></a></div><hr class="article-separator" /><h1 class="article-title"><a href="/2018/12/30/linx-interface-04/">linux-interface-04</a></h1><div class="posted-date-wrapper"><i class="fa fa-clock-o"></i><span class="posted-date">December 30, 2018</span></div><div class="tag-labels"><a href="/tags/linux/"><small class="tag-label">linux</small></a><a href="/tags/books/"><small class="tag-label">books</small></a></div><hr class="article-header-separator" /><h2 id="the-linux-programming-interface">The linux programming interface</h2>

<h3 id="文件io-通用的io模型">文件IO 通用的IO模型</h3>
<hr>
<p><strong>文件描述符： 一个非负整数，来指代打开的文件，其中包括： 管道FIFO socket，终端 设备 普通文件</strong></p>
<ol>
  <li>
    <p>标准文件描述符:</p>

    <table>
      <thead>
        <tr>
          <th style="text-align: left">文件描述符</th>
          <th style="text-align: left">用途</th>
          <th style="text-align: left">名称</th>
          <th style="text-align: left">stdio</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: left">0</td>
     ...</tr>
</tbody>
</table>
</li>
</ol><div class="read-more"><a href="/2018/12/30/linx-interface-04/">Read More <i class="fa fa-angle-double-right"></i></a></div><hr class="article-separator" /><h1 class="article-title"><a href="/2018/12/30/linux-interface-06/">linux-interface-06</a></h1><div class="posted-date-wrapper"><i class="fa fa-clock-o"></i><span class="posted-date">December 30, 2018</span></div><div class="tag-labels"><a href="/tags/linux/"><small class="tag-label">linux</small></a><a href="/tags/books/"><small class="tag-label">books</small></a></div><hr class="article-header-separator" /><h2 id="the-linux-programming-interface">The linux programming interface</h2>
<h2 id="进程">进程</h2>
<p><strong>进程 是可执行程序的实例</strong></p>
<ol>
  <li>进程号 和 父进程号： 每个进程都有一个PID， 唯一标识 某个进程，除了少数(init PID 为1) 之外，多数程序与运行该程序的进程PID没有固定关系。 linux内核限制 进程号小于 32767,当进程号达到这个限制时候，内核将重置进程号计数器，重新从最小的整数开始分配。（进程号计数器会重置为 300， 因为 低于此数值的进程号 为系统进程和守护进程 长期占用， 关于最大进程号 默...</li>
</ol><div class="read-more"><a href="/2018/12/30/linux-interface-06/">Read More <i class="fa fa-angle-double-right"></i></a></div><hr class="article-separator" /><h1 class="article-title"><a href="/2018/12/06/linux-interface-02/">linux-interface-02</a></h1><div class="posted-date-wrapper"><i class="fa fa-clock-o"></i><span class="posted-date">December 06, 2018</span></div><div class="tag-labels"><a href="/tags/linux/"><small class="tag-label">linux</small></a><a href="/tags/books/"><small class="tag-label">books</small></a></div><hr class="article-header-separator" /><h2 id="the-linux-programming-interface">The linux programming interface</h2>

<h2 id="系统编程概念">系统编程概念</h2>

<p>无论何时，执行了系统调用或者库函数，检查调用的返回状态以确定调用是否成功,是一条编程铁律。(消灭nil就好了)</p>

<h3 id="系统调用">系统调用</h3>
<blockquote>
  <p>借助这一机制，进程可以请求内核以自己的名义去执行动作，以API 的形式，内核提供一系列服务供程序访问。（创建进程， IIO操作等）可以参考 csapp中的 异常控制流章节。</p>
</blockquote>

<p>系统调用有以下特征：</p>
<ol>
  <li>系统调用将CPU 从用户态切换到 内核态，以便CPU访问受保护的内存等（越过...</li>
</ol><div class="read-more"><a href="/2018/12/06/linux-interface-02/">Read More <i class="fa fa-angle-double-right"></i></a></div><hr class="article-separator" /><h1 class="article-title"><a href="/2018/11/11/linux-interface/">linux-interface</a></h1><div class="posted-date-wrapper"><i class="fa fa-clock-o"></i><span class="posted-date">November 11, 2018</span></div><div class="tag-labels"><a href="/tags/linux/"><small class="tag-label">linux</small></a><a href="/tags/books/"><small class="tag-label">books</small></a></div><hr class="article-header-separator" /><h2 id="the-linux-programming-interface">The linux programming interface</h2>

<h2 id="基本概念">基本概念</h2>

<h3 id="内核">内核</h3>
<ol>
  <li>通常的定义，1）完整的软件包， 这包括用来管理计算机资源的核心软件 以及附带的标准软件工具（shell，图形用户界面， 文件工具）2) 狭义的层面，是指管理和分配计算机资源的核心软件</li>
  <li>职责: 1）进程调度， 2）内存管理， 3）文件系统， 4）创建和终止进程， 5）设备管理， 6）联网， 7）提供系统调用的编程接口</li>
  <li>内核态、用户态: 区分态的原因： 1）只有cpu处于内核态的时候，才能执行某些...</li>
</ol><div class="read-more"><a href="/2018/11/11/linux-interface/">Read More <i class="fa fa-angle-double-right"></i></a></div><hr class="article-separator" /><h1 class="article-title"><a href="/2018/09/16/redis-rb/">redis-rb</a></h1><div class="posted-date-wrapper"><i class="fa fa-clock-o"></i><span class="posted-date">September 16, 2018</span></div><div class="tag-labels"><a href="/tags/redis/"><small class="tag-label">redis</small></a><a href="/tags/ruby/"><small class="tag-label">ruby</small></a></div><hr class="article-header-separator" /><h2 id="redis-rb-为ruby-连接redis的客户端">redis-rb 为ruby 连接redis的客户端</h2>

<h4 id="项目结构">项目结构</h4>
<ol>
  <li>项目本身依赖于 hiredis，而hiredis 本身是一个redis client c的包装。并没有搞懂为什么需要依赖redis client</li>
  <li>项目目录结构如下</li>
</ol>

<div class="highlight"><pre class="highlight plaintext"><code>  /lib
    |---- redis.rb
    |---- /Redis
          |---- connection.rb
          |---- errors.rb
          |---- pipeline.rb...</code></pre></div><div class="read-more"><a href="/2018/09/16/redis-rb/">Read More <i class="fa fa-angle-double-right"></i></a></div><hr class="article-separator" /><h1 class="article-title"><a href="/2018/03/20/sicp/">计算机程序的构造和解释</a></h1><div class="posted-date-wrapper"><i class="fa fa-clock-o"></i><span class="posted-date">March 20, 2018</span></div><div class="tag-labels"><a href="/tags/sicp/"><small class="tag-label">SICP</small></a></div><hr class="article-header-separator" /><p>计算机程序的构造和解释<br>
    ———</p>

<div class="highlight"><pre class="highlight plaintext"><code>序
---------
</code></pre></div>
<blockquote>
  <p>关注程序的创建、执行和研究。使用Lisp方言书写<br>
本书中讨论的各种问题主要涉及到： 人的大脑，计算机程序的集合，以及计算机本身。每一个计算机程序都是现实中的或者精神中的某个过程的一个模型。通过人的头脑孵化出来，这种过程出现在人们的经验或者思维中。很少能够通过程序将这种过程模拟到永远令人满意的程度。 因为这个原因，程序也在不断的演化。当我们对模型的认识更深入、更扩大，更广泛时，我们就会修改程序。直到达到一中亚稳定状态。...</p>
</blockquote><div class="read-more"><a href="/2018/03/20/sicp/">Read More <i class="fa fa-angle-double-right"></i></a></div><hr class="article-separator" /><div class="paginate-wrapper"><div class="previous-page"><a href="/"><i class="fa fa-arrow-left"></i> Previous Page</a></div><div class="next-page"><a href="/page/3/"><i class="fa fa-arrow-right"></i> Next Page</a></div></div><div class="page-number">Page 2 of 7</div></article></main><footer><div class="footer-wrapper"><div class="author"><div class="image-wrapper"><a href="/author/"><img alt="author" src="../../images/profile-1e71686a.png" /></a></div></div><div class="image-content"><img src="../../images/wechat_nasa-0d87c0dd.png" /></div><div class="copyright"><i class="fa fa-copyright"></i> 2019 <a href="/">日常学习</a> - geniousbar</div></div><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?b43ef53b285c49e1af0bd7080994c825";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script></footer></body></html>