<!DOCTYPE html><html><head><meta charset="utf-8" /><meta content="IE=edge;chrome=1" http-equiv="X-UA-Compatible" /><meta content="initial-scale=1.0, user-scalable=no" name="viewport" /><title>java shell docker | 日常学习</title><meta description="A Little Book on Java 的总结 Basic     编译 与 运行 编译: javac First.java 产生一个 First.class 文件 运行：java First 将运行 编译之后 First.class            java  编译器 将 源代码 中的每个 class 转变为 对应的 class file 并存储 其 字节码       有 main 函数的 class才能够运行，一个项目中存在多个class 有 main 函数 是为了 将 项...   " /><link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/feed.xml" /><link href="../../../../stylesheets/style-198d4031.css" rel="stylesheet" type="text/css" /><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" /><link href="../../../../images/favicon-6c3f3d04.png" rel="icon" type="image/png" /><script src="../../../../javascripts/all-b3988275.js"></script></head><body><header><div class="top-menu"><div class="top-menu-wrapper"><div class="top-menu-list"><ul><li><a href="/">Home</a></li><li><a href="/archives/">Archives</a></li><li><a href="/tags/">Tags</a></li><li><a href="/by-year/">By Year</a></li><li id="wechat"><a href="#" onclick="toggleShowWechat()">Wechat</a></li></ul></div></div></div><div id="header-wechat-img"><img src="../../../../images/wechat_nasa-0d87c0dd.png" /></div><h1 class="logo"><a href="/" title="日常学习"><span class="logo-text">日常学习</span></a></h1></header><main><article><h1 class="article-title">java shell docker</h1><div class="posted-date-wrapper"><i class="fa fa-clock-o"></i><span class="posted-date">September 15, 2020</span></div><div class="tag-labels"><a href="/tags/week/"><small class="tag-label">week</small></a></div><hr class="article-header-separator" /><h2 id="a-little-book-on-java-的总结">A Little Book on Java 的总结</h2>
<h4 id="basic">Basic</h4>

<ol>
  <li>编译 与 运行<br />
编译: javac First.java 产生一个 First.class 文件<br />
运行：java First 将运行 编译之后 First.class
    <ul>
      <li>java  编译器 将 源代码 中的每个 class 转变为 对应的 class file 并存储 其 字节码</li>
      <li>有 main 函数的 class才能够运行，一个项目中存在多个class 有 main 函数 是为了 将 项目分为不同的 可以运行的单元 方便测试</li>
    </ul>
  </li>
  <li>基本类型
    <ul>
      <li>Number, float, double, int</li>
      <li>Character: char a = ’a’;</li>
      <li>Boolean: boolean true and false</li>
      <li>Strings: String title = “A Little Book on Java”;</li>
      <li>Array: datatype[] ArrayName = new datatype[ArraySize]; 当 使用 index 超过 数组边界 时 会发生 ArrayIndexOutOfBoundsException 错误</li>
    </ul>
  </li>
  <li>流程控制语句
    <ul>
      <li>while loop</li>
    </ul>
  </li>
</ol>

<div class="highlight"><pre class="highlight java"><code>  <span class="k">while</span> <span class="o">&lt;</span><span class="kt">boolean</span><span class="o">-</span><span class="n">expression</span><span class="o">&gt;</span>
    <span class="n">statement</span>
</code></pre></div>
<ul>
  <li>
    <p>for loop</p>

<div class="highlight"><pre class="highlight java"><code><span class="k">for</span> <span class="o">(</span><span class="n">initial</span><span class="o">-</span><span class="n">expression</span><span class="o">,</span> <span class="kt">boolean</span><span class="o">-</span><span class="n">expression</span><span class="o">,</span> <span class="n">increment</span><span class="o">-</span><span class="n">expression</span><span class="o">)</span> <span class="n">st</span>  <span class="n">atement</span>
</code></pre></div>  </li>
  <li>
    <p>if</p>

<div class="highlight"><pre class="highlight java"><code><span class="k">if</span> <span class="o">(</span><span class="kt">boolean</span><span class="o">-</span><span class="n">expression</span><span class="o">)</span>
  <span class="n">statement</span>
<span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="kt">boolean</span><span class="o">-</span><span class="n">expression</span><span class="o">)</span> 
  <span class="n">statement</span>
<span class="k">else</span>
  <span class="n">statement</span>
</code></pre></div>  </li>
  <li>
    <p>break;</p>
  </li>
</ul>

<ol>
  <li>抽象机制</li>
  <li>Procedures
    <ul>
      <li>its name,</li>
      <li>what kinds of parameters it expects (if any),</li>
      <li>what kind of result it might return.</li>
    </ul>
  </li>
  <li>class
    <ul>
      <li>Syntax of Class Declarations</li>
    </ul>
  </li>
</ol>

<div class="highlight"><pre class="highlight java"><code>  <span class="kd">class</span> <span class="nc">Hello</span><span class="o">{</span>
  <span class="o">}</span>
</code></pre></div><ul>
  <li>main method; java foo a b c, params as args array</li>
</ul>

<div class="highlight"><pre class="highlight java"><code>  <span class="kd">class</span> <span class="nc">Foo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="n">args</span><span class="o">[]){</span>
        <span class="cm">/* Body of main */</span>
    <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div><ul>
  <li>static variable &amp; function and usage</li>
</ul>

<div class="highlight"><pre class="highlight java"><code>  <span class="kd">class</span> <span class="nc">Foo</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">showFoo</span><span class="o">(){</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="n">classname</span><span class="o">.</span><span class="na">methodname</span><span class="o">(</span><span class="n">parameters</span><span class="o">);</span> <span class="c1">// static method usage</span>
  <span class="n">classname</span><span class="o">.</span><span class="na">variablename</span><span class="o">;</span>           <span class="c1">// static variable usage</span>
</code></pre></div><ul>
  <li>Visibility Issues （可见控制）: Public data and code is visible to all classes, while private data and code is visible only inside the class that contains it.</li>
</ul>

<ol>
  <li>The Object Concept</li>
</ol>

<ul>
  <li>The State of an Object (Instance variables)</li>
</ul>

<div class="highlight"><pre class="highlight java"><code>  <span class="kd">class</span> <span class="nc">PointIn3D</span><span class="o">{</span>
    <span class="c1">//Instance Variables</span>
    <span class="kd">private</span> <span class="kt">double</span> <span class="n">x</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">double</span> <span class="n">y</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">double</span> <span class="n">z</span><span class="o">;</span>
  <span class="o">}</span>
</code></pre></div><ul>
  <li>Constructors</li>
</ul>

<div class="highlight"><pre class="highlight java"><code>  <span class="kd">class</span> <span class="nc">PointIn3D</span><span class="o">{</span>
    <span class="kd">private</span> <span class="kt">double</span> <span class="n">x</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">double</span> <span class="n">y</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">double</span> <span class="n">z</span><span class="o">;</span>

     <span class="c1">//Constructors</span>
    <span class="c1">//This constructor does not take parameters</span>
    <span class="kd">public</span> <span class="nf">PointIn3D</span><span class="o">(){</span>
      <span class="cm">/* Initializing the fields of this object to the origin,
         a default point */</span>
      <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
      <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
      <span class="n">z</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//This constructor takes parameters</span>
    <span class="kd">public</span> <span class="nf">PointIn3D</span><span class="o">(</span><span class="kt">double</span> <span class="no">X</span><span class="o">,</span> <span class="kt">double</span> <span class="no">Y</span><span class="o">,</span> <span class="kt">double</span> <span class="no">Z</span><span class="o">){</span>
      <span class="cm">/* Initializing fields of this object to values specified by
         the parameters */</span>
      <span class="n">x</span> <span class="o">=</span> <span class="no">X</span><span class="o">;</span>
      <span class="n">y</span> <span class="o">=</span> <span class="no">Y</span><span class="o">;</span>
      <span class="n">z</span> <span class="o">=</span> <span class="no">Z</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div><ul>
  <li>Creating an Object</li>
</ul>

<div class="highlight"><pre class="highlight java"><code>  <span class="c1">//Creates a PointIn3D object with coordinates (0, 0, 0)</span>
  <span class="k">new</span> <span class="nf">PointIn3D</span><span class="o">();</span>
  <span class="c1">//Creates a PointIn3D object with coordinates (10.2, 78, 1) new PointIn3D(10.2, 78, 1);</span>
</code></pre></div><ul>
  <li>Object References</li>
</ul>

<div class="highlight"><pre class="highlight java"><code>   <span class="nc">ReferenceType</span> <span class="nc">ReferenceName</span><span class="o">;</span>

   <span class="nc">PointIn3D</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PointIn3D</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
</code></pre></div><ul>
  <li>Accessing the Fields of an Object</li>
</ul>

<div class="highlight"><pre class="highlight java"><code>   <span class="nc">ReferenceName</span><span class="o">.</span><span class="na">FieldName</span><span class="o">;</span>
</code></pre></div><ul>
  <li>The Behavior of an Object
<div class="highlight"><pre class="highlight java"><code>    <span class="nc">ObjectReference</span><span class="o">.</span><span class="na">InstanceMethodName</span><span class="o">(</span><span class="nc">Parameter</span><span class="o">-</span><span class="nc">List</span><span class="o">)</span>
</code></pre></div></li>
  <li>The this reference: Inside an instance method, this is a reference to the object on which the instance method is invoked. Inside a constructor, this refers to the object that the constructor just created.</li>
</ul>

<div class="highlight"><pre class="highlight java"><code>
  <span class="kd">public</span> <span class="nf">PointIn3D</span><span class="o">(){</span>
    <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">z</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="kd">public</span> <span class="kt">double</span> <span class="nf">getX</span><span class="o">(){</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">x</span><span class="o">;</span>
  <span class="o">}</span>

</code></pre></div>
<ul>
  <li>Inheritance: extends, super can use in subtype to call supertype methods</li>
</ul>

<ol>
  <li>Rules for Method Lookup and Type Checking.
    <ul>
      <li>First the rules. Remember that there are two phases: compile time, which is when type checking is done and run time, which is when method lookup happens. Compile time is before run time.</li>
      <li>The type checker has to say that a method call is OK at compile time.</li>
      <li>All type checking is done based on what the declared type of a reference to an object is.</li>
      <li>Subtyping is an integral part of type checking. This means if B is a subtype of A and there is a context that gets a B where A was expected there will not be a type error.</li>
      <li>Method lookup is based on actual type of the object and not the declared type of the reference.</li>
      <li>When there is overloading (as opposed to overriding) this is resolved by type-checking.</li>
    </ul>
  </li>
</ol>

<div class="highlight"><pre class="highlight java"><code>  <span class="kd">class</span> <span class="nc">myInt</span> <span class="o">{</span>
      <span class="kd">private</span> <span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
      <span class="kd">public</span> <span class="nf">myInt</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
          <span class="k">this</span><span class="o">.</span><span class="na">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
      <span class="o">}</span>
      <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getval</span><span class="o">(){</span>
          <span class="k">return</span> <span class="n">n</span><span class="o">;</span>
      <span class="o">}</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">increment</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
          <span class="k">this</span><span class="o">.</span><span class="na">n</span> <span class="o">+=</span> <span class="n">n</span><span class="o">;</span>
      <span class="o">}</span>
      <span class="kd">public</span> <span class="n">myInt</span> <span class="nf">add</span><span class="o">(</span><span class="n">myInt</span> <span class="no">N</span><span class="o">){</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nf">myInt</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">n</span> <span class="o">+</span> <span class="no">N</span><span class="o">.</span><span class="na">getval</span><span class="o">());</span>
      <span class="o">}</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">show</span><span class="o">(){</span>
          <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
      <span class="o">}</span>
  <span class="o">}</span>

  <span class="kd">class</span> <span class="nc">gaussInt</span> <span class="kd">extends</span> <span class="n">myInt</span> <span class="o">{</span>
      <span class="kd">private</span> <span class="kt">int</span> <span class="n">m</span><span class="o">;</span>  <span class="c1">//represents the imaginary part</span>
      <span class="kd">public</span> <span class="nf">gaussInt</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">){</span>
          <span class="kd">super</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
          <span class="k">this</span><span class="o">.</span><span class="na">m</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
      <span class="o">}</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">show</span><span class="o">(){</span>
          <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"realpart is: "</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">getval</span><span class="o">()</span> <span class="o">+</span><span class="s">" imagpart is: "</span> <span class="o">+</span> <span class="n">m</span><span class="o">);</span>
      <span class="o">}</span>
      <span class="kd">public</span> <span class="kt">int</span> <span class="nf">realpart</span><span class="o">()</span> <span class="o">{</span>
          <span class="k">return</span> <span class="nf">getval</span><span class="o">()</span>
              <span class="o">;}</span>
      <span class="kd">public</span> <span class="kt">int</span> <span class="nf">imagpart</span><span class="o">()</span> <span class="o">{</span>
          <span class="k">return</span> <span class="n">m</span><span class="o">;</span>
      <span class="o">}</span>
      <span class="kd">public</span> <span class="n">gaussInt</span> <span class="nf">add</span><span class="o">(</span><span class="n">gaussInt</span> <span class="n">z</span><span class="o">){</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nf">gaussInt</span><span class="o">(</span><span class="n">z</span><span class="o">.</span><span class="na">realpart</span><span class="o">()</span> <span class="o">+</span> <span class="n">realpart</span><span class="o">(),</span>
                              <span class="n">z</span><span class="o">.</span><span class="na">imagpart</span><span class="o">()</span> <span class="o">+</span> <span class="n">imagpart</span><span class="o">());</span>
      <span class="o">}</span>
      <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
          <span class="n">gaussInt</span> <span class="n">kreimhilde</span> <span class="o">=</span> <span class="k">new</span> <span class="n">gaussInt</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">);</span>
          <span class="n">kreimhilde</span><span class="o">.</span><span class="na">show</span><span class="o">();</span>
          <span class="n">kreimhilde</span><span class="o">.</span><span class="na">increment</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
          <span class="n">kreimhilde</span><span class="o">.</span><span class="na">show</span><span class="o">();</span>
          <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Now we watch the subtleties of overloading."</span><span class="o">);</span>
          <span class="n">myInt</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">myInt</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
          <span class="n">gaussInt</span> <span class="n">z</span> <span class="o">=</span> <span class="k">new</span> <span class="n">gaussInt</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">);</span>
          <span class="n">gaussInt</span> <span class="n">w</span><span class="o">;</span>
          <span class="n">myInt</span> <span class="n">b</span> <span class="o">=</span> <span class="n">z</span><span class="o">;</span>
          <span class="n">myInt</span> <span class="n">d</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">b</span><span class="o">);</span> <span class="c1">//this does type System.out.print("the value of d is:</span>

          <span class="c1">// 这里面并没有错误， add 方法为 重载，而非重写，因为 方法签名不同。 同样会通过type check</span>
          <span class="c1">// w = z.add(b);</span>
          <span class="c1">// w = b.add(z);</span>
          <span class="n">w</span> <span class="o">=</span> <span class="o">(</span> <span class="o">(</span><span class="n">gaussInt</span><span class="o">)</span> <span class="n">b</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="n">z</span><span class="o">);</span><span class="c1">//this does type check System.out.print("the value of w is: ");</span>
          <span class="n">w</span><span class="o">.</span><span class="na">show</span><span class="o">();</span>
          <span class="n">myInt</span> <span class="n">c</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">a</span><span class="o">);</span> <span class="c1">//will this typecheck? System.out.print("the value of c is: ");</span>
          <span class="n">c</span><span class="o">.</span><span class="na">show</span><span class="o">();</span>
      <span class="o">}</span>
  <span class="o">}</span>

</code></pre></div><ol>
  <li>The Exception Object
    <ul>
      <li>分为两类： unchecked exceptions and checked exceptions.</li>
      <li>所有的exception 都发生在 runtime， 因为不是的话，要啥编译检查？</li>
      <li>Unchecked exceptions 与  checked exception 的区别主要在于： Unchecked exceptions happen because of the programmer’s carelessness，也就是说  unchecked exception 是可以预防的，可以避免的。两个主要的 unchecked exception 主要有： rrayIndexOutofBoundsException and NullPointerException</li>
      <li>所有其他的非 unchecked exception 则是：checked exceptions， 两个主要的exception 有 FileNotFoundException and IOException.</li>
    </ul>
  </li>
  <li>创建 新的 exception
    <ul>
      <li>新创建的 exception 应该继承 exception 或者 任何 除 RunTimeException 之外的 子类。 因为 新创建的 exception  为 checked exception</li>
      <li>An exception is thrown to indicate the occurrence of a runtime error. Only checked exceptions should be thrown, as all unchecked exceptions should be eliminated. 意思是： 只有 checked exceptions 需要throw 声明， unchecked exception 因为无法预测，只能 尽量消除掉。（If a method’s header does not contain a throws clause, then the method throws no checked exceptions.）</li>
    </ul>
  </li>
  <li>Throwing an Exception
<div class="highlight"><pre class="highlight java"><code>  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span>
                                          <span class="nc">FileNotFoundException</span>
</code></pre></div>    <ul>
      <li>A method’s header advertises the checked exceptions that may occur when the method executes</li>
      <li>An exception can occur in two ways: explicitly through the use of a throw statement or implicitly by calling a method that can throw an exception 意思是：异常产生有两种方式：1. 直接抛出异常 2. 调用 能够抛出异常的函数</li>
    </ul>
  </li>
  <li>Catching an Exception: catch 异常的方式同其他 语言一致， 即是 不断的递归的 解开栈，以找到合适的 catch。如果无法找到适合的 catch 则  使用默认的 default exception handler 来捕获异常，所以default exception handler 是在哪一层？main 层面吗？
<div class="highlight"><pre class="highlight java"><code>  <span class="k">try</span><span class="o">{</span>
     <span class="n">code</span> <span class="n">that</span> <span class="n">could</span> <span class="n">cause</span> <span class="n">exceptions</span>
  <span class="o">}</span>
  <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e1</span><span class="o">){</span>
     <span class="n">code</span> <span class="n">that</span> <span class="n">does</span> <span class="n">something</span> <span class="n">about</span> <span class="n">exception</span> <span class="n">e1</span>
  <span class="o">}</span>
  <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e2</span><span class="o">){</span>
     <span class="n">code</span> <span class="n">that</span> <span class="n">does</span> <span class="n">something</span> <span class="n">about</span> <span class="n">exception</span> <span class="n">e2</span>
  <span class="o">}</span>
</code></pre></div></li>
</ol>

<h2 id="a-little-book-on-shell">A Little Book on Shell</h2>
<h3 id="常用-command">常用 command</h3>
<ol>
  <li>file cp mv mkdir rm ln <br />
  其中ln  命令 ln file link, 默认 创建 hard link， ln -s file link 才 为 soft link， soft link 同样增加 file 的link count</li>
  <li>Working with Commands (type which  help man apropos info whatis alias)</li>
</ol>

<div class="highlight"><pre class="highlight plaintext"><code>| command | meaning                                           |
|---------|---------------------------------------------------|
| type    | Indicate how a command name is interpreted        |
| which   | Display which executable program will be executed |
| help    | Get help for shell builtins                       |
| man     | Display a command's manual page                   |
| apropos | Display a list of appropriate commands            |
| info    | Display a command's info entry                    |
| whatis  | Display one-line manual page descriptions         |
| alias   | Create an alias for a command                     |
</code></pre></div>
<ol>
  <li>
    <p>commands 的来源： <br />
    * An executable program: 例如 /usr/bin 下面的 可执行文件，<br />
    * A command built into the shell itself.： bash 支持的内建 的 命令<br />
    * A shell function： shell 函数 Shell functions are miniature shell scripts incorporated into the environment<br />
    * An alias： Aliases are commands that we can define ourselves, built from other commands.</p>
  </li>
  <li>
    <p>man 详细内容： Display a Program’s Manual Page。 手册内容 被分为 几个 章节， 出了 使用 man command, 之外 可以使用 man 1 command 来显示 User commands 章节</p>
  </li>
</ol>

<div class="highlight"><pre class="highlight plaintext"><code>| section | contents                                       |
|---------|------------------------------------------------|
| 1       | User commands                                  |
| 2       | Programming interfaces for kernel system calls |
| 3       | Programming interfaces to the C library        |
| 4       | Special files such as device nodes and drivers |
| 5       | File formats                                   |
| 6       | Games and amusements such as screen savers     |
| 7       | Miscellaneous                                  |
| 8       | System administration commands                                               |
</code></pre></div>
<ol>
  <li>apropos – Display Appropriate Commands 展示相关的 命令。通过  apropos ls 可以获得 lscpu, lshw, 等一系列 命令</li>
  <li>whatis – Display One-line Manual Page Descriptions:  展示一行关于 command的简单描述</li>
  <li>info 另一种展现形式的 man</li>
  <li>alias: alias name=’string’ 来构建 名为 name 的command line， type name 可以获得 name 对应的 具体string 内容</li>
</ol>

<h3 id="redirection">Redirection</h3>
<ol>
  <li>cat sort uniq grep wc head tail tee(Read from standard input and write to standard output and files)</li>
  <li>command line  数据流 有： 标准输入 标准输出 标准错误输出，即： stdin, stdout, stderr, 0, 1, 2</li>
  <li>重定向 stdout， 使用 &gt; 来将 输出 重定向到 file 中，file中内容将被覆盖。  »  将 数据重定向 到file中，不覆盖 追加到 file 末尾中</li>
  <li>重定向 stderr, 类似 重定向 stdout 使用 2&gt;, 2» 进行 标准错误输出 的数据重定向</li>
  <li>将stdout &amp; stderr 重定向 到一个 file 中：
    <ul>
      <li>ls -l /bin/usr &gt; ls-output.txt 2&gt;&amp;1 ， 注意 其中的 2&gt;&amp;1 的写法，以及， &gt; 与 2&gt;&amp;1 的顺序， 其中原因，为shell 语法需要 控制 两次重定向 打开的是同一个文件</li>
      <li>ls -l /bin/usr &amp;&gt; ls-output.txt 也可以这样 &amp;&gt; 代表 stdout stderr， ls -l /bin/usr &amp;» ls-output.txt 则代表 将stdout stderr 数据流 追加到 文件中</li>
    </ul>
  </li>
  <li>Disposing of Unwanted Output:  ls -l /bin/usr 2&gt; /dev/null 将 数据流 重定向 到 /dev/null 则可以起到忽略 数据流的作用</li>
  <li>重定向 stdin, 使用 &lt; 来重定向 stdin 从 键盘 到 file 上， 但是并不是特别有用（很少用到）</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>Pipelines： 使用 pipe operator</td>
          <td>将 一个command 的标准输出  输送 到 一个command 的标准输入中。 command1</td>
          <td>command2</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>Pipelines 与 重定向的 区别： 重定向只能 定向到 file， 而 pipelines 则可以 重定向到  一个command</li>
</ol>

<h3 id="seeing-the-world-as-the-shell-sees-it">Seeing the World as the Shell Sees It</h3>
<ol>
  <li>扩展 Expansion: how a simple character sequence, for example *, can have a lot of meaning to the shell. The process that makes this happen is called expansion. With expansion, we enter some- thing and it is expanded into something else before the shell acts upon it. 也就是 说 在 传递 参数给 command， command 接收参数处理前，会被 进行处理，该处理过程 即是： expansion。</li>
  <li>echo 是如何 显式化  看到 expansion 结果的 重要方式</li>
  <li>Pathname Expansion （路径扩展）： 如下释义：</li>
</ol>

<div class="highlight"><pre class="highlight shell"><code>  <span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">ls
  </span>Desktop ls-output.txt Pictures Templates Documents Music Public Videos

  <span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">echo </span>D<span class="k">*</span>
  Desktop Documents

  <span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">echo</span> <span class="k">*</span>s
  Documents Pictures Templates Videos

  <span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">echo</span> <span class="o">[[</span>:upper:]]<span class="k">*</span>
  Desktop Documents Music Pictures Public Templates Videos

  <span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">echo</span> /usr/<span class="k">*</span>/share
  /usr/kerberos/share /usr/local/share

</code></pre></div><ol>
  <li>Arithmetic Expansion: $((expression)), expression 是 算术表达式， 操作数 只能是整数， 操作符 有 +, -, *, /, %, **</li>
</ol>

<div class="highlight"><pre class="highlight shell"><code>  <span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">echo</span> <span class="k">$(($((</span><span class="m">5</span><span class="o">**</span><span class="m">2</span><span class="k">))</span> <span class="o">*</span> <span class="m">3</span><span class="k">))</span>
</code></pre></div>
<ol>
  <li>Brace Expansion:</li>
</ol>

<div class="highlight"><pre class="highlight shell"><code>  <span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">echo </span>Front-<span class="o">{</span>A,B,C<span class="o">}</span><span class="nt">-Back</span>
  Front-A-Back Front-B-Back Front-C-Back

  <span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">echo </span>Number_<span class="o">{</span>1..5<span class="o">}</span>
  Number_1 Number_2 Number_3 Number_4 Number_5

  <span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">echo</span> <span class="o">{</span>01..15<span class="o">}</span>
  01 02 03 04 05 06 07 08 09 10 11 12 13 14 15

  <span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">echo</span> <span class="o">{</span>001..15<span class="o">}</span>
  001 002 003 004 005 006 007 008 009 010 011 012 013 014 015

  <span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">echo</span> <span class="o">{</span>Z..A<span class="o">}</span>
  Z Y X W V U T S R Q P ON M L K J I H G F E D C B A


  <span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">mkdir </span>Photos
  <span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">cd </span>Photos
  <span class="o">[</span>me@linuxbox Photos]<span class="nv">$ </span><span class="nb">mkdir</span> <span class="o">{</span>2007..2009<span class="o">}</span>-<span class="o">{</span>01..12<span class="o">}</span> 
  <span class="o">[</span>me@linuxbox Photos]<span class="nv">$ </span><span class="nb">ls
  </span>2007-01 2007-07 2008-01 2008-07 2009-01 2009-07 2007-02 2007-08 2008-02 2008-08 2009-02 2009-08 2007-03 2007-09 2008-03 2008-09 2009-03 2009-09 2007-04 2007-10 2008-04 2008-10 2009-04 2009-10 2007-05 2007-11 2008-05 2008-11 2009-05 2009-11 2007-06 2007-12 2008-06 2008-12 2009-06 2009-12
</code></pre></div>
<ol>
  <li>Parameter Expansion</li>
</ol>

<div class="highlight"><pre class="highlight shell"><code>  <span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$USER</span> 
  me
</code></pre></div><ol>
  <li>Command Substitution: 子命令， 允许在表达式中 执行子命令 并展开. $(command sub)</li>
</ol>

<div class="highlight"><pre class="highlight shell"><code>  <span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">echo</span> <span class="si">$(</span><span class="nb">ls</span><span class="si">)</span>
  Desktop Documents ls-output.txt Music Pictures Public Templates Videos
</code></pre></div>
<ol>
  <li>Quoting: 可以用来控制 是否进行 扩展 展开。
    <ul>
      <li>下面两个示例：</li>
    </ul>
  </li>
</ol>

<div class="highlight"><pre class="highlight shell"><code>  <span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">echo </span>this is a    <span class="nb">test
  </span>this is a <span class="nb">test</span>

  <span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">echo </span>The total is <span class="nv">$100</span>.00
  The total is 00.00
</code></pre></div><p>注意 这两个 的存在的问题： 1. 第一个中 shell 将 params 中多余的空格 去掉了， 即是： ‘a    test’中多余的空格， 因为 shell 将 通过 空格 分隔 参数，认为 a test  为两个参数。 2. $100.00 展开为了 00.00 是因为 $1 不存在的缘故</p>

<ul>
  <li>Double Quotes： 将参数 加上 “” 之后， ““内的内容 将被视为 一个 参数， 但  parameter expansion, arithmetic expansion, and command substitution 依然 有效。<br />
  如下示例:</li>
</ul>

<div class="highlight"><pre class="highlight shell"><code>  <span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-l</span> two words.txt
  <span class="nb">ls</span>: cannot access two: No such file or directory
  <span class="nb">ls</span>: cannot access words.txt: No such file or directory

  <span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-l</span> <span class="s2">"two words.txt"</span>
  <span class="nt">-rw-rw-r--</span> 1 me me 18 2016-02-20 13:03 two words.txt <span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">mv</span> <span class="s2">"two words.txt"</span> two_words.txt
</code></pre></div>
<div class="highlight"><pre class="highlight shell"><code>  <span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">echo </span>this is a    <span class="nb">test
  </span>this is a <span class="nb">test</span>

  <span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"this is a   test"</span>
  this is a   <span class="nb">test</span>




  <span class="o">(</span>calvagrant@precise64:~<span class="nv">$ </span><span class="nb">echo</span> <span class="si">$(</span>cal<span class="si">)</span>
  September 2020 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30

  vagrant@precise64:~<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"</span><span class="si">$(</span>cal<span class="si">)</span><span class="s2">"</span>
     September 2020
  Su Mo Tu We Th Fr Sa
         1  2  3  4  5
   6  7  8  9 10 11 12
  13 14 15 16 17 18 19
  20 21 22 23 24 25 26
  27 28 29 30

</code></pre></div><ul>
  <li>Single Quotes： 单引号 中的内容 扩展 全部 失效。</li>
  <li>Escaping Characters： \</li>
</ul>

<table>
  <thead>
    <tr>
      <th>escape sequence</th>
      <th>meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>\a</td>
      <td>Bell</td>
    </tr>
    <tr>
      <td>\b</td>
      <td>Backspace</td>
    </tr>
    <tr>
      <td>\n</td>
      <td>Newline</td>
    </tr>
    <tr>
      <td>\r</td>
      <td>Carriage return</td>
    </tr>
    <tr>
      <td>\t</td>
      <td>Tab</td>
    </tr>
  </tbody>
</table>

<ol>
  <li>Signals: Signals are one of several ways that the operating system communicates with programs
    <ul>
      <li>kill: The kill command doesn’t exactly “kill” processes: rather it sends them signals <br />
kill [-signal] PID…</li>
    </ul>
  </li>
</ol>

<table>
  <thead>
    <tr>
      <th>keyboard</th>
      <th>signal</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Ctrl-c</td>
      <td>INT</td>
    </tr>
    <tr>
      <td>Ctrl-z</td>
      <td>TSTP</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th>Number</th>
      <th>Name</th>
      <th>Meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>HUP</td>
      <td>Hangup. This is a vestige of the good old days when terminals were attached to remote computers with phone lines and modems. The signal is used to indicate to programs that the controlling terminal has “hung up.” The effect of this signal can be demonstrated by closing a terminal session. The foreground program running on the terminal will be sent the signal and will terminate.</td>
    </tr>
    <tr>
      <td>2</td>
      <td>INT</td>
      <td>Interrupt. This performs the same function as a Ctrl-c sent from the terminal. It will usually terminate a program.</td>
    </tr>
    <tr>
      <td>9</td>
      <td>KILL</td>
      <td>Kill. This signal is special. Whereas programs may choose to handle signals sent to them in different ways, including ignoring them all together, the KILL signal is never actually sent to the target program. Rather, the kernel immediately terminates the process. When a process is terminated in this manner, it is given no opportunity to “clean up” after itself or save its work. For this reason, the KILL signal should be used only as a last resort when other termination signals fail.</td>
    </tr>
    <tr>
      <td>15</td>
      <td>TERM</td>
      <td>Terminate. This is the default signal sent by the kill command. If a program is still “alive” enough to receive signals, it will terminate.</td>
    </tr>
    <tr>
      <td>18</td>
      <td>CONT</td>
      <td>Continue. This will restore a process after a STOP or TSTP signal. This signal is sent by the bg and fg commands.</td>
    </tr>
    <tr>
      <td>19</td>
      <td>STOP</td>
      <td>Stop. This signal causes a process to pause without terminating. Like the KILL signal, it is not sent to the target process, and thus it cannot be ignored.</td>
    </tr>
    <tr>
      <td>20</td>
      <td>TSTP</td>
      <td>Terminal stop. This is the signal sent by the terminal when Ctrl-z is pressed. Unlike the STOP signal, the TSTP signal is received by the program, but the program may choose to ignore it.</td>
    </tr>
    <tr>
      <td>3</td>
      <td>QUIT</td>
      <td>Quit</td>
    </tr>
    <tr>
      <td>11</td>
      <td>SEGV</td>
      <td>Segmentation violation. This signal is sent if a program makes illegal use of memory, that is, if it tried to write somewhere it was not allowed to write.</td>
    </tr>
    <tr>
      <td>28</td>
      <td>WINCH</td>
      <td>Window change. This is the signal sent by the system when a window changes size. Some programs , such as top and less will respond to this signal by redrawing themselves to fit the new window dimensions.</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>example, kill -number | -Name 也即是说 kill 可以接受 number 或者 显示的名称
<div class="highlight"><pre class="highlight shell"><code><span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">kill</span> <span class="nt">-1</span> 13546
<span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">kill</span> <span class="nt">-SIGINT</span> 13608
</code></pre></div>    <h4 id="configuration-and-the-environment">Configuration and the Environment</h4>
    <ol>
      <li>Environment: shell 维护 一个 shell的 session 信息 称为 环境； shell 中保存 environment variables and shell variables 在环境中。但是无法区分 两种类型的变量。</li>
    </ol>
    <ul>
      <li>printenv： 用来展现所有的 变量</li>
      <li>set： 不带参数 展现所有变量以及 shell函数</li>
      <li>alias： 展现所有 alias 相关的<br />
    2. Environment 中的变量是 如何定义的：</li>
      <li>A login shell session： A login shell session is one in which we are prompted for our username and password. This happens when we start a virtual console session, for example.</li>
      <li>A non-login shell session： A non-login shell session typically occurs when we launch a terminal session in the GUI.</li>
      <li>
        <p>Login Shell Sessions 读取配置文件</p>

        <table>
          <thead>
            <tr>
              <th>File</th>
              <th>Contents</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>/etc/profile</td>
              <td>A global configuration script that applies to all users.</td>
            </tr>
            <tr>
              <td>~/.bash_profile</td>
              <td>A user’s personal startup file. This can be used to extend or override settings in the global configuration script.</td>
            </tr>
            <tr>
              <td>~/.bash_login</td>
              <td>If ~/.bash_profile is not found, bash attempts to read this script.</td>
            </tr>
            <tr>
              <td>~/.profile</td>
              <td>If neither ~/.bash_profile nor ~/.bash_login is found, bash attempts to read this file. This is the default in Debian-based distributions, such as Ubuntu.</td>
            </tr>
            <tr>
              <td> </td>
              <td> </td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>Non-Login Shell Sessions 读取配置文件： non-login shells inherit the environ- ment from their parent process, usually a login shell. Non-login 会 继承  Login shell 的环境</li>
    </ul>

    <table>
      <thead>
        <tr>
          <th>File</th>
          <th>Contents</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>/etc/bash.bashrc</td>
          <td>A global configuration script that applies to all users</td>
        </tr>
        <tr>
          <td>~/.bashrc</td>
          <td>A user’s personal startup file. It can be used to extend or  override settings in the global configuration script.</td>
        </tr>
        <tr>
          <td> </td>
          <td> </td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<ol>
  <li>命令查找： ls 命令的 定义在哪里， 又是如何找到的呢？
    <ul>
      <li>shell 从 PATH 变量中 包含的 Path 中 顺序查找</li>
    </ul>
  </li>
</ol>

<div class="highlight"><pre class="highlight shell"><code>  <span class="nv">PATH</span><span class="o">=</span><span class="nv">$PATH</span>:<span class="nv">$HOME</span>/bin
  <span class="nb">export </span>PATH

  简单的将 <span class="nv">$HOME</span>/bin 添加到 PATH 中 <span class="o">(</span>注意 <span class="nv">$HOME</span> 会在此处求值<span class="o">)</span>
  <span class="nb">export </span>PATH 让 shell之后的process 中的PATH都改变
</code></pre></div>
<h4 id="查找文件">查找文件</h4>
<ol>
  <li>locate : 非常简单有效，只能使用 filename 用来查找。 locate 足够高效 因为 其从 updatedb command 更新的数据库中来进行查找，updatedb 经常 放在cron job 来执行（需要确认下，因为没有找到 相关的配置文件）</li>
  <li>find 寻找文件 则显得 复杂 而详尽。可以根据给定的 目录 以及 各个限定 来查找文件。<br />
可选参数与 含义</li>
</ol>

<table>
  <thead>
    <tr>
      <th>参数</th>
      <th>可选值</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>-type</td>
      <td>b: Block special device file; c: Character special device file; d: Directory; f: regular file; l Symbolic link</td>
    </tr>
    <tr>
      <td>-size</td>
      <td>c Bytes; w: 2-byte words; k: kilobytes; M: megabytes; G: Gigabytes;</td>
    </tr>
    <tr>
      <td>-cmin n</td>
      <td>Match files or directories whose content or attributes were last modified exactly n minutes ago. To specify less than n minutes ago, use -n, and to specify more than n minutes ago, use +n.</td>
    </tr>
    <tr>
      <td>-cnewer file</td>
      <td>Match files or directories whose contents or attributes were last modified more recently than those of file.</td>
    </tr>
    <tr>
      <td>-ctime n</td>
      <td>Match files or directories whose contents or attributes were last modified n*24 hours ago.</td>
    </tr>
    <tr>
      <td>-empty</td>
      <td>Match empty files and directories.</td>
    </tr>
    <tr>
      <td>-iname pattern</td>
      <td>Like the -name test but case-insensitive.</td>
    </tr>
    <tr>
      <td>-inum n</td>
      <td>Match files with inode number n. This is helpful for finding all the hard links to a particular inode.</td>
    </tr>
    <tr>
      <td>-mmin n</td>
      <td>Match files or directories whose contents were last modified n minutes ago.</td>
    </tr>
    <tr>
      <td>-mtime n</td>
      <td>Match files or directories whose contents were last modified n*24 hours ago.</td>
    </tr>
    <tr>
      <td>-name pattern</td>
      <td>Match files and directories with the specified wildcard pattern.</td>
    </tr>
    <tr>
      <td>-newer file</td>
      <td>Match files and directories whose contents were modified more recently than the specified file. This is useful when writing shell scripts that perform file backups. Each time you make a backup, update a file (such as a log) and then use find to determine which files have changed since the last update</td>
    </tr>
    <tr>
      <td>-samefile name</td>
      <td>Similar to the -inum test. Match files that share the same inode number as file name</td>
    </tr>
    <tr>
      <td>-user name</td>
      <td>Match files or directories belonging to user name. The user may be expressed by a username or by a numeric user ID.</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>for example</li>
</ul>

<div class="highlight"><pre class="highlight shell"><code><span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span>find ~ <span class="nt">-type</span> f <span class="nt">-name</span> <span class="s2">"*.JPG"</span> <span class="nt">-size</span> +1M | <span class="nb">wc</span> <span class="nt">-l</span>
</code></pre></div><p>注意 其中的 -name 参数需要添加 “” 来防止 pathname expansion， size: 则使用 +1M 表示大于 1M 的文件</p>

<ul>
  <li>find logical Operators： find 则可以更复杂的 使用 -and -or -not () 等来进行  logic 之间的 与或 操作 来设定更复杂的 test 关系</li>
</ul>

<div class="highlight"><pre class="highlight shell"><code><span class="o">(</span> expression 1 <span class="o">)</span> <span class="nt">-or</span> <span class="o">(</span> expression 2 <span class="o">)</span>
</code></pre></div><ul>
  <li>Predefined Actions:</li>
</ul>

<table>
  <thead>
    <tr>
      <th>Action</th>
      <th>Meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>-delete</td>
      <td>delete match file</td>
    </tr>
    <tr>
      <td>-ls</td>
      <td>ls -dils match file</td>
    </tr>
    <tr>
      <td>-print</td>
      <td>output full pathname of match file</td>
    </tr>
    <tr>
      <td>-quit</td>
      <td>Quit once a match has been made</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>User-Defined Actions： -exec rm ‘{}’ ‘;’： {} 代表 match file 的pathname。 这里面 存在的问题是： -exec 中的命令会被  实例化 多次，在每次match file的时候 就会实例化一次。可以简单的 实例化多次 修改为 实例化一次 。 即：</li>
</ul>

<div class="highlight"><pre class="highlight shell"><code>find ~ <span class="nt">-type</span> f <span class="nt">-name</span> <span class="s1">'foo*'</span> <span class="nt">-exec</span> <span class="nb">ls</span> <span class="nt">-l</span> <span class="s1">'{}'</span> <span class="s1">';'</span>
<span class="nt">-rwxr-xr-x</span> 1 me me 224 2007-10-29 18:44 /home/me/bin/foo 
<span class="nt">-rw-r--r--</span> 1 me me 0 2016-09-19 12:53 /home/me/foo.txt

// 修改后
find ~ <span class="nt">-type</span> f <span class="nt">-name</span> <span class="s1">'foo*'</span> <span class="nt">-exec</span> <span class="nb">ls</span> <span class="nt">-l</span> <span class="s1">'{}'</span> +
<span class="nt">-rwxr-xr-x</span> 1 me me 224 2007-10-29 18:44 /home/me/bin/foo 
<span class="nt">-rw-r--r--</span> 1 me me 0 2016-09-19 12:53 /home/me/foo.txt
</code></pre></div><ul>
  <li>xargs: 用于将 接受的input 的信息 作为参数 传递给 command. xargs存在的原因在于： 一些 命令 接受 命令行参数+标准输入，但是其他一些命令 则 只接受命令行 输入，所以需要 xargs 将标准输入 转换为 命令行参数<br />
Some commands such as grep and awk can take input either as command-line arguments or from the standard input. However, others such as cp and echo can only take input as arguments, which is why xargs is necessary. <a href="https://en.wikipedia.org/wiki/Xargs">[name]</a><br />
xargs 中存在一些 问题，主要是 关于 filename 中的空格，等分隔符号 对整个 shell的参数接收 都有影响。 所以 接受filename 的时候 –null 参数 将 是xargs 不被 ‘ ’分隔（ 使用 空字符串 作为分隔）， -d ‘</li>
</ul>

<h4 id="archiving-and-backup">Archiving and Backup：</h4>
<ol>
  <li>
    <p>compressor command: gzip bzip2  gzip options</p>

    <table>
      <thead>
        <tr>
          <th>Option</th>
          <th>Long Option</th>
          <th>Desc</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>-c</td>
          <td>–stdout</td>
          <td>Write output to standard output and keep the original files.</td>
        </tr>
        <tr>
          <td>-d</td>
          <td>–decompress</td>
          <td>Decompress This causes gzip act like gunzip</td>
        </tr>
        <tr>
          <td>-f</td>
          <td>–force</td>
          <td>force compress event if a compressed file already exists</td>
        </tr>
        <tr>
          <td>-l</td>
          <td>–list</td>
          <td>应用 已压缩文件 展示 压缩信息</td>
        </tr>
        <tr>
          <td>-r</td>
          <td>–recursive</td>
          <td>递归压缩目录下的文件（目录下的文件各自压缩为 各自的压缩文件，所以 依然需要archive 程序）</td>
        </tr>
        <tr>
          <td>-v</td>
          <td>–verbose</td>
          <td>Display verbose messages while compressing.</td>
        </tr>
        <tr>
          <td>-number</td>
          <td> </td>
          <td>Set amount of compression. number is an integer in the range of 1 (fastest, least compression) to 9 (slowest, most compression). The values 1 and 9 may also be expressed as –fast and –best, respectively. The default value is 6.</td>
        </tr>
      </tbody>
    </table>

    <blockquote>
      <p>bzip2 同gzip 一样 为压缩程序，其中的参数 都大概相同，除了-r -number 外。 bunzip2 bzcat 用于解压缩。 bzip2recover 可以恢复受损的 压缩文件</p>
    </blockquote>
  </li>
  <li>
    <p>archive command: tar zip:  Archiving is the process of gathering up many files and bundling them together into a single large file.</p>
  </li>
</ol>

<table>
  <thead>
    <tr>
      <th>Mode</th>
      <th>Meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>c</td>
      <td>Create an archive from a list of files and/or directories.</td>
    </tr>
    <tr>
      <td>x</td>
      <td>Extract an archive.</td>
    </tr>
    <tr>
      <td>r</td>
      <td>Append specified pathnames to the end of an archive</td>
    </tr>
    <tr>
      <td>t</td>
      <td>List the content of an archive</td>
    </tr>
  </tbody>
</table>

<div class="highlight"><pre class="highlight shell"><code>  <span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">gzip </span>foo.txt
  <span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-l</span> foo.<span class="k">*</span>
  <span class="nt">-rw-r--r--</span> 1 me me 3230 2018-10-14 07:15 foo.txt.gz

  <span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">gzip</span> <span class="nt">-d</span> foo.txt.gz

  <span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">gunzip </span>foo.txt
  <span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-l</span> foo.<span class="k">*</span>
  <span class="nt">-rw-r--r--</span> 1 me me 15738 2018-10-14 07:15 foo.txt


  <span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span>bzip2 foo.txt
  <span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-l</span> foo.txt.bz2
  <span class="nt">-rw-r--r--</span> 1 me me 2792 2018-10-17 13:51 foo.txt.bz2
  <span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span>bunzip2 foo.txt.bz2
</code></pre></div>
<blockquote>
  <p>tar： 只能以 相对路径 archive 文件。unarchive 的时候 在 当前路径下 以相对路径 恢复文件。example</p>
</blockquote>

<div class="highlight"><pre class="highlight shell"><code>  <span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">tar </span>cf playground2.tar ~/playground

  <span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">cd </span>foo
  <span class="o">[</span>me@linuxbox foo]<span class="nv">$ </span><span class="nb">tar </span>xf ../playground2.tar
  <span class="o">[</span>me@linuxbox foo]<span class="nv">$ </span><span class="nb">ls
  </span>home playground
</code></pre></div>
<blockquote>
  <p>–wildcards 可以用来过滤掉 特定的 match 文件 \n  find 经常用来 与 tar 配合进行 批量 archive</p>
</blockquote>

<div class="highlight"><pre class="highlight shell"><code>  find playground <span class="nt">-name</span> <span class="s1">'file-A'</span> <span class="nt">-exec</span> <span class="nb">tar </span>rf playground.tar <span class="s1">'{}'</span> <span class="s1">'+'</span>

  find playground <span class="nt">-name</span> <span class="s1">'file-A'</span> | <span class="nb">tar </span>cf - <span class="nt">--files-from</span><span class="o">=</span>- | <span class="nb">gzip</span> <span class="o">&gt;</span> playground.tgz
</code></pre></div>
<blockquote>
  <p>第二条命令比较 特殊，在其中  tar cf - –files-from=- 中， - 代表 标准 标准输入或者输出 <br />
 tar 可以通过添加 z j 参数，直接 使用gzip bzip2 进行压缩, z: gzip .tgz, j: bzip2 .tbz</p>
</blockquote>

<div class="highlight"><pre class="highlight shell"><code>  find playground <span class="nt">-name</span> <span class="s1">'file-A'</span> | <span class="nb">tar </span>czf playground.tgz <span class="nt">-T</span> -
</code></pre></div>
<blockquote>
  <p>通过网络进行 文件备份：</p>
</blockquote>

<div class="highlight"><pre class="highlight shell"><code>  ssh remote-sys <span class="s1">'tar cf - Documents'</span> | <span class="nb">tar </span>xf -
</code></pre></div>
<blockquote>
  <p>zip, unzip： 的命令 比较详细，所以只列出简短  的示例：</p>
</blockquote>

<div class="highlight"><pre class="highlight shell"><code>  zip <span class="nt">-r</span> playground.zip playground // <span class="nt">-r</span> 是必须，这样才能 得到 playground 下的所有 archive
  unzip ../playground.zip // 不同与 <span class="nb">tar</span>, zip 使用unzip 来进行 unarchive
  unzip <span class="nt">-l</span> ../playground.zip
</code></pre></div>
<ol>
  <li>sync command: rsync  rsync options source destination<br />
  where source and destination are one of the following:</li>
</ol>

<ul>
  <li>A local file or directory</li>
  <li>A remote file or directory in the form of [user@]host:path</li>
  <li>A remote rsync server specified with a URI of rsync://[user@]host[:port]/path</li>
</ul>

<blockquote>
  <p>注意： source destination 其中之一 必须 为 本地的文件， 远程 到 远程的 copy 是不被允许的。<br />
  示例：</p>
</blockquote>

<div class="highlight"><pre class="highlight shell"><code>  rsync <span class="nt">-av</span> <span class="nb">source </span>destination // <span class="nt">-a</span> 代表 archive mode， v verbose output
  rsync <span class="nt">-av</span> <span class="nb">source</span>/ destination
  // 两种方式不同的地方在于 后一种 只拷贝 <span class="nb">source </span>中的内容到 destination, 而 第一种 则将source 目录也 拷贝到 destination 中.

  rsync <span class="nt">-av</span> <span class="nt">--delete</span> <span class="nb">source</span>/ destination   // delete 参数 为 完全拷贝， <span class="nb">source </span>中删除掉的file 将在 destination 中删除掉。
</code></pre></div>
<ol>
  <li>Using rsync Over a Network： 的两种方式
    <ul>
      <li>source 安装了 rsync  的机器 以及 destination 安装了 远程shell 程序， 如： ssh</li>
      <li>destination 安装了 rsync server， rsync 可以配置为 daemon 模式 等待 sync 请求</li>
    </ul>
  </li>
</ol>

<div class="highlight"><pre class="highlight shell"><code>  <span class="nb">sudo </span>rsync <span class="nt">-av</span> <span class="nt">--delete</span> <span class="nt">--rsh</span><span class="o">=</span>ssh /etc /home /usr/local remote-sys:/backup
  // 这里面 <span class="nt">--rsh</span> 指定为 ssh， 使 rsync 能够 使用ssh 来进行同步操作
  rsync <span class="nt">-av</span> –delete rsync://archive.linux.duke.edu/ fedora/linux/development/rawhide/Everything/x86_64/os/ fedora-devel
</code></pre></div>
<h3 id="text-processing">Text Processing</h3>
<ul>
  <li>cat： 可以这样使用</li>
</ul>

<div class="highlight"><pre class="highlight shell"><code>  <span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">cat</span> <span class="o">&gt;</span> foo.txt // ctrl-d结束输入
  <span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">cat</span> <span class="nt">-A</span> foo.txt // 其中 ^I 代表 tab, <span class="nv">$ </span>代表 line末尾， 所以可以用此来 区分 tab 与 space
  <span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">cat</span> <span class="nt">-nA</span> foo.txt // n 显式 line number
</code></pre></div>
<ul>
  <li>
    <p>[[https://www.gnu.org/software/coreutils/manual/html_node/sort-invocation.html#sort-invocation][sort]]:  对输入进行排序， 是一个比较复杂，有用的命令：下面是详细参数</p>

    <table>
      <thead>
        <tr>
          <th>Option</th>
          <th>Long Option</th>
          <th>meaning</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>-b</td>
          <td>–ignore-leading-blanks</td>
          <td>使忽略掉 行前的 空格，使用第一个非空格排序</td>
        </tr>
        <tr>
          <td>-f</td>
          <td>–ignore-case</td>
          <td> </td>
        </tr>
        <tr>
          <td>-n</td>
          <td>–numeric-sort</td>
          <td>将字符串当做number 来进行比较</td>
        </tr>
        <tr>
          <td>-r</td>
          <td>–reverse</td>
          <td>reverse order 排序</td>
        </tr>
        <tr>
          <td>-k</td>
          <td>–key=field1[,field2]</td>
          <td>使用 field1..field2 作为排序的key, field1 不存在则为1， field2 不存在则 从field1直至末尾， field1 都可以是如此形式 f[.c][opts]  .c 为内部的offset</td>
        </tr>
        <tr>
          <td>-m</td>
          <td>–merge</td>
          <td>将每个参数作为预排序文件的名称。 将多个文件合并为单个排序结果，而不执行任何其他排序。</td>
        </tr>
        <tr>
          <td>-o</td>
          <td>–output=file</td>
          <td>输出到 file 而非 标准输出</td>
        </tr>
        <tr>
          <td>-t</td>
          <td>–field-separator=char</td>
          <td>使用 char 作为分隔符，默认为 space 或者tab</td>
        </tr>
        <tr>
          <td> </td>
          <td>–debug</td>
          <td>将用作sort 的key 进行标记</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <p>下面是几个示例</p>
  </li>
</ul>

<div class="highlight"><pre class="highlight shell"><code>  <span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">du</span> <span class="nt">-s</span> /usr/share/<span class="k">*</span> | <span class="nb">head
  </span>252 /usr/share/aclocal
  96 /usr/share/acpi-support
  8 /usr/share/adduser
  196 /usr/share/alacarte 344 /usr/share/alsa
  8 /usr/share/alsa-base 12488 /usr/share/anthy
  8 /usr/share/apmd


  //  下面对结果进行排序 其中 <span class="nt">-nr</span> 将string作为number 处理并 翻转排序, 这里面之所有管用，是因为 第一列 为 数字, 即 默认按照第一列进行排序
  <span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">du</span> <span class="nt">-s</span> /usr/share/<span class="k">*</span> | <span class="nb">sort</span> <span class="nt">-nr</span> | <span class="nb">head
  </span>509940 /usr/share/locale-langpack
  242660 /usr/share/doc
  197560 /usr/share/fonts
  179144 /usr/share/gnome
  146764 /usr/share/myspell
  144304 /usr/share/gimp
  135880 /usr/share/dict
  76508 /usr/share/icons
  68072 /usr/share/apps
  62844 /usr/share/foomatic

  // 如果是这样的又如何排序?
  <span class="o">[</span>shaohua.li@10-11-112-3 ~]<span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-l</span> /usr/bin/ | <span class="nb">head
  </span>total 58404
  <span class="nt">-rwxr-xr-x</span>  1 root root     33408 Nov 10  2015 <span class="o">[</span>
  <span class="nt">-rwxr-xr-x</span>  1 root root    106792 Nov 10  2015 a2p
  <span class="nt">-rwxr-xr-x</span><span class="nb">.</span> 1 root root     14984 Aug 18  2010 acpi_listen
  <span class="nt">-rwxr-xr-x</span><span class="nb">.</span> 1 root root     23488 Nov 11  2010 addftinfo
  <span class="nt">-rwxr-xr-x</span>  1 root root     24904 Jul 23  2015 addr2line
  <span class="nt">-rwxr-xr-x</span><span class="nb">.</span> 1 root root      1786 Feb 21  2013 apropos
  <span class="nt">-rwxr-xr-x</span>  1 root root     56624 Jul 23  2015 ar
  <span class="nt">-rwxr-xr-x</span>  1 root root    328392 Jul 23  2015 as
  <span class="nt">-rwxr-xr-x</span><span class="nb">.</span> 1 root root     10400 Sep 23  2011 attr

  // <span class="nt">-k</span> 5 使用 第 5 field 作为key 用作 排序使用
  <span class="o">[</span>shaohua.li@10-11-112-3 ~]<span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-l</span> /usr/bin/ | <span class="nb">sort</span> <span class="nt">-nr</span> <span class="nt">-k</span> 5 | <span class="nb">head</span>
  <span class="nt">-rwxr-xr-x</span>  1 root root   3214440 Dec 12  2016 mysql
  <span class="nt">-rwxr-xr-x</span>  1 root root   3051080 Dec 12  2016 mysqlbinlog
  <span class="nt">-rwxr-xr-x</span>  1 root root   2998400 Dec 12  2016 mysqldump
  <span class="nt">-rwxr-xr-x</span>  1 root root   2948832 Dec 12  2016 mysqlslap
  <span class="nt">-rwxr-xr-x</span>  1 root root   2936680 Dec 12  2016 mysqladmin
  <span class="nt">-rwxr-xr-x</span>  1 root root   2935688 Dec 12  2016 mysqlcheck
  <span class="nt">-rwxr-xr-x</span>  1 root root   2933128 Dec 12  2016 mysqlimport
  <span class="nt">-rwxr-xr-x</span>  1 root root   2931712 Dec 12  2016 mysqlshow
  <span class="nt">-rwxr-xr-x</span>  1 root root   2814328 Dec 12  2016 my_print_defaults
  <span class="nt">-rwxr-xr-x</span>  1 root root   2811544 Dec 12  2016 mysql_waitpid


  // 下面是 比较复杂的示例
  root@precise64:~/shell_test#  <span class="nb">cat </span>distros.txt
  Fedora  5    03/20/2006
  Fedora  6    10/24/2006
  Fedora  7    05/31/2007
  Fedora  8    11/08/2007
  Fedora  9    05/13/2008
  Fedora  10   11/25/2008
  SUSE    10.1 05/11/2006
  SUSE    10.2 12/07/2006
  SUSE    10.3 10/04/2007
  SUSE    11.0 06/19/2008
  Ubuntu  6.06 06/01/2006
  Ubuntu  6.10 10/26/2006
  Ubuntu  7.04 04/19/2007
  Ubuntu  7.10 10/18/2007
  Ubuntu  8.04 04/24/2008
  Ubuntu  8.10 10/30/2008

  // 如何对 distros 按照其 发布的版本 以及 发布时间 进行排序呢？

  // 单纯的 按照 发布版本排序
  root@precise64:~/shell_test# <span class="nb">sort </span>distros.txt  <span class="nt">-nrk</span> 2
  SUSE    11.0 06/19/2008
  SUSE    10.3 10/04/2007
  SUSE    10.2 12/07/2006
  SUSE    10.1 05/11/2006
  Fedora  10   11/25/2008
  Fedora  9    05/13/2008
  Ubuntu  8.10 10/30/2008
  Ubuntu  8.04 04/24/2008
  Fedora  8    11/08/2007
  Ubuntu  7.10 10/18/2007
  Ubuntu  7.04 04/19/2007
  Fedora  7    05/31/2007
  Ubuntu  6.10 10/26/2006
  Ubuntu  6.06 06/01/2006
  Fedora  6    10/24/2006
  Fedora  5    03/20/2006

  // 综合排序， 使用多个key， 版本，以及版本号 进行综合排序
  root@precise64:~/shell_test# <span class="nb">sort</span> <span class="nt">--key</span><span class="o">=</span>1,1 <span class="nt">--key</span><span class="o">=</span>2n distros.txt
  Fedora  5    03/20/2006
  Fedora  6    10/24/2006
  Fedora  7    05/31/2007
  Fedora  8    11/08/2007
  Fedora  9    05/13/2008
  Fedora  10   11/25/2008
  SUSE    10.1 05/11/2006
  SUSE    10.2 12/07/2006
  SUSE    10.3 10/04/2007
  SUSE    11.0 06/19/2008
  Ubuntu  6.06 06/01/2006
  Ubuntu  6.10 10/26/2006
  Ubuntu  7.04 04/19/2007
  Ubuntu  7.10 10/18/2007
  Ubuntu  8.04 04/24/2008
  Ubuntu  8.10 10/30/2008

  // k 可以为 f[.c][opts]  可以指定 field 中的 c pos 用来比较
  root@precise64:~/shell_test# <span class="nb">sort</span> <span class="nt">-k</span> 3.7nbr <span class="nt">-k</span> 3.1nbr <span class="nt">-k</span> 3.4nbr distros.txt
  Fedora  10   11/25/2008
  Ubuntu  8.10 10/30/2008
  SUSE    11.0 06/19/2008
  Fedora  9    05/13/2008
  Ubuntu  8.04 04/24/2008
  Fedora  8    11/08/2007
  Ubuntu  7.10 10/18/2007
  SUSE    10.3 10/04/2007
  Fedora  7    05/31/2007
  Ubuntu  7.04 04/19/2007
  SUSE    10.2 12/07/2006
  Ubuntu  6.10 10/26/2006
  Fedora  6    10/24/2006
  Ubuntu  6.06 06/01/2006
  SUSE    10.1 05/11/2006
  Fedora  5    03/20/2006


  // <span class="nt">--debug</span> 选项 是比较有意思的，用来在 不知道 key 以及sort情况时候，用来展现 其内部sort key 的方式
  root@precise64:~/shell_test# <span class="nb">cat</span> /etc/passwd | <span class="nb">sort</span> <span class="nt">-t</span> <span class="s1">':'</span> <span class="nt">-k</span> 7 <span class="nt">--debug</span> | <span class="nb">head
  sort</span>: using <span class="sb">`</span>en_US<span class="s1">' sorting rules
  root:x:0:0:root:/root:/bin/bash
                        _________
  _______________________________
  vagrant:x:1000:1000:vagrant,,,:/home/vagrant:/bin/bash
                                               _________
  ______________________________________________________
  messagebus:x:102:105::/var/run/dbus:/bin/false
                                      __________
  ______________________________________________
  mysql:x:106:111:MySQL Server,,,:/nonexistent:/bin/false
</span></code></pre></div>
<ul>
  <li>
    <p>uniq: 去除 重复的 条目, 比较有意思的是 需要在sort之后 使用，也就是说 uniq只能去除掉 相邻的 重复的条目</p>

<div class="highlight"><pre class="highlight shell"><code><span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">cat</span> <span class="o">&gt;</span> foo.txt 
a
b
c
a
b
c

<span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">uniq </span>foo.txt 
a
b
c
a
b
c

<span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">sort </span>foo.txt | <span class="nb">uniq 
</span>a
b
c
</code></pre></div>  </li>
  <li>
    <p>cut: 用于 使用 -d, –delimiter=DELIM 默认为tab 分隔line， 然后提取 field， characters 等</p>

<div class="highlight"><pre class="highlight shell"><code>root@precise64:~/shell_test# <span class="nb">cat</span> /etc/passwd | <span class="nb">cut</span> <span class="nt">-d</span> <span class="s1">':'</span> <span class="nt">-f</span> 1 | <span class="nb">head
</span>root
daemon
bin
sys
<span class="nb">sync
</span>games
man
lp
mail
news
</code></pre></div>  </li>
  <li>
    <p>comm: 用于比较 两个文本的变化差异: comm file1 file2 其结果 第一列 显式 file1 独有的，第二列 显示 file2 独有的， 第三列 显示 file1 file2 共同的</p>

<div class="highlight"><pre class="highlight shell"><code>root@precise64:~/shell_test# <span class="nb">cat </span>file1.text
a
b
c
d

root@precise64:~/shell_test# <span class="nb">cat </span>file2.text
b
c
d
e

// 注意 其展现形式， 第一列only file1 have  第二列 only file2 have  第三列 <span class="nb">comm
</span>root@precise64:~/shell_test# <span class="nb">comm </span>file1.text file2.text
a
        b
        c
        d
    e
</code></pre></div>  </li>
  <li>https://toroid.org/unix-pipe-implementation</li>
  <li>
    <p>diff: diff file1.txt file2.txt； diff 展现的格式 都为 更改 file1.txt 转变到 file2.txt 的操作序列，即是 字符串 之间最小编辑记录 在文件中的应用。</p>

<div class="highlight"><pre class="highlight shell"><code>root@precise64:~/shell_test# <span class="nb">cat </span>file1.text
a
b
c
d
root@precise64:~/shell_test# <span class="nb">cat </span>file2.text
b
c
d
e

root@precise64:~/shell_test# diff file1.text  file2.text
1d0
&lt; a
4a4
<span class="o">&gt;</span> e
</code></pre></div>
    <table>
      <thead>
        <tr>
          <th>Change</th>
          <th>meaning</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>r1ar2</td>
          <td>将 file2 中的 r2行 追加到 file1 中的 r1 行中</td>
        </tr>
        <tr>
          <td>r1cr2</td>
          <td>将 file1 中 r1 行 替换为 file2中的 r2 行</td>
        </tr>
        <tr>
          <td>r1dr2</td>
          <td>将 file1中的r1行删除掉，下一行将出现在 file2中的 r2 行</td>
        </tr>
      </tbody>
    </table>

    <blockquote>
      <p>此格式为默认格式，但是因为不够直观，所以这种格式并不常用。<br />
上下文格式：diff -c file1.txt file2.txt</p>
    </blockquote>

<div class="highlight"><pre class="highlight shell"><code>root@precise64:~/shell_test# diff <span class="nt">-c</span> file1.text  file2.text
<span class="k">***</span> file1.text	2020-09-24 08:02:08.202406914 +0000 // <span class="k">**</span> 代表 file1.txt，其后是 时间戳
<span class="nt">---</span> file2.text	2020-09-24 08:02:15.854515682 +0000 // <span class="nt">--</span> 代表 file2.txt 其后是 时间戳
<span class="k">***************</span>
<span class="k">***</span> 1,4 <span class="k">****</span> // <span class="k">**</span> 代表 file1.txt
- a
  b
  c
  d
<span class="nt">---</span> 1,4 <span class="nt">----</span> // <span class="nt">--</span> 代表 file2.txt
  b
  c
  d
+ e
</code></pre></div>
    <table>
      <thead>
        <tr>
          <th>Indicator</th>
          <th>Meaning</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>blank</td>
          <td>此行 两个文件没有差别</td>
        </tr>
        <tr>
          <td>-</td>
          <td>需要删除该行(只会出现在 file1中，因为目的是 将file1 转向 file2)</td>
        </tr>
        <tr>
          <td>+</td>
          <td>添加该行 （只会出现在file2中，代表 需要将该行添加到 file1中）</td>
        </tr>
        <tr>
          <td>!</td>
          <td>两个文件中都会出现，代表 file1中的该行 需要被 file2中的 对应行 替换</td>
        </tr>
      </tbody>
    </table>

    <blockquote>
      <p>统一格式： diff -u file1.txt file2.txt</p>
    </blockquote>

<div class="highlight"><pre class="highlight shell"><code>root@precise64:~/shell_test# diff <span class="nt">-u</span> file1.text file2.text
<span class="nt">---</span> file1.text	2020-09-24 08:02:08.202406914 +0000
+++ file2.text	2020-09-25 04:41:15.154310271 +0000
@@ <span class="nt">-1</span>,4 +1,4 @@
<span class="nt">-a</span>
 b
 c
 d
+e
</code></pre></div>
    <table>
      <thead>
        <tr>
          <th>Character</th>
          <th>Meaning</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>blank</td>
          <td>no change</td>
        </tr>
        <tr>
          <td>-</td>
          <td>从file1 文件中删除该行</td>
        </tr>
        <tr>
          <td>+</td>
          <td>从file1 文件中添加该行</td>
        </tr>
      </tbody>
    </table>

    <blockquote>
      <p>也就是说 统一格式 中，将 ！替换操作去除了，通过 - + 来实现了 替换操作</p>
    </blockquote>
  </li>
  <li>patch: 用来将diff 出的结果 apply。 即是： diff -Naur old_file new_file &gt; diff_file; patch &lt; diff_file; 之后 old_file 会转变为 same as new_file</li>
</ul>

<h3 id="shell-语法">shell 语法</h3>
<ol>
  <li>Variables and Constants
    <ul>
      <li>shell 中的变量 是 动态的，不需要预先声明 与类型指定（因为没有类型，可能都为字符串），对于 使用 未定义 未赋值 的变量 其 数值 为 空。 所以我们需要 注意自己的拼写错误，因为 shell可能会将其视为 新变量。</li>
      <li>常量： 规范 使用 全大写 命名 常量，以区分于 普通变量。 也可以使用 declare -r TITLE=”Page Title” 来进行声明</li>
      <li>赋值： variable=value  shell 并不区分 value的类型， value 全部被视为 string， 注意= 左右没有空格</li>
      <li>变量数值引用 需要注意， 因为语法原因 可能 需要使用 {} 来避免 变量名与表达式 的歧义</li>
    </ul>
  </li>
</ol>

<div class="highlight"><pre class="highlight shell"><code>  <span class="nv">a</span><span class="o">=</span>z <span class="c"># a 赋值为 string z</span>
  <span class="nv">b</span><span class="o">=</span><span class="s2">"a string"</span>
  <span class="nv">c</span><span class="o">=</span><span class="s2">"a string and </span><span class="nv">$b</span><span class="s2">"</span> <span class="c"># c </span>

  <span class="nv">d</span><span class="o">=</span><span class="s2">"</span><span class="si">$(</span><span class="nb">ls</span> <span class="nt">-l</span> foo.txt<span class="si">)</span><span class="s2">"</span> <span class="c"># value 为子命令结果</span>
  <span class="nv">e</span><span class="o">=</span><span class="k">$((</span><span class="m">5</span> <span class="o">*</span> <span class="m">7</span><span class="k">))</span> <span class="c"># 数值计算展开</span>

  <span class="nv">a</span><span class="o">=</span>5 <span class="nv">b</span><span class="o">=</span><span class="s2">"string"</span> <span class="c"># 多个变量可以 同时声明</span>

  <span class="nv">filename</span><span class="o">=</span><span class="s2">"myfile"</span>
  <span class="nb">touch</span> <span class="nv">$filename</span>
  <span class="nb">mv</span> <span class="s2">"</span><span class="nv">$filename</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$filename1</span><span class="s2">"</span>  <span class="c"># 这里面的本意是 更改myfile 文件为 myfile1，但是因为并没有 区分 $filename1 是变量还是表达式, 所以这里需要 使用新的形势 来进行区分</span>
  <span class="nb">mv</span>: missing destination file operand after <span class="sb">`</span>myfile<span class="s1">'
  Try `mv --help'</span> <span class="k">for </span>more information.

  <span class="nb">mv</span> <span class="s2">"</span><span class="nv">$filename</span><span class="s2">"</span> <span class="s2">"</span><span class="k">${</span><span class="nv">filename</span><span class="k">}</span><span class="s2">1"</span> <span class="c"># 使用 {} 来解决歧义</span>
</code></pre></div><h3 id="function-define">function define:</h3>
<div class="highlight"><pre class="highlight shell"><code>  <span class="k">function </span>name <span class="o">{</span>
      commands
      <span class="k">return</span>
  <span class="o">}</span>

  name<span class="o">()</span> <span class="o">{</span>
      commands
      <span class="k">return</span>
  <span class="o">}</span>

</code></pre></div>
<ul>
  <li>local var: 局部变量， local foo=</li>
  <li>function 之间的数据传递： 有三种 答案在这里： https://stackoverflow.com/questions/8742783/returning-value-from-called-function-in-a-shell-script</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>其中使用echo 方式传递 返回值 的方式 类似于 local name=$(cat xxx</td>
          <td>grep) 等， 即： 使用 Process Substitution 来分离出一个process 执行 shell 代码， 通过 stdin stdout stderr 等来实现 process的处理结果</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h3 id="flow-control">Flow Control:</h3>
<ul>
  <li>if</li>
</ul>

<div class="highlight"><pre class="highlight shell"><code>  <span class="k">if </span>commands<span class="p">;</span> <span class="k">then 
    </span>commands
  <span class="o">[</span><span class="k">elif </span>commands<span class="p">;</span> <span class="k">then 
    </span>commands...]
  <span class="o">[</span><span class="k">else 
    </span>commands]
  <span class="k">fi</span>
</code></pre></div><ul>
  <li>exit status: 一般为 为一个 0-255 的数值， 0 代表 success， 其他值代表不同的错误。所以0 代表true，false 代表1， 不同于其他语言中的惯例。$? 代表 上个命令执行的返回结果</li>
</ul>

<div class="highlight"><pre class="highlight shell"><code>  root@precise64:~/shell_test# <span class="nb">ls</span> <span class="nt">-d</span> /usr/bin/
  /usr/bin/
  root@precise64:~/shell_test# <span class="nb">echo</span> <span class="nv">$?</span>
  0
  root@precise64:~/shell_test# <span class="nb">ls</span> <span class="nt">-d</span> /bin/usr
  <span class="nb">ls</span>: cannot access /bin/usr: No such file or directory
  root@precise64:~/shell_test# <span class="nb">echo</span> <span class="nv">$?</span>
  2
</code></pre></div><ul>
  <li>
    <p>test： 配合if 使用，返回condition 结果: 两种形式. 成功返回0， 失败 返回1</p>

<div class="highlight"><pre class="highlight shell"><code><span class="nb">test </span>expression

<span class="o">[</span>expression]
</code></pre></div>    <h4 id="相关的测试expression">相关的测试expression</h4>
  </li>
  <li>
    <p>file Expression</p>

    <table>
      <thead>
        <tr>
          <th>Expression</th>
          <th>Is True?</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>file1 -ef file2</td>
          <td>file1 inode eq file2 inode true</td>
        </tr>
        <tr>
          <td>file1 -nt file2</td>
          <td>file1 is newer than file2</td>
        </tr>
        <tr>
          <td>file1 -ot file2</td>
          <td>file1 is older than file2</td>
        </tr>
        <tr>
          <td>-b file</td>
          <td>file exist and is a block-special file</td>
        </tr>
        <tr>
          <td>-c file</td>
          <td>file exist and is a char-special file</td>
        </tr>
        <tr>
          <td>-d file</td>
          <td>file exists and is a dir</td>
        </tr>
        <tr>
          <td>-e file</td>
          <td>file exists</td>
        </tr>
        <tr>
          <td>-f file</td>
          <td>file exists and a regular file</td>
        </tr>
        <tr>
          <td>-g file</td>
          <td>file exists and is set-group-id</td>
        </tr>
        <tr>
          <td>-G file</td>
          <td>file exists and is owner by the effective group ID</td>
        </tr>
        <tr>
          <td>-k file</td>
          <td>file exists and has its ‘sticky bit’ sit</td>
        </tr>
        <tr>
          <td>-L file</td>
          <td>file exists and is a sym link</td>
        </tr>
        <tr>
          <td>-p file</td>
          <td>file exists and a named pipe</td>
        </tr>
        <tr>
          <td>-r file</td>
          <td>file exists and can readable</td>
        </tr>
        <tr>
          <td>-s file</td>
          <td>file exists and has a length greater than zero</td>
        </tr>
        <tr>
          <td>-S file</td>
          <td>file exists and a socket</td>
        </tr>
        <tr>
          <td>-w file</td>
          <td>file exists and writable</td>
        </tr>
        <tr>
          <td>-x fiel</td>
          <td>file exists and executeable</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <p>string expression</p>

    <table>
      <thead>
        <tr>
          <th>Expression</th>
          <th>Meaning</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>string</td>
          <td>string is not null</td>
        </tr>
        <tr>
          <td>-n string</td>
          <td>string len is not zero</td>
        </tr>
        <tr>
          <td>-z string</td>
          <td>string len is zero</td>
        </tr>
        <tr>
          <td>str1 == str2</td>
          <td>equal</td>
        </tr>
        <tr>
          <td>str1 != str2</td>
          <td>not equal</td>
        </tr>
        <tr>
          <td>str1 &gt; str2</td>
          <td>str1 sorts after str2</td>
        </tr>
        <tr>
          <td>str1 &lt; str2</td>
          <td>str1 sort before str2</td>
        </tr>
      </tbody>
    </table>

    <blockquote>
      <p>这里面 需要注意: the &gt; and &lt; expression operators must be quoted (or escaped with a backslash) when used with test. If they are not, they will be interpreted by the<br />
shell as redirection operators</p>
    </blockquote>
  </li>
  <li>
    <p>Integer Expressions</p>

    <table>
      <thead>
        <tr>
          <th>Expression</th>
          <th>Meaning</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>int1 -eq int2</td>
          <td>equal</td>
        </tr>
        <tr>
          <td>int1 -ne int2</td>
          <td>not equal</td>
        </tr>
        <tr>
          <td>int1 -le int2</td>
          <td>int1 &lt;= int2</td>
        </tr>
        <tr>
          <td>int1 -lt int2</td>
          <td>int1 &lt; int2</td>
        </tr>
        <tr>
          <td>int1 -ge int2</td>
          <td>int1 &gt;= int2</td>
        </tr>
        <tr>
          <td>int1 -gt int2</td>
          <td>int1 &gt; int2</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>[[ expression ]] : 类似于 [ expression ], 大使可以测试 string1 =~ regex</li>
  <li>(( )): Designed for Integers, 用于测试 数学计算， 如果 数值 为非0 则是true， 0 则为false。在(()) 中变量可以直接 使用，不用带 $, 例如, 在其中 可以使用 所有的数学表达式，比如 &gt;, &lt;, &gt;=, &lt;=, ==, %, /, * etc</li>
</ul>

<div class="highlight"><pre class="highlight shell"><code>  <span class="nv">INT</span><span class="o">=</span>5
  <span class="k">if</span> <span class="o">((</span>INT <span class="o">==</span> 0<span class="o">))</span><span class="p">;</span> <span class="k">then
      </span><span class="nb">echo</span> <span class="s2">"INT is zero"</span>
  <span class="k">fi</span>
</code></pre></div><ul>
  <li>
    <p>Combining Expressions:</p>

    <table>
      <thead>
        <tr>
          <th>Operation</th>
          <th>test</th>
          <th>[[]] and (())</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>AND</td>
          <td>-a</td>
          <td>&amp;&amp;</td>
        </tr>
        <tr>
          <td>OR</td>
          <td>-o</td>
          <td> </td>
        </tr>
        <tr>
          <td>NOT</td>
          <td>!</td>
          <td>!</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <p>for example:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c">#!/bin/bash</span>

<span class="nv">MIN_VAL</span><span class="o">=</span>1
<span class="nv">MAX_VAL</span><span class="o">=</span>100


<span class="nv">INT</span><span class="o">=</span>50
<span class="k">if</span> <span class="o">[[</span> <span class="s2">"</span><span class="nv">$INT</span><span class="s2">"</span> <span class="o">=</span>~ ^-?[0-9]+<span class="nv">$ </span><span class="o">]]</span><span class="p">;</span> <span class="k">then
    if</span> <span class="o">[[</span> <span class="s2">"</span><span class="nv">$INT</span><span class="s2">"</span> <span class="nt">-ge</span> <span class="s2">"</span><span class="nv">$MIN_VAL</span><span class="s2">"</span> <span class="o">&amp;&amp;</span> <span class="s2">"</span><span class="nv">$INT</span><span class="s2">"</span> <span class="nt">-le</span> <span class="s2">"</span><span class="nv">$MAX_VAL</span><span class="s2">"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
        </span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$INT</span><span class="s2"> is within </span><span class="nv">$MIN_VAL</span><span class="s2"> to </span><span class="nv">$MAX_VAL</span><span class="s2">."</span>
    <span class="k">else
        </span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$INT</span><span class="s2"> is out of range."</span>
    <span class="k">fi
else
    </span><span class="nb">echo</span> <span class="s2">"INT is not an integer."</span> <span class="o">&gt;</span>&amp;2
    <span class="nb">exit </span>1
<span class="k">fi</span>


<span class="c"># 等价的另一种方式</span>

<span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$INT</span><span class="s2">"</span> <span class="nt">-ge</span> <span class="s2">"</span><span class="nv">$MIN_VAL</span><span class="s2">"</span> <span class="nt">-a</span> <span class="s2">"</span><span class="nv">$INT</span><span class="s2">"</span> <span class="nt">-le</span> <span class="s2">"</span><span class="nv">$MAX_VAL</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$INT</span><span class="s2"> is within </span><span class="nv">$MIN_VAL</span><span class="s2"> to </span><span class="nv">$MAX_VAL</span><span class="s2">."</span>
<span class="k">else
  </span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$INT</span><span class="s2"> is out of range."</span>
<span class="k">fi</span>
</code></pre></div>  </li>
</ul>

<h4 id="read-read-用于-从标准输入中-读取数值">read: read 用于 从标准输入中 读取数值。</h4>

<table>
  <thead>
    <tr>
      <th>Options</th>
      <th>Desc</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>-a array</td>
      <td>将输入赋值（转化）给 数组</td>
    </tr>
    <tr>
      <td>-e</td>
      <td>使用 Readline 模式 处理输入</td>
    </tr>
    <tr>
      <td>-i string</td>
      <td>默认数值，在玩家仅仅按 enter的时候 有用</td>
    </tr>
    <tr>
      <td>-p prompt</td>
      <td>输入的 提示信息</td>
    </tr>
    <tr>
      <td>-r</td>
      <td>Raw mode. Do not interpret backslash characters as escapes.</td>
    </tr>
    <tr>
      <td>-s</td>
      <td>slient mode, 用于密码输入</td>
    </tr>
    <tr>
      <td>-t seconds</td>
      <td>Timeout after seconds</td>
    </tr>
    <tr>
      <td>-u fd</td>
      <td>使用file 作为输入，而不是标准输入</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>read：将 标准输入 转到 变量 的使用格式： read  [-options] [variable…]</li>
  <li>read 存在默认变量 REPLY，即当没有 variable 传递的时候</li>
  <li>for example</li>
</ul>

<div class="highlight"><pre class="highlight shell"><code>  <span class="c">#!/bin/bash</span>

  <span class="nb">echo</span> <span class="nt">-n</span> <span class="s2">"please enter an integer -&gt; "</span>
  <span class="nb">read </span>int

  <span class="k">if</span> <span class="o">[[</span> <span class="s2">"</span><span class="nv">$int</span><span class="s2">"</span> <span class="o">=</span>~ ^-?[0-9]+<span class="nv">$ </span><span class="o">]]</span><span class="p">;</span> <span class="k">then
      if</span> <span class="o">((</span> int <span class="o">==</span> 0 <span class="o">))</span><span class="p">;</span> <span class="k">then
          </span><span class="nb">echo</span> <span class="s2">"int is zero"</span>
      <span class="k">else
          if</span> <span class="o">((</span> int &lt; 0<span class="o">))</span><span class="p">;</span> <span class="k">then
              </span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$int</span><span class="s2"> is negative"</span>
          <span class="k">else
              </span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$int</span><span class="s2"> is positive"</span>
          <span class="k">fi
      fi
  fi</span>

  <span class="c">#  read 多个var 测试, 与ruby array 复制差不多，</span>
  <span class="c"># 即是：当多个 参数数目 &gt; 变量数目 时 剩余的变量为空值，当 参数数目 &lt; 变量数目时 最后后一个变量 存储多个数值</span>

  <span class="c">#!/bin/bash</span>
  <span class="c"># read-multiple: read multiple values from keyboard</span>
  <span class="nb">echo</span> <span class="nt">-n</span> <span class="s2">"Enter one or more values &gt; "</span>
  <span class="nb">read </span>var1 var2 var3 var4 var5
  <span class="nb">echo</span> <span class="s2">"var1 = '</span><span class="nv">$var1</span><span class="s2">'"</span>
  <span class="nb">echo</span> <span class="s2">"var2 = '</span><span class="nv">$var2</span><span class="s2">'"</span>
  <span class="nb">echo</span> <span class="s2">"var3 = '</span><span class="nv">$var3</span><span class="s2">'"</span>
  <span class="nb">echo</span> <span class="s2">"var4 = '</span><span class="nv">$var4</span><span class="s2">'"</span>
  <span class="nb">echo</span> <span class="s2">"var5 = '</span><span class="nv">$var5</span><span class="s2">'"</span>

  vagrant@precise64:/vagrant_data/shell_test<span class="nv">$ </span>./read-multiple.sh
  Enter one or more values <span class="o">&gt;</span> 1 2 3 4 4 45 5
  var1 <span class="o">=</span> <span class="s1">'1'</span>
  var2 <span class="o">=</span> <span class="s1">'2'</span>
  var3 <span class="o">=</span> <span class="s1">'3'</span>
  var4 <span class="o">=</span> <span class="s1">'4'</span>
  var5 <span class="o">=</span> <span class="s1">'4 45 5'</span>

  vagrant@precise64:/vagrant_data/shell_test<span class="nv">$ </span>./read-multiple.sh
  Enter one or more values <span class="o">&gt;</span> 1
  var1 <span class="o">=</span> <span class="s1">'1'</span>
  var2 <span class="o">=</span> <span class="s1">''</span>
  var3 <span class="o">=</span> <span class="s1">''</span>
  var4 <span class="o">=</span> <span class="s1">''</span>
  var5 <span class="o">=</span> <span class="s1">''</span>

  <span class="c"># read 不传递 var 时候，默认使用变量 REPLY</span>
  <span class="c">#!/bin/bash</span>
  <span class="c"># read-single: read multiple values into default variable</span>
  <span class="nb">echo</span> <span class="nt">-n</span> <span class="s2">"Enter one or more values &gt; "</span>
  <span class="nb">read
  echo</span> <span class="s2">"REPLY = '</span><span class="nv">$REPLY</span><span class="s2">'"</span>

  vagrant@precise64:/vagrant_data/shell_test<span class="nv">$ </span>./read-single.sh
  Enter one or more values <span class="o">&gt;</span> 1
  REPLY <span class="o">=</span> <span class="s1">'1'</span>



</code></pre></div>
<ul>
  <li>IFS （Internal Field Separator） : 用来控制 read 分隔line 的分隔符， 默认的IFS 包含 space, tab, newline</li>
  <li>
    <p>使用read的 这种方式， 可以很简单的 做 字符串的 split</p>

<div class="highlight"><pre class="highlight shell"><code><span class="nv">IFS</span><span class="o">=</span><span class="s2">":"</span> <span class="nb">read </span>user pw uid gid name home shell <span class="o">&lt;&lt;&lt;</span> <span class="s2">"root:x:0:0:root:/root:/bin/bash"</span>
<span class="nb">echo</span> <span class="s2">"string: </span><span class="k">${</span><span class="nv">user</span><span class="k">}</span><span class="s2">, pw: </span><span class="k">${</span><span class="nv">pw</span><span class="k">}</span><span class="s2">, uid: </span><span class="k">${</span><span class="nv">uid</span><span class="k">}</span><span class="s2">, shell: </span><span class="k">${</span><span class="nv">shell</span><span class="k">}</span><span class="s2">"</span>
</code></pre></div>  </li>
</ul>

<h4 id="flow-control-looping-with-whileuntil">Flow Control: Looping with while/until</h4>
<ul>
  <li>while: shell 中 同样存在 continue break 可供使用，以便提前 循环、或者 终止循环</li>
</ul>

<div class="highlight"><pre class="highlight shell"><code>  <span class="k">while </span>commands<span class="p">;</span> <span class="k">do
      </span>commands
  <span class="k">done


  </span><span class="nv">count</span><span class="o">=</span>1
  <span class="k">while</span> <span class="o">[[</span> <span class="s2">"</span><span class="nv">$count</span><span class="s2">"</span> <span class="nt">-le</span> 5 <span class="o">]]</span><span class="p">;</span>
      <span class="k">do </span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$count</span><span class="s2">"</span>
      <span class="nv">count</span><span class="o">=</span><span class="k">$((</span>count <span class="o">+</span> <span class="m">1</span><span class="k">))</span>
  <span class="k">done
  </span><span class="nb">echo</span> <span class="s2">"Finished."</span>
</code></pre></div><ul>
  <li>until: 与while 同样的基本结构，不过测试条件相反</li>
</ul>

<div class="highlight"><pre class="highlight shell"><code>  <span class="c">#!/bin/bash</span>
  <span class="c"># until-count: display a series of numbers count=1</span>
  <span class="k">until</span> <span class="o">[[</span> <span class="s2">"</span><span class="nv">$count</span><span class="s2">"</span> <span class="nt">-gt</span> 5 <span class="o">]]</span><span class="p">;</span> <span class="k">do
      </span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$count</span><span class="s2">"</span>
      <span class="nv">count</span><span class="o">=</span><span class="k">$((</span>count <span class="o">+</span> <span class="m">1</span><span class="k">))</span>
  <span class="k">done
  </span><span class="nb">echo</span> <span class="s2">"Finished."</span>
</code></pre></div>
<ul>
  <li>
    <p>读取文件的循环示例：</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c">#!/bin/bash</span>
<span class="c"># while-read: read lines from a file</span>
<span class="k">while </span><span class="nb">read </span>distro version release<span class="p">;</span> <span class="k">do
    </span><span class="nb">printf</span> <span class="s2">"Distro: %s</span><span class="se">\t</span><span class="s2">Version: %s</span><span class="se">\t</span><span class="s2">Released: %s</span><span class="se">\n</span><span class="s2">"</span> <span class="se">\</span>
        <span class="s2">"</span><span class="nv">$distro</span><span class="s2">"</span> <span class="se">\</span>
        <span class="s2">"</span><span class="nv">$version</span><span class="s2">"</span> <span class="se">\</span>
        <span class="s2">"</span><span class="nv">$release</span><span class="s2">"</span>
<span class="k">done</span> &lt; distros.txt
</code></pre></div>  </li>
  <li>
    <p>shell 的测试： 1） 除了 print 大法好(在这里是echo 之外) 2) #!/bin/bash -x  这样在脚本运行期间，将会 展示详细信息, 可以 使用 set +x 关闭 tracing set -x开启 tracing</p>
  </li>
  <li>
    <p>case:  使用 pattern 进行匹配，) 结束 匹配。 还可以参考链接 http://tiswww.case.edu/php/chet/bash/bashref.html#SEC21 http://tldp.org/LDP/abs/html/testbranch.html 因为这里面介绍的十分简单</p>

    <table>
      <thead>
        <tr>
          <th>Pattern</th>
          <th>Desc</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>a)</td>
          <td>Match if word equal ‘a’</td>
        </tr>
        <tr>
          <td>[[:aplpha:]])</td>
          <td>Match if word is a single alphabetic char</td>
        </tr>
        <tr>
          <td>???)</td>
          <td>Match if word is exactly three char long</td>
        </tr>
        <tr>
          <td>*.txt)</td>
          <td>Match if word ends with the char “.txt”</td>
        </tr>
        <tr>
          <td>*)</td>
          <td>Matches anyy value of word</td>
        </tr>
      </tbody>
    </table>

<div class="highlight"><pre class="highlight shell"><code><span class="k">case</span> word <span class="k">in</span>
    <span class="o">[</span>pattern <span class="o">[</span><span class="p">|</span> pattern]...<span class="p">)</span> commands <span class="p">;;</span><span class="o">]</span>...
<span class="k">esac</span>
</code></pre></div>  </li>
  <li>
    <p>for example</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c">#!/bin/bash -x</span>

<span class="nb">read</span> <span class="nt">-p</span> <span class="s2">"Enter selection [0-3] &gt; "</span>
<span class="k">case</span> <span class="s2">"</span><span class="nv">$REPLY</span><span class="s2">"</span> <span class="k">in
    </span>0<span class="p">)</span> <span class="nb">echo</span> <span class="s2">"Program terminated."</span>
       <span class="nb">exit</span>
       <span class="p">;;</span>
    1<span class="p">)</span> <span class="nb">echo</span> <span class="s2">"Hostname: </span><span class="nv">$HOSTNAME</span><span class="s2">"</span>
       <span class="nb">uptime</span>
       <span class="p">;;</span>
    2<span class="p">)</span> <span class="nb">df</span> <span class="nt">-h</span>
       <span class="p">;;</span>
    3<span class="p">)</span> <span class="k">if</span> <span class="o">[[</span> <span class="s2">"</span><span class="si">$(</span><span class="nb">id</span> <span class="nt">-u</span><span class="si">)</span><span class="s2">"</span> <span class="nt">-eq</span> 0 <span class="o">]]</span><span class="p">;</span> <span class="k">then
           </span><span class="nb">echo</span> <span class="s2">"Home Space Utilization (All Users)"</span>
           <span class="nb">du</span> <span class="nt">-sh</span> /home/<span class="k">*</span>
       <span class="k">else
           </span><span class="nb">echo</span> <span class="s2">"Home Space Utilization (</span><span class="nv">$USER</span><span class="s2">)"</span>
           <span class="nb">du</span> <span class="nt">-sh</span> <span class="s2">"</span><span class="nv">$HOME</span><span class="s2">"</span>
       <span class="k">fi</span>
       <span class="p">;;</span>
    <span class="k">*</span><span class="p">)</span> <span class="nb">echo</span> <span class="s2">"Invalid entry"</span> <span class="o">&gt;</span>&amp;2
       <span class="nb">exit </span>1
       <span class="p">;;</span>
<span class="k">esac</span>

</code></pre></div>    <h3 id="accessing-the-command-line">Accessing the Command Line:</h3>
  </li>
  <li>shell 中 通过 $0-$9 来接受 command line 传递的参数。其中9 并不是 参数个数的上线，可以使用 更多的比如 $11, $100000 来使用 第 1000000 个参数。</li>
  <li>$# 标志 参数个数。其中 $0 总是为 shell本身</li>
  <li>shift： shift可以将 将 $1后续的变量，转移到 $1上， 同时 $# 减少</li>
</ul>

<div class="highlight"><pre class="highlight shell"><code>  <span class="c">#!/bin/bash</span>
  <span class="c"># posit-param2: script to display all arguments count=1</span>
  <span class="k">while</span> <span class="o">[[</span> <span class="nv">$# </span><span class="nt">-gt</span> 0 <span class="o">]]</span><span class="p">;</span> <span class="k">do
    </span><span class="nb">echo</span> <span class="s2">"Argument </span><span class="nv">$count</span><span class="s2"> = </span><span class="nv">$1</span><span class="s2">"</span>
    <span class="nv">count</span><span class="o">=</span><span class="k">$((</span>count <span class="o">+</span> <span class="m">1</span><span class="k">))</span>
    <span class="nb">shift
  </span><span class="k">done</span>
</code></pre></div>
<ul>
  <li>同样是 作为 函数 传递参数的方式：</li>
  <li>常量： PROGNAME当前shell运行的函数， FUNCNAME 为shell当前运行的shell函数</li>
  <li>$* $@ “$*” “$@” : “$@” 在这里面是最为 重要的，以为保留了 原来参数传递的样式</li>
</ul>

<div class="highlight"><pre class="highlight shell"><code>// fun_test.sh file
<span class="c">#!/bin/bash</span>
<span class="c"># posit-params3: script to demonstrate $* and $@</span>
print_params <span class="o">()</span> <span class="o">{</span>
    <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">1 = </span><span class="nv">$1</span><span class="s2">"</span>
    <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">2 = </span><span class="nv">$2</span><span class="s2">"</span>
    <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">3 = </span><span class="nv">$3</span><span class="s2">"</span>
    <span class="nb">echo</span> <span class="s2">"</span><span class="se">\$</span><span class="s2">4 = </span><span class="nv">$4</span><span class="s2">"</span>
<span class="o">}</span>
pass_params <span class="o">()</span> <span class="o">{</span>
    <span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span> <span class="s1">'$*'</span><span class="p">;</span> print_params <span class="nv">$*</span>
    <span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span> <span class="s1">'$*'</span><span class="p">;</span> print_params <span class="s2">"</span><span class="nv">$*</span><span class="s2">"</span>
    <span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span> <span class="s1">'$@'</span><span class="p">;</span> print_params <span class="nv">$@</span>
    <span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span> <span class="s1">'$@'</span><span class="p">;</span> print_params <span class="s2">"</span><span class="nv">$@</span><span class="s2">"</span>
<span class="o">}</span>
pass_params <span class="s2">"word"</span> <span class="s2">"words with spaces"</span>


// ./fun_test.sh 测试
root@precise64:/vagrant_data/shell_test# ./fun_test.sh

 <span class="nv">$*</span>
<span class="nv">$1</span> <span class="o">=</span> word
<span class="nv">$2</span> <span class="o">=</span> words
<span class="nv">$3</span> <span class="o">=</span> with
<span class="nv">$4</span> <span class="o">=</span> spaces

 <span class="nv">$*</span>
<span class="nv">$1</span> <span class="o">=</span> word words with spaces
<span class="nv">$2</span> <span class="o">=</span>
<span class="nv">$3</span> <span class="o">=</span>
<span class="nv">$4</span> <span class="o">=</span>

 <span class="nv">$@</span>
<span class="nv">$1</span> <span class="o">=</span> word
<span class="nv">$2</span> <span class="o">=</span> words
<span class="nv">$3</span> <span class="o">=</span> with
<span class="nv">$4</span> <span class="o">=</span> spaces

 <span class="nv">$@</span>
<span class="nv">$1</span> <span class="o">=</span> word
<span class="nv">$2</span> <span class="o">=</span> words with spaces
<span class="nv">$3</span> <span class="o">=</span>
<span class="nv">$4</span> <span class="o">=</span>
</code></pre></div>
<h4 id="for-loop">for loop:</h4>
<ul>
  <li>传统形式</li>
</ul>

<div class="highlight"><pre class="highlight shell"><code><span class="k">for </span>variable <span class="o">[</span><span class="k">in </span>words]<span class="p">;</span> <span class="k">do 
  </span>commands
<span class="k">done</span>
</code></pre></div><ul>
  <li>c语言形式： 只支持 在对 数字 进行操作的时候</li>
</ul>

<div class="highlight"><pre class="highlight shell"><code><span class="k">for</span> <span class="o">((</span> expression1<span class="p">;</span> expression2<span class="p">;</span> expression3 <span class="o">))</span><span class="p">;</span> <span class="k">do
  </span>commands
<span class="k">done

for</span> <span class="o">((</span> <span class="nv">i</span><span class="o">=</span>0<span class="p">;</span> i&lt;5<span class="p">;</span> <span class="nv">i</span><span class="o">=</span>i+1 <span class="o">))</span><span class="p">;</span> <span class="k">do
    </span><span class="nb">echo</span> <span class="nv">$i</span>
<span class="k">done</span>
</code></pre></div>
<ul>
  <li>example</li>
</ul>

<div class="highlight"><pre class="highlight shell"><code><span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="k">for </span>i <span class="k">in </span>A B C D<span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="nv">$i</span><span class="p">;</span> <span class="k">done
</span>A
B
C
D


<span class="k">for </span>i <span class="k">in</span> <span class="o">{</span>A..D<span class="o">}</span><span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="nv">$i</span><span class="p">;</span> <span class="k">done
</span>A
B
C
D

<span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="k">for </span>i <span class="k">in </span>distros<span class="k">*</span>.txt<span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$i</span><span class="s2">"</span><span class="p">;</span> <span class="k">done
</span>distros-by-date.txt
distros-dates.txt
distros-key-names.txt
distros-key-vernums.txt
distros-names.txt
distros.txt
distros-vernums.txt
distros-versions.txt



<span class="c"># ./for_test.sh file</span>
<span class="k">for </span>i<span class="p">;</span> <span class="k">do
    </span><span class="nb">echo</span> <span class="s2">"i in ---------- </span><span class="k">${</span><span class="nv">i</span><span class="k">}</span><span class="s2"> </span><span class="se">\n</span><span class="s2">"</span>
<span class="k">done</span>


<span class="c"># 可以使用如此的方式，循环打印 command line 参数</span>
root@precise64:/vagrant_data/shell_test# ./for_test.sh  a b c d e f j
i <span class="k">in</span> <span class="nt">----------</span> a <span class="se">\n</span>
i <span class="k">in</span> <span class="nt">----------</span> b <span class="se">\n</span>
i <span class="k">in</span> <span class="nt">----------</span> c <span class="se">\n</span>
i <span class="k">in</span> <span class="nt">----------</span> d <span class="se">\n</span>
i <span class="k">in</span> <span class="nt">----------</span> e <span class="se">\n</span>
i <span class="k">in</span> <span class="nt">----------</span> f <span class="se">\n</span>
i <span class="k">in</span> <span class="nt">----------</span> j <span class="se">\n</span>

</code></pre></div>
<h3 id="strings-and-numbers">Strings and Numbers</h3>

<table>
  <thead>
    <tr>
      <th>expression</th>
      <th>meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>${para:-word}</td>
      <td>para 为空 express result 为 word</td>
    </tr>
    <tr>
      <td>${para:=word}</td>
      <td>para 为空 express &amp; para result 为 word (position 参数不能够如此赋值)</td>
    </tr>
    <tr>
      <td>${pars:?word}</td>
      <td>pars 为空 则exit，word被输出到 stderr</td>
    </tr>
    <tr>
      <td>${para:+word}</td>
      <td>para不为空，则 expres 为 word</td>
    </tr>
    <tr>
      <td>${!prefix*} 或者  ${!prefix@}</td>
      <td>返回 以 prefix 为前缀的 变量名称</td>
    </tr>
    <tr>
      <td>${#para}</td>
      <td>para length, 如果 para 为 @ 或者 * 则 展开为 command line params size</td>
    </tr>
    <tr>
      <td>${para:offset} ${para:offset:length}</td>
      <td>用于string 的片段截取，没有length时候，则直到末尾, para为 @时候, 则为 参数 从 offset开始 到结尾</td>
    </tr>
    <tr>
      <td>${para#pattern} ${para##pattern}</td>
      <td>将字符串remove pattern match的部分，结果为 剩下的部分， #pattern remove 最短的 match 部分， ## 则remove 最长的match</td>
    </tr>
    <tr>
      <td>${para%pattern}  ${para%%pattern}</td>
      <td>同上，但是 remove 片段从string 的末尾开始，而非开头开始</td>
    </tr>
    <tr>
      <td>${para/pattern/string} ${para//pattern/string} ${para/#pattern/string} ${para/%pattern/string}</td>
      <td>string 的查找替换操作，使用 string 替换 para中的 pattern matched，第一个只替换第一个， 第二个则全部替换， 第三个 则替换开头， 第四个只替换末尾</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>case conversion parameter</li>
</ul>

<table>
  <thead>
    <tr>
      <th>Format</th>
      <th>Result</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>${pars,,}</td>
      <td>展开为  para 的 全部小写形式</td>
    </tr>
    <tr>
      <td>${para,}</td>
      <td>展开式 para 首字母 小写</td>
    </tr>
    <tr>
      <td>${para^^}</td>
      <td>展开为 para 的全部 大写形式</td>
    </tr>
    <tr>
      <td>${para^}</td>
      <td>展开为 para 首字母 大写形式</td>
    </tr>
  </tbody>
</table>

<h4 id="数字操作-expression-基本形式">数字操作: $((expression)) 基本形式</h4>
<ul>
  <li>Operators</li>
</ul>

<table>
  <thead>
    <tr>
      <th>Operator</th>
      <th>Desc</th>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>+</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>-</td>
      <td>*</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>*</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>/</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>**</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>%</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>para = value</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>para += value</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>para -= value</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>para *= value</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>para /= value</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>para %= value</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>para ++</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>para –</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>++ para</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>– para</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>&lt;=</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>&gt;=</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>&lt;</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>&gt;</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
  <tfoot>
    <tr>
      <td>!=</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>&amp;&amp;</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>expre1?expre2:expre3</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
  </tfoot>
</table>

<h4 id="array-bash-version2-才得到支持在原先的shell中-并不支持-array">Array: bash version2 才得到支持，在原先的shell中 并不支持 array</h4>
<ul>
  <li>Create a Array :</li>
</ul>

<div class="highlight"><pre class="highlight shell"><code>a[1]<span class="o">=</span>foo
<span class="nb">echo</span> <span class="k">${</span><span class="nv">a</span><span class="p">[1]</span><span class="k">}</span>

<span class="nb">declare</span> <span class="nt">-a</span> a
</code></pre></div><ul>
  <li>Assigning Values to an Array: name[subscript]=value; name=(value1 value2 …)</li>
  <li>Array Operations: 遍历数组</li>
</ul>

<div class="highlight"><pre class="highlight shell"><code><span class="o">[</span>me@linuxbox ~]<span class="nv">$ animals</span><span class="o">=(</span><span class="s2">"a dog"</span> <span class="s2">"a cat"</span> <span class="s2">"a fish"</span><span class="o">)</span> 
<span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="k">for </span>i <span class="k">in</span> <span class="k">${</span><span class="nv">animals</span><span class="p">[*]</span><span class="k">}</span><span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="nv">$i</span><span class="p">;</span> <span class="k">done 
</span>a
dog
a
<span class="nb">cat
</span>a
fish

<span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="k">for </span>i <span class="k">in</span> <span class="k">${</span><span class="nv">animals</span><span class="p">[@]</span><span class="k">}</span><span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="nv">$i</span><span class="p">;</span> <span class="k">done </span>a
dog
a
<span class="nb">cat
</span>a
fish

<span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="k">for </span>i <span class="k">in</span> <span class="s2">"</span><span class="k">${</span><span class="nv">animals</span><span class="p">[*]</span><span class="k">}</span><span class="s2">"</span><span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="nv">$i</span><span class="p">;</span> <span class="k">done
</span>a dog a <span class="nb">cat </span>a fish

<span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="k">for </span>i <span class="k">in</span> <span class="s2">"</span><span class="k">${</span><span class="nv">animals</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span><span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="nv">$i</span><span class="p">;</span> <span class="k">done
</span>a dog
a <span class="nb">cat
</span>a fish

<span class="c"># "${!array[*]}", "${!array[@]}"</span>
<span class="o">[</span>me@linuxbox ~]<span class="nv">$ foo</span><span class="o">=([</span>2]<span class="o">=</span>a <span class="o">[</span>4]<span class="o">=</span>b <span class="o">[</span>6]<span class="o">=</span>c<span class="o">)</span>

<span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="k">for </span>i <span class="k">in</span> <span class="s2">"</span><span class="k">${</span><span class="nv">foo</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span><span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="nv">$i</span><span class="p">;</span> <span class="k">done 
</span>a
b
c

<span class="c"># 展示数组 有value的 indexs</span>
<span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="k">for </span>i <span class="k">in</span> <span class="s2">"</span><span class="k">${</span><span class="p">!foo[@]</span><span class="k">}</span><span class="s2">"</span><span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="nv">$i</span><span class="p">;</span> <span class="k">done
</span>2
4
6

</code></pre></div>
<ul>
  <li>Sorting an Array:</li>
</ul>

<div class="highlight"><pre class="highlight shell"><code><span class="c">#!/bin/bash</span>
<span class="c"># array-sort: Sort an array a=(f e d c b a)</span>
<span class="nb">echo</span> <span class="s2">"Original array: </span><span class="k">${</span><span class="nv">a</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span>
<span class="c"># 传统的数组排序方式，因为shell并不会构建复杂的 类型系统 来进行 数组函数排序</span>
<span class="nv">a_sorted</span><span class="o">=(</span><span class="si">$(</span><span class="k">for </span>i <span class="k">in</span> <span class="s2">"</span><span class="k">${</span><span class="nv">a</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span><span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="nv">$i</span><span class="p">;</span> <span class="k">done</span> | <span class="nb">sort</span><span class="si">)</span><span class="o">)</span>
<span class="nb">echo</span> <span class="s2">"Sorted array: </span><span class="k">${</span><span class="nv">a_sorted</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span>
</code></pre></div><ul>
  <li>Deleting an Array: unset array; unset ‘array[index]’ array=xxxx 修改 array[0] 中的数值</li>
</ul>

<div class="highlight"><pre class="highlight shell"><code><span class="o">[</span>me@linuxbox ~]<span class="nv">$ foo</span><span class="o">=(</span>a b c d e f<span class="o">)</span>
<span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">echo</span> <span class="k">${</span><span class="nv">foo</span><span class="p">[@]</span><span class="k">}</span>
a b c d e f
<span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">unset </span>foo
<span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">echo</span> <span class="k">${</span><span class="nv">foo</span><span class="p">[@]</span><span class="k">}</span>

<span class="o">[</span>me@linuxbox ~]<span class="err">$</span>


<span class="o">[</span>me@linuxbox ~]<span class="nv">$ foo</span><span class="o">=(</span>a b c d e f<span class="o">)</span>
<span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">echo</span> <span class="k">${</span><span class="nv">foo</span><span class="p">[@]</span><span class="k">}</span>
a b c d e f
<span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">unset</span> <span class="s1">'foo[2]'</span>
<span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">echo</span> <span class="k">${</span><span class="nv">foo</span><span class="p">[@]</span><span class="k">}</span>
a b d e f


<span class="o">[</span>me@linuxbox ~]<span class="nv">$ foo</span><span class="o">=(</span>a b c d e f<span class="o">)</span>
<span class="o">[</span>me@linuxbox ~]<span class="nv">$ foo</span><span class="o">=</span>
<span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">echo</span> <span class="k">${</span><span class="nv">foo</span><span class="p">[@]</span><span class="k">}</span>
b c d e f


<span class="o">[</span>me@linuxbox ~]<span class="nv">$ foo</span><span class="o">=(</span>a b c d e f<span class="o">)</span>
<span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">echo</span> <span class="k">${</span><span class="nv">foo</span><span class="p">[@]</span><span class="k">}</span>
a b c d e f
<span class="o">[</span>me@linuxbox ~]<span class="nv">$ foo</span><span class="o">=</span>A
<span class="o">[</span>me@linuxbox ~]<span class="nv">$ </span><span class="nb">echo</span> <span class="k">${</span><span class="nv">foo</span><span class="p">[@]</span><span class="k">}</span>
A b c d e f
</code></pre></div>
<h4 id="group-commands-and-subshells">Group Commands and Subshells:</h4>
<ul>
  <li>{ command1; command2; [command3; …] }</li>
  <li>(command1; command2; [command3;…])<br />
group commands  可以将  其中的command 的结果 很方便的 合并到一个 数据流汇总，例如：</li>
</ul>

<div class="highlight"><pre class="highlight shell"><code><span class="o">(</span><span class="nb">ls</span> <span class="nt">-l</span><span class="p">;</span> <span class="nb">echo</span> <span class="s2">"Listing of foo.txt"</span><span class="p">;</span> <span class="nb">cat </span>foo.txt<span class="o">)</span> <span class="o">&gt;</span> output.txt
<span class="o">{</span> <span class="nb">ls</span> <span class="nt">-l</span><span class="p">;</span> <span class="nb">echo</span> <span class="s2">"Listing of foo.txt"</span><span class="p">;</span> <span class="nb">cat </span>foo.txt<span class="p">;</span> <span class="o">}</span> <span class="o">&gt;</span> output.txt

<span class="c">#等同于： </span>
<span class="nb">ls</span> <span class="nt">-l</span> <span class="o">&gt;</span> output.txt
<span class="nb">echo</span> <span class="s2">"Listing of foo.txt"</span> <span class="o">&gt;&gt;</span> output.txt
<span class="nb">cat </span>foo.txt <span class="o">&gt;&gt;</span> output.txt

</code></pre></div>
<h4 id="process-substitution-区别于-group-commands--process-sub-运行在-子进程-中而group-command-则运行在当前进程中-所以从效率上来说-group-command-要快于-process-substitution-该技术使得--子进程-中的输出-到当前进程中-进行处理通常-将-子进程中的数据流-输出到当前-进程使用-read-处理">Process Substitution： 区别于 group commands ， Process sub 运行在 子进程 中，而group command 则运行在当前进程中， 所以从效率上来说 group command 要快于 process substitution, 该技术使得  子进程 中的输出 到当前进程中 进行处理。通常 将 子进程中的数据流 输出到当前 进程使用 read 处理。</h4>

<ul>
  <li>形式为： &lt;(list)， &gt;(list)。 for example</li>
</ul>

<div class="highlight"><pre class="highlight shell"><code>
<span class="c">#!/bin/bash</span>
<span class="c"># pro-sub: demo of process substitution</span>
<span class="k">while </span><span class="nb">read </span>attr links owner group size <span class="nb">date time </span>filename<span class="p">;</span> <span class="k">do
done</span> &lt; &lt;<span class="o">(</span><span class="nb">ls</span> <span class="nt">-l</span> | <span class="nb">tail</span> <span class="nt">-n</span> +2<span class="o">)</span>
</code></pre></div>
<h4 id="traps-处理-信号trap-argument-signal-signal--其中-argument-为string-例如">Traps: 处理 信号。trap argument signal [signal…]  其中 argument 为string， 例如：</h4>

<div class="highlight"><pre class="highlight shell"><code><span class="nb">trap</span> <span class="s2">"echo 'I am ignoring you.'"</span> SIGINT SIGTERM

<span class="nb">trap </span>exit_on_signal_SIGINT SIGINT
<span class="nb">trap </span>exit_on_signal_SIGTERM SIGTERM
</code></pre></div>
<h2 id="docker-书籍">Docker 书籍</h2>
<h3 id="docker-的结构--客户端--服务器-docker-服务器-为一个守护进程下层抽象-docker-容器与客户端配合-提供了-一个restful-api-给-客户端">Docker 的结构：  客户端 + 服务器。 Docker 服务器 为一个守护进程，下层抽象 Docker 容器，与客户端配合 提供了 一个RESTful API 给 客户端。</h3>
<h3 id="概念-镜像-与-容器镜像是docker世界的基石类似于-面向对象中的-类-所有容器-都是基于-镜像-运行的也就是说-容器类似于-实例对象镜像-是-docker生命周期-中的-构建或-打包阶段容器则是启动和-执行阶段">概念： 镜像 与 容器。镜像是Docker世界的基石，类似于 面向对象中的 类， 所有容器 都是基于 镜像 运行的。也就是说 容器类似于 实例对象。镜像 是 Docker生命周期 中的 构建或 打包阶段，容器则是启动和 执行阶段。</h3>
<ul>
  <li>Docker容器： 一个镜像格式，一系列标准的操作，一个执行环境
    <h3 id="docker-能够帮助我们做什么">docker 能够帮助我们做什么：</h3>
  </li>
  <li>加速本地开发和构建流程，因为其高效轻量，可以方便本地开发人员进行构建</li>
  <li>能够让独立服务在不同的应用环境中，得到相同的运行结果。</li>
  <li>创建隔离的环境进行测试</li>
  <li>都建一个多用户的平台及服务（PaaS）基础设施</li>
</ul>

<h3 id="docker的特性-linux-namespace-的作用">Docker的特性？ linux namespace 的作用：</h3>
<ul>
  <li>文件系统隔离：每个容器都有自己的root文件系统</li>
  <li>进程隔离： 每个容器都运行在自己的进程环境中</li>
  <li>网络隔离：荣期间的虚拟网络接口和IP地址都是分开的</li>
  <li>资源隔离和分组： 使用cgroups 将CPU 和内存之类的资源独立分配给每个Docker容器</li>
  <li>写时复制： 文件系统都是通过写时复制创建的，这就意味着文件系统是分层的、快速的、占用小的磁盘空间</li>
  <li>日志： 容器产生的STDOUT stderr, stdin 这些IO都会被收集并记录入日志，用来进行日志分析和故常排查</li>
  <li>交互式shell： 用户可以创建一个伪造tty中断连接的，STDIN，为容器提供一个交互式的Shell
    <h3 id="docker-守护进程服务器">Docker 守护进程（服务器）：</h3>
  </li>
  <li>需要以root权限运行，以便处理 诸如 挂载文件系统 等特殊操作。</li>
  <li>守护进程 监听 /var/run/docker.sock Unix套接字 来获得 Docker客户端的请求。</li>
  <li>启动： ubuntu 中 start docker, stop docker， centos 中 service docker stop service docker start
    <h3 id="docker-操作docker容器-则为-docker的运行态运行着-用户的process-容器内部同linux-namespace-一样进行了完全的隔离">Docker 操作：Docker容器 则为 Docker的运行态，运行着 用户的process， 容器内部同linux namespace 一样，进行了完全的隔离</h3>
  </li>
  <li>创建容器： docker run -i -t ubuntu /bin/bash  -i 标志打开容器的STDIN， -t 为容器 分配一个伪 tty 终端</li>
  <li>停止容器： docker stop daemon_dave; docker stop 2q3412c</li>
  <li>删除容器： docker rm daemon_dave // 容器停止运行并不会自动清理，而需要 手动 rm，因为可能存在 重新 start 的需求。类似于进程</li>
  <li>命名容器： docker run –name test_container -i -t ubuntu /bin/bash 容器的命名必须是唯一的。</li>
  <li>创建守护式容器： (daemonized container): docker run –name daemon_dave -d ubuntu /bin/bash -c “while true; do echo hello world; sleep 1; done”//  -d 为 daemon运行的标志， 容器中的进程不能够退出</li>
  <li>重启已经停止的容器： docker start test_container
    <ul>
      <li>附着到容器： docker attach test_container</li>
      <li>查看容器日志： docker logs -f daemon_dave //</li>
      <li>查看容器内进程： docker top daemon_dave</li>
      <li>在容器内运行进程： docker exec -d daemon_dave touch /etc/new_config_file 可以在现有的容器内 启动新进程，无论是后台任务还是交互式任务, docker exec -it <container_id_or_name> /bin/bash</container_id_or_name></li>
      <li>自动重启容器： docker run –restart=always –name daemon_dave // docker可以通过设定  –restart 标志来检测 容器的退出代码 来决定是否重启容器</li>
      <li>深入容器： docker inspect daemon_dave</li>
      <li>查看运行中的容器： docker ps</li>
    </ul>
  </li>
</ul>

<h3 id="docker-镜像">Docker 镜像:</h3>
<ul>
  <li>列出镜像：docker images</li>
  <li>拉取镜像： docker pull ubuntu</li>
  <li>查找镜像: docker search puppet</li>
  <li>使用Dockerfile构建镜像：
    <h4 id="使用dockerfile构建镜像-dockerfile-有一系列-指令和参数构成每条命令-都必须为大写字母-比如-run-from-后面跟随参数-dockerfile-从上到下执行每条指令都会创建一个新的镜像层并对镜像进行提交流程如下">使用Dockerfile构建镜像： Dockerfile 有一系列 指令和参数构成，每条命令 都必须为大写字母 比如 RUN FROM 后面跟随参数， Dockerfile 从上到下执行，每条指令都会创建一个新的镜像层并对镜像进行提交。流程如下：</h4>
  </li>
</ul>

<div class="highlight"><pre class="highlight shell"><code>FROM ubuntu:14.04
RUN apt-get update
RUN apt-get <span class="nb">install</span> <span class="nt">-y</span> nginx
RUN <span class="nb">echo</span> <span class="s1">'Hi, I am in your container'</span> <span class="o">&gt;</span> /usr/share/nginx/html/index.html
EXPOSE 80

docker build <span class="nt">-t</span><span class="o">=</span><span class="s2">"static_web"</span> ./
docker run <span class="nt">-d</span> <span class="nt">-p</span> 80 <span class="nt">--name</span> static_web static_web nginx <span class="nt">-g</span> <span class="s2">"daemon off;"</span>
</code></pre></div>
<h5 id="1-流程">1. 流程:</h5>
<ul>
  <li>Docker 从基础镜像运行一个容器</li>
  <li>执行一条指令，对容器做出修改</li>
  <li>执行类似docker commit 操作，提交一个新的镜像层</li>
  <li>Docker在基于刚才提交的镜像层运行一个新容器</li>
  <li>执行Dockerfile 中的下一条命令，知道所有指令运行完毕
    <h5 id="2-详细">2. 详细：</h5>
  </li>
  <li>每个Dockerfile 的第一条指令 都是从FROM 开始的，该镜像 被称为基础镜像</li>
  <li>expose 指令 指明 容器 使用的端口号，但 docker 在运行容器时候，并不会打开端口，需要使用指令来明确docker 打开特定的端口号</li>
  <li>Dockerfile 的构建方式，导致如果 在因为一些命令失败，则可以得到一个 最近成功命令 的镜像，可以基于该命令 运行一个交换式的容器 来方便调试, 比如 docker run -t -i 最后commit  /bin/bash
    <h5 id="构建-docker-build--txxxx-">构建: docker build -t=”xxxx” ./</h5>
  </li>
  <li>docker 构建 过程会添加缓存： 可以如此 docker build –no-cache -t=”xxxx” 来跳过缓存</li>
  <li>docker 在修改命令之后的 的命令 重建缓存</li>
  <li>可以添加 ENV REFRESHED_AT 2020-10-09 在头部，当希望 重建镜像时候，可以更改 其时间来 进行  之后命令的重建</li>
  <li>查看镜像： docker images;</li>
  <li>查看镜像的构造过程: docker history</li>
  <li>容器端口： -p 用来指定端口， 方式有： -p 80:80 -p 127.0.0.1:80:80, -p 127.0.0.1::80 -P 前两个指定端口绑定到 容器中的端口， 后面两个则 将随机端口绑定到 容器中的端口， -P 表示 将随机的本地端口 绑定到 Dockerfile中的expose 的端口</li>
</ul>

<h5 id="dockerfile-指令">Dockerfile 指令:</h5>
<ul>
  <li>CMD: 指定容器启动时候的运行的命令， 区分于RUN 为镜像被构建时运行的命令，CMD 则是容器启动时候运行的命令。同docker run时候指定的命令， docker run中的命令会覆盖CMD命令，即 docker run中指定了命令，则CMD中的命令将不会被执行</li>
  <li>ENTRYPOINT： 区分于 CMD，不会被 docker run中的命令 所替代，而是 替代 CMD 一起传递给 ENTRYPOINT，示例：</li>
</ul>

<div class="highlight"><pre class="highlight shell"><code>    ENTRYPOINT <span class="o">[</span><span class="s2">"/usr/sbin/nginx"</span><span class="o">]</span>
    CMD <span class="o">[</span><span class="s2">"-h"</span><span class="o">]</span>

      docker  run <span class="nt">-t</span> <span class="nt">-i</span> static_web <span class="nt">-g</span> <span class="s2">"daemon off;"</span>
    <span class="sb">```</span>
  <span class="k">*</span> WORKDIR: 为后续的指令 执行  设定工作目录， 
  <span class="k">*</span> ENV: 指定环境变量， 在后续的 RUN 中使用，也可以在其他命令中使用环境变量。 该变量 持久的保存到 从我们的镜像创建的任何容器中。 相反 在docker run <span class="nt">-e</span> 中传递的环境变量 则一次性有效
  
    <span class="sb">```</span>shell
    ENV RVM_PATH /home/rvm
    RUN gem <span class="nb">install </span>unicorn
    // 等同于  <span class="nv">RVM_PATH</span><span class="o">=</span>/home/rvm gem <span class="nb">install </span>unicorn

    ENV TARGET_DIR /opt/app
    WORKDIR <span class="nv">$TARGET_DIR</span>
    <span class="sb">```</span>
  <span class="k">*</span> VOLUME: 向 从该镜像创建的容器 添加卷。卷是容器中的特殊目录 ，可以跨越文件系统，进行共享，提供持久化功能，有如下特性
    <span class="k">*</span> 卷 可以再 容器间 共享和重用
    <span class="k">*</span> 一个容器 可以不是必须 和 其他容器共享卷
    <span class="k">*</span> 对卷的修改 立即生效
    <span class="k">*</span> 对卷的修改不会影响镜像
    <span class="k">*</span> 卷会一直存在知道没有任何 容器使用它。<span class="o">(</span>标志着 卷 是由 docker管理的，而非容器，也非操作系统<span class="o">)</span>
    <span class="k">*</span> VOLUME <span class="o">[</span><span class="s2">"/opt/project"</span>, <span class="s2">"/data"</span><span class="o">]</span> 可以使用数组形式 创建多个挂载点
  <span class="k">*</span> ADD: 将 构建环境下 的文件或 目录  复制到 镜像中。ADD software /opt/application/software<span class="p">;</span> ADD <span class="nb">source </span>target 
    <span class="k">*</span> 其中source可以是 文件或者目录 或者url，不能对构建目录之外的文件进行ADD操作。<span class="o">(</span>因为docker只关心 构建环建， 构建环境之外的任何东西 在命令中都是不可用的<span class="o">)</span>
    <span class="k">*</span> target 如果目录不存在的话，则 docker会创建 全路径，新建文件目录的权限 为0755
    <span class="k">*</span> ADD命令会屎之后的命令不能够使用缓存。
    <span class="k">*</span> ADD 会将 归档文件 进行 解压，例如 ADD latest.tar.gz /var/www/wordpress/
  <span class="k">*</span> COPY： 区分于 ADD， copy只做纯粹的复制操作。不会进行解压缩操作.
  <span class="k">*</span> 产出镜像： docker rmi static_web

<span class="c">### 实践：</span>
<span class="nt">-v</span> 允许我们将宿主机的目录作为卷，挂在到容器里。-v <span class="nb">source</span>:target 

<span class="k">*</span> 构建 Redis 镜像

<span class="sb">```</span>shell
FROM ubuntu:14.04
ENV REFRESHED_AT 2020-10-09
RUN apt-get update
RUN apt-get <span class="nt">-y</span> <span class="nb">install </span>redis-server redis-tools
EXPOSE 6379
ENTRYPOINT <span class="o">[</span><span class="s2">"/usr/bin/redis-server"</span><span class="o">]</span>
CMD <span class="o">[]</span>
</code></pre></div><ul>
  <li>连接到 redis 容器: 容器之间 互连。 如果使用 映射到宿主机 的ip 来连接到 对应的容器，在 容器重启之后，因为其port会改变（当然可以使用 参数固定 其对应的宿主机 port） 会导致 之前的链接配置失效，从而无法使用 该种 方法 建立长久的固定的链接。</li>
  <li>docker 提供了另一种方法: –link 使用 该标志 创建两个容器的父子链接。链接让 父容器有能力访问子容器， 并将子容器的一些详细信息分享给父容器，应用程序可以利用 这些信息 建立链接。示例：</li>
</ul>

<div class="highlight"><pre class="highlight shell"><code>docker run  <span class="nt">-d</span> <span class="nt">--name</span> redis_con  redis

docker run <span class="nt">-p</span> 4567 <span class="nt">--name</span> webapp <span class="nt">--link</span> redis:db <span class="nt">-t</span> <span class="nt">-i</span> sinatra /bin/bash
// 该命令中 使用--link标志创建了  sinatra 到 redis_conn 的父子链接关系
</code></pre></div><ul>
  <li>链接的特点：
    <ul>
      <li>使子链接 无需公开端口，从而更安全一些。容器端口不需要在宿主机 上 公开，就可以限制被攻击的方面，减少应用暴露的网络</li>
      <li>被连接的容器 必须运行在同一个 Docker宿主机上，不同的Docker宿主机 上的容器不能够互相链接</li>
    </ul>
  </li>
  <li>链接的实现方法： docker 在父容器里的两个地方写入了链接信息。
    <ul>
      <li>/etc/hosts 文件</li>
      <li>包含链接信息的环境变量 ( 自动创建的环境变量包括： 子容器的名字， 子容器服务所运行的 协议 ip 端口 )</li>
    </ul>
  </li>
</ul>

<div class="highlight"><pre class="highlight shell"><code>
docker run <span class="nt">-d</span> <span class="nt">--name</span> redis_con redis
docker run <span class="nt">--link</span> redis:db <span class="nt">-i</span> <span class="nt">-t</span> ubuntu /bin/bash

root@31c4f6ac36a4:/# <span class="nb">cat</span> /etc/hosts
127.0.0.1	localhost
::1	localhost ip6-localhost ip6-loopback
fe00::0	ip6-localnet
ff00::0	ip6-mcastprefix
ff02::1	ip6-allnodes
ff02::2	ip6-allrouters
172.17.0.3	db 949baab68dd4 redis_con
172.17.0.4	31c4f6ac36a4


root@31c4f6ac36a4:/# <span class="nb">env

</span><span class="nv">DB_PORT_6379_TCP_ADDR</span><span class="o">=</span>172.17.0.3
<span class="nv">DB_PORT_6379_TCP</span><span class="o">=</span>tcp://172.17.0.3:6379
<span class="nv">DB_PORT</span><span class="o">=</span>tcp://172.17.0.3:6379
....
</code></pre></div><ul>
  <li>所以： 在应用程序中  通过使用 环境变量 来链接 子容器 是非常方便的方法。</li>
</ul>

<div class="highlight"><pre class="highlight shell"><code>require <span class="s1">'uri

uri = URI.parse(ENV['</span>DB_PORT<span class="s1">'])
redis = Redis.new(:host =&gt; uri.host, :port =&gt; uri.port)
</span></code></pre></div>
<h4 id="实践-通过-jekyll-apache-来构建-自动构建一个博客网站">实践： 通过 Jekyll Apache 来构建 自动构建一个博客网站</h4>

<ul>
  <li>jekyll 镜像</li>
</ul>

<div class="highlight"><pre class="highlight shell"><code>FROM ubuntu:14.04
ENV refreshed_at 2020-10-10

RUN apt-get update
RUN apt-get <span class="nb">install</span> <span class="nt">-y</span> ruby ruby-dev make nodejs
RUN gem <span class="nb">install</span> <span class="nt">--no-rdoc</span> <span class="nt">--no-ri</span> jekyll

VOLUME /data
VOLUME /var/www/html

WORKDIR /data

ENTRYPOINT <span class="o">[</span> <span class="s2">"jekyll"</span>, <span class="s2">"build"</span>, <span class="s2">"--destination=/var/www/html"</span> <span class="o">]</span>

docker build <span class="nt">-t</span> jekyll ./
</code></pre></div>
<ul>
  <li>apache 镜像</li>
</ul>

<div class="highlight"><pre class="highlight shell"><code>FROM ubuntu:14.04
ENV REFRESHED_AT 2020-10-10

RUN apt-get update
RUN apt-get <span class="nb">install</span> <span class="nt">-y</span> apache2

VOLUME <span class="o">[</span> <span class="s2">"/var/www/html"</span> <span class="o">]</span>
WORKDIR /var/www/html

ENV APACHE_RUN_USER www-data
ENV APACHE_RUN_GROUP www-data
ENV APACHE_LOG_DIR /var/logapache2
ENV APACHE_PID_FILE /var/run/apache2.pid
ENV APACHE_RUN_DIR /var/run/apache2
ENV APACHE_LOCK_DIR /var/lock/apache2

RUN <span class="nb">mkdir</span> <span class="nt">-p</span> <span class="nv">$apache_run_dir</span> <span class="nv">$apache_lock_dir</span> <span class="nv">$apache_log_dir</span>
EXPOSE 80

ENTRYPOINT <span class="o">[</span> <span class="s2">"/usr/sbin/apache2"</span> <span class="o">]</span>
CMD <span class="o">[</span><span class="s2">"-D"</span>, <span class="s2">"foreground"</span><span class="o">]</span>

docker build <span class="nt">-t</span> apache ./
</code></pre></div>
<blockquote>
  <p>docker run -v /home/james/blog:/data/ –name jekyll_con jekyll<br />
docker run -d -P –volumns-from jekyll_con –name apache_conn apache<br />
// 这里使用了 标志 –volumes-from 标志 将指定容器 中的所有卷 添加到 新创建 的容器中。意味着容器 apache_conn 可以访问 容器 jekyll_conn 中的所有卷，即： 可以访问 jekyll_conn 产生的博客文件 目录 /var/www/html 中的内容。<br />
// 卷 只有在没有容器 使用的时候才会被清理，也就是说 在 删除 docker rm jekyll_conn 之后 /var/www/html 中的内容就不复存在了 （这里面是否需要 同时删除 apache_conn 才可以？ 因为apache_conn 依然在使用，把持 该卷. 可以进行实验验证）</p>
</blockquote>

<ul>
  <li>备份卷：</li>
</ul>

<blockquote>
  <p>docker run –rm –volumnes-from jekyll_conn -v $(pwd):/backup ubuntu tar cvf /backup/blog.tar /var/www/html<br />
创建一个 docker 容器，将 共享的 /var/www/html 卷，进行打包 到 外部目录中。</p>
</blockquote>

<h4 id="不使用-ssh-管理-docker-容器">不使用 ssh 管理 Docker 容器</h4>

<ul>
  <li>传统上将，通过ssh 登入运行环境或者虚拟机 来管理服务，在Docker世界中， 大部分容器只运行一个进程，所以不能够使用该方法进行访问。可以通过如下方式进行访问： 使用卷 或者 链接 完成大部分管理操作。比如服务通过某个网络接口做管理， 或者使用 Unix套接字 做管理， 就可以通过 卷 来公开这个套接字，或者发信号 可以 docker kill -s <signal> <container></container></signal></li>
  <li>如果是登录 容器，则可以使用 nsenter 工具。使用方法如下：</li>
</ul>

<div class="highlight"><pre class="highlight shell"><code>  <span class="nv">PID</span><span class="o">=</span><span class="si">$(</span>docker inspect <span class="nt">--format</span> <span class="o">{{</span>.State.Pid<span class="o">}}</span> 949baab68dd4<span class="si">)</span>
  nsenter <span class="nt">--target</span> 16870 <span class="nt">--mount</span> <span class="nt">--uts</span> <span class="nt">--ipc</span> <span class="nt">--net</span> <span class="nt">--pid</span>
  nsenter <span class="nt">--target</span> 16870 <span class="nt">--mount</span> <span class="nt">--uts</span> <span class="nt">--ipc</span> <span class="nt">--net</span> <span class="nt">--pid</span> <span class="nb">ls</span>
</code></pre></div><h4 id="对-docker-容器的编排或者是非常重要的一步-k8s">对 Docker 容器的编排，或者是非常重要的一步. K8s</h4>

<h3 id="-实际中遇到的一些问题">? 实际中遇到的一些问题：</h3>
<h5 id="ssh--ssh-经常使用-ssh-ip-command-可以用来在远端-ip-上执行command-但是-当command存在复杂的-command-比如-for-循环则总是不能够正确执行-比如-sh-2-syntax-error-word-unexpected-expecting-do-在进行了一番查找之后-httpsstackoverflowcomquestions26325685execute-for-loop-over-ssh--发现自己忽略到了-在-command-中的--会会在-shell-传递给-ip-机器-之前就会展开-这将导致--远端ip-接收到的-command并非-我们传递给-ssh的command两种解决办法">ssh：  ssh 经常使用， ssh ip “command” 可以用来在远端 ip 上执行command， 但是 当command存在复杂的 command 比如 for 循环，则总是不能够正确执行， 比如 sh: 2: Syntax error: word unexpected (expecting “do”)， 在进行了一番查找之后， https://stackoverflow.com/questions/26325685/execute-for-loop-over-ssh  发现自己忽略到了 在 command 中的 $ 会，会在 shell 传递给 $ip 机器 之前，就会展开， 这将导致  远端$ip 接收到的 command并非 我们传递给 ssh的command。两种解决办法：</h5>
<ul>
  <li>
    <ol>
      <li>将command 中所有的 $ 进行转义 $</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>将 “command” 替换为 ‘command’, 即展开 command中的所有内容</li>
    </ol>
  </li>
</ul>
<div class="social"></div></article></main><footer><div class="footer-wrapper"><div class="author"><div class="image-wrapper"><a href="/author/"><img alt="author" src="../../../../images/profile-1e71686a.png" /></a></div></div><div class="image-content"><img src="../../../../images/wechat_nasa-0d87c0dd.png" /></div><div class="copyright"><i class="fa fa-copyright"></i> 2022 <a href="/">日常学习</a> - geniousbar</div></div><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?b43ef53b285c49e1af0bd7080994c825";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script></footer></body></html>