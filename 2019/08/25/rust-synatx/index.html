<!DOCTYPE html><html><head><meta charset="utf-8" /><meta content="IE=edge;chrome=1" http-equiv="X-UA-Compatible" /><meta content="initial-scale=1.0, user-scalable=no" name="viewport" /><title>rust synatx | 日常学习</title><meta description="Ownership Rules     Each value in Rust has a variable that’s called its owner.   There can only be one owner at a time.   When the owner goes out of scope, the value will be dropped.   Scope : { //scope }   内存申请 let s = String::from(“xx”);   内存释放：..." /><link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/feed.xml" /><link href="../../../../stylesheets/style-198d4031.css" rel="stylesheet" type="text/css" /><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" /><link href="../../../../images/favicon-6c3f3d04.png" rel="icon" type="image/png" /><script src="../../../../javascripts/all-b3988275.js"></script></head><body><header><div class="top-menu"><div class="top-menu-wrapper"><div class="top-menu-list"><ul><li><a href="/">Home</a></li><li><a href="/archives/">Archives</a></li><li><a href="/tags/">Tags</a></li><li><a href="/by-year/">By Year</a></li><li id="wechat"><a href="#" onclick="toggleShowWechat()">Wechat</a></li></ul></div></div></div><div id="header-wechat-img"><img src="../../../../images/wechat_nasa-0d87c0dd.png" /></div><h1 class="logo"><a href="/" title="日常学习"><span class="logo-text">日常学习</span></a></h1></header><main><article><h1 class="article-title">rust synatx</h1><div class="posted-date-wrapper"><i class="fa fa-clock-o"></i><span class="posted-date">August 25, 2019</span></div><div class="tag-labels"><a href="/tags/rust/"><small class="tag-label">rust</small></a></div><hr class="article-header-separator" /><h3 id="ownership-rules">Ownership Rules</h3>

<ul>
  <li>Each value in Rust has a variable that’s called its owner.</li>
  <li>There can only be one owner at a time.</li>
  <li>When the owner goes out of scope, the value will be dropped.</li>
</ul>

<p>Scope : { //scope }<br />
  内存申请 let s = String::from(“xx”);<br />
  内存释放： s 超出scop，变为不可用。rust自动添加drop调动代码， 归还内存<br />
  所有权规则：</p>

<p>堆、栈 中变量的其他 赋值方式：</p>
<ul>
  <li>
    <p>stack-only: copy</p>

<div class="highlight"><pre class="highlight rust"><code><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="c">// x, y  都可用， 因为x 为栈上分配， 对于内存方式为 copy， 不影响所有权</span>
</code></pre></div>  </li>
  <li>
    <p>Heap: clone、所有权转移</p>
  </li>
</ul>

<div class="highlight"><pre class="highlight rust"><code>  <span class="k">let</span> <span class="n">s1</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>
  <span class="k">let</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">s1</span><span class="nf">.clone</span><span class="p">();</span><span class="c">// s2 copy s1的内存，s1 依然可用</span>
</code></pre></div><div class="highlight"><pre class="highlight rust"><code>  <span class="k">let</span> <span class="n">s1</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"xx"</span><span class="p">);</span>
  <span class="k">let</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">s1</span><span class="p">;</span> <span class="c">// s1 不在可用， s2为 字符串的 owner, 这里只是转移 指向 string的指针，而非 copy string</span>
</code></pre></div>
<h3 id="function-调用">Function 调用：</h3>
<ul>
  <li>Function 调用参数： 跟 赋值 一样的所有权  转移一样</li>
  <li>Function 返回参数： 堆上的内存，作为返回值的时候， 两种情况： 1. 转移所有权 到 函数调用者 2. drop掉 （因为超过 函数中的作用域 scope）</li>
</ul>

<h3 id="引用-function-调用-每次都需要转移所有权在将所有权转回到调用者非常麻烦-所以设计了-引用">引用： Function 调用： 每次都需要转移所有权，在将所有权转回到调用者。非常麻烦， 所以设计了 引用</h3>
<p><strong>指向变量的指针， 并不具有 ownership， 所以drop并不会，释放内存，使得引用的变量不可用。在Function 中使用 非常合适，因为不需要ownership传递回去， 因为根本没有ownership的转移</strong></p>

<ul>
  <li>可变 mut 引用: 可以 改变 引用指向的内容。</li>
  <li>不可变引用</li>
  <li>引用 规则:<br />
    1. 任何时候，只有一个 可更改引用，或者 同时多个不可变应用<br />
    2. 引用需要总是有效的。即： 引用的scope应该小于变量的scope</li>
</ul>

<div class="highlight"><pre class="highlight rust"><code>  <span class="k">fn</span> <span class="nf">no_dangle</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nb">String</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>
    <span class="o">&amp;</span><span class="n">s</span>
  <span class="p">}</span>
  <span class="c">// 函数返回， s 会drop掉， 所以会造成空指针 null reference</span>
</code></pre></div><p>错误的函数，s在 函数中分配内存，但是只返回引用，<strong>引用变量作用于大于 指向的变量作用域</strong><br />
  <em>slice: 同refrence， 引用一个连续的collection，但是没有ownership。 这里用来防止，在同样的作用域使用 mut refrence， 或者 mut 调用 (因为不能同时存在  mut 引用，和 非mut引用。所以自动的添加一份检查)</em></p>

<h3 id="generic-define--syntax">Generic define &amp; syntax</h3>
<p>定义 函数参数签名（告诉编译器 参数类型）, 形式如下:</p>

<div class="highlight"><pre class="highlight rust"><code>  <span class="k">fn</span> <span class="n">largest</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">list</span><span class="p">:</span><span class="o">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="n">T</span> <span class="p">{</span>
  <span class="p">}</span>

  <span class="k">struct</span> <span class="n">Point</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
      <span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
      <span class="n">y</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
  <span class="p">}</span>
  <span class="c">// x, y 是同一类型， 也可以写成不一样的类型</span>
  <span class="k">struct</span> <span class="n">Point</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="o">&gt;</span> <span class="p">{</span>
      <span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
      <span class="n">y</span><span class="p">:</span> <span class="n">U</span><span class="p">,</span>
  <span class="p">}</span>

  <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Point</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">x</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">T</span> <span class="p">{</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="py">.x</span>
    <span class="p">}</span>
  <span class="p">}</span> 
  <span class="c">// 这里为什么显得如此怪异的原因， 在于 我们可以写出 impl Point&lt;String&gt; 来定定制 T=String 时候特有的方法定义。所以我们需要写成如此 impl&lt;T&gt; 来区分于 impl Point&lt;String&gt; , 声明 T 代表是一个place holder</span>
</code></pre></div><p>**这里为什么显得如此怪异的原因， 在于 我们可以写出 impl Point<String> 来定定制 T=String 时候特有的方法定义。所以我们需要写成如此 impl<T> 来区分于 impl Point<String> , 声明 T 代表是一个place holder**
并不会牺牲性能，没有runtime的耗时， 在编译阶段， rust 会填充 placeholder, 来完成， 不同类型的定义。</String></T></String></p>

<h3 id="trait-defining-shared-behavior">Trait: Defining Shared Behavior</h3>
<ul>
  <li>impl 定义 及其 实现</li>
</ul>

<div class="highlight"><pre class="highlight rust"><code>    <span class="k">pub</span> <span class="k">trait</span> <span class="n">Summary</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">summarize</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span><span class="k">-&gt;</span> <span class="nb">String</span><span class="p">;</span>
        <span class="k">fn</span> <span class="nf">speak</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.summarize</span><span class="p">();</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"speak"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">struct</span> <span class="n">NewsArticle</span> <span class="p">{</span>
    <span class="p">}</span>

    <span class="k">impl</span> <span class="n">Summary</span> <span class="k">for</span> <span class="n">NewsArticle</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">summarize</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"---------"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div><ul>
  <li>Trait 类似于Interface， 共享 行为（函数） 定义，还可以 实现 类似 模板调用的方法。</li>
  <li>Trait 当 Function 参数</li>
</ul>

<div class="highlight"><pre class="highlight rust"><code>    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">notify</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Summary</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"---------"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c">// Trait Bound syntax</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">notify</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Summary</span><span class="o">&gt;</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
          <span class="nd">println!</span><span class="p">(</span><span class="s">"---------"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c">// multiple Trait Bound</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">notify</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Summary</span> <span class="o">+</span> <span class="n">Display</span><span class="o">&gt;</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
          <span class="nd">println!</span><span class="p">(</span><span class="s">"---------"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c">// use where</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">some_function</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">one</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">two</span><span class="p">:</span> <span class="n">U</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="n">Display</span> <span class="o">+</span> <span class="n">Clone</span><span class="p">,</span>
              <span class="n">U</span><span class="p">:</span> <span class="n">Clone</span> <span class="o">+</span> <span class="n">Debug</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"---------"</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div>
<ul>
  <li>Trait 当做Function 的return type, 但是 存在一些限制： 主要有， 返回值不能是不同类型， 而只能是一个确定的类型 impl trait（例如{} 中 通过if else 返回一个完全不同类型，却实现了同样的Trait 的类型）</li>
  <li>Trait with Generic 可以 约束 impl Generic 的 类型为实现了 Trait 的类型。</li>
</ul>

<div class="highlight"><pre class="highlight rust"><code>  <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Display</span> <span class="o">+</span> <span class="n">PartialOrd</span><span class="o">&gt;</span> <span class="n">Point</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
      <span class="k">fn</span> <span class="nf">only_some</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">}</span><span class="c">// 只有实现了 Display &amp; PartialOrd trait的 Point&lt;_&gt; 类型，才会有 only_some 方法</span>
  <span class="p">}</span>
</code></pre></div><ul>
  <li>Advanced Traits: Traits with placeholder</li>
</ul>

<div class="highlight"><pre class="highlight rust"><code>    <span class="k">pub</span> <span class="k">trait</span> <span class="n">Iterator</span> <span class="p">{</span>
      <span class="k">type</span> <span class="n">Item</span><span class="p">;</span>

       <span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nn">Self</span><span class="p">::</span><span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">impl</span> <span class="n">Iterator</span> <span class="k">for</span> <span class="n">Counter</span> <span class="p">{</span>
        <span class="k">type</span> <span class="n">Item</span> <span class="o">=</span> <span class="nb">u32</span><span class="p">;</span>

        <span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nn">Self</span><span class="p">::</span><span class="n">Item</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div><p>为什么不适用这样的实现呢？</p>

<div class="highlight"><pre class="highlight rust"><code>  <span class="k">pub</span> <span class="k">trait</span> <span class="n">Iterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
      <span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div><p>原因在于 如果采用第二种实现， 我们需要 写成这样</p>

<div class="highlight"><pre class="highlight rust"><code>  <span class="k">impl</span> <span class="n">Iterator</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Counter</span> <span class="p">{</span>

  <span class="p">}</span>
  <span class="k">impl</span> <span class="n">Iterator</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Counter</span> <span class="p">{</span>

  <span class="p">}</span>
</code></pre></div><p>这里面存在多种实现方式。 更重要的是，我们在调用next时候，需要显式的指定 .next::&lt;Iterator<String>&gt; 来 指导 rust使用哪个Iterator<T> for Counter 的代码实现。所以第一种更可取
但是确实存在 Generic 与 Trait 结合的例子：</T></String></p>

<div class="highlight"><pre class="highlight rust"><code>
<span class="k">trait</span> <span class="nb">Add</span><span class="o">&lt;</span><span class="n">RHS</span><span class="o">=</span><span class="n">Self</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Output</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="n">RHS</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">Self</span><span class="p">::</span><span class="n">Output</span><span class="p">;</span>
<span class="p">}</span>

<span class="c">// 常用的声明可以如下:</span>
<span class="k">struct</span> <span class="n">Point</span> <span class="p">{</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">Add</span> <span class="k">for</span> <span class="n">Point</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">Point</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Point</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Point</span> <span class="p">{</span>
        <span class="n">Point</span> <span class="p">{</span>
            <span class="n">x</span><span class="p">:</span> <span class="k">self</span><span class="py">.x</span> <span class="o">+</span> <span class="n">other</span><span class="py">.x</span><span class="p">,</span>
            <span class="n">y</span><span class="p">:</span> <span class="k">self</span><span class="py">.y</span> <span class="o">+</span> <span class="n">other</span><span class="py">.y</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c">// 然而我们依然可以这样，指定 RHS Generic参数， 来实现， Millimeters + Meters 的函数调用实现, 只不过，placeholder 并没有作为返回值，所有，可以直接+ 而不需要显示的，指定 + 之后的返回数值类型</span>
<span class="k">struct</span> <span class="nf">Millimeters</span><span class="p">(</span><span class="nb">u32</span><span class="p">);</span>
<span class="k">struct</span> <span class="nf">Meters</span><span class="p">(</span><span class="nb">u32</span><span class="p">);</span>

<span class="k">impl</span> <span class="nb">Add</span><span class="o">&lt;</span><span class="n">Meters</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Millimeters</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">Millimeters</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Meters</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Millimeters</span> <span class="p">{</span>
        <span class="nf">Millimeters</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span> <span class="o">+</span> <span class="p">(</span><span class="n">other</span><span class="na">.0</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>多个Trait 出现同样函数名字的情况：</p>

<div class="highlight"><pre class="highlight rust"><code>
<span class="k">trait</span> <span class="n">Pilot</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fly</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">trait</span> <span class="n">Wizard</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fly</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="c">//两个 Trait 拥有同样的函数名称，不同的函数实现。那如何在调用时候，决策函数调用实体呢？</span>
<span class="k">struct</span> <span class="n">Human</span><span class="p">;</span>

<span class="k">impl</span> <span class="n">Pilot</span> <span class="k">for</span> <span class="n">Human</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fly</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"This is your captain speaking."</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Wizard</span> <span class="k">for</span> <span class="n">Human</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fly</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Up!"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Human</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fly</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"*waving arms furiously*"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c">// 下面，person.fly 默认调用 Human 自己的实现， 如果需要 显式的调用 Pilot::fly 则需要， 如下格式</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">person</span> <span class="o">=</span> <span class="n">Human</span><span class="p">;</span>
    <span class="n">person</span><span class="nf">.fly</span><span class="p">();</span>
    <span class="nn">Pilot</span><span class="p">::</span><span class="nf">fly</span><span class="p">(</span><span class="o">&amp;</span><span class="n">person</span><span class="p">);</span>
    <span class="nn">Wizard</span><span class="p">::</span><span class="nf">fly</span><span class="p">(</span><span class="o">&amp;</span><span class="n">person</span><span class="p">);</span>
    <span class="n">person</span><span class="nf">.fly</span><span class="p">();</span>
<span class="p">}</span>
<span class="c">// 因为其为实例方法， 存在&amp;self， 如果不存在呢？ 下面示例:</span>

<span class="k">trait</span> <span class="n">Animal</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">baby_name</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">String</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Dog</span><span class="p">;</span>

<span class="k">impl</span> <span class="n">Dog</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">baby_name</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Spot"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Animal</span> <span class="k">for</span> <span class="n">Dog</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">baby_name</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"puppy"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"A baby dog is called a {}"</span><span class="p">,</span> <span class="nn">Dog</span><span class="p">::</span><span class="nf">baby_name</span><span class="p">());</span><span class="c">// Ok</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"A baby dog is called a {}"</span><span class="p">,</span> <span class="nn">Animal</span><span class="p">::</span><span class="nf">baby_name</span><span class="p">());</span> <span class="c">// Error, 下面是正解</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"A baby dog is called a {}"</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">Dog</span> <span class="k">as</span> <span class="n">Animal</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">baby_name</span><span class="p">());</span>
<span class="p">}</span>


</code></pre></div>
<p>SuperTriat： 超级 Trait， 依赖于一个Trait的实现， 示例如下：</p>
<div class="highlight"><pre class="highlight rust"><code>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">fmt</span><span class="p">;</span>
<span class="c">// 声明语法如下： trait SuperTrait: Trait {}</span>
<span class="k">trait</span> <span class="n">OutlinePrint</span><span class="p">:</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">outline_print</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">output</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.to_string</span><span class="p">();</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"output is --- {}"</span><span class="p">,</span> <span class="n">output</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c">// 我们只需要为point 实现 Display， 即可 拥有 outline_print 方法</span>
<span class="k">impl</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span> <span class="k">for</span> <span class="n">Point</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Result</span> <span class="p">{</span>
        <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"({}, {})"</span><span class="p">,</span> <span class="k">self</span><span class="py">.x</span><span class="p">,</span> <span class="k">self</span><span class="py">.y</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="n">OutlinePrint</span> <span class="k">for</span> <span class="n">Point</span> <span class="p">{}</span>
</code></pre></div><p>NewType: 因为 impl Trait for Type, 中的type需要在本地的crate，而不是 引用库 中的Type。 所以 可以通过Newtype类来包装 Type，实现一些 Trait. <br />
这里面包含另外一些需要东西： 如何让 NewType， 伪装成Type？<br />
实现 Deref Trait。</p>

<div class="highlight"><pre class="highlight rust"><code>  <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">fmt</span><span class="p">;</span>

  <span class="k">struct</span> <span class="nf">Wrapper</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">);</span> <span class="c">// 新的type 类似于下边的</span>
  <span class="k">struct</span> <span class="nf">Color</span><span class="p">(</span><span class="nb">i32</span><span class="p">,</span> <span class="nb">i32</span><span class="p">,</span> <span class="nb">i32</span><span class="p">);</span>
  <span class="k">struct</span> <span class="nf">Point</span><span class="p">(</span><span class="nb">i32</span><span class="p">,</span> <span class="nb">i32</span><span class="p">,</span> <span class="nb">i32</span><span class="p">);</span>

  <span class="k">impl</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span> <span class="k">for</span> <span class="n">Wrapper</span> <span class="p">{</span>
      <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Result</span> <span class="p">{</span>
          <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"[{}]"</span><span class="p">,</span> <span class="k">self</span><span class="na">.0</span><span class="nf">.join</span><span class="p">(</span><span class="s">", "</span><span class="p">))</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">w</span> <span class="o">=</span> <span class="nf">Wrapper</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">),</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"world"</span><span class="p">)]);</span>
      <span class="nd">println!</span><span class="p">(</span><span class="s">"w = {}"</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>
<h3 id="generic-生命周期-syntax-用于区分函数中-参数生命周期-对比-参数返回值-等-生命周期之间的关系-确保-参数传递生命周期符合-函数声明-生命周期-需要关联-参数与返回值才会有效果只有参数的生命周期没有用处">Generic 生命周期 syntax： 用于区分函数中 参数生命周期， 对比 参数、返回值 等 生命周期之间的关系。 确保 参数传递生命周期符合 函数声明. 生命周期 需要关联 参数与返回值，才会有效果，只有参数的生命周期没有用处</h3>

<div class="highlight"><pre class="highlight rust"><code>  <span class="k">fn</span> <span class="nf">longest</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">x</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">y</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">x</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">y</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="c">// error, rust并不能知道 函数返回值， 是x还是y， 无法检查生命周期</span>

  <span class="k">fn</span> <span class="n">longest</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span> <span class="p">{</span>
      <span class="k">if</span> <span class="n">x</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">y</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
          <span class="n">x</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="n">y</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="c">// 要求 函数返回值，应该小于等于 参数， x y的生命周期, 所以下面的函数调用是可以pass的</span>
  <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">string1</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"long string is long"</span><span class="p">);</span>

      <span class="p">{</span>
          <span class="k">let</span> <span class="n">string2</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"xyz"</span><span class="p">);</span>
          <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">longest</span><span class="p">(</span><span class="n">string1</span><span class="nf">.as_str</span><span class="p">(),</span> <span class="n">string2</span><span class="nf">.as_str</span><span class="p">());</span>
          <span class="nd">println!</span><span class="p">(</span><span class="s">"The longest string is {}"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="c">// 而这个， 则是编译失败的，因为 返回值的生命周期 大于其中参数 y 的生命周期， 会导致 dangling refrence, 比如， result指向 y, 而y 在 内部的scope中已经销毁了</span>
  <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">string1</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"long string is long"</span><span class="p">);</span>
      <span class="k">let</span> <span class="n">result</span><span class="p">;</span>
      <span class="p">{</span>
          <span class="k">let</span> <span class="n">string2</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"xyz"</span><span class="p">);</span>
          <span class="n">result</span> <span class="o">=</span> <span class="nf">longest</span><span class="p">(</span><span class="n">string1</span><span class="nf">.as_str</span><span class="p">(),</span> <span class="n">string2</span><span class="nf">.as_str</span><span class="p">());</span>
      <span class="p">}</span>
      <span class="nd">println!</span><span class="p">(</span><span class="s">"The longest string is {}"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c">// 还可以这样， 总是 返回其中的一个值</span>
  <span class="k">fn</span> <span class="n">longest</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span> <span class="p">{</span>
      <span class="n">x</span>
  <span class="p">}</span>
</code></pre></div><ul>
  <li>Struct 的生命周期： struct 保持的refrence 的生命周期 与struct 生命周期关联。struct 不应该 长于 内部变量的refrence。
<div class="highlight"><pre class="highlight rust"><code>  <span class="k">struct</span> <span class="n">ImportantExcerpt</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="n">part</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span>
  <span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">novel</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Call me Ishmael. Some years ago..."</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">first_sentence</span> <span class="o">=</span> <span class="n">novel</span><span class="nf">.split</span><span class="p">(</span><span class="sc">'.'</span><span class="p">)</span>
        <span class="nf">.next</span><span class="p">()</span>
        <span class="nf">.expect</span><span class="p">(</span><span class="s">"Could not find a '.'"</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ImportantExcerpt</span> <span class="p">{</span> <span class="n">part</span><span class="p">:</span> <span class="n">first_sentence</span> <span class="p">};</span>
  <span class="p">}</span><span class="c">// 其中 i 的生命从周期不应该长于 novel</span>
  <span class="c">// impl Struct Generic 方法时候的 声明语法， 同 impl Generic。 其中声明方法时候，需要不要 生命周期 声明，需要看，是否与struct field 、 返回值 相关</span>
 <span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">ImportantExcerpt</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
 <span class="k">fn</span> <span class="nf">announce_and_return_part</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">announcement</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="p">{</span>
     <span class="nd">println!</span><span class="p">(</span><span class="s">"Attention please: {}"</span><span class="p">,</span> <span class="n">announcement</span><span class="p">);</span>
     <span class="k">self</span><span class="py">.part</span>
 <span class="p">}</span>
 <span class="p">}</span>
</code></pre></div>    <p>Static lifetime， 静态生命周期，表明变量， 将贯穿于整个program, 将直接保存于， 代码的二进制中。</p>
  </li>
</ul>

<h3 id="closures">Closures:</h3>
<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td>/</td>
          <td>x/</td>
          <td>{}</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>FnOnce: 获取参数的ownership</li>
  <li>FnMut： 获取参数的 mut 引用</li>
  <li>Fn： 获取参数的 非mut引用</li>
  <li>以上三种 为 Trait， 可以声明类型为 FN(i32) -&gt; i32</li>
  <li>function as paramas： Function Pointer(fn a Type diff with Fn) ， fn 类型，实现了， Fn, FnMut, FnOnce 的实现， 即 impl Fn, FnMut, FnOnce for fn {….} 所以，可以传递 fn 到 接受 closures的 函数中。 还可以声明接受fn类型的 函数</li>
</ul>

<div class="highlight"><pre class="highlight rust"><code>  <span class="k">fn</span> <span class="nf">add_one</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
      <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="p">}</span>

  <span class="k">fn</span> <span class="nf">do_twice</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">fn</span><span class="p">(</span><span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">arg</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
      <span class="nf">f</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span> <span class="nf">f</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">answer</span> <span class="o">=</span> <span class="nf">do_twice</span><span class="p">(</span><span class="n">add_one</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>

      <span class="nd">println!</span><span class="p">(</span><span class="s">"The answer is: {}"</span><span class="p">,</span> <span class="n">answer</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c">// 可以 传递参数fn 类型</span>
  <span class="k">let</span> <span class="n">list_of_numbers</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
  <span class="k">let</span> <span class="n">list_of_strings</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">list_of_numbers</span>
      <span class="nf">.iter</span><span class="p">()</span>
      <span class="nf">.map</span><span class="p">(</span><span class="nn">ToString</span><span class="p">::</span><span class="n">to_string</span><span class="p">)</span>
      <span class="nf">.collect</span><span class="p">();</span>
</code></pre></div>
<h3 id="macros">macros:</h3>
<h4 id="rust-tokens-分类">rust tokens 分类：</h4>
<div class="highlight"><pre class="highlight plaintext"><code>  Identifiers: foo, Bambous, self, we_can_dance, LaCaravane, …
  Integers: 42, 72u32, 0_______0, …
  Keywords: _, fn, self, match, yield, macro, …
  Lifetimes: 'a, 'b, 'a_rare_long_lifetime_name, …
  Strings: "", "Leicester", r##"venezuelan beaver"##, …
  Symbols: [, :, ::, -&gt;, @, &lt;-, …
</code></pre></div><ul>
  <li>c语言 需要特殊的 “macro层面” 即 预处理，而rust  macro处理时机 在 编译器 将 token 转换为  AST 之后进行（Abstract Syntax Tree）</li>
  <li>编译过程 文本 -&gt; token tree  -&gt; AST  基本所有的 token都是叶子节点 ，只有 （…） […] {…} 包含一组节点，是 树节点。</li>
</ul>

<div class="highlight"><pre class="highlight plaintext"><code>表达式： a + b + (c + d[0]) + e
token tree
«a» «+» «b» «+» «(   )» «+» «e»
          ╭────────┴──────────╮
           «c» «+» «d» «[   ]»
                        ╭─┴─╮
                        «0»

AST
              ┌─────────┐
              │ BinOp   │
              │ op: Add │
            ┌╴│ lhs: ◌  │
┌─────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐
│ Var     │╶┘ └─────────┘ └╴│ BinOp   │
│ name: a │                 │ op: Add │
└─────────┘               ┌╴│ lhs: ◌  │
              ┌─────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐
              │ Var     │╶┘ └─────────┘ └╴│ BinOp   │
              │ name: b │                 │ op: Add │
              └─────────┘               ┌╴│ lhs: ◌  │
                            ┌─────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐
                            │ BinOp   │╶┘ └─────────┘ └╴│ Var     │
                            │ op: Add │                 │ name: e │
                          ┌╴│ lhs: ◌  │                 └─────────┘
              ┌─────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐
              │ Var     │╶┘ └─────────┘ └╴│ Index   │
              │ name: c │               ┌╴│ arr: ◌  │
              └─────────┘   ┌─────────┐ │ │ ind: ◌  │╶┐ ┌─────────┐
                            │ Var     │╶┘ └─────────┘ └╴│ LitInt  │
                            │ name: d │                 │ val: 0  │
                            └─────────┘                 └─────────┘


</code></pre></div>
<h4 id="macro-rule-的语法规则-httpsdanielkeepgithubiotlbormbookmbe-macro-ruleshtml">macro rule 的语法规则: https://danielkeep.github.io/tlborm/book/mbe-macro-rules.html</h4>

<div class="highlight"><pre class="highlight plaintext"><code>匹配 语法如下：

macro_rules! four {
  (pattern) =&gt; {

  };
  (pattern1) =&gt; {

  };
}



捕获： $name:kind

kind类型如下：

  item: an item, like a function, struct, module, etc. 
  block: a block (i.e. a block of statements and/or an expression, surrounded by braces)
  stmt: a statement
  pat: a pattern
  expr: an expression
  ty: a type
  ident: an identifier
  path: a path (e.g. foo, ::std::mem::replace, transmute::&lt;_, int&gt;, …)
  meta: a meta item; the things that go inside #[...] and #![...] attributes
  tt: a single token tree

示例如下：

macro_rules! times_five {
    ($e:expr) =&gt; {5 * $e};
}


重复：语法 $(...) sep rep.

$: $ 符号
(...)： 被重复内容： 可以包含 token tree， captures（捕获） 或者 其他重复（递归）
seq 为 可选的split token，一般可选 , . ;
rep 为 重复控制，可选有 + *

示例如下：
macro_rules! vec_strs {
    (
        // Start a repetition:
        $(
            // Each repeat must contain an expression...
            $element:expr
        )
        // ...separated by commas...
        ,
        // ...zero or more times.
        *
    ) =&gt; {
        // Enclose the expansion in a block so that we can use
        // multiple statements.
        {
            let mut v = Vec::new();

            // Start a repetition:
            $(
                // Each repeat will contain the following statement, with
                // $element replaced with the corresponding expression.
                v.push(format!("{}", $element));
            )*

            v
        }
    };
}
</code></pre></div>
<h4 id="捕获与扩展-细节">捕获与扩展 细节：</h4>

<ol>
  <li>匹配项 应该从 最具体 到最广泛的匹配规则， 因为 一旦 捕获表达式 开始消费 tokens，将不能后退 或者在匹配其他的 选项</li>
  <li>
    <p>macro 之间的内容传递: 即 第一个macro接受的 为token，如果 第一个macro将捕获传递给其他的macro 则为 AST形式。示例如下：</p>

<div class="highlight"><pre class="highlight plaintext"><code>
 macro_rules! capture_expr_then_stringify {
     ($e:expr) =&gt; {
         stringify!($e)
     };
 }

 fn main() {
     println!("{:?}", stringify!(dummy(2 * (1 + (3)))));
     println!("{:?}", capture_expr_then_stringify!(dummy(2 * (1 + (3)))));
 }

 output like this:

 "dummy ( 2 * ( 1 + ( 3 ) ) )"
 "dummy(2 * (1 + (3)))"

 第一个 macro stringify 接受的形式 如下： tokens

 «dummy» «(   )»
    ╭───────┴───────╮
     «2» «*» «(   )»
        ╭───────┴───────╮
         «1» «+» «(   )»
                  ╭─┴─╮
                   «3»

 第二个 macro stringify 接受的形式如下： AST

 « »
  │ ┌─────────────┐
  └╴│ Call        │
    │ fn: dummy   │   ┌─────────┐
    │ args: ◌     │╶─╴│ BinOp   │
    └─────────────┘   │ op: Mul │
                    ┌╴│ lhs: ◌  │
         ┌────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐
         │ LitInt │╶┘ └─────────┘ └╴│ BinOp   │
         │ val: 2 │                 │ op: Add │
         └────────┘               ┌╴│ lhs: ◌  │
                       ┌────────┐ │ │ rhs: ◌  │╶┐ ┌────────┐
                       │ LitInt │╶┘ └─────────┘ └╴│ LitInt │
                       │ val: 1 │                 │ val: 3 │
                       └────────┘                 └────────┘

</code></pre></div>  </li>
  <li>
    <p>macro 将  input 从tokens转到 AST，将导致 input再也不能被 macro 表达式匹配，如下：</p>

<div class="highlight"><pre class="highlight rust"><code>  <span class="nd">macro_rules!</span> <span class="n">capture_then_what_is</span> <span class="p">{</span>
      <span class="p">(</span><span class="nd">#[</span><span class="err">$</span><span class="nd">m:meta]</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span><span class="nd">what_is!</span><span class="p">(</span><span class="nd">#[</span><span class="err">$</span><span class="nd">m]</span><span class="p">)};</span>
  <span class="p">}</span>

  <span class="nd">macro_rules!</span> <span class="n">what_is</span> <span class="p">{</span>
      <span class="p">(</span><span class="nd">#[no_mangle]</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span><span class="s">"no_mangle attribute"</span><span class="p">};</span>
      <span class="p">(</span><span class="nd">#[inline]</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span><span class="s">"inline attribute"</span><span class="p">};</span>
      <span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$tts:tt</span><span class="p">)</span><span class="o">*</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span><span class="nd">concat!</span><span class="p">(</span><span class="s">"something else ("</span><span class="p">,</span> <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$tts</span><span class="p">)</span><span class="o">*</span><span class="p">),</span> <span class="s">")"</span><span class="p">)};</span>
  <span class="p">}</span>

  <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
      <span class="nd">println!</span><span class="p">(</span>
          <span class="s">"{}</span><span class="se">\n</span><span class="s">{}</span><span class="se">\n</span><span class="s">{}</span><span class="se">\n</span><span class="s">{}"</span><span class="p">,</span>
          <span class="nd">what_is!</span><span class="p">(</span><span class="nd">#[no_mangle]</span><span class="p">),</span>
          <span class="nd">what_is!</span><span class="p">(</span><span class="nd">#[inline]</span><span class="p">),</span>
          <span class="nd">capture_then_what_is!</span><span class="p">(</span><span class="nd">#[no_mangle]</span><span class="p">),</span>
          <span class="nd">capture_then_what_is!</span><span class="p">(</span><span class="nd">#[inline]</span><span class="p">),</span>
      <span class="p">);</span>
  <span class="p">}</span>

  <span class="c">// The output is:  即  macro capture_then_what_is 将input转化 传递给 macro what_is 之后 ，再也 不能被 what_is 中的 pattern 匹配</span>

  <span class="n">no_mangle</span> <span class="n">attribute</span>
  <span class="n">inline</span> <span class="n">attribute</span>
  <span class="n">something</span> <span class="k">else</span> <span class="p">(</span><span class="err">#</span> <span class="p">[</span> <span class="n">no_mangle</span> <span class="p">])</span>
  <span class="n">something</span> <span class="k">else</span> <span class="p">(</span><span class="err">#</span> <span class="p">[</span> <span class="n">inline</span> <span class="p">])</span>

</code></pre></div>  </li>
  <li>避免此类情况的唯一方法: 使用 tt 与 ident 进行匹配，使用任何其他的匹配 获得的捕获 不能够传递给其他的 macro</li>
  <li>
    <p>卫生： 默认情况下 macro都是卫生macro，除非我们需要：如下：</p>

<div class="highlight"><pre class="highlight rust"><code> <span class="c">// 卫生宏</span>
 <span class="nd">macro_rules!</span> <span class="n">using_a</span> <span class="p">{</span>
     <span class="p">(</span><span class="nv">$e:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
         <span class="p">{</span>
             <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
             <span class="nv">$e</span>
         <span class="p">}</span>
     <span class="p">}</span>
 <span class="p">}</span>
 <span class="c">// 宏调用是错误的，将导致编译错误，即a没有定义</span>
 <span class="k">let</span> <span class="n">four</span> <span class="o">=</span> <span class="nd">using_a!</span><span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="mi">10</span><span class="p">);</span>

 <span class="c">// 非卫生宏，捕获 环境中的a</span>
 <span class="nd">macro_rules!</span> <span class="n">using_a</span> <span class="p">{</span>
     <span class="p">(</span><span class="nv">$a:ident</span><span class="p">,</span> <span class="nv">$e:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
         <span class="p">{</span>
             <span class="k">let</span> <span class="nv">$a</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
             <span class="nv">$e</span>
         <span class="p">}</span>
     <span class="p">}</span>
 <span class="p">}</span>

 <span class="k">let</span> <span class="n">four</span> <span class="o">=</span> <span class="nd">using_a!</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span> <span class="o">/</span> <span class="mi">10</span><span class="p">);</span>
</code></pre></div>  </li>
  <li>
    <p>self: 标识符或关键字。self在代码中是一个关键字，但是macro中可以成为一个标识符，使用macro在struct中定义方法：</p>

<div class="highlight"><pre class="highlight rust"><code> <span class="c">//依然需要借助  非卫生宏 来污染 空间，捕获 self</span>
 <span class="nd">macro_rules!</span> <span class="n">double_method</span> <span class="p">{</span>
     <span class="p">(</span><span class="nv">$self_:ident</span><span class="p">,</span> <span class="nv">$body:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
         <span class="k">fn</span> <span class="nf">double</span><span class="p">(</span><span class="k">mut</span> <span class="nv">$self_</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Dummy</span> <span class="p">{</span>
             <span class="nv">$body</span>
         <span class="p">}</span>
     <span class="p">};</span>
 <span class="p">}</span>

 <span class="k">struct</span> <span class="nf">Dummy</span><span class="p">(</span><span class="nb">i32</span><span class="p">);</span>

 <span class="k">impl</span> <span class="n">Dummy</span> <span class="p">{</span>
     <span class="nd">double_method!</span> <span class="p">{</span><span class="k">self</span><span class="p">,</span> <span class="p">{</span>
         <span class="k">self</span><span class="na">.0</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
         <span class="k">self</span>
     <span class="p">}}</span>
 <span class="p">}</span>

</code></pre></div>  </li>
  <li>
    <p>一个巧妙的 macro之间传递内容的方法： 通过 ident捕获callback名称，通过添加 ! 来完成，对另一个macro的调用</p>

<div class="highlight"><pre class="highlight rust"><code> <span class="nd">macro_rules!</span> <span class="n">call_with_ident</span> <span class="p">{</span>
     <span class="p">(</span><span class="nv">$c:ident</span><span class="p">(</span><span class="nv">$i:ident</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="p">{</span><span class="nv">$c</span><span class="o">!</span><span class="p">(</span><span class="nv">$i</span><span class="p">)};</span>
 <span class="p">}</span>
</code></pre></div>  </li>
  <li>macro的 作用域：
    <ul>
      <li>macro 在定义之后 的代码中 以及 sub-module 中可见。</li>
      <li>macro 需要 使用 #[macro_use] attribute 才能被 export 出来。</li>
      <li>macro不同于 函数调用， 导致了一些 macro之间相互依赖的关系 与 可见性 关联起来 导致的复杂情景。  但基本上 可以按照 将macro层层 展开来，每层 macro依然 符合 前面两条规则 即： macro使用在 macro定义之后， macro 可见。</li>
    </ul>
  </li>
</ol>

<h4 id="macro-中的模式">macro 中的模式：</h4>
<ol>
  <li>
    <p>callback: 因为macro之间传递参数的 限制，导致的一种间接调用形式。即：使用tt对callback 以及其参数 进行匹配，然后 拼接成  macro调用形式。</p>

<div class="highlight"><pre class="highlight rust"><code> <span class="c">//因为 macro 接受参数问题 导致的问题 示例：</span>

 <span class="nd">acro_rules!</span> <span class="n">call_with_larch</span> <span class="p">{</span>
     <span class="p">(</span>$<span class="n">callback</span><span class="p">:</span><span class="n">ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> $<span class="nd">callback!</span><span class="p">(</span><span class="n">larch</span><span class="p">)</span> <span class="p">};</span>
 <span class="p">}</span>

 <span class="nd">macro_rules!</span> <span class="n">expand_to_larch</span> <span class="p">{</span>
     <span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="n">larch</span> <span class="p">};</span>
 <span class="p">}</span>

 <span class="nd">macro_rules!</span> <span class="n">recognise_tree</span> <span class="p">{</span>
     <span class="p">(</span><span class="n">larch</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"#1, the Larch."</span><span class="p">)</span> <span class="p">};</span>
     <span class="p">(</span><span class="n">redwood</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"#2, the Mighty Redwood."</span><span class="p">)</span> <span class="p">};</span>
     <span class="p">(</span><span class="n">fir</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"#3, the Fir."</span><span class="p">)</span> <span class="p">};</span>
     <span class="p">(</span><span class="n">chestnut</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"#4, the Horse Chestnut."</span><span class="p">)</span> <span class="p">};</span>
     <span class="p">(</span><span class="n">pine</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"#5, the Scots Pine."</span><span class="p">)</span> <span class="p">};</span>
     <span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$other:tt</span><span class="p">)</span><span class="o">*</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"I don't know; some kind of birch maybe?"</span><span class="p">)</span> <span class="p">};</span>
 <span class="p">}</span>

 <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="nd">recognise_tree!</span><span class="p">(</span><span class="nd">expand_to_larch!</span><span class="p">());</span>
     <span class="nd">call_with_larch!</span><span class="p">(</span><span class="n">recognise_tree</span><span class="p">);</span>
 <span class="p">}</span>

 <span class="c">// 展开形式 与 输出</span>

 <span class="nd">recognise_tree!</span> <span class="p">{</span> <span class="n">expand_to_larch</span> <span class="o">!</span> <span class="p">(</span>  <span class="p">)</span> <span class="p">}</span>
 <span class="nd">println!</span> <span class="p">{</span> <span class="s">"I don't know; some kind of birch maybe?"</span> <span class="p">}</span>
 <span class="c">// ...</span>

 <span class="nd">call_with_larch!</span> <span class="p">{</span> <span class="n">recognise_tree</span> <span class="p">}</span>
 <span class="nd">recognise_tree!</span> <span class="p">{</span> <span class="n">larch</span> <span class="p">}</span>
 <span class="nd">println!</span> <span class="p">{</span> <span class="s">"#1, the Larch."</span> <span class="p">}</span>

 <span class="c">//callback形式 解决：</span>

 <span class="nd">macro_rules!</span> <span class="n">callback</span> <span class="p">{</span>
     <span class="p">(</span><span class="nv">$callback:ident</span><span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$args:tt</span><span class="p">)</span><span class="o">*</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="c">//注意这里 使用tt 不仅匹配了callback name 还匹配了参数 ，保留了参数token的形式 </span>
         <span class="nv">$callback</span><span class="o">!</span><span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$args</span><span class="p">)</span><span class="o">*</span><span class="p">)</span>
     <span class="p">};</span>
 <span class="p">}</span>

 <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="nd">callback!</span><span class="p">(</span><span class="nf">callback</span><span class="p">(</span><span class="nf">println</span><span class="p">(</span><span class="s">"Yes, this *was* unnecessary."</span><span class="p">)));</span>
 <span class="p">}</span>

</code></pre></div>  </li>
  <li>
    <p>tt 递归匹配器，该模式 每次处理一个递归项目，然后调用自身 macro继续 处理后续 递归项目。需要注意macro的 递归次数限制。macro recursion limit 示例：</p>

<div class="highlight"><pre class="highlight rust"><code> <span class="nd">macro_rules!</span> <span class="n">mixed_rules</span> <span class="p">{</span>
     <span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{};</span>
     <span class="p">(</span><span class="n">trace</span> <span class="nv">$name:ident</span><span class="p">;</span> <span class="nv">$</span><span class="p">(</span><span class="nv">$tail:tt</span><span class="p">)</span><span class="o">*</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
         <span class="p">{</span>
             <span class="nd">println!</span><span class="p">(</span><span class="nd">concat!</span><span class="p">(</span><span class="nd">stringify!</span><span class="p">(</span><span class="nv">$name</span><span class="p">),</span> <span class="s">" = {:?}"</span><span class="p">),</span> <span class="nv">$name</span><span class="p">);</span>
             <span class="nd">mixed_rules!</span><span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$tail</span><span class="p">)</span><span class="o">*</span><span class="p">);</span>
         <span class="p">}</span>
     <span class="p">};</span>
     <span class="p">(</span><span class="n">trace</span> <span class="nv">$name:ident</span> <span class="o">=</span> <span class="nv">$init:expr</span><span class="p">;</span> <span class="nv">$</span><span class="p">(</span><span class="nv">$tail:tt</span><span class="p">)</span><span class="o">*</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
         <span class="p">{</span>
             <span class="k">let</span> <span class="nv">$name</span> <span class="o">=</span> <span class="nv">$init</span><span class="p">;</span>
             <span class="nd">println!</span><span class="p">(</span><span class="nd">concat!</span><span class="p">(</span><span class="nd">stringify!</span><span class="p">(</span><span class="nv">$name</span><span class="p">),</span> <span class="s">" = {:?}"</span><span class="p">),</span> <span class="nv">$name</span><span class="p">);</span>
             <span class="nd">mixed_rules!</span><span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$tail</span><span class="p">)</span><span class="o">*</span><span class="p">);</span>
         <span class="p">}</span>
     <span class="p">};</span>
 <span class="p">}</span>
</code></pre></div>  </li>
  <li>
    <p>为了隐藏 内部的macro，因为macro 可见性问题 导致 简单的macro_use 可能与其他的crate 产生名称冲突。所以：  使用一个 包含 所有 pattern规则 的module 进行封装：</p>

<div class="highlight"><pre class="highlight rust"><code> <span class="nd">#[macro_export]</span>
 <span class="nd">macro_rules!</span> <span class="n">foo</span> <span class="p">{</span>
     <span class="p">(</span><span class="o">@</span><span class="n">as_expr</span> <span class="nv">$e:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span><span class="nv">$e</span><span class="p">};</span>

     <span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$tts:tt</span><span class="p">)</span><span class="o">*</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
         <span class="nd">foo!</span><span class="p">(</span><span class="o">@</span><span class="n">as_expr</span> <span class="nv">$</span><span class="p">(</span><span class="nv">$tts</span><span class="p">)</span><span class="o">*</span><span class="p">)</span>
     <span class="p">};</span>
 <span class="p">}</span>
 <span class="c">//这样将 将as_expr 包装在 mod  foo 内部</span>

 <span class="c">// macro 封装的通用形式</span>
 <span class="nd">macro_rules!</span> <span class="n">crate_name_util</span> <span class="p">{</span>
     <span class="p">(</span><span class="o">@</span><span class="n">as_expr</span> <span class="nv">$e:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span><span class="nv">$e</span><span class="p">};</span>
     <span class="p">(</span><span class="o">@</span><span class="n">as_item</span> <span class="nv">$i:item</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span><span class="nv">$i</span><span class="p">};</span>
     <span class="p">(</span><span class="o">@</span><span class="n">count_tts</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span><span class="mi">0u</span><span class="n">size</span><span class="p">};</span>
     <span class="c">// ...</span>
 <span class="p">}</span>
</code></pre></div>  </li>
  <li>
    <p>tt 模式常用方式，push down计算：</p>

    <blockquote>
      <p>如何实现 接受 形式 如 let strings: [String; 3] = init_array![String::from(“hi!”); 3]; 的macro 实现。</p>
    </blockquote>

<div class="highlight"><pre class="highlight rust"><code> <span class="c">//一个明显的、直接的 但实现错误的 递归实现 方法。</span>

 <span class="nd">macro_rules!</span> <span class="n">init_array</span> <span class="p">{</span>
     <span class="p">(</span><span class="o">@</span><span class="n">accum</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">$_e:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span><span class="cm">/* empty */</span><span class="p">};</span>
     <span class="p">(</span><span class="o">@</span><span class="n">accum</span> <span class="mi">1</span><span class="p">,</span> <span class="nv">$e:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span><span class="nv">$e</span><span class="p">};</span>
     <span class="p">(</span><span class="o">@</span><span class="n">accum</span> <span class="mi">2</span><span class="p">,</span> <span class="nv">$e:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span><span class="nv">$e</span><span class="p">,</span> <span class="nd">init_array!</span><span class="p">(</span><span class="o">@</span><span class="n">accum</span> <span class="mi">1</span><span class="p">,</span> <span class="nv">$e</span><span class="p">)};</span>
     <span class="p">(</span><span class="o">@</span><span class="n">accum</span> <span class="mi">3</span><span class="p">,</span> <span class="nv">$e:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span><span class="nv">$e</span><span class="p">,</span> <span class="nd">init_array!</span><span class="p">(</span><span class="o">@</span><span class="n">accum</span> <span class="mi">2</span><span class="p">,</span> <span class="nv">$e</span><span class="p">)};</span>
     <span class="p">[</span><span class="nv">$e:expr</span><span class="p">;</span> <span class="nv">$n:tt</span><span class="p">]</span> <span class="k">=&gt;</span> <span class="p">{</span>
         <span class="p">{</span>
             <span class="k">let</span> <span class="n">e</span> <span class="o">=</span> <span class="nv">$e</span><span class="p">;</span>
             <span class="p">[</span><span class="nd">init_array!</span><span class="p">(</span><span class="o">@</span><span class="n">accum</span> <span class="nv">$n</span><span class="p">,</span> <span class="n">e</span><span class="p">)]</span>
         <span class="p">}</span>
     <span class="p">};</span>
 <span class="p">}</span>


 <span class="c">//该模式 编译不通过的原因 在于， 在 每一步骤中 构建了一个不完全的 {String::from("hi"), init_array!(@accum 1, $e)} 的表达式。因为 init_array! 并非一个完整的 表达式。所以 该种方法 并不正确。并导致 编译不通过。</span>


 <span class="c">//下面是 push-down accumulation  方式 来实现：</span>

 <span class="nd">macro_rules!</span> <span class="n">init_array</span> <span class="p">{</span>
     <span class="p">(</span><span class="o">@</span><span class="nf">accum</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nv">$_e:expr</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$body:tt</span><span class="p">)</span><span class="o">*</span><span class="p">))</span>
         <span class="k">=&gt;</span> <span class="p">{</span><span class="nd">init_array!</span><span class="p">(</span><span class="o">@</span><span class="n">as_expr</span> <span class="p">[</span><span class="nv">$</span><span class="p">(</span><span class="nv">$body</span><span class="p">)</span><span class="o">*</span><span class="p">])};</span>
     <span class="p">(</span><span class="o">@</span><span class="nf">accum</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nv">$e:expr</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$body:tt</span><span class="p">)</span><span class="o">*</span><span class="p">))</span>
         <span class="k">=&gt;</span> <span class="p">{</span><span class="nd">init_array!</span><span class="p">(</span><span class="o">@</span><span class="nf">accum</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nv">$e</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$body</span><span class="p">)</span><span class="o">*</span> <span class="nv">$e</span><span class="p">,))};</span>
     <span class="p">(</span><span class="o">@</span><span class="nf">accum</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nv">$e:expr</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$body:tt</span><span class="p">)</span><span class="o">*</span><span class="p">))</span>
         <span class="k">=&gt;</span> <span class="p">{</span><span class="nd">init_array!</span><span class="p">(</span><span class="o">@</span><span class="nf">accum</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nv">$e</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$body</span><span class="p">)</span><span class="o">*</span> <span class="nv">$e</span><span class="p">,))};</span>
     <span class="p">(</span><span class="o">@</span><span class="nf">accum</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nv">$e:expr</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$body:tt</span><span class="p">)</span><span class="o">*</span><span class="p">))</span>
         <span class="k">=&gt;</span> <span class="p">{</span><span class="nd">init_array!</span><span class="p">(</span><span class="o">@</span><span class="nf">accum</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nv">$e</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$body</span><span class="p">)</span><span class="o">*</span> <span class="nv">$e</span><span class="p">,))};</span>
     <span class="p">(</span><span class="o">@</span><span class="n">as_expr</span> <span class="nv">$e:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span><span class="nv">$e</span><span class="p">};</span>
     <span class="p">[</span><span class="nv">$e:expr</span><span class="p">;</span> <span class="nv">$n:tt</span><span class="p">]</span> <span class="k">=&gt;</span> <span class="p">{</span>
         <span class="p">{</span>
             <span class="k">let</span> <span class="n">e</span> <span class="o">=</span> <span class="nv">$e</span><span class="p">;</span>
             <span class="nd">init_array!</span><span class="p">(</span><span class="o">@</span><span class="nf">accum</span> <span class="p">(</span><span class="nv">$n</span><span class="p">,</span> <span class="n">e</span><span class="nf">.clone</span><span class="p">())</span> <span class="k">-&gt;</span> <span class="p">())</span>
         <span class="p">}</span>
     <span class="p">};</span>
 <span class="p">}</span>

 <span class="k">let</span> <span class="n">strings</span><span class="p">:</span> <span class="p">[</span><span class="nb">String</span><span class="p">;</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="nd">init_array!</span><span class="p">[</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hi!"</span><span class="p">);</span> <span class="mi">3</span><span class="p">];</span>

 <span class="c">//其展开形式为</span>

 <span class="nd">init_array!</span> <span class="p">{</span> <span class="nn">String</span><span class="p">::</span> <span class="nf">from</span> <span class="p">(</span> <span class="s">"hi!"</span> <span class="p">)</span> <span class="p">;</span> <span class="mi">3</span> <span class="p">}</span>
 <span class="nd">init_array!</span> <span class="p">{</span> <span class="o">@</span> <span class="nf">accum</span> <span class="p">(</span> <span class="mi">3</span> <span class="p">,</span> <span class="n">e</span> <span class="nf">. clone</span> <span class="p">(</span>  <span class="p">)</span> <span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span>  <span class="p">)</span> <span class="p">}</span>
 <span class="nd">init_array!</span> <span class="p">{</span> <span class="o">@</span> <span class="nf">accum</span> <span class="p">(</span> <span class="mi">2</span> <span class="p">,</span> <span class="n">e</span><span class="nf">.clone</span><span class="p">()</span> <span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span> <span class="n">e</span><span class="nf">.clone</span><span class="p">()</span> <span class="p">,</span> <span class="p">)</span> <span class="p">}</span>
 <span class="nd">init_array!</span> <span class="p">{</span> <span class="o">@</span> <span class="nf">accum</span> <span class="p">(</span> <span class="mi">1</span> <span class="p">,</span> <span class="n">e</span><span class="nf">.clone</span><span class="p">()</span> <span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span> <span class="n">e</span><span class="nf">.clone</span><span class="p">()</span> <span class="p">,</span> <span class="n">e</span><span class="nf">.clone</span><span class="p">()</span> <span class="p">,</span> <span class="p">)</span> <span class="p">}</span>
 <span class="nd">init_array!</span> <span class="p">{</span> <span class="o">@</span> <span class="nf">accum</span> <span class="p">(</span> <span class="mi">0</span> <span class="p">,</span> <span class="n">e</span><span class="nf">.clone</span><span class="p">()</span> <span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span> <span class="n">e</span><span class="nf">.clone</span><span class="p">()</span> <span class="p">,</span> <span class="n">e</span><span class="nf">.clone</span><span class="p">()</span> <span class="p">,</span> <span class="n">e</span><span class="nf">.clone</span><span class="p">()</span> <span class="p">,</span> <span class="p">)</span> <span class="p">}</span>
 <span class="nd">init_array!</span> <span class="p">{</span> <span class="o">@</span> <span class="n">as_expr</span> <span class="p">[</span> <span class="n">e</span><span class="nf">.clone</span><span class="p">()</span> <span class="p">,</span> <span class="n">e</span><span class="nf">.clone</span><span class="p">()</span> <span class="p">,</span> <span class="n">e</span><span class="nf">.clone</span><span class="p">()</span> <span class="p">,</span> <span class="p">]</span> <span class="p">}</span>

 <span class="c">//我们通过  在 一个新的匹配 部分 -&gt; (($(body):tt)*) 的重复匹配项，来匹配 递归过程中的积累部分 。通过 -&gt;($($body)* $e,)  来 进行 积累 以便 通过编译。</span>

</code></pre></div>  </li>
  <li>
    <p>分隔符号： 通过该种形式，我们可以实现 表达式尾部 匹配 任意多的 ，</p>

<div class="highlight"><pre class="highlight rust"><code>  <span class="nd">macro_rules!</span> <span class="n">match_exprs</span> <span class="p">{</span>
      <span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$exprs:expr</span><span class="p">),</span><span class="o">*</span> <span class="nv">$</span><span class="p">(,)</span><span class="o">*</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span><span class="o">...</span><span class="p">};</span>
  <span class="p">}</span>

</code></pre></div>
    <p>一般情况下，我们使用表达式  ($($exprs:expr),* 或者  $($exprs:expr,)*)  来写  macro的匹配项，这两种模式 只能匹配 存在 ， 或者 不存在 ， 而 使用上面的匹配方式 可以匹配任意多的，符号。</p>
  </li>
  <li>
    <p>tt bundle 技巧： 在一个复杂的 macro中， 往往设定 许多中间的转发层 来携带 表达式或标识符 以传递给 最终处理层，在这种情况下， 中间层 可以将所有的参数 绑定到 一个tt中， 而不需要 写准确的 匹配规则，只是简单的将tt转发给 下一次层面 即可。</p>

<div class="highlight"><pre class="highlight rust"><code> <span class="c">// 下面的示例中，macro通过,  一个 ($ab:tt, $_skip:tt $($tail:tt)*) 的pattern 来进行 匹配，并在随后的 模式中 传递 $ab tt</span>
 <span class="nd">macro_rules!</span> <span class="n">call_a_or_b_on_tail</span> <span class="p">{</span>
     <span class="p">((</span><span class="n">a</span><span class="p">:</span> <span class="nv">$a:expr</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nv">$b:expr</span><span class="p">),</span> <span class="n">call</span> <span class="n">a</span><span class="p">:</span> <span class="nv">$</span><span class="p">(</span><span class="nv">$tail:tt</span><span class="p">)</span><span class="o">*</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
         <span class="nv">$a</span><span class="p">(</span><span class="nd">stringify!</span><span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$tail</span><span class="p">)</span><span class="o">*</span><span class="p">))</span>
     <span class="p">};</span>

     <span class="p">((</span><span class="n">a</span><span class="p">:</span> <span class="nv">$a:expr</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nv">$b:expr</span><span class="p">),</span> <span class="n">call</span> <span class="n">b</span><span class="p">:</span> <span class="nv">$</span><span class="p">(</span><span class="nv">$tail:tt</span><span class="p">)</span><span class="o">*</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
         <span class="nv">$b</span><span class="p">(</span><span class="nd">stringify!</span><span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$tail</span><span class="p">)</span><span class="o">*</span><span class="p">))</span>
     <span class="p">};</span>

     <span class="p">(</span><span class="nv">$ab:tt</span><span class="p">,</span> <span class="nv">$_skip:tt</span> <span class="nv">$</span><span class="p">(</span><span class="nv">$tail:tt</span><span class="p">)</span><span class="o">*</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
         <span class="nd">call_a_or_b_on_tail!</span><span class="p">(</span><span class="nv">$ab</span><span class="p">,</span> <span class="nv">$</span><span class="p">(</span><span class="nv">$tail</span><span class="p">)</span><span class="o">*</span><span class="p">)</span>
     <span class="p">};</span>
 <span class="p">}</span>

 <span class="k">fn</span> <span class="nf">compute_len</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
     <span class="nf">Some</span><span class="p">(</span><span class="n">s</span><span class="nf">.len</span><span class="p">())</span>
 <span class="p">}</span>

 <span class="k">fn</span> <span class="nf">show_tail</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
     <span class="nd">println!</span><span class="p">(</span><span class="s">"tail: {:?}"</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
     <span class="nb">None</span>
 <span class="p">}</span>

 <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="nd">assert_eq!</span><span class="p">(</span>
         <span class="nd">call_a_or_b_on_tail!</span><span class="p">(</span>
             <span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">compute_len</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">show_tail</span><span class="p">),</span>
             <span class="n">the</span> <span class="n">recursive</span> <span class="n">part</span> <span class="n">that</span> <span class="n">skips</span> <span class="n">over</span> <span class="n">all</span> <span class="n">these</span>
             <span class="n">tokens</span> <span class="n">doesn</span><span class="nv">'t</span> <span class="n">much</span> <span class="n">care</span> <span class="n">whether</span> <span class="n">we</span> <span class="n">will</span> <span class="n">call</span> <span class="n">a</span>
             <span class="n">or</span> <span class="n">call</span> <span class="n">b</span><span class="p">:</span> <span class="n">only</span> <span class="n">the</span> <span class="n">terminal</span> <span class="n">rules</span> <span class="n">care</span>.
         <span class="p">),</span>
         <span class="nb">None</span>
     <span class="p">);</span>
     <span class="nd">assert_eq!</span><span class="p">(</span>
         <span class="nd">call_a_or_b_on_tail!</span><span class="p">(</span>
             <span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">compute_len</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">show_tail</span><span class="p">),</span>
             <span class="n">and</span> <span class="n">now</span><span class="p">,</span> <span class="n">to</span> <span class="n">justify</span> <span class="n">the</span> <span class="n">existence</span> <span class="n">of</span> <span class="n">two</span> <span class="n">paths</span>
             <span class="n">we</span> <span class="n">will</span> <span class="n">also</span> <span class="n">call</span> <span class="n">a</span><span class="p">:</span> <span class="n">its</span> <span class="n">input</span> <span class="n">should</span> <span class="n">somehow</span>
             <span class="n">be</span> <span class="k">self</span><span class="o">-</span><span class="n">referential</span><span class="p">,</span> <span class="n">so</span> <span class="k">let</span><span class="nv">'s</span> <span class="n">make</span> <span class="n">it</span> <span class="k">return</span>
             <span class="n">some</span> <span class="n">ninety</span> <span class="nd">one!</span>
         <span class="p">),</span>
         <span class="nf">Some</span><span class="p">(</span><span class="mi">91</span><span class="p">)</span>
     <span class="p">);</span>
 <span class="p">}</span>

</code></pre></div>  </li>
  <li>
    <p>因为rust对于 权限控制 可见性问题 上缺少 matcher，导致 macro处理起来非常困难。</p>

<div class="highlight"><pre class="highlight rust"><code> <span class="c">// 下面示例，使用单独的 pattern 来匹配， 不同的 权限的 （pub 或者无pub） 的 结构声明</span>
 <span class="nd">macro_rules!</span> <span class="n">newtype_new</span> <span class="p">{</span>
     <span class="p">(</span><span class="k">struct</span> <span class="nv">$name:ident</span><span class="p">(</span><span class="nv">$t:ty</span><span class="p">);)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="nd">newtype_new!</span> <span class="p">{</span> <span class="p">()</span> <span class="k">struct</span> <span class="nv">$name</span><span class="p">(</span><span class="nv">$t</span><span class="p">);</span> <span class="p">}</span> <span class="p">};</span>
     <span class="p">(</span><span class="k">pub</span> <span class="k">struct</span> <span class="nv">$name:ident</span><span class="p">(</span><span class="nv">$t:ty</span><span class="p">);)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="nd">newtype_new!</span> <span class="p">{</span> <span class="p">(</span><span class="k">pub</span><span class="p">)</span> <span class="k">struct</span> <span class="nv">$name</span><span class="p">(</span><span class="nv">$t</span><span class="p">);</span> <span class="p">}</span> <span class="p">};</span>

     <span class="p">((</span><span class="nv">$</span><span class="p">(</span><span class="nv">$vis:tt</span><span class="p">)</span><span class="o">*</span><span class="p">)</span> <span class="k">struct</span> <span class="nv">$name:ident</span><span class="p">(</span><span class="nv">$t:ty</span><span class="p">);)</span> <span class="k">=&gt;</span> <span class="p">{</span>
         <span class="nd">as_item!</span> <span class="p">{</span>
             <span class="k">impl</span> <span class="nv">$name</span> <span class="p">{</span>
                 <span class="nv">$</span><span class="p">(</span><span class="nv">$vis</span><span class="p">)</span><span class="o">*</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="nv">$t</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
                     <span class="nv">$name</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                 <span class="p">}</span>
             <span class="p">}</span>
         <span class="p">}</span>
     <span class="p">};</span>
 <span class="p">}</span>

 <span class="nd">macro_rules!</span> <span class="n">as_item</span> <span class="p">{</span> <span class="p">(</span><span class="nv">$i:item</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span><span class="nv">$i</span><span class="p">}</span> <span class="p">}</span>

</code></pre></div>  </li>
  <li>
    <p>AST 强制： 解决rust 编译器 对于tt的一些问题，（当解析器期待一个特定的语法结构，而是找到一堆替换的 tt 标记时，就会出现问题。 它通常不会尝试解析它们，而是会放弃） 该种情况下，需要使用 AST强制， 这些强制通常与下推累积宏一起使用，以便让解析器将最终的 tt 序列视为一种特殊的语法结构。有以下几种 AST强制。</p>

<div class="highlight"><pre class="highlight rust"><code> <span class="nd">macro_rules!</span> <span class="n">as_expr</span> <span class="p">{</span> <span class="p">(</span><span class="nv">$e:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span><span class="nv">$e</span><span class="p">}</span> <span class="p">}</span>
 <span class="nd">macro_rules!</span> <span class="n">as_item</span> <span class="p">{</span> <span class="p">(</span><span class="nv">$i:item</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span><span class="nv">$i</span><span class="p">}</span> <span class="p">}</span>
 <span class="nd">macro_rules!</span> <span class="n">as_pat</span>  <span class="p">{</span> <span class="p">(</span><span class="nv">$p:pat</span><span class="p">)</span> <span class="k">=&gt;</span>  <span class="p">{</span><span class="nv">$p</span><span class="p">}</span> <span class="p">}</span>
 <span class="nd">macro_rules!</span> <span class="n">as_stmt</span> <span class="p">{</span> <span class="p">(</span><span class="nv">$s:stmt</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span><span class="nv">$s</span><span class="p">}</span> <span class="p">}</span>
</code></pre></div>  </li>
  <li>
    <p>常见的 counting macro 的几种解法：</p>

<div class="highlight"><pre class="highlight rust"><code>
 <span class="c">// 重复方法</span>
 <span class="nd">macro_rules!</span> <span class="n">replace_expr</span> <span class="p">{</span>
     <span class="p">(</span><span class="nv">$_t:tt</span> <span class="nv">$sub:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span><span class="nv">$sub</span><span class="p">};</span>
 <span class="p">}</span>

 <span class="nd">macro_rules!</span> <span class="n">count_tts</span> <span class="p">{</span>
     <span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$tts:tt</span><span class="p">)</span><span class="o">*</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span><span class="mi">0u</span><span class="n">size</span> <span class="nv">$</span><span class="p">(</span><span class="o">+</span> <span class="nd">replace_expr!</span><span class="p">(</span><span class="nv">$tts</span> <span class="mi">1u</span><span class="n">size</span><span class="p">))</span><span class="o">*</span><span class="p">};</span>
 <span class="p">}</span>


 <span class="c">// 对于较小的数字，这是一种很好的方法，但可能会使编译器在输入大约 500 个左右的标记时崩溃。 考虑到输出将如下所示：</span>
 <span class="c">//0usize + 1usize + /* ~500 `+ 1usize`s */ + 1usize</span>

 <span class="nd">macro_rules!</span> <span class="n">count_tts</span> <span class="p">{</span>
     <span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span><span class="mi">0u</span><span class="n">size</span><span class="p">};</span>
     <span class="p">(</span><span class="nv">$_head:tt</span> <span class="nv">$</span><span class="p">(</span><span class="nv">$tail:tt</span><span class="p">)</span><span class="o">*</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span><span class="mi">1u</span><span class="n">size</span> <span class="o">+</span> <span class="nd">count_tts!</span><span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$tail</span><span class="p">)</span><span class="o">*</span><span class="p">)};</span>
 <span class="p">}</span>

 <span class="c">//递归调用， 存在与重复方法同样的 递归限制 问题，可以使用一次匹配 多个项目 来减少 递归深度。如下： 将能够匹配的项目 提高到 ~1,200 </span>

 <span class="nd">macro_rules!</span> <span class="n">count_tts</span> <span class="p">{</span>
     <span class="p">(</span><span class="nv">$_a:tt</span> <span class="nv">$_b:tt</span> <span class="nv">$_c:tt</span> <span class="nv">$_d:tt</span> <span class="nv">$_e:tt</span>
      <span class="nv">$_f:tt</span> <span class="nv">$_g:tt</span> <span class="nv">$_h:tt</span> <span class="nv">$_i:tt</span> <span class="nv">$_j:tt</span>
      <span class="nv">$_k:tt</span> <span class="nv">$_l:tt</span> <span class="nv">$_m:tt</span> <span class="nv">$_n:tt</span> <span class="nv">$_o:tt</span>
      <span class="nv">$_p:tt</span> <span class="nv">$_q:tt</span> <span class="nv">$_r:tt</span> <span class="nv">$_s:tt</span> <span class="nv">$_t:tt</span>
      <span class="nv">$</span><span class="p">(</span><span class="nv">$tail:tt</span><span class="p">)</span><span class="o">*</span><span class="p">)</span>
         <span class="k">=&gt;</span> <span class="p">{</span><span class="mi">20u</span><span class="n">size</span> <span class="o">+</span> <span class="nd">count_tts!</span><span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$tail</span><span class="p">)</span><span class="o">*</span><span class="p">)};</span>
     <span class="p">(</span><span class="nv">$_a:tt</span> <span class="nv">$_b:tt</span> <span class="nv">$_c:tt</span> <span class="nv">$_d:tt</span> <span class="nv">$_e:tt</span>
      <span class="nv">$_f:tt</span> <span class="nv">$_g:tt</span> <span class="nv">$_h:tt</span> <span class="nv">$_i:tt</span> <span class="nv">$_j:tt</span>
      <span class="nv">$</span><span class="p">(</span><span class="nv">$tail:tt</span><span class="p">)</span><span class="o">*</span><span class="p">)</span>
         <span class="k">=&gt;</span> <span class="p">{</span><span class="mi">10u</span><span class="n">size</span> <span class="o">+</span> <span class="nd">count_tts!</span><span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$tail</span><span class="p">)</span><span class="o">*</span><span class="p">)};</span>
     <span class="p">(</span><span class="nv">$_a:tt</span> <span class="nv">$_b:tt</span> <span class="nv">$_c:tt</span> <span class="nv">$_d:tt</span> <span class="nv">$_e:tt</span>
      <span class="nv">$</span><span class="p">(</span><span class="nv">$tail:tt</span><span class="p">)</span><span class="o">*</span><span class="p">)</span>
         <span class="k">=&gt;</span> <span class="p">{</span><span class="mi">5u</span><span class="n">size</span> <span class="o">+</span> <span class="nd">count_tts!</span><span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$tail</span><span class="p">)</span><span class="o">*</span><span class="p">)};</span>
     <span class="p">(</span><span class="nv">$_a:tt</span>
      <span class="nv">$</span><span class="p">(</span><span class="nv">$tail:tt</span><span class="p">)</span><span class="o">*</span><span class="p">)</span>
         <span class="k">=&gt;</span> <span class="p">{</span><span class="mi">1u</span><span class="n">size</span> <span class="o">+</span> <span class="nd">count_tts!</span><span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$tail</span><span class="p">)</span><span class="o">*</span><span class="p">)};</span>
     <span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span><span class="mi">0u</span><span class="n">size</span><span class="p">};</span>
 <span class="p">}</span>
</code></pre></div>  </li>
</ol>

<h5 id="对macro进行debug">对macro进行debug：</h5>
<ul>
  <li>
    <p>1）trace_macros 使用示例： 同样可以传递  -Z trace-macros 给rustc 命令调用上。</p>

<div class="highlight"><pre class="highlight rust"><code>  <span class="nd">#![feature(trace_macros)]</span>

  <span class="nd">macro_rules!</span> <span class="n">each_tt</span> <span class="p">{</span>
      <span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{};</span>
      <span class="p">(</span><span class="nv">$_tt:tt</span> <span class="nv">$</span><span class="p">(</span><span class="nv">$rest:tt</span><span class="p">)</span><span class="o">*</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span><span class="nd">each_tt!</span><span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$rest</span><span class="p">)</span><span class="o">*</span><span class="p">);};</span>
  <span class="p">}</span>

  <span class="nd">each_tt!</span><span class="p">(</span><span class="n">foo</span> <span class="n">bar</span> <span class="n">baz</span> <span class="n">quux</span><span class="p">);</span>
  <span class="nd">trace_macros!</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span> <span class="c">// 打开 debug</span>
  <span class="nd">each_tt!</span><span class="p">(</span><span class="n">spim</span> <span class="n">wak</span> <span class="n">plee</span> <span class="n">whum</span><span class="p">);</span> <span class="c">// 将 macro的调用进行展开</span>
  <span class="nd">trace_macros!</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span> <span class="c">// 关闭debug</span>
  <span class="nd">each_tt!</span><span class="p">(</span><span class="n">trom</span> <span class="n">qlip</span> <span class="n">winp</span> <span class="n">xod</span><span class="p">);</span>


  <span class="n">The</span> <span class="n">output</span> <span class="n">is</span><span class="p">:</span>

  <span class="nd">each_tt!</span> <span class="p">{</span> <span class="n">spim</span> <span class="n">wak</span> <span class="n">plee</span> <span class="n">whum</span> <span class="p">}</span>
  <span class="nd">each_tt!</span> <span class="p">{</span> <span class="n">wak</span> <span class="n">plee</span> <span class="n">whum</span> <span class="p">}</span>
  <span class="nd">each_tt!</span> <span class="p">{</span> <span class="n">plee</span> <span class="n">whum</span> <span class="p">}</span>
  <span class="nd">each_tt!</span> <span class="p">{</span> <span class="n">whum</span> <span class="p">}</span>
  <span class="nd">each_tt!</span> <span class="p">{</span>  <span class="p">}</span>
</code></pre></div>  </li>
  <li>
    <p>2) macro log_syntax  可以将 编译器 传递给macro的 内容全部输出出来，可以这样。</p>
  </li>
</ul>

<div class="highlight"><pre class="highlight rust"><code><span class="nd">#![feature(log_syntax)]</span>

<span class="nd">macro_rules!</span> <span class="n">sing</span> <span class="p">{</span>
    <span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{};</span>
    <span class="p">(</span><span class="nv">$tt:tt</span> <span class="nv">$</span><span class="p">(</span><span class="nv">$rest:tt</span><span class="p">)</span><span class="o">*</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span><span class="nd">log_syntax!</span><span class="p">(</span><span class="nv">$tt</span><span class="p">);</span> <span class="nd">sing!</span><span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$rest</span><span class="p">)</span><span class="o">*</span><span class="p">);};</span>
<span class="p">}</span>

</code></pre></div>
<ul>
  <li>3) 可以使用 编译参数 rustc -Z unstable-options –pretty expanded hello.rs 来输出macro展开之后的 形式内容</li>
</ul>

<div class="highlight"><pre class="highlight rust"><code><span class="c">// Shorthand for initialising a `String`.</span>
<span class="nd">macro_rules!</span> <span class="n">S</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$e:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="nv">$e</span><span class="p">)};</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">world</span> <span class="o">=</span> <span class="nd">S!</span><span class="p">(</span><span class="s">"World"</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Hello, {}!"</span><span class="p">,</span> <span class="n">world</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c">//使用 --pretty  之后输出如下， 这里面将 println同样输出出来了。</span>
<span class="nd">#![feature(no_std,</span> <span class="nd">prelude_import)]</span>
<span class="nd">#![no_std]</span>
<span class="nd">#[prelude_import]</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">prelude</span><span class="p">::</span><span class="nn">v1</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
<span class="nd">#[macro_use]</span>
<span class="k">extern</span> <span class="n">crate</span> <span class="n">std</span> <span class="k">as</span> <span class="n">std</span><span class="p">;</span>
<span class="c">// Shorthand for initialising a `String`.</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">world</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"World"</span><span class="p">);</span>
    <span class="p">::</span><span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="mi">_</span><span class="nf">print</span><span class="p">(::</span><span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nn">Arguments</span><span class="p">::</span><span class="nf">new_v1</span><span class="p">(</span>
        <span class="p">{</span>
            <span class="k">static</span> <span class="mi">__</span><span class="n">STATIC_FMTSTR</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'static</span> <span class="p">[</span><span class="o">&amp;</span><span class="nv">'static</span> <span class="nb">str</span><span class="p">]</span>
                <span class="o">=</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"Hello, "</span><span class="p">,</span> <span class="s">"!</span><span class="se">\n</span><span class="s">"</span><span class="p">];</span>
            <span class="mi">__</span><span class="n">STATIC_FMTSTR</span>
        <span class="p">},</span>
        <span class="o">&amp;</span><span class="k">match</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">world</span><span class="p">,)</span> <span class="p">{</span>
             <span class="p">(</span><span class="mi">__</span><span class="n">arg0</span><span class="p">,)</span> <span class="k">=&gt;</span> <span class="p">[</span>
                <span class="p">::</span><span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nn">ArgumentV1</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">__</span><span class="n">arg0</span><span class="p">,</span> <span class="p">::</span><span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nn">Display</span><span class="p">::</span><span class="n">fmt</span><span class="p">)</span>
            <span class="p">],</span>
        <span class="p">}</span>
    <span class="p">));</span>
<span class="p">}</span>

</code></pre></div>
<div class="social"></div></article></main><footer><div class="footer-wrapper"><div class="author"><div class="image-wrapper"><a href="/author/"><img alt="author" src="../../../../images/profile-1e71686a.png" /></a></div></div><div class="image-content"><img src="../../../../images/wechat_nasa-0d87c0dd.png" /></div><div class="copyright"><i class="fa fa-copyright"></i> 2022 <a href="/">日常学习</a> - geniousbar</div></div><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?b43ef53b285c49e1af0bd7080994c825";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script></footer></body></html>