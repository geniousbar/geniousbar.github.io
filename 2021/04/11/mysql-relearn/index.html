<!DOCTYPE html><html><head><meta charset="utf-8" /><meta content="IE=edge;chrome=1" http-equiv="X-UA-Compatible" /><meta content="initial-scale=1.0, user-scalable=no" name="viewport" /><title>Mysql | 日常学习</title><meta description="Mysql Relearn 内存模型：     Change BUffer： 缓存 不在Buffer pool 中的 索引页的变动， 变动 可能由 insert update， delete 等操作 导致， 将在以后 页面 被加载到 Buffer pool时 被合并            [image]       不同于 聚簇索引， 普通的索引 通常是不唯一的，索引 的插入 删除 更新 通常是 random 的， 随后 将 change Buffer 的合并到 Buffer pool（当...   " /><link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/feed.xml" /><link href="../../../../stylesheets/style-198d4031.css" rel="stylesheet" type="text/css" /><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" /><link href="../../../../images/favicon-6c3f3d04.png" rel="icon" type="image/png" /><script src="../../../../javascripts/all-b3988275.js"></script></head><body><header><div class="top-menu"><div class="top-menu-wrapper"><div class="top-menu-list"><ul><li><a href="/">Home</a></li><li><a href="/archives/">Archives</a></li><li><a href="/tags/">Tags</a></li><li><a href="/by-year/">By Year</a></li><li id="wechat"><a href="#" onclick="toggleShowWechat()">Wechat</a></li></ul></div></div></div><div id="header-wechat-img"><img src="../../../../images/wechat_nasa-0d87c0dd.png" /></div><h1 class="logo"><a href="/" title="日常学习"><span class="logo-text">日常学习</span></a></h1></header><main><article><h1 class="article-title">Mysql</h1><div class="posted-date-wrapper"><i class="fa fa-clock-o"></i><span class="posted-date">April 11, 2021</span></div><div class="tag-labels"><a href="/tags/mysql/"><small class="tag-label">mysql</small></a></div><hr class="article-header-separator" /><h2 id="mysql-relearn">Mysql Relearn</h2>
<h3 id="内存模型">内存模型：</h3>
<p><img src="../../../../images/innodb-change-buffer-5fbd1a84.png" alt="memory-cache" /></p>
<ul>
  <li>Change BUffer： 缓存 不在Buffer pool 中的 索引页的变动， 变动 可能由 insert update， delete 等操作 导致， 将在以后 页面 被加载到 Buffer pool时 被合并
    <ul>
      <li>[image]</li>
      <li>不同于 聚簇索引， 普通的索引 通常是不唯一的，索引 的插入 删除 更新 通常是 random 的， 随后 将 change Buffer 的合并到 Buffer pool（当索引页被load 到 buffer pool时） 将减少 随机 的IO 操作。</li>
      <li>当系统 空闲时，或者缓慢关闭时 会定时的进行清理操作（将cache 写回到 硬盘中） 清理操作 将 一系列的 索引更新 写入到磁盘中 的速度 远高于 每个更新立即写入</li>
      <li>当存在大量的 受影响的row 和 众多的 索引时， change Buffer 的合并（这里的合并 应该不是简单的与 Buffer pool的合并，而是 合并之后，需要写回到 硬盘中吧） 可能 需要数个小时， 在这期间， IO将显著增加， 导致 磁盘绑定查询（意思是 需要 访问硬盘？） 的速度显著变慢，</li>
      <li>在Memory中， change buff 是Buffer pool 的一部分， 在disk上， change buff 是 system tablespace 的一部分（当服务器关闭是， 索引的更改change buff 可能保存其中）</li>
      <li>配置：
        <ol>
          <li>innodb_change_buffering 因为 change buffer 虽然能够 减少IO操作，但 依然占用了 部分的 Buffer pool, 所以提供了此变量 来精确的控制 insert， delete， purge（physical deletion happen in background）， changes(insert + delete) 操作 是否使用  change buffer</li>
          <li>innodb_change_buffer_max_size 可以控制 buffer的大小，数值为 其所占 Buffer pool 的百分比， 默认为 25，最高 为 50</li>
        </ol>
      </li>
      <li>Monitor：
        <ul>
          <li>show engine Innodb status 中的 INSERT BUFFER AND ADAPTIVE HASH INDEX 段</li>
        </ul>
      </li>
    </ul>

<div class="highlight"><pre class="highlight plaintext"><code>  -------------------------------------
  INSERT BUFFER AND ADAPTIVE HASH INDEX
  -------------------------------------
  Ibuf: size 1, free list len 0, seg size 2, 0 merges
  merged operations:
   insert 0, delete mark 0, delete 0
  discarded operations:
   insert 0, delete mark 0, delete 0
  Hash table size 4425293, used cells 32, node heap has 1 buffer(s)
  13577.57 hash searches/s, 202.47 non-hash searches/s

</code></pre></div>    <ul>
      <li>数据库方式： information_schema 中 相关的table 可以查询到相关信息 <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-change-buffer.html#innodb-change-buffer-maximum-size">url</a></li>
    </ul>
  </li>
</ul>

<h3 id="自适应hash-索引">自适应Hash 索引：</h3>
<ul>
  <li>Hash 索引： 通过 索引 的前缀 构建 hash 的 key， 通过监控到的搜索， 如果InnoDB 认为可以 让查询从 简历Hash索引中 收益， 他会自动构建。</li>
  <li>在一些负载比较繁重的情况下， 导致 监控 争用 Hash索引 的开销 并不能够 使其 受益，则可以选择关闭 该选项， 以为很难判定 这种情况的出现， 则 应该使用 准确的基准测试 之后来决定</li>
  <li>自适应 Hash索引： 已经实现了 分区(partition)， 每个索引都绑定到特定的分区（并不知道有啥用,这里要讲啥?） 分区数量由 innodb_adaptive_hash_index_parts  控制，在 8…512 范围内</li>
  <li>可以 在 show engine innodb  status 中的  SEMAPHORES 段 来查看 btr0sea.c 的rw 锁 争用情况， 可以考虑增加 Hash索引的分区数值，或者关闭 该功能</li>
</ul>

<h3 id="log-buffer">Log Buffer:</h3>
<ul>
  <li>Log buffer 用来缓存 将要写入 disk 的 log file的数据，</li>
  <li>配置：
    <ol>
      <li>innodb_log_buffer_size  用来控制Buffer 的大小， default is 16MB, 定期 刷新到 disk, 一个大 的 log buffer 可以让一个 da的 transaction 在commit 提交前 不需要将 redo log 刷新到disk 中。</li>
      <li>innodb_flush_log_at_trx_commit  控制 log buffer 而如何 同步到disk中</li>
      <li>innodb_flush_log_at_timeout： 控制log buffer 同步的频率</li>
    </ol>
  </li>
</ul>

<h3 id="innodb-磁盘数据结构">InnoDB 磁盘数据结构：</h3>

<h4 id="table">Table</h4>
<h4 id="创建表-create-table">创建表： create table,</h4>
<div class="highlight"><pre class="highlight sql"><code>   <span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">t1</span> <span class="p">(</span><span class="n">a</span> <span class="nb">INT</span><span class="p">,</span> <span class="n">b</span> <span class="nb">CHAR</span> <span class="p">(</span><span class="mi">20</span><span class="p">),</span> <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span><span class="p">;</span>  
</code></pre></div><ul>
  <li>Innodb 默认 table 的存储方式 为一个 文件 一个table， 配置 innodb_file_per_table 用来打开、关闭 此行为
    <h4 id="row-format">Row format：</h4>
  </li>
  <li>row 的格式，决定了 InnoDB 行 在物理上的disk 的存储，支持 4中format， 每个格式 都有对应的存储特性。格式有：
    <ul>
      <li>redundant： 冗余</li>
      <li>compact： 紧凑</li>
      <li>dynamic： 动态</li>
      <li>compressed： 压缩</li>
    </ul>
  </li>
  <li>row 格式控制： 默认为 dynamic， 变量 innodb_default_row_format 可以控制 默认的row 存储格式， create table, alter table 也同样可以控制 row 格式</li>
</ul>

<h4 id="primary-key">Primary key</h4>
<ul>
  <li>
    <p>建议 为每个table 创建自己的 primary key, 选取 primary key 的column 规则为：</p>

    <ul>
      <li>重要查询所使用</li>
      <li>永远不会存储空</li>
      <li>永远不会存储重复数值</li>
      <li>插入之后 很少更新的数值</li>
    </ul>
  </li>
  <li>如果没有 明显的选择的话， 则 可以创建一个 type 为number auto-increment 的column 作为主建</li>
  <li>尽管在没有定义主键的情况下表可以正常工作，但是主键涉及性能的许多方面，并且对于任何大型或经常使用的表都是至关重要的设计方面。 建议始终在CREATE TABLE语句中指定主键</li>
  <li>查看table的相关的属性：
    <ol>
      <li>SHOW TABLE STATUS</li>
    </ol>

<div class="highlight"><pre class="highlight sql"><code>   <span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SHOW</span> <span class="k">TABLE</span> <span class="n">STATUS</span> <span class="k">FROM</span> <span class="n">test</span> <span class="k">LIKE</span> <span class="s1">'t%'</span> <span class="err">\</span><span class="k">G</span><span class="p">;</span>
   <span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
              <span class="n">Name</span><span class="p">:</span> <span class="n">t1</span>
            <span class="n">Engine</span><span class="p">:</span> <span class="n">InnoDB</span>
           <span class="k">Version</span><span class="p">:</span> <span class="mi">10</span>
        <span class="n">Row_format</span><span class="p">:</span> <span class="k">Dynamic</span>
              <span class="k">Rows</span><span class="p">:</span> <span class="mi">0</span>
    <span class="n">Avg_row_length</span><span class="p">:</span> <span class="mi">0</span>
       <span class="n">Data_length</span><span class="p">:</span> <span class="mi">16384</span>
   <span class="n">Max_data_length</span><span class="p">:</span> <span class="mi">0</span>
      <span class="n">Index_length</span><span class="p">:</span> <span class="mi">0</span>
         <span class="n">Data_free</span><span class="p">:</span> <span class="mi">0</span>
    <span class="n">Auto_increment</span><span class="p">:</span> <span class="k">NULL</span>
       <span class="n">Create_time</span><span class="p">:</span> <span class="mi">2021</span><span class="o">-</span><span class="mi">02</span><span class="o">-</span><span class="mi">18</span> <span class="mi">12</span><span class="p">:</span><span class="mi">18</span><span class="p">:</span><span class="mi">28</span>
       <span class="n">Update_time</span><span class="p">:</span> <span class="k">NULL</span>
        <span class="n">Check_time</span><span class="p">:</span> <span class="k">NULL</span>
         <span class="k">Collation</span><span class="p">:</span> <span class="n">utf8mb4_0900_ai_ci</span>
          <span class="n">Checksum</span><span class="p">:</span> <span class="k">NULL</span>
    <span class="n">Create_options</span><span class="p">:</span> 
           <span class="k">Comment</span><span class="p">:</span>    
</code></pre></div>
    <ol>
      <li>
        <p>从 INFORMATION_SCHEMA.INNODB_TABLES 中获取信息:</p>

<div class="highlight"><pre class="highlight sql"><code>
  <span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">INFORMATION_SCHEMA</span><span class="p">.</span><span class="n">INNODB_TABLES</span> <span class="k">WHERE</span> <span class="n">NAME</span><span class="o">=</span><span class="s1">'test/t1'</span> <span class="err">\</span><span class="k">G</span>
 <span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
      <span class="n">TABLE_ID</span><span class="p">:</span> <span class="mi">1144</span>
          <span class="n">NAME</span><span class="p">:</span> <span class="n">test</span><span class="o">/</span><span class="n">t1</span>
          <span class="n">FLAG</span><span class="p">:</span> <span class="mi">33</span>
        <span class="n">N_COLS</span><span class="p">:</span> <span class="mi">5</span>
         <span class="k">SPACE</span><span class="p">:</span> <span class="mi">30</span>
    <span class="n">ROW_FORMAT</span><span class="p">:</span> <span class="k">Dynamic</span>
 <span class="n">ZIP_PAGE_SIZE</span><span class="p">:</span> <span class="mi">0</span>
    <span class="n">SPACE_TYPE</span><span class="p">:</span> <span class="n">Single</span>
  <span class="n">INSTANT_COLS</span><span class="p">:</span> <span class="mi">0</span>
</code></pre></div>      </li>
    </ol>
  </li>
</ul>

<h4 id="在其他目录中存储-数据即-外部创建表">在其他目录中存储 数据：（即 外部创建表）</h4>
<ul>
  <li>Using the DATA DIRECTORY Clause： 在 create table syntax 中 可以 添加  DATA DIRECTORY 来制定数据的存储目录</li>
  <li>Using TABLESPACE Clause: 在create table syntax 中添加 TABLESPACE = innodb_file_per_table 配合 data dictory 使用</li>
  <li>
    <p>示例：</p>

<div class="highlight"><pre class="highlight sql"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="n">USE</span> <span class="n">test</span><span class="p">;</span>
<span class="k">Database</span> <span class="n">changed</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">t1</span> <span class="p">(</span><span class="n">c1</span> <span class="nb">INT</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">)</span> <span class="k">DATA</span> <span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s1">'/external/directory'</span><span class="p">;</span>

<span class="o">#</span> <span class="n">MySQL</span> <span class="n">creates</span> <span class="n">the</span> <span class="k">table</span><span class="s1">'s data file in a schema directory
# under the external directory

shell&gt; cd /external/directory/test
shell&gt; ls
t1.ibd
</span></code></pre></div>  </li>
</ul>

<h4 id="导入-innodb-表">导入 InnoDB 表：</h4>
<ul>
  <li>可能应用的场景有：
    <ol>
      <li>利用 线上 的数据做报表，而不像 增加额外的负担 在线上 2） 复制数据给 replica server 3） 从backup 上恢复 表 4）</li>
      <li>比import a dump file 更快的 移动数据 的方法</li>
    </ol>
  </li>
  <li>先决条件
    <ol>
      <li>innodb_file_per_table  变量 必须是打开的</li>
      <li>source server &amp; desitnation server  的 page size of tablespace 配置必须相同，  innodb_page_size  变量控制</li>
      <li>foreign key 的关系， 如果 导出表 有 foreign key，  在 执行 discard talbespace 之前， 则 需要 foreign_key_checks 需要关闭， 还需要导出所有外键 关联的表，因为ALTER TABLE … IMPORT TABLESPACE不会对导入的数据实施外键约束。 为此 需要 停止更新 相关的表， 提交所有 transaction， 获取表 的 S锁，然后执行 export 操作</li>
      <li>导出导入 的mysql version  必须兼容</li>
      <li>导出导入server 的 data directory 必须 相同, 导致 schema mismatch error</li>
      <li>导出导入server 的 ROW_FORMAT 需要相同, 导致 schema mismatch errorgg</li>
    </ol>
  </li>
  <li>示例
    <ol>
      <li>
        <p>在 destination server 上 创建表， schema 需要与 source server 表的 syntax 相同</p>

<div class="highlight"><pre class="highlight sql"><code> <span class="n">mysql</span><span class="o">&gt;</span> <span class="n">USE</span> <span class="n">test</span><span class="p">;</span>
 <span class="n">mysql</span><span class="o">&gt;</span> <span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">t1</span> <span class="p">(</span><span class="n">c1</span> <span class="nb">INT</span><span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">INNODB</span><span class="p">;</span>

</code></pre></div>      </li>
      <li>在destination server 上， 执行 discard tablespace 命令
        <ul>
          <li>table 将会 上 X 锁</li>
          <li>
            <p>tablespace 与table 分离</p>

<div class="highlight"><pre class="highlight sql"><code> <span class="n">mysql</span><span class="o">&gt;</span> <span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">t1</span> <span class="n">DISCARD</span> <span class="n">TABLESPACE</span><span class="p">;</span>
</code></pre></div>          </li>
        </ul>
      </li>
      <li>在source server 上 执行 flush tables … for export， 执行之后 只能允许 读表请求， 将产生 .cfg, .ibd文件
        <ul>
          <li>导出的table 将会上S锁， 并将更新 flush 到disk</li>
          <li>停止 purge thread</li>
          <li>Dirty page sync to disk</li>
          <li>
            <p>table metadata write to .cfg file</p>

<div class="highlight"><pre class="highlight sql"><code> <span class="n">mysql</span><span class="o">&gt;</span> <span class="n">USE</span> <span class="n">test</span><span class="p">;</span>
 <span class="n">mysql</span><span class="o">&gt;</span> <span class="n">FLUSH</span> <span class="n">TABLES</span> <span class="n">t1</span> <span class="k">FOR</span> <span class="n">EXPORT</span><span class="p">;</span>

 <span class="o">#</span> <span class="err">可能看到的</span> <span class="err">输出为</span>
 <span class="p">[</span><span class="n">Note</span><span class="p">]</span> <span class="n">InnoDB</span><span class="p">:</span> <span class="n">Sync</span> <span class="k">to</span> <span class="n">disk</span> <span class="k">of</span> <span class="s1">'"test"."t1"'</span> <span class="n">started</span><span class="p">.</span>
 <span class="p">[</span><span class="n">Note</span><span class="p">]</span> <span class="n">InnoDB</span><span class="p">:</span> <span class="n">Stopping</span> <span class="n">purge</span>
 <span class="p">[</span><span class="n">Note</span><span class="p">]</span> <span class="n">InnoDB</span><span class="p">:</span> <span class="n">Writing</span> <span class="k">table</span> <span class="n">metadata</span> <span class="k">to</span> <span class="s1">'./test/t1.cfg'</span>
 <span class="p">[</span><span class="n">Note</span><span class="p">]</span> <span class="n">InnoDB</span><span class="p">:</span> <span class="k">Table</span> <span class="s1">'"test"."t1"'</span> <span class="n">flushed</span> <span class="k">to</span> <span class="n">disk</span>
</code></pre></div>          </li>
        </ul>
      </li>
      <li>
        <p>复制数据：</p>

<div class="highlight"><pre class="highlight sql"><code> <span class="n">shell</span><span class="o">&gt;</span> <span class="n">scp</span> <span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="k">to</span><span class="o">/</span><span class="n">datadir</span><span class="o">/</span><span class="n">test</span><span class="o">/</span><span class="n">t1</span><span class="p">.</span><span class="err">{</span><span class="n">ibd</span><span class="p">,</span><span class="n">cfg</span><span class="err">}</span> <span class="n">destination</span><span class="o">-</span><span class="n">server</span><span class="p">:</span><span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="k">to</span><span class="o">/</span><span class="n">datadir</span><span class="o">/</span><span class="n">test</span>
</code></pre></div>      </li>
      <li>在 source server 上执行 unlock tables
        <ul>
          <li>删除 .cfg 文件</li>
          <li>table上的S锁 被释放</li>
          <li>purge thread 被重启</li>
        </ul>

<div class="highlight"><pre class="highlight sql"><code>  <span class="n">mysql</span><span class="o">&gt;</span> <span class="n">USE</span> <span class="n">test</span><span class="p">;</span>
  <span class="n">mysql</span><span class="o">&gt;</span> <span class="n">UNLOCK</span> <span class="n">TABLES</span><span class="p">;</span>

  <span class="o">#</span> <span class="err">可能的输出</span><span class="n">log</span><span class="err">为</span>
  <span class="p">[</span><span class="n">Note</span><span class="p">]</span> <span class="n">InnoDB</span><span class="p">:</span> <span class="n">Deleting</span> <span class="n">the</span> <span class="n">meta</span><span class="o">-</span><span class="k">data</span> <span class="n">file</span> <span class="s1">'./test/t1.cfg'</span>
  <span class="p">[</span><span class="n">Note</span><span class="p">]</span> <span class="n">InnoDB</span><span class="p">:</span> <span class="n">Resuming</span> <span class="n">purge</span>
</code></pre></div></li>
      <li>在 destination server 上import tablespace
        <ul>
          <li>每个 tablespace page 会被 校验是否正确</li>
          <li>The space ID and log sequence numbers (LSNs) on each page are updated.</li>
          <li>Flags are validated and LSN updated for the header page.</li>
          <li>Btree pages are updated.</li>
          <li>
            <p>The page state is set to dirty so that it is written to disk.</p>

<div class="highlight"><pre class="highlight sql"><code> <span class="n">mysql</span><span class="o">&gt;</span> <span class="n">USE</span> <span class="n">test</span><span class="p">;</span>
 <span class="n">mysql</span><span class="o">&gt;</span> <span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">t1</span> <span class="n">IMPORT</span> <span class="n">TABLESPACE</span><span class="p">;</span>

 <span class="o">#</span> <span class="err">可能输出</span> <span class="n">log</span> <span class="err">为：</span>

 <span class="p">[</span><span class="n">Note</span><span class="p">]</span> <span class="n">InnoDB</span><span class="p">:</span> <span class="n">Importing</span> <span class="n">tablespace</span> <span class="k">for</span> <span class="k">table</span> <span class="s1">'test/t1'</span> <span class="n">that</span> <span class="n">was</span> <span class="n">exported</span>
 <span class="k">from</span> <span class="k">host</span> <span class="s1">'host_name'</span>
 <span class="p">[</span><span class="n">Note</span><span class="p">]</span> <span class="n">InnoDB</span><span class="p">:</span> <span class="n">Phase</span> <span class="n">I</span> <span class="o">-</span> <span class="k">Update</span> <span class="k">all</span> <span class="n">pages</span>
 <span class="p">[</span><span class="n">Note</span><span class="p">]</span> <span class="n">InnoDB</span><span class="p">:</span> <span class="n">Sync</span> <span class="k">to</span> <span class="n">disk</span>
 <span class="p">[</span><span class="n">Note</span><span class="p">]</span> <span class="n">InnoDB</span><span class="p">:</span> <span class="n">Sync</span> <span class="k">to</span> <span class="n">disk</span> <span class="o">-</span> <span class="n">done</span><span class="o">!</span>
 <span class="p">[</span><span class="n">Note</span><span class="p">]</span> <span class="n">InnoDB</span><span class="p">:</span> <span class="n">Phase</span> <span class="n">III</span> <span class="o">-</span> <span class="n">Flush</span> <span class="n">changes</span> <span class="k">to</span> <span class="n">disk</span>
 <span class="p">[</span><span class="n">Note</span><span class="p">]</span> <span class="n">InnoDB</span><span class="p">:</span> <span class="n">Phase</span> <span class="n">IV</span> <span class="o">-</span> <span class="n">Flush</span> <span class="n">complete</span>
</code></pre></div>          </li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<h4 id="auto_increment-在innodb-中的处理方式">AUTO_INCREMENT 在InnoDB 中的处理方式</h4>
<ul>
  <li>在表中 添加 AUTO_INCREMENT 字段， 是InnoDB 提高性能 与 稳定性的一种方式， 为了有效利用 AUTO_INCREMENT ， 必须将 AUTO_INCREMENT 字段设为索引， 以便 执行 select max(col) 以获得 最大值，</li>
  <li>AUTO_INCREMENT 锁的 集中方式，其中的区别 以及 每种对 replic 的影响</li>
  <li>数据插入的集中方式： 所有生成 新row的 语句， 包括 insert, insert .. select, replace, replace .. select, load data 包含
    <ol>
      <li>simple-insert: 可以预先知道 插入 行数 的 insert 语句，比如简单的单行， 多行 insert</li>
      <li>bulk-insert: 插入行数未知  的语句，比如： insert .. select ,replace .. select, load data 语句</li>
      <li>mixed-mode insert: 指定 auto_increment 数值的 insert 语句 或者  INSERT … ON DUPLICATE KEY UPDATE 等复杂的 语句，这些语句可能不会使用 auto_increment 分配的数值 比如：</li>
    </ol>

<div class="highlight"><pre class="highlight sql"><code>   <span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">t1</span> <span class="p">(</span><span class="n">c1</span><span class="p">,</span><span class="n">c2</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s1">'a'</span><span class="p">),</span> <span class="p">(</span><span class="k">NULL</span><span class="p">,</span><span class="s1">'b'</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="s1">'c'</span><span class="p">),</span> <span class="p">(</span><span class="k">NULL</span><span class="p">,</span><span class="s1">'d'</span><span class="p">);</span>
</code></pre></div></li>
  <li>innodb_autoinc_lock_mode 可能的模式有： 0 (traditional), 1(consecutive), 2(interleaved) Mysql 8.0 默认为 interleaved 模式， 8.0 之前 默认为 consecutive 模式
    <h5 id="lock-mode-的变化-反映了-mysql-从--基于语句-replica-转变到-基于-row-replica-的转变-基于语句复制-需要-一个-consecutive-的lock-mode--来确保-auto-increment-数值的-可以预测-可重复-性-因为-在replic时候-同步的是-sql-执行语句只有这样才能够保证-replic与-master-server-的数据一致性-而基于-row-replica-对于-语句的执行顺序并不敏感">lock mode 的变化 反映了 Mysql 从  基于语句 replica 转变到 基于 row replica 的转变。 基于语句复制 需要 一个 consecutive 的lock mode  来确保 auto-increment 数值的 可以预测 可重复 性 （因为 在replic时候， 同步的是 sql 执行语句，只有这样才能够保证 replic与 master server 的数据一致性）， 而基于 row replica 对于 语句的执行顺序并不敏感</h5>
    <ol>
      <li>traditional: 该种模式下， 所有的inert like 语句 斗殴需要获取 一个特殊的 table-level  auto-inc lock， 该锁 需要把持到 语句的结束（非 transaction 结束） 来 保证 auto-increment 数值 的可重复性 与 可预见性， 同时保证了  auto-increment 字段数值的 连续性。 假设在 基于 语句 的复制模式中， 这意味着 sql语句 replic 到 replica server上的时候，将产生 与 source server上 完全相同的数值。 如果 让 多个 insert 语句 交替执行，则将导致 结果 不可重现， 即 replica server 与 source server数据 并不相同。 下面示例：</li>
    </ol>

<div class="highlight"><pre class="highlight sql"><code>  <span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">t1</span> <span class="p">(</span>
    <span class="n">c1</span> <span class="nb">INT</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
    <span class="n">c2</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">c1</span><span class="p">)</span>
  <span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span><span class="p">;</span>

  <span class="o">#</span> <span class="c1">----------</span>
  <span class="n">Tx1</span><span class="p">:</span> <span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">t1</span> <span class="p">(</span><span class="n">c2</span><span class="p">)</span> <span class="k">SELECT</span> <span class="mi">1000</span> <span class="k">rows</span> <span class="k">from</span> <span class="n">another</span> <span class="k">table</span> <span class="p">...</span>
  <span class="n">Tx2</span><span class="p">:</span> <span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">t1</span> <span class="p">(</span><span class="n">c2</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'xxx'</span><span class="p">);</span>


  <span class="o">#</span> <span class="n">InnoDB</span> <span class="err">并不能知道</span> <span class="n">Tx1</span> <span class="err">中到底有多少数据</span> <span class="err">需要插入，</span> <span class="err">使用</span> <span class="err">一个</span> <span class="k">table</span><span class="o">-</span><span class="k">level</span> <span class="err">的</span><span class="k">lock</span> <span class="err">，可以</span> <span class="err">使</span> <span class="err">在同一时间</span> <span class="err">只执行</span> <span class="err">一个</span> <span class="k">sql</span> <span class="err">语句。</span> <span class="err">所以</span> <span class="err">当在</span> <span class="n">replica</span> <span class="n">server</span> <span class="err">上</span> <span class="err">使用</span> <span class="err">基于</span>  <span class="nb">binary</span> <span class="n">log</span> <span class="err">重放</span> <span class="k">sql</span> <span class="err">语句时候，无论是</span><span class="n">Tx1</span> <span class="err">与</span> <span class="n">Tx2</span> <span class="err">谁先执行，</span> <span class="err">都会产生相同的结果。当然</span> <span class="err">一个</span><span class="k">table</span><span class="o">-</span><span class="k">level</span><span class="err">的</span><span class="k">lock</span> <span class="err">必然会限制</span> <span class="err">并发</span> <span class="err">与</span> <span class="err">可伸缩性</span> <span class="err">的发挥</span>
</code></pre></div></li>
</ul>

<ol>
  <li>consecutive mode: 在该种模式下，
    <ul>
      <li>“bulk inserts” 使用特殊的 AUTO-INC table level lock 并一直把持到 语句的最后。该类规则将 应用到 所有 的 insert ..select, replace .. select, load data 的语句中，同一时间 只有 一个把持 AUTO-INC 的语句 能够执行，</li>
      <li>“simple inserts”: 因为可以预先知道插入的数量， 可以使用 特殊的 轻量级 X锁（只在auto-increment 分配阶段 保持），来避免  table-level AUTO-INC 锁。如果存在 其他的 transaction 持有 table-level 的 AUTO-INC lock 则 需要等待 该 transaction 完成</li>
      <li>
        <p>”mixed-mode inserts“: 分配的数值增量 要大于 插入的行数， 自动分配的数值 也是连续的。</p>
      </li>
      <li>简单的说， consecutive lock mode 下， 在 保证 基于语句的 replic 正确下，提高了 并发与可伸缩性， 完美兼容 tranditional mode</li>
    </ul>
  </li>
  <li>
    <p>interleaved mode: 不使用 table-level auto-inc lock， 而且可以同时执行多个insert 语句， 是最快的，可伸缩 的 lock 模式， 但是对于 基于语句 复制的 server来说 并不安全。 在这种锁定模式下，保证auto-increment column 是唯一的，并且在所有同时执行的“类似INSERT”语句中单调递增。 但是，由于多个语句可以同时生成数字（也就是说，在语句之间交错分配数字），因此为任何给定语句插入的行生成的值可能不是连续的。即： 在 simple insert 语句中， auto-increment 中的column是连续的， mixed-mode insert 与 bulk insert 中 可能存在 gap</p>
  </li>
  <li>auto-increment gap: 自动增量间隙
    <ul>
      <li>在所有的lock mode下： 如果事务发生回滚，则分配给该 transaction 的数值 就丢失了，该值 将不会被重用，因为表中的 auto-increment column 数值 可能存在 gap</li>
      <li>批量插入： 在 traditional 或者 consecutive 模式下 任何插入 都不会产生 gap，因为批量插入 都需要获得 table-level 的 auto-inr lock 并保持到 活动结束。 在 interleaved 下，”bulk-insert” 可能产生gap。在 consecutive 或者 interleaved 模式下， 在连续的语句之间可能会出现gap，因为对于批量插入，可能不知道每个语句所需的自动递增值的确切数量，并且可能会高估。( 这里面 是不是描述有问题？ 因为已经在前面说了， tranditional or consecutive 模式下 批量插入并不会产生gap， 这里又说会有， 为什么？ <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html">文档在此</a>)</li>
      <li>mixed mode insert 在各种不同mode下产生的结果： 最近产生的sequence number  is 100：</li>
    </ul>

<div class="highlight"><pre class="highlight sql"><code>    <span class="n">mysql</span><span class="o">&gt;</span> <span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">t1</span> <span class="p">(</span>
    <span class="o">-&gt;</span> <span class="n">c1</span> <span class="nb">INT</span> <span class="nb">UNSIGNED</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span> 
    <span class="o">-&gt;</span> <span class="n">c2</span> <span class="nb">CHAR</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="o">-&gt;</span> <span class="p">)</span> <span class="n">ENGINE</span> <span class="o">=</span> <span class="n">INNODB</span><span class="p">;</span>  

    <span class="n">mysql</span><span class="o">&gt;</span> <span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">t1</span> <span class="p">(</span><span class="n">c1</span><span class="p">,</span><span class="n">c2</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s1">'a'</span><span class="p">),</span> <span class="p">(</span><span class="k">NULL</span><span class="p">,</span><span class="s1">'b'</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="s1">'c'</span><span class="p">),</span> <span class="p">(</span><span class="k">NULL</span><span class="p">,</span><span class="s1">'d'</span><span class="p">);</span>

    <span class="o">#</span> <span class="k">lock</span> <span class="k">mode</span> <span class="err">为</span> <span class="n">traditional</span> <span class="err">时候，</span> <span class="err">执行插入操作</span>
    <span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="k">FROM</span> <span class="n">t1</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">c2</span><span class="p">;</span>
     <span class="o">+</span><span class="c1">-----+------+</span>
     <span class="o">|</span> <span class="n">c1</span>  <span class="o">|</span> <span class="n">c2</span>   <span class="o">|</span>
     <span class="o">+</span><span class="c1">-----+------+</span>
     <span class="o">|</span>   <span class="mi">1</span> <span class="o">|</span> <span class="n">a</span>    <span class="o">|</span>
     <span class="o">|</span> <span class="mi">101</span> <span class="o">|</span> <span class="n">b</span>    <span class="o">|</span>
     <span class="o">|</span>   <span class="mi">5</span> <span class="o">|</span> <span class="k">c</span>    <span class="o">|</span>
     <span class="o">|</span> <span class="mi">102</span> <span class="o">|</span> <span class="n">d</span>    <span class="o">|</span>
     <span class="o">+</span><span class="c1">-----+------+</span>

    <span class="o">#</span> <span class="k">lock</span> <span class="k">mode</span> <span class="err">为</span> <span class="n">consecutive</span> <span class="err">时候，</span> <span class="err">执行插入操作</span>   

        <span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="k">FROM</span> <span class="n">t1</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">c2</span><span class="p">;</span>
    <span class="o">+</span><span class="c1">-----+------+</span>
    <span class="o">|</span> <span class="n">c1</span>  <span class="o">|</span> <span class="n">c2</span>   <span class="o">|</span>
    <span class="o">+</span><span class="c1">-----+------+</span>
    <span class="o">|</span>   <span class="mi">1</span> <span class="o">|</span> <span class="n">a</span>    <span class="o">|</span>
    <span class="o">|</span> <span class="mi">101</span> <span class="o">|</span> <span class="n">b</span>    <span class="o">|</span>
    <span class="o">|</span>   <span class="mi">5</span> <span class="o">|</span> <span class="k">c</span>    <span class="o">|</span>
    <span class="o">|</span> <span class="mi">102</span> <span class="o">|</span> <span class="n">d</span>    <span class="o">|</span>
    <span class="o">+</span><span class="c1">-----+------+</span>


    <span class="o">#</span> <span class="k">lock</span> <span class="k">mode</span> <span class="err">为</span> <span class="n">interleaved</span> <span class="err">时候，</span> <span class="err">执行插入操作</span> 

     <span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="k">FROM</span> <span class="n">t1</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">c2</span><span class="p">;</span>
     <span class="o">+</span><span class="c1">-----+------+</span>
     <span class="o">|</span> <span class="n">c1</span>  <span class="o">|</span> <span class="n">c2</span>   <span class="o">|</span>
     <span class="o">+</span><span class="c1">-----+------+</span>
     <span class="o">|</span>   <span class="mi">1</span> <span class="o">|</span> <span class="n">a</span>    <span class="o">|</span>
     <span class="o">|</span>   <span class="n">x</span> <span class="o">|</span> <span class="n">b</span>    <span class="o">|</span>
     <span class="o">|</span>   <span class="mi">5</span> <span class="o">|</span> <span class="k">c</span>    <span class="o">|</span>
     <span class="o">|</span>   <span class="n">y</span> <span class="o">|</span> <span class="n">d</span>    <span class="o">|</span>
     <span class="o">+</span><span class="c1">-----+------+    </span>

     <span class="n">x</span> <span class="n">y</span> <span class="err">代表</span> <span class="err">唯一，但是并不能够确定的数值</span>
</code></pre></div></li>
</ol>

<ul>
  <li>
    <p>InnoDB AUTO_INCREMENT Counter 的初始化：</p>
  </li>
  <li>mysql 5.7 auto-increment 的counter 存储在 main memory not disk， 所以 当server 重启，将执行  类似  SELECT MAX(ai_col) FROM table_name FOR UPDATE; 来 进行 counter 的初始化</li>
  <li>MySQL 8.0 之后，行为发生了改变， 目前最大的 auto-increment counter 数值 被写入到了 redo log， server 重启直接从 disk 进行初始化counter</li>
  <li>所以， 5.7 之后，如果transaction 发生rollback之后，重启server， 会出现rollback的 auto-increment id 被重复使用的问题，而 8.0 的server，则不会 重用 id， 因为 其将 counter 写入到了 disk中</li>
  <li>auto_increment_increment 设定 auto-increment 的起始点， 默认为1， auto_increment_increment 设置 增量 默认为 1</li>
</ul>

<h4 id="index-没个-innodb-表-都有一个-特殊的index-称为-聚簇索引-用来保存-row-data-通常-聚簇索引-与-primary-key主键-同意-为了-请求获得-更好的性能-理解-innodb-如何使用-聚簇索引-来-进行优化-查询和-dml-操作-是非常重要-的">index: 没个 InnoDB 表， 都有一个 特殊的index 称为 聚簇索引， 用来保存 row data， 通常 聚簇索引 与 primary key(主键) 同意， 为了 请求获得 更好的性能， 理解 InnoDB 如何使用 聚簇索引 来 进行优化 查询，和 DML 操作 是非常重要 的</h4>
<ul>
  <li>当你定义table 的Primary key时， InnoDB 用它作为聚簇索引， 如果没有 逻辑上的 唯一 非空 作为主键的情况下， 可以添加一个 auto-increment column 作为 主键</li>
  <li>如果没有为 table 设定 Primary key（ 主键） 时， InnoDB 使用第一个 Unique &amp; 所有column not null 的index 作为聚簇索引</li>
  <li>
    <p>如果table 没有 Primary key 和 合适的Unique index， 则 InnoDB 生成一个隐藏的名称为 GEN_CLUST_INDEX 的聚簇索引， 该字段为 6-byte 的单调递增</p>
  </li>
  <li>聚簇索引 如何 加快查询：
    <blockquote>
      <p>Accessing a row through the clustered index is fast because the index search leads directly to the page that contains the row data. If a table is large, the clustered index architecture often saves a disk I/O operation when compared to storage organizations that store row data using a different page from the index record.</p>
    </blockquote>
  </li>
  <li>二级索引 是如何关联到 聚簇索引的： 二级索引定义为： 除 聚簇索引之外的索引</li>
  <li>二级索引的每个条目（记录） 中 都包含 主键 + 二级索引 包含的column，InnoDB 使用 包含的主键 来 在聚簇索引中进行查找</li>
  <li>
    <p>所以 如果聚簇索引 很大的话，将加大 二级索引 的空间占用</p>
  </li>
  <li>InnoDB index 的物理结构：</li>
  <li>InnoDB 所以为B-tree， 索引记录 存储在 B-tree 的 页子 page 中， 默认的 index page 大小为 16KB， 可以通过   innodb_page_size  进行设定</li>
  <li>当插入 新纪录 到 聚簇索引时， InnoDB 尝试留下  1/16 的 空间 来满足 未来的insert update。 如果数据时按照 顺序插入的，则 index page 将占用 15/16 空间， 如果数据按照 random 顺序插入的，则可能 占用 1/2 - 15/16， innodb_fill_factor  用来控制 空间占用百分比</li>
  <li>
    <p>如果InnoDB 索引页的占用率下降到 MERGE_THRESHOLD(默认为50%) 时， InnoDB 将尝试 收缩索引 以 释放页面</p>
  </li>
  <li><a href="https://dev.mysql.com/doc/refman/8.0/en/sorted-index-builds.html">Sorted index builde</a></li>
</ul>

<h3 id="the-system-tablespace">The System Tablespace:</h3>

<ul>
  <li>change buffer 在 disk 上存储到 system tablespace, 如果在system tablespace 而非 file-per-table 或者 general tablespace 则 其中还包含 table 和 index data的数据。 8.0之前 还存储 doublewrite buffer， innodb data dictionary， 8.0之后 则分开存储</li>
  <li>system tablespace 可以有多个 data 文件， 默认的 一个 ibddata1 在 data directory中，</li>
  <li>tablespace 的数量 与 大小 在 启动项 innodb_data_file_path  进行设定</li>
  <li>可以进行调整，<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-system-tablespace.html">文档在此</a></li>
</ul>

<h3 id="file-per-table-tablespace-包含-table中的-data-和-index存储在系统中-单个文件中">File-Per-Table Tablespace: 包含 table中的 data 和 index，存储在系统中 单个文件中</h3>
<ul>
  <li>innodb_file_per_table 控制开关， 默认为 打开状态。关闭将导致 InnoDB 存储table 数据到 system tablespace 中</li>
  <li>
    <p>file-per-table tablespace 在mysql 的 data directory(DATA DIRECTORY 可以在create table syntax 中指定) 目录下 存储 table_name.idb ，下面为示例：</p>

<div class="highlight"><pre class="highlight sql"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="n">USE</span> <span class="n">test</span><span class="p">;</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">t1</span> <span class="p">(</span>
   <span class="n">id</span> <span class="nb">INT</span> <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
   <span class="n">name</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
 <span class="p">)</span> <span class="n">ENGINE</span> <span class="o">=</span> <span class="n">InnoDB</span><span class="p">;</span>

<span class="n">shell</span><span class="o">&gt;</span> <span class="n">cd</span> <span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="k">to</span><span class="o">/</span><span class="n">mysql</span><span class="o">/</span><span class="k">data</span><span class="o">/</span><span class="n">test</span>
<span class="n">shell</span><span class="o">&gt;</span> <span class="n">ls</span>
<span class="n">t1</span><span class="p">.</span><span class="n">ibd</span>
</code></pre></div>  </li>
  <li>File-per-table 的优势：
    <ol>
      <li>当 发生drop file， table_name.idb 直接被删掉， 存储空间 可以快速的归还给操作系统</li>
      <li>Truncate table 表现的比较好</li>
      <li>可以将 data directory 指定到 单独的设备上</li>
      <li>创建在 改 tablespace 的table， 支持 dynamic compressed 存储格式(System tablespace 不支持)</li>
      <li>比较容易恢复和 备份</li>
      <li>允许单独监控 操作系统的 文件系统</li>
      <li>减少空间限制</li>
    </ol>
  </li>
</ul>

<h3 id="general-tablespace-通用-tablespace">General Tablespace： 通用 Tablespace</h3>
<ul>
  <li>使用create  tablespace 创建的 共享的 tablespace, 其属性 是 file-per-tablespace 与 system tablespace 的结合。 可以 像 file-per-table tablespace 一样 指定目录存储 general tablespace， 想system tablespace 一样 存储多个 table 在一个文件中， 并可以支持 所有的存储类型。</li>
  <li>下面是 使用 General Tablespace 的方法：</li>
</ul>

<ol>
  <li>创建</li>
</ol>

<div class="highlight"><pre class="highlight sql"><code><span class="k">CREATE</span> <span class="n">TABLESPACE</span> <span class="n">tablespace_name</span>
    <span class="p">[</span><span class="k">ADD</span> <span class="n">DATAFILE</span> <span class="s1">'file_name'</span><span class="p">]</span>
    <span class="p">[</span><span class="n">FILE_BLOCK_SIZE</span> <span class="o">=</span> <span class="n">value</span><span class="p">]</span>
        <span class="p">[</span><span class="n">ENGINE</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="n">engine_name</span><span class="p">]</span>  

<span class="o">#</span> <span class="err">可以</span> <span class="err">使用</span> <span class="err">变量</span> <span class="n">innodb_directories</span>  <span class="err">控制</span> <span class="k">general</span> <span class="n">tablespace</span> <span class="err">的存储目录，</span> 
<span class="o">#</span> <span class="n">ts1</span><span class="p">.</span><span class="n">idb</span> <span class="err">为相对</span> <span class="n">innodb_directories</span> <span class="err">目录</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">CREATE</span> <span class="n">TABLESPACE</span> <span class="nv">`ts1`</span> <span class="k">ADD</span> <span class="n">DATAFILE</span> <span class="s1">'ts1.ibd'</span> <span class="n">Engine</span><span class="o">=</span><span class="n">InnoDB</span><span class="p">;</span>

<span class="o">#</span> <span class="err">也可以执行全路径</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">CREATE</span> <span class="n">TABLESPACE</span> <span class="nv">`ts1`</span> <span class="k">ADD</span> <span class="n">DATAFILE</span> <span class="s1">'/my/tablespace/directory/ts1.ibd'</span> <span class="n">Engine</span><span class="o">=</span><span class="n">InnoDB</span><span class="p">;</span>

</code></pre></div>
<ol>
  <li>使用： 添加table 到 general tablespace:<br />
  ```sql</li>
</ol>

<p>mysql&gt; CREATE TABLE t1 (c1 INT PRIMARY KEY) TABLESPACE ts1;<br />
  mysql&gt; ALTER TABLE t2 TABLESPACE ts1;</p>

<div class="highlight"><pre class="highlight plaintext"><code>  
   * 使用alter table 可以将table 的tablespace 在各个 tablespace 中进行转换： general tablespace为具体的create tablespace 的名字， file-per-table名称为 innodb_file_per_table， system tablespace 为innodb_system； 如下： 
   
   ```sql
   
   
   ALTER TABLE tbl_name TABLESPACE [=] tablespace_name;
   
   ALTER TABLE tbl_name TABLESPACE [=] innodb_system;
   
   ALTER TABLE tbl_name TABLESPACE [=] innodb_file_per_table;
</code></pre></div><ol>
  <li>
    <p>重命名tablespace： ALTER TABLESPACE s1 RENAME TO s2;， 重命名操作不能发生在 lock tables， flush tables 作用期间</p>
  </li>
  <li>
    <p>删掉 tablespace： 在tablespace中的所有table 都必须删除掉，才能够成功的 drop tablespace</p>
  </li>
</ol>

<div class="highlight"><pre class="highlight sql"><code>   
    <span class="o">#</span><span class="n">Use</span> <span class="n">a</span> <span class="n">query</span> <span class="k">similar</span> <span class="k">to</span> <span class="n">the</span> <span class="n">following</span> <span class="k">to</span> <span class="n">identify</span> <span class="n">tables</span> <span class="k">in</span> <span class="n">a</span> <span class="k">general</span> <span class="n">tablespace</span><span class="p">.</span> 
     <span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="n">a</span><span class="p">.</span><span class="n">NAME</span> <span class="k">AS</span> <span class="n">space_name</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">NAME</span> <span class="k">AS</span> <span class="k">table_name</span> <span class="k">FROM</span> <span class="n">INFORMATION_SCHEMA</span><span class="p">.</span><span class="n">INNODB_TABLESPACES</span> <span class="n">a</span><span class="p">,</span>
          <span class="n">INFORMATION_SCHEMA</span><span class="p">.</span><span class="n">INNODB_TABLES</span> <span class="n">b</span> <span class="k">WHERE</span> <span class="n">a</span><span class="p">.</span><span class="k">SPACE</span><span class="o">=</span><span class="n">b</span><span class="p">.</span><span class="k">SPACE</span> <span class="k">AND</span> <span class="n">a</span><span class="p">.</span><span class="n">NAME</span> <span class="k">LIKE</span> <span class="s1">'ts1'</span><span class="p">;</span>
   <span class="o">+</span><span class="c1">------------+------------+</span>
   <span class="o">|</span> <span class="n">space_name</span> <span class="o">|</span> <span class="k">table_name</span> <span class="o">|</span>
   <span class="o">+</span><span class="c1">------------+------------+</span>
   <span class="o">|</span> <span class="n">ts1</span>        <span class="o">|</span> <span class="n">test</span><span class="o">/</span><span class="n">t1</span>    <span class="o">|</span>
   <span class="o">|</span> <span class="n">ts1</span>        <span class="o">|</span> <span class="n">test</span><span class="o">/</span><span class="n">t2</span>    <span class="o">|</span>
   <span class="o">|</span> <span class="n">ts1</span>        <span class="o">|</span> <span class="n">test</span><span class="o">/</span><span class="n">t3</span>    <span class="o">|</span>
   <span class="o">+</span><span class="c1">------------+------------+</span>

   <span class="k">DROP</span> <span class="n">TABLESPACE</span> <span class="n">ts1</span><span class="p">;</span>
</code></pre></div>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/general-tablespaces.html">文档在此</a></p>

<ul>
  <li>Undo tablespace: 用于保存undo log 的地方， undo log 产生于 insert, update, delete, 等DML 操作， 用于 事务回滚， consistent reading 等</li>
  <li>默认的undo tablespace 存储在 mysql data dir 中， 可以使用 innodb_undo_directory  进行控制， 默认的 tablespace 文件为  undo_001 , undo_002， 对应的 tablespace名称 为 innodb_undo_001, innodb_undo_002</li>
  <li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-undo-tablespaces.html">文档在此</a></li>
  <li>undo tablespace 作为一个系统使用的tablespace 一样可以允许创建，删除， 但是与 应系统性能表现相关， 比较重要</li>
</ul>

<div class="social"></div></article></main><footer><div class="footer-wrapper"><div class="author"><div class="image-wrapper"><a href="/author/"><img alt="author" src="../../../../images/profile-1e71686a.png" /></a></div></div><div class="image-content"><img src="../../../../images/wechat_nasa-0d87c0dd.png" /></div><div class="copyright"><i class="fa fa-copyright"></i> 2022 <a href="/">日常学习</a> - geniousbar</div></div><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?b43ef53b285c49e1af0bd7080994c825";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script></footer></body></html>