<!DOCTYPE html><html><head><meta charset="utf-8" /><meta content="IE=edge;chrome=1" http-equiv="X-UA-Compatible" /><meta content="initial-scale=1.0, user-scalable=no" name="viewport" /><title>Rust Async | 日常学习</title><meta description="并发模型     OS threads:  1) 不需要改变代码编码模式  2) 线程间 同步困难  3) 性能开销比较大， 线程池 可以一定程度上减少这些开销， 但是并不能够支撑起 庞大的IO 工作    事件驱动模型(Event-driven)： 结合callback, 性能非常好，但是 导致 非线性的控制流， Data flow and error propagation is often hard to follow.    协程(coroutines)： like thread， 不需... " /><link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/feed.xml" /><link href="../../../../stylesheets/style-198d4031.css" rel="stylesheet" type="text/css" /><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" /><link href="../../../../images/favicon-6c3f3d04.png" rel="icon" type="image/png" /><script src="../../../../javascripts/all-b3988275.js"></script></head><body><header><div class="top-menu"><div class="top-menu-wrapper"><div class="top-menu-list"><ul><li><a href="/">Home</a></li><li><a href="/archives/">Archives</a></li><li><a href="/tags/">Tags</a></li><li><a href="/by-year/">By Year</a></li><li id="wechat"><a href="#" onclick="toggleShowWechat()">Wechat</a></li></ul></div></div></div><div id="header-wechat-img"><img src="../../../../images/wechat_nasa-0d87c0dd.png" /></div><h1 class="logo"><a href="/" title="日常学习"><span class="logo-text">日常学习</span></a></h1></header><main><article><h1 class="article-title">Rust Async</h1><div class="posted-date-wrapper"><i class="fa fa-clock-o"></i><span class="posted-date">May 09, 2021</span></div><div class="tag-labels"><a href="/tags/rust/"><small class="tag-label">rust</small></a><a href="/tags/async/"><small class="tag-label">async</small></a><a href="/tags/cocurrent/"><small class="tag-label">cocurrent</small></a></div><hr class="article-header-separator" /><h3 id="并发模型">并发模型</h3>
<ul>
  <li><strong>OS threads</strong>:  1) 不需要改变代码编码模式  2) 线程间 同步困难  3) 性能开销比较大， 线程池 可以一定程度上减少这些开销， 但是并不能够支撑起 庞大的IO 工作</li>
  <li><strong>事件驱动模型(Event-driven)</strong>： 结合callback, 性能非常好，但是 导致 非线性的控制流， Data flow and error propagation is often hard to follow.</li>
  <li><strong>协程(coroutines)</strong>： like thread， 不需要改变代码编码模式， 共容易使用，提供了包括async 的工具， 支持大量的 任务，但是，其对于 底层的细节抽象 导致 系统编程非常困难</li>
  <li><strong>Actor model</strong>： 将所有的并行运算抽象为 actor ，其之间的沟通通过 message passing 非常像 分布式系统， 可以实现非常好的性能， 但是留下了许多实际问题 依然没有解决， 比如 flow control and retry logic</li>
  <li>总结： async 编程 能够让 Rust 此类 <strong>系统编程语言</strong> 编写出高性能代码，同时具有 thread 与 协程(coroutines) 的优势;</li>
</ul>

<h3 id="rust-async-的现状">Rust Async 的现状</h3>
<ol>
  <li>Rust Async 的特点：
    <ul>
      <li>Futures是rust 内置的</li>
      <li>Async是zero-cost 的，即： 并不需要 在堆上 进行内存分配 和动态分发，即高性能（you can use async without heap allocations and dynamic dispatch, which is great for performance!）</li>
      <li>没有内建的runtime， 由社区提供</li>
      <li>可以支持 单线程 或者 多线程 的runtime</li>
    </ul>
  </li>
  <li>Rust Async vs threads 的比较
    <ul>
      <li>threads： 适合少量的工作， 不用改变代码结构， 生成 线程 与线程之间的切换 是非常昂贵的， 线程池可以一定程度上减轻此类开销</li>
      <li>Async： 可以显著的减少CPU 与 内存的开销， 尤其是在对于 大量IO任务时。 比thread 模式能够处理更多的任务，因为 该模型，使用 较少的 threads 处理大量的 task。 但是其二进制的文件会比传统的非异步编码的代码要大。</li>
    </ul>
  </li>
  <li>异步编程的支持：
    <ul>
      <li>标准库： 提供 Future trait 抽象</li>
      <li>Rust Compiler： 提供对  async/await 语法的支持</li>
      <li>futures crate： 提供 工具类型， macros， 以及 方法</li>
      <li>async runtime： 提供对 async code, IO, task spawn 的运行。有 TOkio, async-std</li>
    </ul>
  </li>
  <li>编译 与  debug：
    <ul>
      <li>为了支持异步代码：  rust 需要使用异常一些更复杂的 语言特性， 比如lifetimes pinning。 你可能将经常遇到此类错误</li>
      <li>runtime errors： 编译器 遇到 async function，将产生一个 状态机（state machine）， Stack traces 将包含状态机内部的详细信息， 对比 Rust 同步代码, runtime errors debug 要复杂不少</li>
    </ul>
  </li>
  <li>New failure modes： 异步Rust中可能会出现一些新颖的故障模式，例如，如果您从异步上下文中调用了阻止函数，或者您错误地实现了Future特性。 这样的错误可以无声地通过编译器，有时甚至可以通过单元测试。 本书旨在为您提供对底层概念的深刻理解，可以帮助您避免这些陷阱。</li>
</ol>

<h3 id="rust-异步编程-简单示例">Rust 异步编程 简单示例：</h3>
<ul>
  <li>async/.await 语法： rust compiler 为 async 声明的block转换成一个实现了 Future trait 的 state machine。 await 等待Future的完成， 但是将thread yield 出去以允许其他Future执行</li>
  <li>block_on: 阻塞当前 thread，直到 future 完成， 不允许 thread 运行其他的 Future</li>
</ul>

<div class="highlight"><pre class="highlight rust"><code><span class="c">// Cargo.toml</span>
<span class="p">[</span><span class="n">dependencies</span><span class="p">]</span>
<span class="n">futures</span> <span class="o">=</span> <span class="s">"0.3"</span>

<span class="c">// main.rs</span>
<span class="k">use</span> <span class="nn">futures</span><span class="p">::</span><span class="nn">executor</span><span class="p">::</span><span class="n">block_on</span><span class="p">;</span>

<span class="k">async</span> <span class="k">fn</span> <span class="nf">hello_world</span><span class="p">()</span> <span class="p">{</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"hello, world!"</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">future</span> <span class="o">=</span> <span class="nf">hello_world</span><span class="p">();</span> <span class="c">// Nothing is printed</span>
  <span class="nf">block_on</span><span class="p">(</span><span class="n">future</span><span class="p">);</span> <span class="c">// `future` is run and "hello, world!" is printed</span>
<span class="p">}</span>


<span class="c">// await 示例： </span>

<span class="k">async</span> <span class="k">fn</span> <span class="nf">learn_song</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Song</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">sing_song</span><span class="p">(</span><span class="n">song</span><span class="p">:</span> <span class="n">Song</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">dance</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>


<span class="c">// 这里使用 block_on 导致  learn_song  aing_song dance 的 串行执行, 因为block_on 将阻塞thread，直到 Future 执行完成</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">song</span> <span class="o">=</span> <span class="nf">block_on</span><span class="p">(</span><span class="nf">learn_song</span><span class="p">());</span>
  <span class="nf">block_on</span><span class="p">(</span><span class="nf">sing_song</span><span class="p">(</span><span class="n">song</span><span class="p">));</span>
  <span class="nf">block_on</span><span class="p">(</span><span class="nf">dance</span><span class="p">());</span>
<span class="p">}</span>



<span class="c">// 这里使用await 可以将 thread 让出，以便  Future f2 执行。 join 能够同时执行 两个 future</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">learn_and_sing</span><span class="p">()</span> <span class="p">{</span>
  <span class="c">// Wait until the song has been learned before singing it.</span>
  <span class="c">// We use `.await` here rather than `block_on` to prevent blocking the // thread, which makes it possible to `dance` at the same time.</span>
  <span class="k">let</span> <span class="n">song</span> <span class="o">=</span> <span class="nf">learn_song</span><span class="p">()</span><span class="k">.await</span><span class="p">;</span>
  <span class="nf">sing_song</span><span class="p">(</span><span class="n">song</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">async</span> <span class="k">fn</span> <span class="nf">async_main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">f1</span> <span class="o">=</span> <span class="nf">learn_and_sing</span><span class="p">();</span> 
  <span class="k">let</span> <span class="n">f2</span> <span class="o">=</span> <span class="nf">dance</span><span class="p">();</span>
  <span class="c">// `join!` is like `.await` but can wait for multiple futures concurrently. </span>
  <span class="c">// If we're temporarily blocked in the `learn_and_sing` future, the `dance`</span>
  <span class="c">// future will take over the current thread. If `dance` becomes blocked, </span>
  <span class="c">// `learn_and_sing` can take back over. If both futures are blocked, then </span>
  <span class="c">// `async_main` is blocked and will yield to the executor. </span>
  <span class="nn">futures</span><span class="p">::</span><span class="nd">join!</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">);</span>
<span class="p">}</span>



<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span> 
  <span class="nf">block_on</span><span class="p">(</span><span class="nf">async_main</span><span class="p">());</span>
<span class="p">}</span>

</code></pre></div>
<h4 id="future-trait-rust-异步编程的-核心点-future-即是一个可以产生-value-的异步计算抽象简单的-future-可以如下">Future Trait: rust 异步编程的 核心点， Future 即是一个可以产生 value 的异步计算抽象。简单的 Future 可以如下：</h4>

<div class="highlight"><pre class="highlight rust"><code><span class="k">trait</span> <span class="n">SimpleFuture</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Output</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">poll</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">wake</span><span class="p">:</span> <span class="k">fn</span><span class="p">())</span> <span class="k">-&gt;</span> <span class="n">Poll</span><span class="o">&lt;</span><span class="nn">Self</span><span class="p">::</span><span class="n">Output</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">enum</span> <span class="n">Poll</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nf">Ready</span><span class="p">(</span><span class="n">T</span><span class="p">),</span>
    <span class="n">Pending</span><span class="p">,</span>
<span class="p">}</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">SocketRead</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">socket</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">Socket</span><span class="p">,</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="n">SimpleFuture</span> <span class="k">for</span> <span class="n">SocketRead</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">poll</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">wake</span><span class="p">:</span> <span class="k">fn</span><span class="p">())</span> <span class="k">-&gt;</span> <span class="n">Poll</span><span class="o">&lt;</span><span class="nn">Self</span><span class="p">::</span><span class="n">Output</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.socket</span><span class="nf">.has_data_to_read</span><span class="p">()</span> <span class="p">{</span>
            <span class="c">// The socket has data-- read it into a buffer and return it.</span>
            <span class="nn">Poll</span><span class="p">::</span><span class="nf">Ready</span><span class="p">(</span><span class="k">self</span><span class="py">.socket</span><span class="nf">.read_buf</span><span class="p">())</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c">// The socket does not yet have data. //</span>
            <span class="c">// Arrange for `wake` to be called once data is available.</span>
            <span class="c">// When data becomes available, `wake` will be called, and the</span>
            <span class="c">// user of this `Future` will know to call `poll` again and</span>
            <span class="c">// receive data. self.socket.set_readable_callback(wake); Poll::Pending</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div><ul>
  <li>poll func 为Future 接口， 如果future 完成  则返回 Poll::Ready(result), 否则 返回 Poll::Pending, 并在当 Future 可以取得进一步进展时 调用 wake() 函数， 当wake 函数调用， Future 的 executor 将再次 在future 调用poll 以取得进展</li>
  <li>wake 的作用： 如果没有wake 则 executor 将没有任何知识 能够知道 一个特定的future 可以取得进展， 除非周期性的在 每个future 上进行poll。 wake的存在能够让 executor 知道 那个 future 需要被poll</li>
  <li>Timer Future 的简单实现：</li>
</ul>

<div class="highlight"><pre class="highlight rust"><code>
<span class="k">use</span> <span class="nn">std</span><span class="p">::{</span>
    <span class="nn">future</span><span class="p">::</span><span class="n">Future</span><span class="p">,</span>
    <span class="nn">pin</span><span class="p">::</span><span class="n">Pin</span><span class="p">,</span>
    <span class="nn">sync</span><span class="p">::{</span><span class="nb">Arc</span><span class="p">,</span> <span class="n">Mutex</span><span class="p">},</span>
    <span class="nn">task</span><span class="p">::{</span><span class="n">Context</span><span class="p">,</span> <span class="n">Poll</span><span class="p">,</span> <span class="n">Waker</span><span class="p">},</span>
    <span class="n">thread</span><span class="p">,</span>
    <span class="nn">time</span><span class="p">::</span><span class="n">Duration</span><span class="p">,</span>
<span class="p">};</span>


<span class="k">pub</span> <span class="k">struct</span> <span class="n">TimerFuture</span> <span class="p">{</span>
    <span class="n">shared_state</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="n">SharedState</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="c">// 需要使用锁， 跨 thread 更改变量</span>
<span class="p">}</span>

<span class="c">/// Shared state between the future and the waiting thread</span>
<span class="k">struct</span> <span class="n">SharedState</span> <span class="p">{</span>
    <span class="c">/// Whether or not the sleep time has elapsed</span>
    <span class="n">completed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>

    <span class="c">// The waker for the task that `TimerFuture` is running on.</span>
    <span class="c">// The thread can use this after setting `completed = true` to tell</span>
    <span class="c">// `TimerFuture`'s task to wake up, see that `completed = true`, and</span>
    <span class="c">// move forward.</span>
    <span class="n">waker</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Waker</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>


<span class="k">impl</span> <span class="n">Future</span> <span class="k">for</span> <span class="n">TimerFuture</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="p">();</span>
    <span class="c">// 需要注意 这里面 self参数类型为Pin&lt;&amp;mut Self&gt; 以及cx 为Context</span>
    <span class="k">fn</span> <span class="nf">poll</span><span class="p">(</span><span class="k">self</span><span class="p">:</span> <span class="n">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">Self</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">cx</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Context</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Poll</span><span class="o">&lt;</span><span class="nn">Self</span><span class="p">::</span><span class="n">Output</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c">// Look at the shared state to see if the timer has already completed.</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">shared_state</span> <span class="o">=</span> <span class="k">self</span><span class="py">.shared_state</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="k">if</span> <span class="n">shared_state</span><span class="py">.completed</span> <span class="p">{</span>
            <span class="nn">Poll</span><span class="p">::</span><span class="nf">Ready</span><span class="p">(())</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c">// Set waker so that the thread can wake up the current task</span>
            <span class="c">// when the timer has completed, ensuring that the future is polled</span>
            <span class="c">// again and sees that `completed = true`.</span>
            <span class="c">//</span>
            <span class="c">// It's tempting to do this once rather than repeatedly cloning</span>
            <span class="c">// the waker each time. However, the `TimerFuture` can move between</span>
            <span class="c">// tasks on the executor, which could cause a stale waker pointing</span>
            <span class="c">// to the wrong task, preventing `TimerFuture` from waking up</span>
            <span class="c">// correctly.</span>
            <span class="c">//</span>
            <span class="c">// N.B. it's possible to check for this using the `Waker::will_wake`</span>
            <span class="c">// function, but we omit that here to keep things simple.</span>
            <span class="n">shared_state</span><span class="py">.waker</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">cx</span><span class="nf">.waker</span><span class="p">()</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="nn">Poll</span><span class="p">::</span><span class="n">Pending</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span> <span class="n">TimerFuture</span> <span class="p">{</span>
    <span class="c">// Create a new `TimerFuture` which will complete after the provided</span>
    <span class="c">// timeout.</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">duration</span><span class="p">:</span> <span class="n">Duration</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">shared_state</span> <span class="o">=</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Mutex</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">SharedState</span> <span class="p">{</span>
            <span class="n">completed</span><span class="p">:</span> <span class="k">false</span><span class="p">,</span>
            <span class="n">waker</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
        <span class="p">}));</span>

        <span class="c">// Spawn the new thread</span>
        <span class="c">// 这个 Future 实现的 比较奇怪，直接 使用另一个 thread 中sleep 进行 timer 的实现, 所以 在上面 TimerFuture 中的 Sharedstate 需要进行 Mutex 进行保护</span>
        <span class="c">// 这也是后面提到 Runtime  需要提供 Timer的 重要原因吧</span>
        <span class="k">let</span> <span class="n">thread_shared_state</span> <span class="o">=</span> <span class="n">shared_state</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="nn">thread</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span><span class="n">duration</span><span class="p">);</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">shared_state</span> <span class="o">=</span> <span class="n">thread_shared_state</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="c">// Signal that the timer has completed and wake up the last</span>
            <span class="c">// task on which the future was polled, if one exists.</span>
            <span class="n">shared_state</span><span class="py">.completed</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">waker</span><span class="p">)</span> <span class="o">=</span> <span class="n">shared_state</span><span class="py">.waker</span><span class="nf">.take</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">waker</span><span class="nf">.wake</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">});</span>

        <span class="n">TimerFuture</span> <span class="p">{</span> <span class="n">shared_state</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="c">// Executor 的实现：</span>

<span class="c">/// Task executor that receives tasks off of a channel and runs them.</span>
<span class="k">struct</span> <span class="n">Executor</span> <span class="p">{</span>
    <span class="n">ready_queue</span><span class="p">:</span> <span class="n">Receiver</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="c">/// `Spawner` spawns new futures onto the task channel.</span>
<span class="nd">#[derive(Clone)]</span>
<span class="k">struct</span> <span class="n">Spawner</span> <span class="p">{</span>
    <span class="n">task_sender</span><span class="p">:</span> <span class="n">SyncSender</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="c">/// A future that can reschedule itself to be polled by an `Executor`.</span>
<span class="k">struct</span> <span class="n">Task</span> <span class="p">{</span>
    <span class="c">/// In-progress future that should be pushed to completion.</span>
    <span class="c">///</span>
    <span class="c">/// The `Mutex` is not necessary for correctness, since we only have</span>
    <span class="c">/// one thread executing tasks at once. However, Rust isn't smart</span>
    <span class="c">/// enough to know that `future` is only mutated from one thread,</span>
    <span class="c">/// so we need to use the `Mutex` to prove thread-safety. A production</span>
    <span class="c">/// executor would not need this, and could use `UnsafeCell` instead.</span>
    <span class="n">future</span><span class="p">:</span> <span class="n">Mutex</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">BoxFuture</span><span class="o">&lt;</span><span class="nv">'static</span><span class="p">,</span> <span class="p">()</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>

    <span class="c">/// Handle to place the task itself back onto the task queue.</span>
    <span class="n">task_sender</span><span class="p">:</span> <span class="n">SyncSender</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">new_executor_and_spawner</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="n">Executor</span><span class="p">,</span> <span class="n">Spawner</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// Maximum number of tasks to allow queueing in the channel at once.</span>
    <span class="c">// This is just to make `sync_channel` happy, and wouldn't be present in</span>
    <span class="c">// a real executor.</span>
    <span class="k">const</span> <span class="n">MAX_QUEUED_TASKS</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">10_000</span><span class="p">;</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">task_sender</span><span class="p">,</span> <span class="n">ready_queue</span><span class="p">)</span> <span class="o">=</span> <span class="nf">sync_channel</span><span class="p">(</span><span class="n">MAX_QUEUED_TASKS</span><span class="p">);</span>
    <span class="p">(</span><span class="n">Executor</span> <span class="p">{</span> <span class="n">ready_queue</span> <span class="p">},</span> <span class="n">Spawner</span> <span class="p">{</span> <span class="n">task_sender</span> <span class="p">})</span>
<span class="p">}</span>


<span class="k">impl</span> <span class="n">Spawner</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">spawn</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">future</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Future</span><span class="o">&lt;</span><span class="n">Output</span> <span class="o">=</span> <span class="p">()</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'static</span> <span class="o">+</span> <span class="nb">Send</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">future</span> <span class="o">=</span> <span class="n">future</span><span class="nf">.boxed</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">task</span> <span class="o">=</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">Task</span> <span class="p">{</span>
            <span class="n">future</span><span class="p">:</span> <span class="nn">Mutex</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="n">future</span><span class="p">)),</span>
            <span class="n">task_sender</span><span class="p">:</span> <span class="k">self</span><span class="py">.task_sender</span><span class="nf">.clone</span><span class="p">(),</span>
        <span class="p">});</span>
        <span class="k">self</span><span class="py">.task_sender</span><span class="nf">.send</span><span class="p">(</span><span class="n">task</span><span class="p">)</span><span class="nf">.expect</span><span class="p">(</span><span class="s">"too many tasks queued"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span> <span class="n">ArcWake</span> <span class="k">for</span> <span class="n">Task</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">wake_by_ref</span><span class="p">(</span><span class="n">arc_self</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="c">// Implement `wake` by sending this task back onto the task channel</span>
        <span class="c">// so that it will be polled again by the executor.</span>
        <span class="k">let</span> <span class="n">cloned</span> <span class="o">=</span> <span class="n">arc_self</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="n">arc_self</span>
            <span class="py">.task_sender</span>
            <span class="nf">.send</span><span class="p">(</span><span class="n">cloned</span><span class="p">)</span>
            <span class="nf">.expect</span><span class="p">(</span><span class="s">"too many tasks queued"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Executor</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span> <span class="k">let</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">task</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.ready_queue</span><span class="nf">.recv</span><span class="p">()</span> <span class="p">{</span>
            <span class="c">// Take the future, and if it has not yet completed (is still Some),</span>
            <span class="c">// poll it in an attempt to complete it.</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">future_slot</span> <span class="o">=</span> <span class="n">task</span><span class="py">.future</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="k">mut</span> <span class="n">future</span><span class="p">)</span> <span class="o">=</span> <span class="n">future_slot</span><span class="nf">.take</span><span class="p">()</span> <span class="p">{</span>
                <span class="c">// Create a `LocalWaker` from the task itself</span>
                <span class="k">let</span> <span class="n">waker</span> <span class="o">=</span> <span class="nf">waker_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="p">);</span>
                <span class="k">let</span> <span class="n">context</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">Context</span><span class="p">::</span><span class="nf">from_waker</span><span class="p">(</span><span class="o">&amp;*</span><span class="n">waker</span><span class="p">);</span>
                <span class="c">// `BoxFuture&lt;T&gt;` is a type alias for</span>
                <span class="c">// `Pin&lt;Box&lt;dyn Future&lt;Output = T&gt; + Send + 'static&gt;&gt;`.</span>
                <span class="c">// We can get a `Pin&lt;&amp;mut dyn Future + Send + 'static&gt;`</span>
                <span class="c">// from it by calling the `Pin::as_mut` method.</span>
                <span class="k">if</span> <span class="k">let</span> <span class="nn">Poll</span><span class="p">::</span><span class="n">Pending</span> <span class="o">=</span> <span class="n">future</span><span class="nf">.as_mut</span><span class="p">()</span><span class="nf">.poll</span><span class="p">(</span><span class="n">context</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c">// We're not done processing the future, so put it</span>
                    <span class="c">// back in its task to be run again in the future.</span>
                    <span class="o">*</span><span class="n">future_slot</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">future</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>



<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">executor</span><span class="p">,</span> <span class="n">spawner</span><span class="p">)</span> <span class="o">=</span> <span class="nf">new_executor_and_spawner</span><span class="p">();</span>

    <span class="c">// Spawn a task to print before and after waiting on a timer.</span>
    <span class="n">spawner</span><span class="nf">.spawn</span><span class="p">(</span><span class="k">async</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"howdy!"</span><span class="p">);</span>
        <span class="c">// Wait for our timer future to complete after two seconds.</span>
        <span class="nn">TimerFuture</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="k">.await</span><span class="p">;</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"done!"</span><span class="p">);</span>
    <span class="p">});</span>

    <span class="c">// Drop the spawner so that our executor knows it is finished and won't</span>
    <span class="c">// receive more incoming tasks to run.</span>
    <span class="k">drop</span><span class="p">(</span><span class="n">spawner</span><span class="p">);</span>

    <span class="c">// Run the executor until the task queue is empty.</span>
    <span class="c">// This will print "howdy!", pause, and then print "done!".</span>
    <span class="n">executor</span><span class="nf">.run</span><span class="p">();</span>
<span class="p">}</span>

</code></pre></div>
<h3 id="executors-and-system-io">Executors and System IO:</h3>
<h4 id="executor-谁来调用-future-的poll-方法-答案是-future-executor-executor-调用一大堆-futures-的poll方法-以便让future-取得进展-当-future-能够-取得进一步进展时通过调用wake-方法-以便-executor-再次执行-future">Executor： 谁来调用 Future 的poll 方法？ 答案是 Future Executor。 executor 调用一大堆 Futures 的poll方法 以便让Future 取得进展， 当 Future 能够 取得进一步进展时，通过调用wake 方法， 以便 executor 再次执行 Future。</h4>
<h4 id="system-io-在上面的-simplefuture-代码中-谁来执行-wake-方法呢-selfsocketset_readable_callbackwake-又是如何处罚呢-答案是-epoll-的io多路复用可以让我们-使用thread-对-socket文件进行-监听循环检测-io-事件">System IO: 在上面的 SimpleFuture 代码中， 谁来执行 wake 方法呢？ self.socket.set_readable_callback(wake) 又是如何处罚呢？ 答案是 epoll 的IO多路复用，可以让我们 使用thread 对 socket文件进行 监听，循环检测 IO 事件。</h4>
<h4 id="executors-单线程-与-多线程">Executors: 单线程 与 多线程</h4>
<blockquote>
  <p>多线程执行程序可同时在多个任务上取得进展。 对于具有许多任务的工作负载，它可以极大地加快执行速度，但是在任务之间同步数据通常会更加昂贵。 在单线程和多线程运行时之间进行选择时，建议测量应用程序的性能。</p>
</blockquote>

<p>任务可以在创建任务的线程上运行，也可以在单独的线程上运行。 异步运行时通常提供将任务生成到单独线程上的功能。 即使任务在单独的线程上执行，它们也应该是非阻塞的。 为了在多线程执行器上安排任务，它们也必须是Send。 一些运行时提供了生成非发送任务的功能，以确保每个任务都在生成它的线程上执行。 它们还可以提供用于将阻塞任务生成到专用线程上的功能，这对于从其他库运行阻塞同步代码很有用。</p>

<ul>
  <li>async Lifetimes， async move， 因为异步的存在， 导致 async { /../ } 可以 传递给变量 并进行 .await， 导致  block {} 中 的包含的变量，以及 引用 需要与 Future 存在的周期相同。 async move 允许 like normal block 一样， 允许将 block中变量 移入到 block中， 并跟随 Future 一样的生命周期</li>
  <li>当使用 多线程的 executor时， Future 可能在 threads 中进行移动，所以 在async block中的 any variables 必须同样能够在 threads中进行移动， 意味着  任何没有实现 <a href="https://doc.rust-lang.org/std/marker/trait.Send.html">Send trait</a>、reference type 没有 实现 <a href="https://doc.rust-lang.org/std/marker/trait.Sync.html">Sync trait</a> 的都不能够 在async block中使用。</li>
  <li>锁：不能使用 传统的 non-futures-aware lock, 因为Future 可能在threads 中进行移动 从而导致死锁，应该使用  futures::lock 中的Mutex</li>
</ul>

<h3 id="工具以及-trait">工具以及 trait:</h3>

<h4 id="pin">Pin:</h4>
<ul>
  <li>Pin： maker， 保证 对象 implement !Unpin 永远不会被移动。因为比较难以理解， 下面为英文：</li>
</ul>

<blockquote>
  <p>The Pin type wraps pointer types, guaranteeing that the values behind the pointer won’t be moved. For example, Pin&lt;&amp;mut T&gt; , Pin&lt;&amp;T&gt; , Pin&lt;Box<T>&gt; all guarantee that T won't be moved if T: !Unpin .
Most types don't have a problem being moved. These types implement a trait called Unpin . Pointers to Unpin types can be freely placed into or taken out of Pin . For example, u8 is
Unpin , so Pin&lt;&amp;mut u8&gt; behaves just like a normal &amp;mut u8 .
However, types that can't be moved after they're pinned have a marker called !Unpin .
Futures created by async/await is an example of this.</T></p>
</blockquote>

<ul>
  <li>Pinning: 大概的以为是 是一个编译器 标记（marker） 用来保证 impl  !Unpin 的对象 在内存中 不被移动，即pin:</li>
  <li>Pin Summary:
    <ol>
      <li>If T: Unpin (which is the default), then Pin&lt;’a, T&gt; is entirely equivalent to &amp;’a mut T. in other words: Unpin means it’s OK for this type to be moved even when pinned, so Pin will have no effect on such a type.</li>
      <li>Getting a &amp;mut T to a pinned T requires unsafe if T: !Unpin.</li>
      <li>Most standard library types implement Unpin. The same goes for most “normal” types you encounter in Rust. A Future generated by async/await is an exception to this rule.</li>
      <li>You can add a !Unpin bound on a type on nightly with a feature flag, or by adding std::marker::PhantomPinned to your type on stable.</li>
      <li>You can either pin data to the stack or to the heap.</li>
      <li>Pinning a !Unpin object to the stack requires unsafe</li>
      <li>Pinning a !Unpin object to the heap does not require unsafe. There is a shortcut for doing this using Box::pin.</li>
      <li>For pinned data where T: !Unpin you have to maintain the invariant that its memory will not get invalidated or repurposed from the moment it gets pinned until when drop is called. This is an important part of the pin contract.</li>
    </ol>
  </li>
</ul>

<h4 id="stream-trait-like-future-但是能够-在完成之前-传递多个数值-like-iterator即-返回对象为---polloptionselfitem--stream-可以实现并行函数有-for_each_concurrent-try_for_each_concurrent">Stream Trait: like Future 但是能够 在完成之前 传递多个数值 like Iterator，即： 返回对象为   Poll&lt;Option&lt;Self::Item&gt; &gt;。 stream 可以实现并行，函数有 for_each_concurrent， try_for_each_concurrent</h4>
<h4 id="多个future-同时执行">多个Future 同时执行:</h4>
<ul>
  <li>工具方法:
    <ol>
      <li>join! : waits for futures to all complete</li>
      <li>select! : waits for one of several futures to complete</li>
      <li>Spawning: creates a top-level task which ambiently runs a future to completion</li>
      <li>FuturesUnordered : a group of futures which yields the result of each subfuture</li>
    </ol>
  </li>
  <li>join! 示例代码: try_join!  在其中一个 Future 返回错误的时候，立即返回</li>
</ul>

<div class="highlight"><pre class="highlight rust"><code><span class="c">// book 与 music 串行执行， music 等待book 执行完 才能执行</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">get_book_and_music</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="n">Book</span><span class="p">,</span> <span class="n">Music</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">book</span> <span class="o">=</span> <span class="nf">get_book</span><span class="p">()</span><span class="k">.await</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">music</span> <span class="o">=</span> <span class="nf">get_music</span><span class="p">()</span><span class="k">.await</span><span class="p">;</span>
    <span class="p">(</span><span class="n">book</span><span class="p">,</span> <span class="n">music</span><span class="p">)</span>
<span class="p">}</span>
<span class="c">// 错误的尝试，将 book 与 music 并行执行</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">get_book_and_music</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="n">Book</span><span class="p">,</span> <span class="n">Music</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">book_future</span> <span class="o">=</span> <span class="nf">get_book</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">music_future</span> <span class="o">=</span> <span class="nf">get_music</span><span class="p">();</span>
    <span class="p">(</span><span class="n">book_future</span><span class="k">.await</span><span class="p">,</span> <span class="n">music_future</span><span class="k">.await</span><span class="p">)</span>
<span class="p">}</span>
<span class="c">// 真正的并行执行</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">get_book_and_music</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="n">Book</span><span class="p">,</span> <span class="n">Music</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">book_fut</span> <span class="o">=</span> <span class="nf">get_book</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">music_fut</span> <span class="o">=</span> <span class="nf">get_music</span><span class="p">();</span>
    <span class="nd">join!</span><span class="p">(</span><span class="n">book_fut</span><span class="p">,</span> <span class="n">music_fut</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div><ul>
  <li>select! 示例代码： select macro 的使用风格比较奇怪， 需要在深入理解一下</li>
</ul>

<div class="highlight"><pre class="highlight rust"><code>
<span class="nd">#![allow(unused)]</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="k">use</span> <span class="nn">futures</span><span class="p">::{</span>
    <span class="nn">future</span><span class="p">::</span><span class="n">FutureExt</span><span class="p">,</span> <span class="c">// for `.fuse()`</span>
    <span class="n">pin_mut</span><span class="p">,</span>
    <span class="n">select</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">async</span> <span class="k">fn</span> <span class="nf">task_one</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">task_two</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>

<span class="k">async</span> <span class="k">fn</span> <span class="nf">race_tasks</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">t1</span> <span class="o">=</span> <span class="nf">task_one</span><span class="p">()</span><span class="nf">.fuse</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">t2</span> <span class="o">=</span> <span class="nf">task_two</span><span class="p">()</span><span class="nf">.fuse</span><span class="p">();</span>

    <span class="nd">pin_mut!</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">);</span>

    <span class="nd">select!</span> <span class="p">{</span>
        <span class="p">()</span> <span class="o">=</span> <span class="n">t1</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"task one completed first"</span><span class="p">),</span>
        <span class="p">()</span> <span class="o">=</span> <span class="n">t2</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"task two completed first"</span><span class="p">),</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<ul>
  <li>Unpin ： Unpin 是必须的， 因为在 select 中 数值是使用mut reference，而非take ownership 的， 没有完成的future 依然可以在后面的select 中使用。</li>
  <li>FusedFuture: 同样是必须的， 因为 select 中 必须 not poll 已经完成的Future， FusedFuture 实现了 跟踪 Future 是否已经完成，</li>
  <li>这两个 trait 能够让 select 在 loop block 中使用。 如下代码示例：</li>
</ul>

<div class="highlight"><pre class="highlight rust"><code><span class="nd">#![allow(unused)]</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="k">use</span> <span class="nn">futures</span><span class="p">::{</span><span class="n">future</span><span class="p">,</span> <span class="n">select</span><span class="p">};</span>

<span class="k">async</span> <span class="k">fn</span> <span class="nf">count</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">a_fut</span> <span class="o">=</span> <span class="nn">future</span><span class="p">::</span><span class="nf">ready</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">b_fut</span> <span class="o">=</span> <span class="nn">future</span><span class="p">::</span><span class="nf">ready</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="nd">select!</span> <span class="p">{</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">a_fut</span> <span class="k">=&gt;</span> <span class="n">total</span> <span class="o">+=</span> <span class="n">a</span><span class="p">,</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">b_fut</span> <span class="k">=&gt;</span> <span class="n">total</span> <span class="o">+=</span> <span class="n">b</span><span class="p">,</span>
            <span class="n">complete</span> <span class="k">=&gt;</span> <span class="k">break</span><span class="p">,</span>
            <span class="n">default</span> <span class="k">=&gt;</span> <span class="nd">unreachable!</span><span class="p">(),</span> <span class="c">// never runs (futures are ready, then complete)</span>
        <span class="p">};</span>
    <span class="p">}</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">total</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">}</span>

</code></pre></div>
<h3 id="async-blocks-编码存在的一些问题">Async Blocks 编码存在的一些问题:</h3>
<ul>
  <li>？: 在 async block 中  使用 ? 需要  额外的 声明 Error type 来帮助 编译器确定 错误类型， 如下：</li>
</ul>

<div class="highlight"><pre class="highlight rust"><code><span class="c">// 产生 编译错误</span>
<span class="k">let</span> <span class="n">fut</span> <span class="o">=</span> <span class="k">async</span> <span class="p">{</span>
    <span class="nf">foo</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">bar</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">};</span>

<span class="c">// 正确的解决方法</span>
<span class="nd">#![allow(unused)]</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="k">struct</span> <span class="n">MyError</span><span class="p">;</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">foo</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">MyError</span><span class="o">&gt;</span> <span class="p">{</span> <span class="nf">Ok</span><span class="p">(())</span> <span class="p">}</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">bar</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">MyError</span><span class="o">&gt;</span> <span class="p">{</span> <span class="nf">Ok</span><span class="p">(())</span> <span class="p">}</span>
<span class="k">let</span> <span class="n">fut</span> <span class="o">=</span> <span class="k">async</span> <span class="p">{</span>
    <span class="nf">foo</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">bar</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
    <span class="nn">Ok</span><span class="p">::</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">MyError</span><span class="o">&gt;</span><span class="p">(())</span> <span class="c">// &lt;- note the explicit type annotation here</span>
<span class="p">};</span>
<span class="p">}</span>
</code></pre></div><ul>
  <li>Future 是否 能够 send： 有些Future state machines 可以安全地被send, 而有些则不能。 是否Future 可以被 send 取决于是否在.await点上保留 non-send type。 当可能在.await点上保留值时，编译器会尽力进行近似，但是编译器的分析在许多地方都过于保守。 如下面代码示例：</li>
</ul>

<div class="highlight"><pre class="highlight rust"><code><span class="c">// 通过编译</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nb">Rc</span><span class="p">;</span>
<span class="nd">#[derive(Default)]</span>
<span class="k">struct</span> <span class="nf">NotSend</span><span class="p">(</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">);</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{}</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="nn">NotSend</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span>
    <span class="nf">bar</span><span class="p">()</span><span class="k">.await</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">require_send</span><span class="p">(</span><span class="mi">_</span><span class="p">:</span> <span class="k">impl</span> <span class="nb">Send</span><span class="p">)</span> <span class="p">{}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">require_send</span><span class="p">(</span><span class="nf">foo</span><span class="p">());</span>
<span class="p">}</span>

<span class="c">// 产生编译错误</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nb">Rc</span><span class="p">;</span>
<span class="nd">#[derive(Default)]</span>
<span class="k">struct</span> <span class="nf">NotSend</span><span class="p">(</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">);</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{}</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nn">NotSend</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span>
    <span class="nf">bar</span><span class="p">()</span><span class="k">.await</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">fn</span> <span class="nf">require_send</span><span class="p">(</span><span class="mi">_</span><span class="p">:</span> <span class="k">impl</span> <span class="nb">Send</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="nf">require_send</span><span class="p">(</span><span class="nf">foo</span><span class="p">());</span>
<span class="p">}</span>


<span class="c">// 正确的解决方法</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nb">Rc</span><span class="p">;</span>
<span class="nd">#[derive(Default)]</span>
<span class="k">struct</span> <span class="nf">NotSend</span><span class="p">(</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">);</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{}</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nn">NotSend</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="nf">bar</span><span class="p">()</span><span class="k">.await</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">fn</span> <span class="nf">require_send</span><span class="p">(</span><span class="mi">_</span><span class="p">:</span> <span class="k">impl</span> <span class="nb">Send</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="nf">require_send</span><span class="p">(</span><span class="nf">foo</span><span class="p">());</span>
<span class="p">}</span>

</code></pre></div>
<ul>
  <li>递归问题： 因async fn 内部的状态机 实现导致 递归的使用 需要 额外 解决方案. 如下：</li>
</ul>

<div class="highlight"><pre class="highlight rust"><code><span class="c">// This function:</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">step_one</span><span class="p">()</span><span class="k">.await</span><span class="p">;</span>
    <span class="nf">step_two</span><span class="p">()</span><span class="k">.await</span><span class="p">;</span>
<span class="p">}</span>
<span class="c">// generates a type like this:</span>
<span class="k">enum</span> <span class="n">Foo</span> <span class="p">{</span>
    <span class="nf">First</span><span class="p">(</span><span class="n">StepOne</span><span class="p">),</span>
    <span class="nf">Second</span><span class="p">(</span><span class="n">StepTwo</span><span class="p">),</span>
<span class="p">}</span>

<span class="c">// So this function:</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">recursive</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">recursive</span><span class="p">()</span><span class="k">.await</span><span class="p">;</span>
    <span class="nf">recursive</span><span class="p">()</span><span class="k">.await</span><span class="p">;</span>
<span class="p">}</span>

<span class="c">// generates a type like this:  因为类型对象存在递归，导致 无法通过编译，需要通过 Box 进行封装 来进行规避</span>
<span class="k">enum</span> <span class="n">Recursive</span> <span class="p">{</span>
    <span class="nf">First</span><span class="p">(</span><span class="n">Recursive</span><span class="p">),</span>
    <span class="nf">Second</span><span class="p">(</span><span class="n">Recursive</span><span class="p">),</span>
<span class="p">}</span>

<span class="c">// --------------------</span>
<span class="c">// In order to allow this, we have to introduce an indirection using Box. Unfortunately, compiler limitations mean that just wrapping the calls to recursive() in Box::pin isn't enough. To make this work, we have to make recursive into a non-async function which returns a .boxed() async block:</span>

<span class="k">use</span> <span class="nn">futures</span><span class="p">::</span><span class="nn">future</span><span class="p">::{</span><span class="n">BoxFuture</span><span class="p">,</span> <span class="n">FutureExt</span><span class="p">};</span>

<span class="k">fn</span> <span class="nf">recursive</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">BoxFuture</span><span class="o">&lt;</span><span class="nv">'static</span><span class="p">,</span> <span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
        <span class="nf">recursive</span><span class="p">()</span><span class="k">.await</span><span class="p">;</span>
        <span class="nf">recursive</span><span class="p">()</span><span class="k">.await</span><span class="p">;</span>
    <span class="p">}</span><span class="nf">.boxed</span><span class="p">()</span>
<span class="p">}</span>

</code></pre></div><h3 id="async-生态">Async 生态:</h3>

<ul>
  <li>Async Runtimes = reactor + one or more executors</li>
  <li>Reactors： 提供对于 外部事件 比如: 异步IO 进程内通讯 timer 等 简单的订阅方式 (provide subscription mechanisms for external events, like async I/O, interprocess communication, and timers. In an async runtime, subscribers are typically futures representing low-level I/O operations)</li>
  <li>Executors: Future 具体的执行者， 因为只有 thread ，process 才能够执行代码，所以Future等 抽象事物，依然需要具体的executor  (handle the scheduling and execution of tasks. They keep track of running and suspended tasks, poll futures to completion, and wake tasks when they can make progress)</li>
  <li>Futures Crate： 包含 async code 有用的trait 与 函数， 包含trait有： Stream, Sink, AsyncRead, AsyncWrite  , 工具有： join! select! etc （这些可能将成为 标准库 的一部分） future 实现了自己的 executor， 但是并没有 reactor。 所以一个常见的组合是： Future 的工具 + 其他crate 的executor</li>
  <li>常见的 Async runtime:
    <ul>
      <li>Tokio: A popular async ecosystem with HTTP, gRPC, and tracing frameworks. async-std: A crate that provides asynchronous counterparts to standard library components.</li>
      <li>smol: A small, simplified async runtime. Provides the Async trait that can be used to wrap structs like*  UnixStream or TcpListener</li>
      <li>fuchsia-async: An executor for use in the Fuchsia OS.</li>
    </ul>
  </li>
</ul>

<h3 id="相关资料">相关资料：</h3>
<ul>
  <li>Event-driven programming（事件驱动 模型， rust future 就是此类模型 ） https://en.wikipedia.org/wiki/Event-driven_programming</li>
  <li>event driven  同样存在多种形式， refactor  pattern &amp; https://en.wikipedia.org/wiki/Proactor_pattern</li>
  <li>相关资料： 有： http://www.alan-g.me.uk/l2p/tutevent.htm http://www.dre.vanderbilt.edu/~schmidt/PDF/reactor-siemens.pdf  https://altushost-swe.dl.sourceforge.net/project/eventdrivenpgm/event_driven_programming.pdf</li>
  <li>在rust 的 async program 中： 主要有  rust async 的语法支持， 社区提供的 future 模型， 以及 对应 runtime executor 实现，则有： async-std, tokio， smol， fuchsia-async。 future 的抽象只有一种，而对应的 runtime executor 因为 与 操作系统 生态有关，则有多种的实现</li>
  <li>Coroutines （协程， 即是语言在 OS上 对于 轻量线程的抽象， 在 《现代操作系统》 中 有详细介绍过此类模型，但是因为其 一些根源性问题， 对于系统信号、调度等并不友好）</li>
  <li>The actor model: 将单元划分为 actor， 使用消息进行 通讯， Erlang 是典型的 actor并发代表</li>
</ul>
<div class="social"></div></article></main><footer><div class="footer-wrapper"><div class="author"><div class="image-wrapper"><a href="/author/"><img alt="author" src="../../../../images/profile-1e71686a.png" /></a></div></div><div class="image-content"><img src="../../../../images/wechat_nasa-0d87c0dd.png" /></div><div class="copyright"><i class="fa fa-copyright"></i> 2021 <a href="/">日常学习</a> - geniousbar</div></div><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?b43ef53b285c49e1af0bd7080994c825";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script></footer></body></html>