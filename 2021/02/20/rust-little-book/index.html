<!DOCTYPE html><html><head><meta charset="utf-8" /><meta content="IE=edge;chrome=1" http-equiv="X-UA-Compatible" /><meta content="initial-scale=1.0, user-scalable=no" name="viewport" /><title>Rust little book | 日常学习</title><meta description="Rust little book  rustup:  rust complier 的管理工具， 可以方便的切换 stable, beta, and nightly cargo 是rust的包管理工具， 用来 下载 rust的依赖， 编译， 以及 分发 到 crates.io    在安装 rust 之后， cargo 也会被自动安装上   cargo 提供了一些有用的工具有:            cargo new package # default –bin 生成 可执行 program...   " /><link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/feed.xml" /><link href="../../../../stylesheets/style-198d4031.css" rel="stylesheet" type="text/css" /><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" /><link href="../../../../images/favicon-6c3f3d04.png" rel="icon" type="image/png" /><script src="../../../../javascripts/all-b3988275.js"></script></head><body><header><div class="top-menu"><div class="top-menu-wrapper"><div class="top-menu-list"><ul><li><a href="/">Home</a></li><li><a href="/archives/">Archives</a></li><li><a href="/tags/">Tags</a></li><li><a href="/by-year/">By Year</a></li><li id="wechat"><a href="#" onclick="toggleShowWechat()">Wechat</a></li></ul></div></div></div><div id="header-wechat-img"><img src="../../../../images/wechat_nasa-0d87c0dd.png" /></div><h1 class="logo"><a href="/" title="日常学习"><span class="logo-text">日常学习</span></a></h1></header><main><article><h1 class="article-title">Rust little book</h1><div class="posted-date-wrapper"><i class="fa fa-clock-o"></i><span class="posted-date">February 20, 2021</span></div><div class="tag-labels"><a href="/tags/rust/"><small class="tag-label">rust</small></a><a href="/tags/cargo/"><small class="tag-label">cargo</small></a><a href="/tags/rustup/"><small class="tag-label">rustup</small></a></div><hr class="article-header-separator" /><h2 id="rust-little-book">Rust little book</h2>

<h3 id="rustup--rust-complier-的管理工具-可以方便的切换-stable-beta-and-nightly">rustup:  rust complier 的管理工具， 可以方便的切换 stable, beta, and nightly</h3>
<h3 id="cargo-是rust的包管理工具-用来-下载-rust的依赖-编译-以及-分发-到-cratesio">cargo 是rust的包管理工具， 用来 下载 rust的依赖， 编译， 以及 分发 到 crates.io</h3>
<ul>
  <li>在安装 rust 之后， cargo 也会被自动安装上</li>
  <li>cargo 提供了一些有用的工具有:
    <ol>
      <li>cargo new package # default –bin 生成 可执行 program, 可以传递 –lib 来产生库程序</li>
      <li>cargo build</li>
      <li>cargo 存在的意义：
        <ul>
          <li>剥离 rustc 的复杂度， 类似 make 与 c 一样</li>
          <li>cargo 最终调用rustc 来编译 项目， 当然可以 直接使用 rustc 来编译项目，但是 需要出入 复杂的参数 来 添加项目 依赖关系， 编译文件， 依赖关系 等，并精心安排顺序 来进行调用。</li>
          <li>所以使用cargo： make工具， cargo 的功能
            <ol>
              <li>使用两个文件 来 包含 package的信息</li>
              <li>拉取，构建  package 依赖</li>
              <li>使用正确的参数 来调用rustc 或者其他 tool， 来构建项目</li>
              <li>引用约定，方便package 构建</li>
            </ol>
          </li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<h3 id="cargo-使用笔记">cargo 使用笔记：</h3>
<ul>
  <li>cargo new hello_world –bin</li>
</ul>

<div class="highlight"><pre class="highlight shell"><code><span class="nv">$ </span><span class="nb">cd </span>hello_world
<span class="nv">$ </span>tree <span class="nb">.</span>
<span class="nb">.</span>
├── Cargo.toml
└── src
    └── main.rs

1 directory, 2 files
</code></pre></div>
<ul>
  <li>其中 Cargo.toml 被称为 manifest,包含package的元数据</li>
</ul>

<div class="highlight"><pre class="highlight shell"><code>fn main<span class="o">()</span> <span class="o">{</span>
    println!<span class="o">(</span><span class="s2">"Hello, world!"</span><span class="o">)</span><span class="p">;</span>
<span class="o">}</span>


<span class="nv">$ </span>cargo build
   Compiling hello_world v0.1.0 <span class="o">(</span>file:///path/to/package/hello_world<span class="o">)</span>

<span class="nv">$ </span>./target/debug/hello_world
Hello, world!


<span class="nv">$ </span>cargo run
   Compiling hello_world v0.1.0 <span class="o">(</span>file:///path/to/package/hello_world<span class="o">)</span>
     Running <span class="sb">`</span>target/debug/hello_world<span class="sb">`</span>
Hello, world!



<span class="nv">$ </span>cargo build <span class="nt">--release</span>
   Compiling hello_world v0.1.0 <span class="o">(</span>file:///path/to/package/hello_world<span class="o">)</span>

</code></pre></div>
<ul>
  <li>cargo build  将会 构建 package</li>
  <li>cargo run 则 构建并运行它</li>
  <li>cargo build –release 将 构建 优化的代码</li>
  <li>cargo 默认的构建 代码优化级别 为 debug, 存在的目录为 target/debug, 构建 优化后的代码需要 显式传递 参数 –release 生成的文件目录为 target/release</li>
  <li>Dependencies：
    <ul>
      <li>crate.io 为 rust 中间的 package 机构， 用于发现 下载 更新package</li>
      <li>添加依赖关系： 在 Cargo.toml 中 的dependencies 下，添加项目</li>
    </ul>

<div class="highlight"><pre class="highlight shell"><code><span class="o">[</span>package]
name <span class="o">=</span> <span class="s2">"hello_world"</span>
version <span class="o">=</span> <span class="s2">"0.1.0"</span>
authors <span class="o">=</span> <span class="o">[</span><span class="s2">"Your Name &lt;you@example.com&gt;"</span><span class="o">]</span>
edition <span class="o">=</span> <span class="s2">"2018"</span>

<span class="o">[</span>dependencies]
<span class="nb">time</span> <span class="o">=</span> <span class="s2">"0.1.12"</span>
regex <span class="o">=</span> <span class="s2">"0.1.41"</span>
</code></pre></div>
    <ul>
      <li>之后的 cargo build 过程</li>
    </ul>

<div class="highlight"><pre class="highlight shell"><code><span class="nv">$ </span>cargo build
      Updating crates.io index
   Downloading memchr v0.1.5
   Downloading libc v0.1.10
   Downloading regex-syntax v0.2.1
   Downloading memchr v0.1.5
   Downloading aho-corasick v0.3.0
   Downloading regex v0.1.41
     Compiling memchr v0.1.5
     Compiling libc v0.1.10
     Compiling regex-syntax v0.2.1
     Compiling memchr v0.1.5
     Compiling aho-corasick v0.3.0
     Compiling regex v0.1.41
     Compiling hello_world v0.1.0 <span class="o">(</span>file:///path/to/package/hello_world<span class="o">)</span>
</code></pre></div></li>
</ul>

<h4 id="package-构成">package 构成：</h4>

<div class="highlight"><pre class="highlight shell"><code>  <span class="nb">.</span>
  ├── Cargo.lock
  ├── Cargo.toml
  ├── src/
  │   ├── lib.rs
  │   ├── main.rs
  │   └── bin/
  │       ├── named-executable.rs
  │       ├── another-executable.rs
  │       └── multi-file-executable/
  │           ├── main.rs
  │           └── some_module.rs
  ├── benches/
  │   ├── large-input.rs
  │   └── multi-file-bench/
  │       ├── main.rs
  │       └── bench_module.rs
  ├── examples/
  │   ├── simple.rs
  │   └── multi-file-example/
  │       ├── main.rs
  │       └── ex_module.rs
  └── tests/
      ├── some-integration-tests.rs
      └── multi-file-test/
          ├── main.rs
          └── test_module.rs
</code></pre></div><ul>
  <li>Cargo.toml and Cargo.lock 在项目的根目录</li>
  <li>src 下 为源代码</li>
  <li>默认的 library file 为 src/lib.rs</li>
  <li>默认的 executable file 是 src/main.rc, 其他的 放在 src/bin/</li>
  <li>基准测试 放在benches 目录下</li>
  <li>示例代码放在examples 目录下</li>
  <li>集成测试 放在 tests 目录下</li>
  <li>
    <p>其他详细的需要参看 [[https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html]]</p>
  </li>
  <li>Cargo.toml 与 Cargo.lock: 两种目的，
    <ul>
      <li>cargo.toml 描述 大概的依赖关系 并不准确，是由 人来确定的</li>
      <li>Cargo.lock 包含准确的依赖关系， 由cargo 来维护</li>
      <li>[[https://doc.rust-lang.org/cargo/faq.html#why-do-binaries-have-cargolock-in-version-control-but-not-libraries]]</li>
      <li>示例:</li>
    </ul>

<div class="highlight"><pre class="highlight shell"><code>Cargo.toml

<span class="o">[</span>package]
name <span class="o">=</span> <span class="s2">"hello_world"</span>
version <span class="o">=</span> <span class="s2">"0.1.0"</span>
authors <span class="o">=</span> <span class="o">[</span><span class="s2">"Your Name &lt;you@example.com&gt;"</span><span class="o">]</span>

<span class="o">[</span>dependencies]
rand <span class="o">=</span> <span class="o">{</span> git <span class="o">=</span> <span class="s2">"https://github.com/rust-lang-nursery/rand.git"</span>, rev <span class="o">=</span> <span class="s2">"9f35b8e"</span> <span class="o">}</span>


Cargo.lock


<span class="o">[[</span>package]]
name <span class="o">=</span> <span class="s2">"hello_world"</span>
version <span class="o">=</span> <span class="s2">"0.1.0"</span>
dependencies <span class="o">=</span> <span class="o">[</span>
 <span class="s2">"rand 0.1.0 (git+https://github.com/rust-lang-nursery/rand.git#9f35b8e439eeedd60b9414c58f389bdc6a3284f9)"</span>,
<span class="o">]</span>

<span class="o">[[</span>package]]
name <span class="o">=</span> <span class="s2">"rand"</span>
version <span class="o">=</span> <span class="s2">"0.1.0"</span>
<span class="nb">source</span> <span class="o">=</span> <span class="s2">"git+https://github.com/rust-lang-nursery/rand.git#9f35b8e439eeedd60b9414c58f389bdc6a3284f9"</span>
</code></pre></div></li>
  <li>Cargo.lock 中包含 依赖的确定的 version， 当其他人使用的时候， 他们将使用相同的 sha，即便我们并没有在Cargo.toml 中使用</li>
  <li>
    <p>cargo update 更新全部的依赖， cargo update -p rand 只更新依赖 rand</p>
  </li>
  <li>Test:
    <ul>
      <li>cargo test 执行 package中的所有test， test主要有两种： 1) 在每个 src 目录中的文件， 2） tests/ 目录下的所有文件。 1）中的为单元测试， 2）则为 集成测试，</li>
    </ul>

<div class="highlight"><pre class="highlight shell"><code><span class="nv">$ </span>cargo <span class="nb">test
   </span>Compiling rand v0.1.0 <span class="o">(</span>https://github.com/rust-lang-nursery/rand.git#9f35b8e<span class="o">)</span>
   Compiling hello_world v0.1.0 <span class="o">(</span>file:///path/to/package/hello_world<span class="o">)</span>
     Running target/test/hello_world-9c2b65bbb79eabce

running 0 tests

<span class="nb">test </span>result: ok. 0 passed<span class="p">;</span> 0 failed<span class="p">;</span> 0 ignored<span class="p">;</span> 0 measured<span class="p">;</span> 0 filtered out
</code></pre></div>    <ul>
      <li>cargo test foo  可以单独执行 名字为foo的测试，</li>
      <li>cargo test 其实还会执行 额外的测试，包含在 src中的部分 文档中的测试（并不重要，为补充部分）</li>
    </ul>
  </li>
  <li>Cargo Home： 当build package的时候， cargo 将下载的依赖package 存储到 Cargo home 下。当做cache 使用。
    <ul>
      <li>可以通过 改变 环境变量 CARGO_HOME 来改变 cargo home的值， 默认 为 $HOME/.cargo/</li>
      <li>Cargo Home 目录下的 数据：
        <ul>
          <li>bin 目录： 可执行crate， 包括cargo install 或者 rustup 安装的</li>
          <li>git/db: crate 依赖git 项目时， cargo clone 项目到 该目录下</li>
          <li>git/checkouts： git/db 项目中的检出到该文件， 比如 依赖于特定的commit</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>registry： 项目依赖于 crate.io 中的crate 存放在该目录下
    <ul>
      <li>registry/index： crate 的原数据， 包括： version， dependencies 等</li>
      <li>registry/cache： 下载的crate 储存到该目录下， 存储形式为 .crate 的gzip压缩文件</li>
      <li>registry/src： cache 的解压形式 存放在 该文件中</li>
    </ul>
  </li>
</ul>

<h4 id="指定-dependencies">指定 Dependencies：</h4>
<ul>
  <li>依赖版本： 版本号各个位置数字的含义： [[https://semver.org/][SemVer compatible]] 与 link 中讲的同样， major.minor.patch</li>
  <li>Caret requirements： 指定 可以使用 一个 major 版本号 不变的更新， 但是 0 是 一个特殊的数字，标识不与 任何 数字兼容。即是： 0.0.1， 与 0.1.x 不兼容</li>
  <li>
    <p>下面为兼容样例：</p>

<div class="highlight"><pre class="highlight shell"><code>^1.2.3  :<span class="o">=</span>  <span class="o">&gt;=</span>1.2.3, &lt;2.0.0
^1.2    :<span class="o">=</span>  <span class="o">&gt;=</span>1.2.0, &lt;2.0.0
^1      :<span class="o">=</span>  <span class="o">&gt;=</span>1.0.0, &lt;2.0.0
^0.2.3  :<span class="o">=</span>  <span class="o">&gt;=</span>0.2.3, &lt;0.3.0
^0.2    :<span class="o">=</span>  <span class="o">&gt;=</span>0.2.0, &lt;0.3.0
^0.0.3  :<span class="o">=</span>  <span class="o">&gt;=</span>0.0.3, &lt;0.0.4
^0.0    :<span class="o">=</span>  <span class="o">&gt;=</span>0.0.0, &lt;0.1.0
^0      :<span class="o">=</span>  <span class="o">&gt;=</span>0.0.0, &lt;1.0.0
</code></pre></div>  </li>
  <li>Tilde requirements:  分为以下情况:
    <ul>
      <li>有 major.minor.patch 或者  major.minor 只有patch version 的升级是允许的</li>
      <li>有major情况下, minor patch verison的升级 是允许的</li>
      <li>for example</li>
    </ul>

<div class="highlight"><pre class="highlight shell"><code>~1.2.3  :<span class="o">=</span> <span class="o">&gt;=</span>1.2.3, &lt;1.3.0
~1.2    :<span class="o">=</span> <span class="o">&gt;=</span>1.2.0, &lt;1.3.0
~1      :<span class="o">=</span> <span class="o">&gt;=</span>1.0.0, &lt;2.0.0
</code></pre></div></li>
  <li>Wildcard requirements:
    <ul>
      <li>允许所在位置上的 任何版本</li>
      <li>for example</li>
    </ul>

<div class="highlight"><pre class="highlight shell"><code><span class="se">\*</span>     :<span class="o">=</span> <span class="o">&gt;=</span>0.0.0
1.<span class="k">*</span>   :<span class="o">=</span> <span class="o">&gt;=</span>1.0.0, &lt;2.0.0
1.2.<span class="k">*</span> :<span class="o">=</span> <span class="o">&gt;=</span>1.2.0, &lt;1.3.0
</code></pre></div></li>
</ul>

<h4 id="workspaces-workspace-下的一系列package-共享同样的cargolock-output-dir-等配置比如profile-workspace下的packages-被称为-workspace-members">Workspaces: workspace 下的一系列package 共享同样的Cargo.lock， output dir 等配置（比如profile）， workspace下的packages 被称为 workspace members</h4>
<ul>
  <li>存在两种形式： 1） [package] 与 [workspace] 共存在 Cargo.toml 中 2） 只有 [workspace] 存在Cargo.toml 中， 被称作 Virtual manifest</li>
  <li>主要作用：
    <ol>
      <li>共享Cargo.lock</li>
      <li>共享output dir， Cargo.toml 中 [target]</li>
      <li>[patch], [replace] and [profile.*] 等 在Cargo.toml 中的 段  只能识别在 workspace 中的 manifest，member package 中的被忽略</li>
    </ol>
  </li>
  <li>
    <p>workspace section 中的配置</p>

<div class="highlight"><pre class="highlight shell"><code><span class="o">[</span>workspace]
members <span class="o">=</span> <span class="o">[</span><span class="s2">"member1"</span>, <span class="s2">"path/to/member2"</span>, <span class="s2">"crates/*"</span><span class="o">]</span>
exclude <span class="o">=</span> <span class="o">[</span><span class="s2">"crates/foo"</span>, <span class="s2">"path/to/other"</span><span class="o">]</span>
</code></pre></div>  </li>
  <li>members 为 成员package 列表， exclude 排除 member
    <ul>
      <li>workspace 寻找： Cargo 自动的 向上目录 寻找 含有 [workspace] 的Cargo.toml， 在 member中可以指定 package.workspace 来 直接指定 workspace 的位置， 来防止自动查找， 这个对于 没有在 workspace 目录下的member package 非常有用</li>
      <li>member package： cargo command -p package 可以指定 package 来 执行命令， 如果没有指定 package， 则 选择当前所在目录的package， default-members = [“path/to/member2”, “path/to/member3/”] 可以指定默认的 操作的member package</li>
    </ul>
  </li>
</ul>

<h3 id="rustup-从官方下载rustc-使能够随意的在-stable-beta-nightly-中切换-让-cross-compiling-编译变的简单">rustup： 从官方下载rustc， 使能够随意的在 stable, beta, nightly 中切换。 让 cross-compiling 编译变的简单</h3>
<ul>
  <li>工作原理：  rustup 通过 ~/.cargo/bin 下的工具 来实现其功能， 比如 安装在~/.cargo/bin   下的  rustc cargo 等 只是一个 到真正执行工具的 代理，</li>
  <li>rustup 提供了一个方便的机制来 控制 这些代理的行为， 比如 通过执行rustup default nightly 来切换 nightly 下的工具</li>
</ul>

<h4 id="概念">概念:</h4>
<ul>
  <li>channel: rustc 按照 beta, night, stable 三个 channel 进行发布， channel 并没有什么用， 只是个概念而已。</li>
  <li>toolchain： rustc and cargo 等相关工具。 因为能够控制rustc (即是channel概念下的实际应用)</li>
  <li>target： rustc 可以为多个平台生成代码。 默认的 rustc 使用host(即本机) 作为target， 为了生成不同target的代码，我们需要 使用rustup target 来安装目标target</li>
  <li>component: 每个rust版本的发布，都会包含一些 组件， 包括rustc， clippy 等</li>
  <li>profile： 为了更好的与component 工作， profile 定义了 一组component，</li>
</ul>

<blockquote>
  <p>toolchain：  rustup 不仅可以 安装stable, beta, nightly 三个channel， 还可以安装 其他的 官方 历史版本</p>
</blockquote>

<ul>
  <li>channel 的命令规则:</li>
</ul>

<div class="highlight"><pre class="highlight shell"><code>&lt;channel&gt;[-&lt;<span class="nb">date</span><span class="o">&gt;][</span>-&lt;host&gt;]

&lt;channel&gt;       <span class="o">=</span> stable|beta|nightly|&lt;major.minor&gt;|&lt;major.minor.patch&gt;
&lt;<span class="nb">date</span><span class="o">&gt;</span>          <span class="o">=</span> YYYY-MM-DD
&lt;host&gt;          <span class="o">=</span> &lt;target-triple&gt;

<span class="c">#+end_src</span>
<span class="k">**</span> 其他命令： 保持 rust 更新： 
<span class="c">#+begin_src </span>
<span class="nv">$ </span>rustup update
info: syncing channel updates <span class="k">for</span> <span class="s1">'stable'</span>
info: downloading component <span class="s1">'rustc'</span>
info: downloading component <span class="s1">'rust-std'</span>
info: downloading component <span class="s1">'rust-docs'</span>
info: downloading component <span class="s1">'cargo'</span>
info: installing component <span class="s1">'rustc'</span>
info: installing component <span class="s1">'rust-std'</span>
info: installing component <span class="s1">'rust-docs'</span>
info: installing component <span class="s1">'cargo'</span>
info: checking <span class="k">for </span>self-updates
info: downloading self-updates

  stable updated: rustc 1.7.0 <span class="o">(</span>a5d1e7a59 2016-02-29<span class="o">)</span>
</code></pre></div><blockquote>
  <p>如上， rustup update 会更新 stable， component， 以及 rustup self， 可以使用 rustup self update 来手动更新rustup</p>
</blockquote>

<h3 id="rust-知识">Rust 知识：</h3>
<h4 id="stdfmt">std::fmt:</h4>
<ul>
  <li>format! 的使用 方法：  positional params：， named params： ， formating params：</li>
  <li>
    <p>示例</p>

<div class="highlight"><pre class="highlight rust"><code><span class="nd">format!</span><span class="p">(</span><span class="s">"Hello, {}!"</span><span class="p">,</span> <span class="s">"world"</span><span class="p">);</span>   <span class="c">// =&gt; "Hello, world!"</span>
<span class="nd">format!</span><span class="p">(</span><span class="s">"{1} {} {0} {}"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c">// =&gt; "2 1 1 2"</span>
<span class="nd">format!</span><span class="p">(</span><span class="s">"{argument}"</span><span class="p">,</span> <span class="n">argument</span> <span class="o">=</span> <span class="s">"test"</span><span class="p">);</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"Hello {:1$}!"</span><span class="p">,</span> <span class="s">"x"</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</code></pre></div>  </li>
  <li>formating trait: 实践显式 对于外部的Type  {}确实需要impl Display， 而{:?} 需要 impl Debug
    <ol>
      <li>{} =&gt; Display</li>
      <li>{:?} =&gt; Debug</li>
      <li>{:o} =&gt; Octal</li>
      <li>{:p} =&gt; Pointer</li>
    </ol>
  </li>
  <li>fmt::Display vs fmt::Debug
    <ol>
      <li>Display: 断言 实现者 总是返回 UTF-8 的字符串， 并非所有的 都实现了 Display</li>
      <li>Debug：  应该为所有pub type 实现， 输出为 内部状态， 该Trait 的目的是为了方便Rust Debug， 可以 使用#[derive(Debug)] 来使用默认的内部实现</li>
    </ol>
  </li>
</ul>

<h4 id="array--slice">array &amp; Slice</h4>
<ul>
  <li>array的类型为： [T: len], let mut array: [i32; 3] = [0; 3];</li>
  <li>Slice: [T]</li>
</ul>

<h4 id="structures-有三种类型-1-tuple-struct-2-classic-struct-3-unit-structs">structures： 有三种类型： 1） Tuple struct, 2) classic struct 3) Unit structs</h4>
<ul>
  <li>struct Pair(i32, f32);</li>
  <li>struct Person {  name: String,    age: u8}</li>
  <li>struct Unit; unit Struct 没有任何的 field</li>
</ul>

<h4 id="enums-包含多个-变体-的-组合项-任何一个变体-都是一个-正确的-enum-类型">Enums： 包含多个 变体 的 组合项， 任何一个变体 都是一个 正确的 enum 类型</h4>

<div class="highlight"><pre class="highlight rust"><code>  <span class="k">enum</span> <span class="n">WebEvent</span> <span class="p">{</span>
      <span class="c">// An `enum` may either be `unit-like`,</span>
      <span class="n">PageLoad</span><span class="p">,</span>
      <span class="n">PageUnload</span><span class="p">,</span>
      <span class="c">// like tuple structs,</span>
      <span class="nf">KeyPress</span><span class="p">(</span><span class="nb">char</span><span class="p">),</span>
      <span class="nf">Paste</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span>
      <span class="c">// or c-like structures.</span>
      <span class="n">Click</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="nb">i64</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">i64</span> <span class="p">},</span>
  <span class="p">}</span>

  <span class="c">// A function which takes a `WebEvent` enum as an argument and</span>
  <span class="c">// returns nothing.</span>
  <span class="k">fn</span> <span class="nf">inspect</span><span class="p">(</span><span class="n">event</span><span class="p">:</span> <span class="n">WebEvent</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">match</span> <span class="n">event</span> <span class="p">{</span>
          <span class="nn">WebEvent</span><span class="p">::</span><span class="n">PageLoad</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"page loaded"</span><span class="p">),</span>
          <span class="nn">WebEvent</span><span class="p">::</span><span class="n">PageUnload</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"page unloaded"</span><span class="p">),</span>
          <span class="c">// Destructure `c` from inside the `enum`.</span>
          <span class="nn">WebEvent</span><span class="p">::</span><span class="nf">KeyPress</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"pressed '{}'."</span><span class="p">,</span> <span class="n">c</span><span class="p">),</span>
          <span class="nn">WebEvent</span><span class="p">::</span><span class="nf">Paste</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"pasted </span><span class="se">\"</span><span class="s">{}</span><span class="se">\"</span><span class="s">."</span><span class="p">,</span> <span class="n">s</span><span class="p">),</span>
          <span class="c">// Destructure `Click` into `x` and `y`.</span>
          <span class="nn">WebEvent</span><span class="p">::</span><span class="n">Click</span> <span class="p">{</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
              <span class="nd">println!</span><span class="p">(</span><span class="s">"clicked at x={}, y={}."</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
          <span class="p">},</span>
      <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div>
<h4 id="type-aliastype-关键字能够-使用-type-name--existingtype-语法来-使用-name-代替-existingtype-使用-self-是一种type-alias">Type Alias：type 关键字能够 使用 type Name = ExistingType； 语法来 使用 Name 代替 ExistingType 使用。 Self 是一种Type Alias</h4>

<h4 id="const-static">const， static</h4>

<h4 id="variable-bindings-1变量默认-是不可修改的-使用mut-改变-2-可以在内部的scope中-其同样的名字来shadow即使不可见-外部的变量-3可以使用-先声明-后设定数值的形式-使用变量但是rust-会检查-使用-未定义变量的错误-来预防因此产生的问题">Variable Bindings： 1）变量默认 是不可修改的， 使用mut 改变 2） 可以在内部的scope中 其同样的名字来shadow(即使不可见) 外部的变量 3）可以使用 先声明 后设定数值的形式 使用变量，但是rust 会检查 使用 未定义变量的错误， 来预防因此产生的问题</h4>

<h4 id="types-1转换-as关键字--2-type-alias-type-nanosecond--u64-3-数值的类型可以添加到--后面最为后缀使用-例如-42i32">Types: 1）转换 as关键字  2） type alias： type NanoSecond = u64; 3） 数值的类型，可以添加到  后面最为后缀使用， 例如： 42i32</h4>

<h4 id="conversion-rust-的struct-以及-enum-等自定义类型的-type转换">Conversion： rust 的struct 以及 enum 等自定义类型的 type转换</h4>

<ol>
  <li>From &amp; Into:
    <ul>
      <li>From 为一个类型定义， 如何create self 从 另一个type中转变</li>
      <li>Into 则是From 的 调用者， From<T> for U 自动实现了 Into<u> for T ( blank implement)</u></T></li>
    </ul>
  </li>
  <li>TryFrom &amp; TryInto: 类似于 From &amp; Into 不同的是， 转换可能失败，返回Result
    <ul>
      <li>ToString &amp; FromStr:</li>
      <li>ToString： 单独为 String 类型 定义了一个 ToString Trait，但是并不需要直接实现 ToString，而是实现了 fmt::Display 之后 就自动了提供了 ToString 中的to_string 方法</li>
    </ul>
  </li>
</ol>

<div class="highlight"><pre class="highlight rust"><code>    <span class="nd">#[stable(feature</span> <span class="nd">=</span> <span class="s">"rust1"</span><span class="nd">,</span> <span class="nd">since</span> <span class="nd">=</span> <span class="s">"1.0.0"</span><span class="nd">)]</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span> <span class="o">+</span> <span class="o">?</span><span class="n">Sized</span><span class="o">&gt;</span> <span class="n">ToString</span> <span class="k">for</span> <span class="n">T</span> <span class="p">{</span>
    <span class="c">// A common guideline is to not inline generic functions. However,</span>
    <span class="c">// removing `#[inline]` from this method causes non-negligible regressions.</span>
    <span class="c">// See &lt;https://github.com/rust-lang/rust/pull/74852&gt;, the last attempt</span>
    <span class="c">// to try to remove it.</span>
    <span class="nd">#[inline]</span>
    <span class="n">default</span> <span class="k">fn</span> <span class="nf">to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="k">use</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Write</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">buf</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="n">buf</span><span class="nf">.write_fmt</span><span class="p">(</span><span class="nd">format_args!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="k">self</span><span class="p">))</span>
            <span class="nf">.expect</span><span class="p">(</span><span class="s">"a Display implementation returned an error unexpectedly"</span><span class="p">);</span>
        <span class="n">buf</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="fromstr--parse-将string-转换为其他类型-只需要实现了-fromstr-for-struct-而string-中的parse-方法-只是-对fromstrfrom_strstring-的调用">FromStr &amp; parse: 将String 转换为其他类型， 只需要实现了 FromStr for struct, 而String 中的parse 方法 只是 对FromStr::from_str(&amp;string) 的调用</h4>

<h4 id="expression-程序是由一系列表达式组成的-1-赋值表达式-用-结尾-2--也是表达式-如果最后一个表达式-以-结尾则返回---否则为最后一个表达式的-结果">Expression： 程序是由一系列表达式组成的， 1） 赋值表达式 用; 结尾， 2） {} 也是表达式， 如果最后一个表达式 以; 结尾，则返回  (), 否则为最后一个表达式的 结果</h4>

<h4 id="flow-of-control">Flow of control：</h4>
<ul>
  <li>if-else  也是表达式， 所有的分支必须返回同样的类型</li>
  <li>loop： loop break continue。 break 用来随时中断退出loop， continue 则用于 用于 跳过剩下的 代码，重新开始一个 循环</li>
  <li>
    <p>loop 是可以嵌套的，并起名字, break ，以及continue 可以使用名字来进行 break， 或者continue</p>

<div class="highlight"><pre class="highlight rust"><code><span class="nd">#![allow(unreachable_code)]</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nv">'outer</span><span class="p">:</span> <span class="k">loop</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Entered the outer loop"</span><span class="p">);</span>

        <span class="nv">'inner</span><span class="p">:</span> <span class="k">loop</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Entered the inner loop"</span><span class="p">);</span>

            <span class="c">// This would break only the inner loop</span>
            <span class="c">//break;</span>

            <span class="c">// This breaks the outer loop</span>
            <span class="k">break</span> <span class="nv">'outer</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nd">println!</span><span class="p">(</span><span class="s">"This point will never be reached"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"Exited the outer loop"</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="k">loop</span> <span class="p">{</span>
        <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">counter</span> <span class="o">==</span> <span class="mi">10</span> <span class="p">{</span>
            <span class="k">break</span> <span class="n">counter</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div>  </li>
  <li>loop 也是可以 返回数值的， 放到break 后面</li>
  <li>while</li>
  <li>for: for in 结构用来 遍历 所有实现了 IntoIterator 的对象， 比如简单 range形式： a..b, a..=b
    <ul>
      <li>for loop 会自动调用 into_iter 在参数上，我们可以主动产生下面几类实现IntoIterator 的 Iterator：</li>
    </ul>
  </li>
  <li>iter: 产生 引用的 Iterator, 对 ownership不产生影响
    <ul>
      <li>into_iter: 将ownership 交给 Iterator， 调用过之后的对象，将不再可用。产生</li>
      <li>iter_mut: 产生mut 引用的Iterator， 可以进行修改</li>
    </ul>
  </li>
  <li>match:
    <ul>
      <li>c like 方式： 即 match  number</li>
      <li>解构对象：
        <ul>
          <li>Tuples：  使用.. 来 忽略剩余所有的 tuple</li>
          <li>Enums:</li>
          <li>Pointers: *  &amp; ref ref mut 见下面示例</li>
          <li>Structs: struct 同样可以被match</li>
        </ul>
      </li>
      <li>Guards: 在match 对象的arm中，同样可以 使用 if 条件判断 即是 guards</li>
      <li>
        <p>Bindings： match 在 arm中，除了解构对象的同时 可以将变量整体绑定 到一个变量上</p>

<div class="highlight"><pre class="highlight rust"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">triple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="c">// TODO ^ Try different values for `triple`</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"Tell me about {:?}"</span><span class="p">,</span> <span class="n">triple</span><span class="p">);</span>
    <span class="c">// Match can be used to destructure a tuple</span>
    <span class="k">match</span> <span class="n">triple</span> <span class="p">{</span>
        <span class="c">// Destructure the second and third elements</span>
        <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"First is `0`, `y` is {:?}, and `z` is {:?}"</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span>
        <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">..</span><span class="p">)</span>  <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"First is `1` and the rest doesn't matter"</span><span class="p">),</span>
        <span class="c">// `..` can be the used ignore the rest of the tuple</span>
        <span class="mi">_</span>      <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"It doesn't matter what they are"</span><span class="p">),</span>
        <span class="c">// `_` means don't bind the value to a variable</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c">//point s </span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c">// Assign a reference of type `i32`. The `&amp;` signifies there</span>
    <span class="c">// is a reference being assigned.</span>
    <span class="k">let</span> <span class="n">reference</span> <span class="o">=</span> <span class="o">&amp;</span><span class="mi">4</span><span class="p">;</span>

    <span class="k">match</span> <span class="n">reference</span> <span class="p">{</span>
        <span class="c">// If `reference` is pattern matched against `&amp;val`, it results</span>
        <span class="c">// in a comparison like:</span>
        <span class="c">// `&amp;i32`</span>
        <span class="c">// `&amp;val`</span>
        <span class="c">// ^ We see that if the matching `&amp;`s are dropped, then the `i32`</span>
        <span class="c">// should be assigned to `val`.</span>
        <span class="o">&amp;</span><span class="n">val</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"Got a value via destructuring: {:?}"</span><span class="p">,</span> <span class="n">val</span><span class="p">),</span>
    <span class="p">}</span>

    <span class="c">// To avoid the `&amp;`, you dereference before matching.</span>
    <span class="k">match</span> <span class="o">*</span><span class="n">reference</span> <span class="p">{</span>
        <span class="n">val</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"Got a value via dereferencing: {:?}"</span><span class="p">,</span> <span class="n">val</span><span class="p">),</span>
    <span class="p">}</span>

    <span class="c">// What if you don't start with a reference? `reference` was a `&amp;`</span>
    <span class="c">// because the right side was already a reference. This is not</span>
    <span class="c">// a reference because the right side is not one.</span>
    <span class="k">let</span> <span class="mi">_</span><span class="n">not_a_reference</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

    <span class="c">// Rust provides `ref` for exactly this purpose. It modifies the</span>
    <span class="c">// assignment so that a reference is created for the element; this</span>
    <span class="c">// reference is assigned.</span>
    <span class="k">let</span> <span class="k">ref</span> <span class="mi">_</span><span class="n">is_a_reference</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

    <span class="c">// Accordingly, by defining 2 values without references, references</span>
    <span class="c">// can be retrieved via `ref` and `ref mut`.</span>
    <span class="k">let</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">mut_value</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>

    <span class="c">// Use `ref` keyword to create a reference.</span>
    <span class="k">match</span> <span class="n">value</span> <span class="p">{</span>
        <span class="k">ref</span> <span class="n">r</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"Got a reference to a value: {:?}"</span><span class="p">,</span> <span class="n">r</span><span class="p">),</span>
    <span class="p">}</span>

    <span class="c">// Use `ref mut` similarly.</span>
    <span class="k">match</span> <span class="n">mut_value</span> <span class="p">{</span>
        <span class="k">ref</span> <span class="k">mut</span> <span class="n">m</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="c">// Got a reference. Gotta dereference it before we can</span>
            <span class="c">// add anything to it.</span>
            <span class="o">*</span><span class="n">m</span> <span class="o">+=</span> <span class="mi">10</span><span class="p">;</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"We added 10. `mut_value`: {:?}"</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
        <span class="p">},</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">Foo</span> <span class="p">{</span>
        <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="nb">u32</span><span class="p">,</span> <span class="nb">u32</span><span class="p">),</span>
        <span class="n">y</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c">// Try changing the values in the struct to see what happens</span>
    <span class="k">let</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">Foo</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">y</span><span class="p">:</span> <span class="mi">3</span> <span class="p">};</span>

    <span class="k">match</span> <span class="n">foo</span> <span class="p">{</span>
        <span class="n">Foo</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">y</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"First of x is 1, b = {},  y = {} "</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span>

        <span class="c">// you can destructure structs and rename the variables,</span>
        <span class="c">// the order is not important</span>
        <span class="n">Foo</span> <span class="p">{</span> <span class="n">y</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">i</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"y is 2, i = {:?}"</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span>

        <span class="c">// and you can also ignore some variables:</span>
        <span class="n">Foo</span> <span class="p">{</span> <span class="n">y</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"y = {}, we don't care about x"</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span>
        <span class="c">// this will give an error: pattern does not mention field `x`</span>
        <span class="c">//Foo { y } =&gt; println!("y = {}", y),</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">pair</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">);</span>
    <span class="c">// TODO ^ Try different values for `pair`</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"Tell me about {:?}"</span><span class="p">,</span> <span class="n">pair</span><span class="p">);</span>
    <span class="k">match</span> <span class="n">pair</span> <span class="p">{</span>
        <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"These are twins"</span><span class="p">),</span>
        <span class="c">// The ^ `if condition` part is a guard</span>
        <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"Antimatter, kaboom!"</span><span class="p">),</span>
        <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">_</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"The first one is odd"</span><span class="p">),</span>
        <span class="mi">_</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"No correlation..."</span><span class="p">),</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="c">// A function `age` which returns a `u32`.</span>
<span class="k">fn</span> <span class="nf">age</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="mi">15</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Tell me what type of person you are"</span><span class="p">);</span>

    <span class="k">match</span> <span class="nf">age</span><span class="p">()</span> <span class="p">{</span>
        <span class="mi">0</span>             <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"I haven't celebrated my first birthday yet"</span><span class="p">),</span>
        <span class="c">// Could `match` 1 ..= 12 directly but then what age</span>
        <span class="c">// would the child be? Instead, bind to `n` for the</span>
        <span class="c">// sequence of 1 ..= 12. Now the age can be reported.</span>
        <span class="n">n</span> <span class="o">@</span> <span class="mi">1</span>  <span class="o">..=</span> <span class="mi">12</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"I'm a child of age {:?}"</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span>
        <span class="n">n</span> <span class="o">@</span> <span class="mi">13</span> <span class="o">..=</span> <span class="mi">19</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"I'm a teen of age {:?}"</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span>
        <span class="c">// Nothing bound. Return the result.</span>
        <span class="n">n</span>             <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"I'm an old person of age {:?}"</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div>      </li>
    </ul>
  </li>
  <li>if let: 在判断的同时 进行match</li>
  <li>while let</li>
</ul>

<h4 id="functions">Functions:</h4>

<ul>
  <li>methods: 依附于 对象的函数， 在methods 的block中，能够 通过self使用 对象的 数据</li>
  <li>closures:  |val| {val + x}
    <ul>
      <li>Capturing： 捕获， 其可以 捕获环境中的 变量， 可以是： &amp;T, &amp;mut T , T（by value）</li>
      <li>作为参数： 分为三类： Fn, FnMut, FnOnce， 对应ownership  的 &amp;T, &amp;mut T, T. Fn 可以无限次执行， FnMut 则要求 capture 变量的 mut 引用， FnOnce 则 只能执行一次</li>
      <li>疑问：
        <ol>
          <li>如何 区分  Fn(i64, i64) -&gt; i64 与Fn(&amp;String) -&gt; i64</li>
          <li>FnOnce 是如何确定的， 有些函数，即便将变量 move 到了block中， 然而依然可以调用多次， 这些优势如何判断的？ 根据内部函数调用的 Fn 属性吗？ 比如mem::drop(p) 则 包含其调用的函数 则为 FnOnce?</li>
          <li>如何断定 Cloosure 为 Fn or FnMut ?</li>
        </ol>

<div class="highlight"><pre class="highlight rust"><code>  <span class="k">struct</span> <span class="n">Point</span> <span class="p">{</span>
      <span class="n">x</span><span class="p">:</span> <span class="nb">f64</span><span class="p">,</span>
      <span class="n">y</span><span class="p">:</span> <span class="nb">f64</span><span class="p">,</span>
  <span class="p">}</span>

  <span class="c">// Implementation block, all `Point` methods go in here</span>
  <span class="k">impl</span> <span class="n">Point</span> <span class="p">{</span>
      <span class="c">// This is a static method</span>
      <span class="c">// Static methods don't need to be called by an instance</span>
      <span class="c">// These methods are generally used as constructors</span>
      <span class="k">fn</span> <span class="nf">origin</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Point</span> <span class="p">{</span>
          <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">0.0</span> <span class="p">}</span>
      <span class="p">}</span>

      <span class="c">// Another static method, taking two arguments:</span>
      <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">f64</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">f64</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Point</span> <span class="p">{</span>
          <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span> <span class="p">}</span>
      <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div></li>
    </ul>
  </li>
</ul>

<h4 id="modules">Modules:</h4>
<ul>
  <li>mod visibility: mod 的可见性， mod 默认只能在本mod 可见， 需要使用 pub 来对外可见， 定义其中的fn， struct 使用同样的规则， 因为mod 可以nest， 所以 存在pub(self) (等同于private) pub(super) 即让super mod 可见,  而pub(crate)则让crate 可见</li>
  <li>struct visibility: struct 中包含fn 以及 field，默认都为 对 所在 定义的mod可见， pub 则开放为对外部的 mod可见</li>
  <li>mod vs struct: struct 的控制比较弱， mod的控制则相对复杂， struct 可能并不需要如此复杂的规则吧</li>
  <li>关键字 use： 我们可以使用 use mod::struct as another_struct 来 减少路径的拼写， 使用as 更可以 启用别名</li>
  <li>mod 的 使用类似于 Unix下的 目录 安排， super 代表 .. self 则代表 本mod</li>
</ul>

<h4 id="attributes-可以用来作什么-1-条件编译-2设定crate-属性-3关闭-warning-4启用编译器特性maros-etc-5-link-to-a-foreign-library-6-设定unit-test">Attributes: 可以用来作什么？ 1） 条件编译， 2）设定crate 属性， 3）关闭 warning 4)启用编译器特性(maros etc) 5） link to a foreign library 6) 设定unit test</h4>
<ul>
  <li>形式： 当应用到 整个crate： #![crate_attribute], 应用到module 或者 item ： #[item_attribute]</li>
  <li>还可以接受参数： 1) #[attribute = “value”] 2) #[attribute(key = “value”)] 3) #[attribute(value)]</li>
  <li>示例：
    <ul>
      <li>#[allow(dead_code)]： 关闭rust 关于没有调用函数的提示</li>
      <li>#![crate_name = “rary”]</li>
      <li>cfg(Configuration):  1） #[cfg(…)] 条件编译  2） cfg!(…) 在运行阶段的条件判断， 返回bool值</li>
    </ul>
  </li>
</ul>

<div class="highlight"><pre class="highlight rust"><code>   <span class="c">// This function only gets compiled if the target OS is linux</span>
   <span class="nd">#[cfg(target_os</span> <span class="nd">=</span> <span class="s">"linux"</span><span class="nd">)]</span>
   <span class="k">fn</span> <span class="nf">are_you_on_linux</span><span class="p">()</span> <span class="p">{</span>
       <span class="nd">println!</span><span class="p">(</span><span class="s">"You are running linux!"</span><span class="p">);</span>
   <span class="p">}</span>

   <span class="c">// And this function only gets compiled if the target OS is *not* linux</span>
   <span class="nd">#[cfg(not(target_os</span> <span class="nd">=</span> <span class="s">"linux"</span><span class="nd">))]</span>
   <span class="k">fn</span> <span class="nf">are_you_on_linux</span><span class="p">()</span> <span class="p">{</span>
       <span class="nd">println!</span><span class="p">(</span><span class="s">"You are *not* running linux!"</span><span class="p">);</span>
   <span class="p">}</span>

   <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
       <span class="nf">are_you_on_linux</span><span class="p">();</span>

       <span class="nd">println!</span><span class="p">(</span><span class="s">"Are you sure?"</span><span class="p">);</span>
       <span class="k">if</span> <span class="nd">cfg!</span><span class="p">(</span><span class="n">target_os</span> <span class="o">=</span> <span class="s">"linux"</span><span class="p">)</span> <span class="p">{</span>
           <span class="nd">println!</span><span class="p">(</span><span class="s">"Yes. It's definitely linux!"</span><span class="p">);</span>
       <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
           <span class="nd">println!</span><span class="p">(</span><span class="s">"Yes. It's definitely *not* linux!"</span><span class="p">);</span>
       <span class="p">}</span>
   <span class="p">}</span>
</code></pre></div>
<h3 id="rust-工具-trait">Rust 工具 Trait：</h3>
<h4 id="总览">总览：</h4>

<table>
  <thead>
    <tr>
      <th>Trait</th>
      <th>Desc</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Drop</td>
      <td>析构函数，当value 被drop时候，自动调用</td>
    </tr>
    <tr>
      <td>Sized</td>
      <td>Marker Trait， 标记 在编译期间能够确定 size的类型（与之对应的 为 动态 sized 比如 slice）</td>
    </tr>
    <tr>
      <td>Clone</td>
      <td>支持clone方法的类型</td>
    </tr>
    <tr>
      <td>Copy</td>
      <td>Marker Trait， 标记 支持可以 通过简单的 memory byte-for-bytes 复制 来支持 clone的类型</td>
    </tr>
    <tr>
      <td>Deref &amp; DerefMut</td>
      <td>为 smart 指针 支持的类型</td>
    </tr>
    <tr>
      <td>Default</td>
      <td>存在default 数值的类型</td>
    </tr>
    <tr>
      <td>AsRef &amp; AsMut</td>
      <td>Conversion traits for borrowing one type of reference from another.</td>
    </tr>
    <tr>
      <td>Borrow and BorrowMut</td>
      <td>Conversion traits, like AsRef/AsMut, but additionally guaranteeing consistent hashing, ordering, and equality.</td>
    </tr>
    <tr>
      <td>From and Into</td>
      <td>Conversion traits for transforming one type of value into another.</td>
    </tr>
    <tr>
      <td>ToOwned</td>
      <td>Conversion trait for converting a reference to an owned value.</td>
    </tr>
  </tbody>
</table>

<h4 id="drop">Drop:</h4>
<ol>
  <li>
    <p>定义</p>

<div class="highlight"><pre class="highlight rust"><code> <span class="k">trait</span> <span class="n">Drop</span> <span class="p">{</span>
   <span class="k">fn</span> <span class="k">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">);</span>
 <span class="p">}</span>


 <span class="c">//一个简单的 实现 示例：</span>

 <span class="k">struct</span> <span class="n">Appellation</span> <span class="p">{</span>
     <span class="n">name</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
     <span class="n">nicknames</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span>
 <span class="p">}</span>

 <span class="k">impl</span> <span class="n">Drop</span> <span class="k">for</span> <span class="n">Appellation</span> <span class="p">{</span>
     <span class="k">fn</span> <span class="k">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
         <span class="nd">print!</span><span class="p">(</span><span class="s">"Dropping {}"</span><span class="p">,</span> <span class="k">self</span><span class="py">.name</span><span class="p">);</span>
         <span class="k">if</span> <span class="o">!</span><span class="k">self</span><span class="py">.nicknames</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
             <span class="nd">print!</span><span class="p">(</span><span class="s">" (AKA {})"</span><span class="p">,</span> <span class="k">self</span><span class="py">.nicknames</span><span class="nf">.join</span><span class="p">(</span><span class="s">", "</span><span class="p">));</span>
         <span class="p">}</span>
         <span class="nd">println!</span><span class="p">(</span><span class="s">""</span><span class="p">);</span>
     <span class="p">}</span>
 <span class="p">}</span>

</code></pre></div>  </li>
  <li>Drop trait中 drop函数调用的时机：
    <ul>
      <li>value drop时候调用</li>
      <li>在drop 内部的field之前 进行调用，所以 在Appellation 的drop实现中  内部的field 依然可用。</li>
      <li>在 drop调用之后 ，依次调用内部的field的 drop 函数，来释放field内存占用。</li>
    </ul>
  </li>
  <li>
    <p>何时需要： Drop 一般很少需要自己进行实现。 只有当 自己定义的类型 <strong>拥有rust 并不知道如何清理的资源时</strong>，才需要实现Drop Trait。比如下面：</p>

<div class="highlight"><pre class="highlight rust"><code>
<span class="k">struct</span> <span class="n">FileDesc</span> <span class="p">{</span>
    <span class="n">fd</span><span class="p">:</span> <span class="nb">c_int</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Drop</span> <span class="k">for</span> <span class="n">FileDesc</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="k">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="mi">_</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">libc</span><span class="p">::</span><span class="nf">close</span><span class="p">(</span><span class="k">self</span><span class="py">.fd</span><span class="p">)</span> <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>  </li>
  <li>Drop组成的结构将是 一个 树状的 调用链。链中 链接关系为 field， 每个节点不是自己实现了 Drop，就是链接节点实现了Drop</li>
  <li>Drop 与 Copy Trait 存在 互斥关系，即  实现了Drop 则不能实现  Copy。</li>
  <li>标准库中存在一个 drop函数， fn drop<T>(_x: T) {} 函数 拿到 T的ownership，但并不做任何事情。</T></li>
</ol>

<h4 id="sized-该类型的数值-在内存中-总是-固定的大小即-在编译期间-即能够确定空间大小几乎rust中所有的type都是-sized包括-enum-类型即便vec-在heap中存在一个变长的内存但是vec-本身-是一个指向-内存地址的指针包含-address-capacity-length-所以-vec是一个-size-type">Sized： 该类型的数值 在内存中 总是 固定的大小，即： 在编译期间 即能够确定空间大小。几乎rust中所有的type都是 Sized，包括 enum 类型，即便Vec<T> 在heap中存在一个变长的内存，但是Vec 本身 是一个指向 内存地址的指针，包含 address， capacity， length 所以 Vec<T>是一个 Size type。</T></T></h4>

<ul>
  <li>rust中少有的 unsized类型， str, [T],  reference of a trait object.
    <ul>
      <li>str类型 实例 “name” “big” 在 内存中的大小并不相同。</li>
      <li>trait Object 比如 std::io::Write 因为实现了 Trait Write 的类型不同，其对应的 size 也不相同。</li>
    </ul>
  </li>
  <li>Rust 无法 存储 unsized数值的变量 以及 作为参数传递，只能 通过 Sized  pointer来进行包装， 比如  &amp;str， Box<Write></Write></li>
  <li>
    <p>slice‘s pointer 与 Trait pointer 同样是一个 fat pointer</p>
  </li>
  <li>Sized Trait是一个marker trait， 即 rust 编译器自动实现 Sized 类型， 我们不能够自己为类型实现 Sized， 即 rust 使用 该trait实现一种 类型标记作用</li>
  <li>在函数参数中可以 添加 T: Sized 来限制 参数</li>
  <li>
    <p>因为 unsized类型 非常少，而限制非常多，所以 默认情况下 rust 自动为我们的 T placeholder 添加 Sized限制，如果我们不需要 该约束 则 使用过 T： ?Sized 来取消约束，即： 类型 不需要是 Sized。 比如 Box<str></str></p>
  </li>
  <li>
    <p>示例： Box 与 RcBox 并不要求 模版参数 T 为Sized</p>

<div class="highlight"><pre class="highlight rust"><code> <span class="k">pub</span> <span class="k">struct</span> <span class="nb">Box</span><span class="o">&lt;</span>
     <span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="n">Sized</span><span class="p">,</span>
     <span class="nd">#[unstable(feature</span> <span class="nd">=</span> <span class="s">"allocator_api"</span><span class="nd">,</span> <span class="nd">issue</span> <span class="nd">=</span> <span class="s">"32838"</span><span class="nd">)]</span> <span class="n">A</span><span class="p">:</span> <span class="n">Allocator</span> <span class="o">=</span> <span class="n">Global</span><span class="p">,</span>
 <span class="o">&gt;</span><span class="p">(</span><span class="n">Unique</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">A</span><span class="p">);</span>



 <span class="k">struct</span> <span class="n">RcBox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="n">Sized</span><span class="o">&gt;</span> <span class="p">{</span>
   <span class="n">ref_count</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
   <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
 <span class="p">}</span>
</code></pre></div>  </li>
</ul>

<h4 id="clone-复制一个--独立-的-self-并返回它-self-不应该是unsized-clone一般是-比较耗费资源的操作所以rust并没有为每个-类型实现它而是-由我们自己来实现但是rc--与-arc是一个例外其clone只是简单的增加计数而已">Clone： 复制一个  独立 的 self 并返回它， Self 不应该是unsized， clone一般是 比较耗费资源的操作，所以rust并没有为每个 类型实现它，而是 由我们自己来实现，但是Rc<T>  与 Arc<T>是一个例外，其clone只是简单的增加计数而已。</T></T></h4>
<ul>
  <li>定义：
<div class="highlight"><pre class="highlight rust"><code>  <span class="k">trait</span> <span class="n">Clone</span><span class="p">:</span> <span class="n">Sized</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Self</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">clone_from</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Self</span><span class="p">)</span> <span class="p">{</span>
      <span class="o">*</span><span class="k">self</span> <span class="o">=</span> <span class="n">source</span><span class="nf">.clone</span><span class="p">()</span>
    <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div></li>
  <li>
    <p>Clone trait提供的 clone_from(&amp;mut self, source: &amp;Self) 函数， 该函数 通过 修改self， 复制source中的内容，来实现clone。应该总是在能够使用clone_from的时候 使用它，如下情况，将减少heap内存的分配和释放。</p>

<div class="highlight"><pre class="highlight rust"><code>  <span class="k">let</span> <span class="k">mut</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"source"</span><span class="p">);</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">target</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"target"</span><span class="p">);</span>
  <span class="c">// 第一种写法, 将造成 target 的 复制操作， 然后是 赋值操作， 将导致 s原先 heap的释放 与target的 heap复制</span>
  <span class="n">s</span> <span class="o">=</span> <span class="n">target</span><span class="nf">.clone</span><span class="p">();</span>

  <span class="c">// 第二种写法， 该种写法， 在符合条件下，将不会在 heap重新分配内存， 也不需要s释放原先的heap内存，在s原地修改</span>
  <span class="n">s</span><span class="nf">.clone_from</span><span class="p">(</span><span class="o">&amp;</span><span class="n">target</span><span class="p">)</span>
</code></pre></div>  </li>
  <li>derive: rust为我们提供了一种简单的 clone 各个field 的方式。添加 #[derive(Clone)]  即可。</li>
  <li>一些没有实现了Clone trait的type， std::sync::Mutex, std::fs::File</li>
</ul>

<h4 id="copy-在表达式-a--b中-将-b赋值给a时-不是转移b的ownership给a而是-直接-copy-一个-b出来-赋值给a该种情况即是-实现了-copy-trait-比如基本的简单类型-i32-i64">Copy: 在表达式 A = B中， 将 B赋值给A时 不是转移B的ownership给A，而是 直接 copy 一个 B出来 赋值给A，该种情况即是 实现了 Copy Trait， 比如基本的简单类型。 i32， i64</h4>
<ul>
  <li>定义 以及 实现：
<div class="highlight"><pre class="highlight rust"><code>  <span class="k">trait</span> <span class="nb">Copy</span><span class="p">:</span> <span class="n">Clone</span> <span class="p">{</span> <span class="p">}</span>
  <span class="k">impl</span> <span class="nb">Copy</span> <span class="k">for</span> <span class="n">MyType</span> <span class="p">{</span> <span class="p">}</span>
</code></pre></div></li>
  <li>
    <p>Copy 同样是一个 Marker trait， 但 rust 允许我们为自己的类型实现 Copy， 因为 在Copy 过程中，我们需要Clone B， 所以 Clone Trait 是该 trait 的super trait。 同样rust 为我们实现了一个默认的实现 #[derive(Copy)] 通常情况下  Copy 存在的时候 Clone也需要存在 即 常见的形式为 #[derive(Copy, Clone)]</p>
  </li>
  <li>注意问题：
    <ul>
      <li>
        <p>与 Drop 的关系： 任何实现 Drop 特性的类型都不能是 Copy。 Rust 假定如果一个类型需要特殊的清理代码，它也必须需要特殊的复制代码，因此不能被复制。</p>
      </li>
      <li>
        <p>该Trait的实现 将 方便代码的编写，因为 clone() 隐式的实现， 但是需要注意应该谨慎的为 类型实现 copy， 导致大量clone 导致的 资源损耗。</p>
      </li>
    </ul>
  </li>
</ul>

<h4 id="deref-and-derefmut-rust-将自动尝试使用-两个trait提供的方法-将-类型转换到-需要的类型即-如果-deref-能够防止类型的不匹配那么rust将自动帮我们-插入代码">Deref and DerefMut: rust 将自动尝试使用 两个trait提供的方法 将 类型转换到 需要的类型。即： 如果 deref 能够防止类型的不匹配，那么rust将自动帮我们 插入代码。</h4>
<ul>
  <li>定义：
<div class="highlight"><pre class="highlight rust"><code>
<span class="k">trait</span> <span class="n">Deref</span> <span class="p">{</span>
<span class="k">type</span> <span class="n">Target</span><span class="p">:</span> <span class="o">?</span><span class="n">Sized</span><span class="p">;</span>
  <span class="k">fn</span> <span class="nf">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nn">Self</span><span class="p">::</span><span class="n">Target</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">trait</span> <span class="n">DerefMut</span><span class="p">:</span> <span class="n">Deref</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">deref_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">Self</span><span class="p">::</span><span class="n">Target</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></li>
  <li>std库中实例：
    <ul>
      <li>
        <p>r: Rc<String> 我们可以 使用 r.find（‘？’） 而不是 (*r).find('?') 因为 Rc<T> 实现了 Deref&lt;Target=T&gt;, Rc<String> 可以转化为 String</String></T></String></p>
      </li>
      <li>r: String, 我们可以直接使用 str 的split_at 方法， 因为 String 实现了 Deref&lt;Target=str&gt;</li>
      <li>r: Vec<T>, 同样可以使用 [T]的方法，因为 Vec<T> 实现了 Deref&lt;Target=[T]&gt;</T></T></li>
    </ul>
  </li>
  <li>注意情况：
    <ul>
      <li>
        <p>rust 可能会插入 多个转换代码 如果需要的话，比如 &amp;Rc<String> deref 到 &amp;String, deref 到 &amp;str， &amp;str中拥有 split_at 方法。</String></p>
      </li>
      <li>
        <p>rust为并不会为  模版方法 尝试 进行 类型的自动deref 转换。</p>
      </li>
    </ul>
  </li>
  <li>使用场景：
    <ul>
      <li><strong>该Trait 是为了实现smart pointer 而设计的</strong>。比如 Box， Rc， Arc ， 一些 能够被视为 拥有 reference的类型（比如 String 与str 以及 Vec&lt;T&gt; 与 [T] ） 不应该为了 使用Target 的方法 而为类型实现 Deref&lt;Target&gt;</li>
    </ul>
  </li>
</ul>

<h4 id="default为-有明显的理由-提供默认值的-type实现">Default：为 有明显的理由 提供默认值的 type实现。</h4>
<ul>
  <li>定义：
<div class="highlight"><pre class="highlight rust"><code><span class="k">trait</span> <span class="n">Default</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">default</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Self</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></li>
  <li>std库中的实例：
    <ul>
      <li>String 也提供了 Default 的实现。</li>
      <li>
        <p>所有的rust collection 类型， Vec HashMap， BinaryHeap … 都提供了 Default 的实现，default 函数提供空的 collection。 这对于 提供一个方法，有用户来指定 返回的collection 类型有很好的帮助，比如</p>

<div class="highlight"><pre class="highlight rust"><code> <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashSet</span><span class="p">;</span>
 <span class="k">let</span> <span class="n">squares</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">64</span><span class="p">];</span>
 <span class="k">let</span> <span class="p">(</span><span class="n">powers_of_two</span><span class="p">,</span> <span class="n">impure</span><span class="p">):</span> <span class="p">(</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=</span> <span class="n">squares</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.partition</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">n</span><span class="p">|</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
 <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">powers_of_two</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">3</span><span class="p">);</span>
 <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">impure</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">4</span><span class="p">);</span>

</code></pre></div>      </li>
    </ul>
  </li>
  <li>使用场景： 1) 上述 std collection， 2） 为一个拥有大量field的 struct 提供默认数值。</li>
  <li><strong>derive</strong>:  如果一个struct中各个字段实现了 Default， 则我们使用  #[derive(Default)] 来提供 默认的Default 实现。</li>
</ul>

<h4 id="asref-and-asmut--为类型转换提供了除了-deref-之外的另外一种方法-不同于-deref-能够提供-rust-内部的代码deref调用的插入-asref-仅仅是-提供了-as_ref的-trait">AsRef and AsMut:  为类型转换提供了除了 Deref 之外的另外一种方法。 不同于 Deref 能够提供 rust 内部的代码deref()调用的插入， AsRef 仅仅是 提供了 as_ref的 trait</h4>
<ul>
  <li>定义：
<div class="highlight"><pre class="highlight rust"><code>  <span class="k">trait</span> <span class="n">AsRef</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="n">Sized</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">trait</span> <span class="n">AsMut</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="n">Sized</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">as_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">T</span><span class="p">;</span>
  <span class="p">}</span>

</code></pre></div></li>
  <li>
    <p>std库中的实例：</p>

<div class="highlight"><pre class="highlight rust"><code>  <span class="k">fn</span> <span class="n">open</span><span class="o">&lt;</span><span class="n">P</span><span class="p">:</span> <span class="n">AsRef</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="n">P</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">File</span><span class="o">&gt;</span>

  <span class="c">//因为 String， 以及 str  实现了 AsRef&lt;Path&gt; 所以， 我们可以进行如下的 写法：</span>

  <span class="k">let</span> <span class="n">dot_emacs</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fs</span><span class="p">::</span><span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="s">"/home/jimb/.emacs"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

  <span class="c">// 这里面需要注意，因为 实现了 AsRef&lt;Path&gt; 的是 str， 并不是 &amp;str， 那么为什么上面的代码能够通过编译呢？ 这里面 rust 并不会进行类型转换，因为 rust并不提供 对于 变量约束 模版变量参数 的类型转换。</span>
  <span class="c">// 因为 存在 如下 blanket implement: 即： any type T impl AsRef&lt;U&gt; then &amp;T impl AsRef&lt;U&gt; also.</span>

  <span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="o">&gt;</span> <span class="n">AsRef</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span>
  <span class="k">where</span>
      <span class="n">T</span><span class="p">:</span> <span class="n">AsRef</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">,</span>
      <span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="n">Sized</span><span class="p">,</span>
      <span class="n">U</span><span class="p">:</span> <span class="o">?</span><span class="n">Sized</span><span class="p">,</span>
  <span class="p">{</span>
      <span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">U</span> <span class="p">{</span>
          <span class="p">(</span><span class="o">*</span><span class="k">self</span><span class="p">)</span><span class="nf">.as_ref</span><span class="p">()</span>
      <span class="p">}</span>
  <span class="p">}</span>

</code></pre></div>  </li>
  <li>使用场景： 该Trait 显得简单，但是依然非常重要， 为 减少更具体类型 提供了帮助， 在 定义更具体的AsFoo trait之前，应该考虑是否可以 让现有类型实现 AsRef&lt;Foo&gt;</li>
</ul>

<h4 id="borrow-and-borrowmut-与-asref-相似如果type-impl-borrow-则-能够从type-borrow-出一个-t-区别在于-borrow-添加了一些限制要求-type-与-t-能够hash-的数值一样-才行rust-并没有强制要求-而是-以文档方式要求-这-为-hash-table-与-tree-的key-比较-提供了方便">Borrow and BorrowMut: 与 AsRef 相似，如果type impl Borrow<T> 则 能够从type borrow() 出一个 &amp;T, 区别在于 Borrow 添加了一些限制，要求 type 与 &amp;T 能够hash 的数值一样 才行。（rust 并没有强制要求 ，而是 以文档方式要求） 这 为 Hash table 与 tree 的key 比较 提供了方便。</T></h4>

<ul>
  <li>定义：</li>
</ul>

<div class="highlight"><pre class="highlight rust"><code><span class="k">trait</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Borrowed</span><span class="p">:</span> <span class="o">?</span><span class="n">Sized</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">borrow</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">Borrowed</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<ul>
  <li>
    <p>std 库中的实例： HashMap</p>

<div class="highlight"><pre class="highlight rust"><code>   <span class="c">// 考虑我们有一个 HashMap&lt;String, i32&gt; 的collection，</span>
   <span class="c">// 我们需要获取 'name' 对应的数值，</span>
   <span class="c">// 考虑Hashmap的get 实现</span>

   <span class="k">impl</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="nb">Eq</span> <span class="o">+</span> <span class="n">Hash</span> <span class="p">{</span>
      <span class="k">fn</span> <span class="nf">get</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">K</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
   <span class="p">}</span>
   <span class="c">// 因为 get方法签名， key： K， 这要求我们 传递 一个String 类型的数值，来寻找 key对应的 value</span>
   <span class="c">// 这里的问题在于 我们每次需要查询 都需要构建一个 String（进行内存分配）将是十分浪费的方法。</span>

   <span class="k">impl</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="nb">Eq</span> <span class="o">+</span> <span class="n">Hash</span> <span class="p">{</span>
      <span class="k">fn</span> <span class="nf">get</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">K</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
   <span class="p">}</span>

   <span class="c">// 对比上面要好一点，方法要求我们传递 &amp;String类型，但是 我们需要查找一个 constant string对应的数值时候，</span>
   <span class="c">//我们需要这样写, 该种写法 同样造成 name 转换为string，即分配内存空间。</span>

   <span class="n">hashtable</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="s">"name"</span><span class="nf">.to_string</span><span class="p">());</span>


   <span class="k">impl</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="nb">Eq</span> <span class="o">+</span> <span class="n">Hash</span> <span class="p">{</span>
     <span class="k">fn</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">Q</span><span class="p">:</span> <span class="o">?</span><span class="n">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">V</span><span class="o">&gt;</span>
        <span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
              <span class="n">Q</span><span class="p">:</span><span class="nb">Eq</span><span class="o">+</span><span class="n">Hash</span>
        <span class="p">{</span><span class="o">...</span><span class="p">}</span>

   <span class="p">}</span>

   <span class="c">// 最终的解法，我们要求 参数 Q 是一个能够 从 HashMap K中 borrow出来的 类型，并且 Q impl  Eq + Hash， 所以我们 将从HashMap 中的K 调用borrow 方法，来与 key: &amp;Q 进行比较，来寻找到 对应的value</span>
   <span class="c">// 因为 String impl  Borrow&lt;str&gt; Borrow&lt;String&gt;, 所以我们 可以 传递 &amp;str, &amp;String 给 get 方法</span>
</code></pre></div>  </li>
  <li>
    <p>使用场景：</p>
    <ul>
      <li>std 库中所有的collection 使用 Borrow 来进行 进行 lookup</li>
      <li>std 库提供了 blanket implementation ， impl T for Borrow<T> ， impl &amp;mut T for Borrow<T>  所以 在HashMap&lt;K, V&gt; 中，我们可以 .get(&amp;K) 来进行查找。</T></T></li>
    </ul>
  </li>
</ul>

<h4 id="from-and-into--消耗-type-a-的ownership-返回-type-b-对比-asref-borrow-trait-他们并不使用-调用者-的ownership只是返回一个-reference">From and Into:  消耗 type A 的ownership 返回 type B (对比 AsRef Borrow trait 他们并不使用 调用者 的ownership，只是返回一个 reference)</h4>

<ul>
  <li>
    <p>定义：</p>

<div class="highlight"><pre class="highlight rust"><code>   <span class="k">trait</span> <span class="n">Into</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">Sized</span> <span class="p">{</span>
     <span class="k">fn</span> <span class="nf">into</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">T</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="k">trait</span> <span class="n">From</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">Sized</span> <span class="p">{</span>
     <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Self</span><span class="p">;</span>
   <span class="p">}</span>

</code></pre></div>  </li>
  <li>std 自动实现了 A impl From &lt;B&gt; 则  B impl Into&lt;A&gt;</li>
  <li>使用场景： 两个Trait 虽然扮演了一个角色（类型转换）， 但用法不同，
    <ul>
      <li>Into： 一般用作 function 参数，来将  function 参数变得更加灵活。</li>
      <li>
        <p>From： 一般用作通用的构造函数， 从多种 类型中产生一个 type。<br />
如下是示例：</p>

<div class="highlight"><pre class="highlight rust"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">net</span><span class="p">::</span><span class="n">Ipv4Addr</span><span class="p">;</span>
<span class="k">fn</span> <span class="n">ping</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="n">address</span><span class="p">:</span> <span class="n">A</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="n">Result</span><span class="o">&lt;</span><span class="nb">bool</span><span class="o">&gt;</span>
 <span class="k">where</span> <span class="n">A</span><span class="p">:</span> <span class="n">Into</span><span class="o">&lt;</span><span class="n">Ipv4Addr</span><span class="o">&gt;</span>
 <span class="p">{</span>
   <span class="k">let</span> <span class="n">ipv4_address</span> <span class="o">=</span> <span class="n">address</span><span class="nf">.into</span><span class="p">();</span> <span class="o">...</span>
 <span class="p">}</span>


<span class="k">let</span> <span class="n">addr1</span> <span class="o">=</span> <span class="nn">Ipv4Addr</span><span class="p">::</span><span class="nf">from</span><span class="p">([</span><span class="mi">66</span><span class="p">,</span> <span class="mi">146</span><span class="p">,</span> <span class="mi">219</span><span class="p">,</span> <span class="mi">98</span><span class="p">]);</span>
<span class="k">let</span> <span class="n">addr2</span> <span class="o">=</span> <span class="nn">Ipv4Addr</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="mi">0xd076eb94_u32</span><span class="p">);</span>
</code></pre></div>      </li>
    </ul>
  </li>
  <li>限制； 1) 与 AsRef 的转换相比 From Into 可能会比较“重”， 即AsRef 的转换是相对廉价的。From Into的转换可能涉及到 内存分配，copy等操作 ， 比如 String impl From&lt;&amp;str&gt; 需要 copy str 的内容到 string中。 2） From &amp; Into 转换 不允许失败</li>
</ul>

<h4 id="toowned-存在目的是-为了解决-clone-trait-的限制即-a-impl-clone-则-aclone-将返回-一个a-但是-对于-str-clone-返回-str-则不能接受因为str-为unsized-类型-所以-创建了-toowned-trait">ToOwned： 存在目的是： 为了解决 clone trait 的限制，即 A impl Clone， 则 &amp;A.clone() 将返回 一个A， 但是 对于 &amp;str .clone() 返回 str 则不能接受（因为str 为unsized 类型）， 所以 创建了 ToOwned trait：</h4>

<ul>
  <li>
    <p>定义： 即 任何实现了 A Borrow &lt;B&gt; 的，则能够 B.to_owned() A</p>

<div class="highlight"><pre class="highlight rust"><code>   <span class="k">trait</span> <span class="n">ToOwned</span> <span class="p">{</span>
      <span class="k">type</span> <span class="nb">Owned</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="p">;</span>
      <span class="k">fn</span> <span class="nf">to_owned</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">Self</span><span class="p">::</span><span class="nb">Owned</span><span class="p">;</span>
   <span class="p">}</span>
</code></pre></div>  </li>
  <li>
    <p>std库中的实例： str impl ToOwned&lt;Owned=String&gt; 则 str.to_owned() String</p>
  </li>
</ul>

<h4 id="cow-borrow-and-toowned-at-work">Cow: Borrow and ToOwned at Work</h4>

<ul>
  <li>
    <p>定义： Cow 是 clone on write的缩写。</p>

<div class="highlight"><pre class="highlight rust"><code>   <span class="k">enum</span> <span class="n">Cow</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">B</span><span class="p">:</span> <span class="o">?</span><span class="n">Sized</span> <span class="o">+</span> <span class="nv">'a</span><span class="o">&gt;</span>
     <span class="k">where</span> <span class="n">B</span><span class="p">:</span> <span class="n">ToOwned</span>
   <span class="p">{</span>
     <span class="nf">Borrowed</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">'a</span> <span class="n">B</span><span class="p">),</span>
     <span class="nf">Owned</span><span class="p">(</span><span class="o">&lt;</span><span class="n">B</span> <span class="k">as</span> <span class="n">ToOwned</span><span class="o">&gt;</span><span class="p">::</span><span class="nb">Owned</span><span class="p">),</span> <span class="c">//这里的语法 有些奇怪 </span>
   <span class="p">}</span>

   <span class="c">// cow存在两个 enum类型，Borrowed为 一个reference， Owned 则保存 一个 实际数值 ，该数值 应该是从 &amp;'B 中 to_owned出来的，</span>
   <span class="c">//下面为一个示例：</span>

   <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">borrow</span><span class="p">::</span><span class="n">Cow</span><span class="p">;</span>
   <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">path</span><span class="p">::</span><span class="n">PathBuf</span><span class="p">;</span>
   <span class="k">fn</span> <span class="nf">describe</span><span class="p">(</span><span class="n">error</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Error</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Cow</span><span class="o">&lt;</span><span class="nv">'static</span><span class="p">,</span> <span class="nb">str</span><span class="o">&gt;</span> <span class="p">{</span>
       <span class="k">match</span> <span class="o">*</span><span class="n">error</span> <span class="p">{</span>
           <span class="nn">Error</span><span class="p">::</span><span class="n">OutOfMemory</span> <span class="k">=&gt;</span> <span class="s">"out of memory"</span><span class="nf">.into</span><span class="p">(),</span>
           <span class="nn">Error</span><span class="p">::</span><span class="n">StackOverflow</span> <span class="k">=&gt;</span> <span class="s">"stack overflow"</span><span class="nf">.into</span><span class="p">(),</span>
           <span class="nn">Error</span><span class="p">::</span><span class="n">MachineOnFire</span> <span class="k">=&gt;</span> <span class="s">"machine on fire"</span><span class="nf">.into</span><span class="p">(),</span>
           <span class="nn">Error</span><span class="p">::</span><span class="n">Unfathomable</span> <span class="k">=&gt;</span> <span class="s">"machine bewildered"</span><span class="nf">.into</span><span class="p">(),</span>
           <span class="nn">Error</span><span class="p">::</span><span class="nf">FileNotFound</span><span class="p">(</span><span class="k">ref</span> <span class="n">path</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"file not found: {}"</span><span class="p">,</span> <span class="n">path</span><span class="nf">.display</span><span class="p">())</span><span class="nf">.into</span><span class="p">(),</span>
       <span class="p">}</span>
   <span class="p">}</span>

   <span class="nd">println!</span><span class="p">(</span><span class="s">"Disaster has struck: {}"</span><span class="p">,</span> <span class="nf">describe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">error</span><span class="p">));</span>

   <span class="k">let</span> <span class="k">mut</span> <span class="k">log</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
   <span class="k">log</span><span class="nf">.push</span><span class="p">(</span><span class="nf">describe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">error</span><span class="p">)</span><span class="nf">.into_owned</span><span class="p">());</span>

   <span class="c">// Cow impl  Into 所以 在 describe match  arm 中可以使用 str.into() 方法返回 Cow</span>
   <span class="c">// Cow的存在 可以让 println 中 继续 保持 str， 而在  Vec&lt;String&gt;.push中 则 into_owned()返回 String，即需要的时候才会分配内存</span>

</code></pre></div>  </li>
</ul>

<div class="social"></div></article></main><footer><div class="footer-wrapper"><div class="author"><div class="image-wrapper"><a href="/author/"><img alt="author" src="../../../../images/profile-1e71686a.png" /></a></div></div><div class="image-content"><img src="../../../../images/wechat_nasa-0d87c0dd.png" /></div><div class="copyright"><i class="fa fa-copyright"></i> 2021 <a href="/">日常学习</a> - geniousbar</div></div><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?b43ef53b285c49e1af0bd7080994c825";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script></footer></body></html>