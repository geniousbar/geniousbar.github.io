<!DOCTYPE html><html><head><meta charset="utf-8" /><meta content="IE=edge;chrome=1" http-equiv="X-UA-Compatible" /><meta content="initial-scale=1.0, user-scalable=no" name="viewport" /><title>Phoenix framework 1.3 context | 日常学习</title><meta description="Design  思考设计  context 是专门用来 组织、暴露 相关的功能的module。比如我们每次调用Elixir标准库 Logger.info, 其实是在接触不同的context， 在内部， Elixir Logger是由 诸如 Logger.Config. Logger.Backends 的module组成的， 但是我们从来不会直接跟这些module交互， 我们使用Logger context， 因为他组织并且暴露接口。   Phoenix 组织目录类似于其他的Elixir Project..." /><link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/feed.xml" /><link href="../../../../stylesheets/style-32b4222b.css" rel="stylesheet" type="text/css" /><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" /><link href="../../../../images/favicon-6c3f3d04.png" rel="icon" type="image/png" /><script src="../../../../javascripts/all-b3988275.js"></script></head><body><header><div class="top-menu"><div class="top-menu-wrapper"><div class="top-menu-list"><ul><li><a href="/">Home</a></li><li><a href="/archives/">Archives</a></li><li><a href="/tags/">Tags</a></li><li><a href="/by-year/">By Year</a></li><li id="wechat"><a href="#" onclick="toggleShowWechat()">Wechat</a></li></ul></div></div></div><div id="header-wechat-img"><img src="../../../../images/wechat_nasa-0d87c0dd.png" /></div><h1 class="logo"><a href="/" title="日常学习"><span class="logo-text">日常学习</span></a></h1></header><main><article><h1 class="article-title">Phoenix framework 1.3 context</h1><div class="posted-date-wrapper"><i class="fa fa-clock-o"></i><span class="posted-date">August 07, 2017</span></div><div class="tag-labels"><a href="/tags/phoenix/"><small class="tag-label">phoenix</small></a><a href="/tags/elixir/"><small class="tag-label">elixir</small></a><a href="/tags/desigin/"><small class="tag-label">desigin</small></a></div><hr class="article-header-separator" /><h2 id="design">Design</h2>

<h3 id="思考设计">思考设计</h3>

<p>context 是专门用来 组织、暴露 相关的功能的module。比如我们每次调用Elixir标准库 Logger.info, 其实是在接触不同的context， 在内部， Elixir Logger是由 诸如 Logger.Config. Logger.Backends 的module组成的， 但是我们从来不会直接跟这些module交互， 我们使用Logger context， 因为他组织并且暴露接口。<br />
  Phoenix 组织目录类似于其他的Elixir Project， 我们拆分代码到context中， 一个context 将会组织相关的功能代码， 比如post，comment， 经常封装诸如 验证、数据存取的功能。应用context, 我们拆分系统到 容易管理、互相独立的 组成部分中。</p>

<h3 id="建立account-context">建立Account context</h3>
<ul>
  <li>user 是 系统中广泛接触的，以至于需要思考设计 接口。 我们的目标是设计一个 Account API 处理创建、更新、删除user、包括用户验证。 我们以基本的功能开始，然后逐步添加功能。</li>
  <li>Phoenix 包含了 phx.gen.html, phx.gen.json, phoenix.gen.context 脚手架来支持 拆分 应用功能到 contex中， 这些脚手架有力的推动了在 应用变大 的时候，朝着正确的方向上前进。</li>
  <li>为了使用 context 脚手架， 我们需要想出一个module名字，来组织相关的功能。在Ecto Guide中，我们使用Changesets 和Repo 来验证，存储user， 但是当应用变大的时候，我们不会使用这些在应用中。事实上，我们从来不会想， user应该存在于应用的什么地方，退回重新思考一下 应用中个个组成部分的不同。 在用户 需要账户登录，验证，和注册的情况下，Account context 是一个最好的地方来存放相关的功能。</li>
</ul>

<div class="highlight"><pre class="highlight elixir"><code>    <span class="n">mix</span> <span class="n">phx</span><span class="o">.</span><span class="n">gen</span><span class="o">.</span><span class="n">html</span> <span class="no">Accounts</span> <span class="no">User</span> <span class="n">user</span> <span class="n">users</span> <span class="ss">name:</span><span class="n">string</span> <span class="ss">username:string:</span><span class="n">unique</span>
    <span class="n">resources</span> <span class="s2">"/users"</span><span class="p">,</span> <span class="no">UserController</span>
    <span class="n">mix</span> <span class="n">ecto</span><span class="o">.</span><span class="n">migrate</span>

    <span class="n">scopes</span> <span class="s2">"/"</span> <span class="no">HelloWeb</span> <span class="k">do</span>
      <span class="n">pipe_through</span> <span class="ss">:browser</span>

      <span class="n">get</span> <span class="s2">"/"</span><span class="p">,</span> <span class="no">PageController</span><span class="p">,</span> <span class="ss">:index</span>
      <span class="n">resources</span> <span class="s2">"/users"</span><span class="p">,</span> <span class="no">UserController</span>
    <span class="k">end</span>
</code></pre></div><ul>
  <li>Phoenix 生成的web相关的文件， 在 lib/hello_web/中， context文件在 lib/hello/accounts 中， 注意 这个区别， 我们使用Accounts module来管理account相关的功能， Accounts.User struct 是Ecto 来转换、验证的user的模型，</li>
</ul>

<h3 id="starting-with-generators">starting with Generators</h3>
<ul>
  <li>phx.gen.html  脚手架 生成了一个开箱能用的 创建，更新，删除用户。离真正的app很远。但是脚手架 是第一个也是最重要的 开始真正构建真是的功能的 学习工具和开始的地方。 脚手架不能解决所有问题，但是依然可以教你朝着一个正确的方向 来思考设计你的应用 。</li>
</ul>

<div class="highlight"><pre class="highlight elixir"><code>  <span class="k">defmodule</span> <span class="no">HelloWeb</span><span class="o">.</span><span class="no">UserController</span> <span class="k">do</span>
    <span class="kn">use</span> <span class="no">HelloWeb</span><span class="p">,</span> <span class="ss">:controller</span>
    <span class="n">alias</span> <span class="no">Hello</span><span class="o">.</span><span class="no">Accounts</span>

    <span class="k">def</span> <span class="n">index</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">_params</span><span class="p">)</span> <span class="k">do</span>
      <span class="n">users</span> <span class="o">=</span> <span class="no">Accounts</span><span class="o">.</span><span class="n">list_users</span><span class="p">()</span>
      <span class="n">render</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="s2">"index.html"</span><span class="p">,</span> <span class="ss">users:</span> <span class="n">users</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="n">new</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">_params</span><span class="p">)</span> <span class="k">do</span>
      <span class="n">changeset</span> <span class="o">=</span> <span class="no">Accounts</span><span class="o">.</span><span class="n">change_user</span><span class="p">(%</span><span class="no">Hello</span><span class="o">.</span><span class="no">Accounts</span><span class="o">.</span><span class="no">User</span><span class="p">{})</span>
      <span class="n">render</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="s2">"new.html"</span><span class="p">,</span> <span class="ss">changeset:</span> <span class="n">changeset</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="n">create</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="p">%{</span><span class="s2">"user"</span> <span class="o">=&gt;</span> <span class="n">user_params</span><span class="p">})</span> <span class="k">do</span>
      <span class="k">case</span> <span class="no">Accounts</span><span class="o">.</span><span class="n">create_user</span><span class="p">(</span><span class="n">user_params</span><span class="p">)</span> <span class="k">do</span>
        <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">user</span><span class="p">}</span> <span class="o">-&gt;</span>
          <span class="n">conn</span>
          <span class="o">|&gt;</span> <span class="n">put_flash</span><span class="p">(</span><span class="ss">:info</span><span class="p">,</span> <span class="s2">"user create success"</span><span class="p">)</span>
          <span class="o">|&gt;</span> <span class="n">redirect</span><span class="p">(</span><span class="ss">to:</span> <span class="n">user_path</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="ss">:show</span><span class="p">,</span> <span class="n">user</span><span class="p">))</span>
        <span class="p">{</span><span class="ss">:error</span><span class="p">,</span> <span class="p">%</span><span class="no">Ecto</span><span class="o">.</span><span class="no">Changeset</span><span class="p">{}</span> <span class="o">=</span> <span class="n">changeset</span><span class="p">}</span> <span class="o">-&gt;</span>
          <span class="n">render</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="s2">"new.html"</span><span class="p">,</span> <span class="ss">changeset:</span> <span class="n">changeset</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
</code></pre></div><ul>
  <li>我们注意的是， Controller如何调用Accounts context，我们可以看到index action，通过Accounts.list_users获取一系列用户，通过Accounts.create_user调用 实现创建用户，我们并不知道 Accounts，创建、获取的实现方法，然而这才是重要的， Phoenix Controller， 就是web interface， 她并不关系 关于如何获取用户， 创建的细节。我们只关心　告诉我们的应用为我们执行一些任务。我们将业务逻辑存储引擎通过web　层分离开来，如果我们转移到一个全文索引来代替sql查询，我们的Controller不需要改动。</li>
  <li>在这个create示例中，当我们成功的创建了一个用户，我们调用Phoenix.Controller.push_flash　来展示成功的消息　然后重定向到user_path　，　如果失败了，　我们渲染”new.html”模板，并且传递Ecto.changeset　来传递错误信息</li>
  <li>下面，我们会更深入的挖掘Account　context　</li>
  <li>在这个帐号管理系统中，我们可能需要处理用户登录凭证，用户喜好，和密, 码重置等。如果我们深入到list_users 函数中，我们可以看到获取用户的细节，Repo.all(User), 意图是对caller隐藏从Postgresql获取的细节，　这是Phoenix　生成器一个常见的主题。Phoenix会驱动我们去思考，系统中不同的组成部分，然后包装这些不同的部分到Well-named　的module中、function　让我们代码的意图更加清晰，同时屏蔽细节。</li>
</ul>

<h3 id="in-context-relationship">In-context relationship</h3>

<p>　*  我们基础的用户功能实现的非常好，让我们补充实现用户登录，我们不会实现一个完整的认证系统，而只是给我们一个系统成长的好的开始。许多的验证系统的解决方案是　凭证跟用户是一对一的。这样经常造成问题，比如支持不同的登录方式，例如social的给你路， email邮箱登录。将会造成主要代码逻辑改变，我们要建立一个凭证、用户一对一，但是容易支持其他功能。</p>
<ul>
  <li>就当前，用户凭证之包含email信息，我们地一个任务是决定凭证放在哪里。我们有Accounts context，用户凭证适合放在这里。Phoenix也足够聪明在已经存在的context生成代码</li>
</ul>

<blockquote>
  <p>mix phx.gen.context Accounts Credenttial credentials email:string:unique user_id:references:users<br />
  我们使用phx.gen.context 区别与 phx.gen.html 除了不会生成 html，因为我们已经有了Controller<br />
  Template<br />
  我们可以从输出看到Phoenix为我们的Accounts.Credential 生成了 accounts/credential.ex , 还有migration<br />
  在执行迁移之前，我们需要修改生成的迁移文件。我们需要删除用户的凭证，当删除用户的时候，执行下面的改动</p>
</blockquote>

<div class="highlight"><pre class="highlight elixir"><code>  <span class="k">def</span> <span class="n">change</span> <span class="k">do</span>
      <span class="n">create</span> <span class="n">table</span><span class="p">(</span><span class="ss">:credentials</span><span class="p">)</span> <span class="k">do</span>
        <span class="n">add</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">:string</span>
        <span class="n">add</span> <span class="ss">:user_id</span><span class="p">,</span> <span class="n">references</span><span class="p">(</span><span class="ss">:users</span><span class="p">,</span> <span class="ss">on_delete:</span> <span class="ss">:nothing</span><span class="p">)</span>
        <span class="n">add</span> <span class="ss">:user_id</span><span class="p">,</span> <span class="n">references</span><span class="p">(</span><span class="ss">:users</span><span class="p">,</span> <span class="ss">on_delete:</span> <span class="ss">:delete_all</span><span class="p">),</span> <span class="ss">null:</span> <span class="no">false</span>
        <span class="n">timestamps</span><span class="p">()</span>
      <span class="k">end</span>

      <span class="n">create</span> <span class="n">uniqu_index</span><span class="p">(</span><span class="ss">:credentials</span><span class="p">,</span> <span class="p">[</span><span class="ss">:email</span><span class="p">])</span>
      <span class="n">create</span> <span class="n">index</span><span class="p">(</span><span class="ss">:credentials</span><span class="p">,</span> <span class="p">[</span><span class="ss">:user_id</span><span class="p">])</span>
  <span class="k">end</span>
</code></pre></div>
<p>我们将:on_delete 从nothing 改变为:delete_all，这就会生成外键约束，约束会删除所有的用户凭证，当用户删除的时候, 我们设定null: false 来阻止 创建没有关联用户的凭证创建。应用数据库约束，我们在数据层面限制data， 而不是在应用层面。<br />
  在我们与web 层面交互之前，我们需要 让我们的context 知道关联的user 和credentials ， 编辑lib/accoutns/user.ex</p>

<div class="highlight"><pre class="highlight elixir"><code>
  <span class="n">alias</span> <span class="no">Hello</span><span class="o">.</span><span class="no">Accounts</span><span class="o">.</span><span class="p">{</span><span class="no">User</span><span class="p">,</span> <span class="no">Credential</span><span class="p">}</span>

  <span class="n">schema</span> <span class="s2">"users"</span> <span class="k">do</span>
    <span class="n">field</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:string</span>
    <span class="n">field</span> <span class="ss">:username</span><span class="p">,</span> <span class="ss">:string</span>
    <span class="n">has_one</span> <span class="ss">:credential</span><span class="p">,</span> <span class="no">Credential</span>
    <span class="n">timestamps</span><span class="p">()</span>
  <span class="k">end</span>
</code></pre></div>
<p>我们使用Ecto.Schema’s has_one macro来让Ecto知道如何关联User and Credential， 同样的编辑accounts/credential.ex</p>
<div class="highlight"><pre class="highlight elixir"><code>  <span class="n">alias</span> <span class="no">Hello</span><span class="o">.</span><span class="no">Accounts</span><span class="o">.</span><span class="p">{</span><span class="no">Credential</span><span class="p">,</span> <span class="no">User</span><span class="p">}</span>
  <span class="n">schema</span> <span class="s2">"credential"</span> <span class="k">do</span>
    <span class="n">field</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">:string</span>
    <span class="n">field</span> <span class="ss">:user_id</span><span class="p">,</span> <span class="ss">:id</span>
    <span class="n">belongs_to</span> <span class="ss">:user</span><span class="p">,</span> <span class="no">User</span>
    <span class="n">timestamps</span><span class="p">()</span>
  <span class="k">end</span>
</code></pre></div><div class="highlight"><pre class="highlight elixir"><code>  <span class="k">def</span> <span class="n">list_users</span> <span class="k">do</span>
    <span class="no">User</span>
    <span class="o">|&gt;</span> <span class="no">Repo</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
    <span class="o">|&gt;</span> <span class="no">Repo</span><span class="o">.</span><span class="n">preload</span><span class="p">(</span><span class="ss">:credenttial</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">get_user!</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">User</span>
    <span class="o">|&gt;</span> <span class="no">Repo</span><span class="o">.</span><span class="n">get!</span><span class="p">(</span><span class="n">id</span><span class="p">)</span>
    <span class="o">|&gt;</span> <span class="no">Repo</span><span class="o">.</span><span class="n">preload</span><span class="p">(</span><span class="ss">:credential</span><span class="p">)</span>
  <span class="k">end</span>
</code></pre></div><p>我们重写了list_user 和get_user以便于主动加载credential 关联关系，无论什么时候我们获取用户，Repo.preload 函数获取schema的关联关系。当我们操作一个集合，比如list_users， Ecto可以高效的预加载关联关系在一个sql中， 这允许我们直接调用credients，而不需要额外的 查询。<br />
  下面我们在页面中加入credential</p>

<div class="highlight"><pre class="highlight html"><code>  + <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"form-group"</span><span class="nt">&gt;</span>
  +   <span class="nt">&lt;</span><span class="err">%=</span> <span class="na">inputs_for</span> <span class="na">f</span><span class="err">,</span> <span class="na">:credential</span><span class="err">,</span> <span class="na">fn</span> <span class="na">cf</span> <span class="na">-</span><span class="nt">&gt;</span> %&gt;
  +     <span class="nt">&lt;</span><span class="err">%=</span> <span class="na">label</span> <span class="na">cf</span><span class="err">,</span> <span class="na">:email</span><span class="err">,</span> <span class="na">class:</span> <span class="err">"</span><span class="na">control-label</span><span class="err">"</span> <span class="err">%</span><span class="nt">&gt;</span>
  +     <span class="nt">&lt;</span><span class="err">%=</span> <span class="na">text_input</span> <span class="na">cf</span><span class="err">,</span> <span class="na">:email</span><span class="err">,</span> <span class="na">class:</span> <span class="err">"</span><span class="na">form-control</span><span class="err">"</span> <span class="err">%</span><span class="nt">&gt;</span>
  +     <span class="nt">&lt;</span><span class="err">%=</span> <span class="na">error_tag</span> <span class="na">cf</span><span class="err">,</span> <span class="na">:email</span> <span class="err">%</span><span class="nt">&gt;</span>
  +   <span class="nt">&lt;</span><span class="err">%</span> <span class="na">end</span> <span class="err">%</span><span class="nt">&gt;</span>
  + <span class="nt">&lt;/div&gt;</span>

  <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"form-group"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;</span><span class="err">%=</span> <span class="na">submit</span> <span class="err">"</span><span class="na">Submit</span><span class="err">",</span> <span class="na">class:</span> <span class="err">"</span><span class="na">btn</span> <span class="na">btn-primary</span><span class="err">"</span> <span class="err">%</span><span class="nt">&gt;</span>
  <span class="nt">&lt;/div&gt;</span>
</code></pre></div>
<p>使用 Phoenix.HTML’s inputs_for 函数来添加一个关联的嵌套的fields， 在嵌套的inputs中，我们渲染了 credfential‘s 的email error_tag 等。<br />
  展示用户的user 的email地址在用户的show页面中。添加下面的代码到show.html.eex中</p>

<div class="highlight"><pre class="highlight html"><code>  + <span class="nt">&lt;li&gt;</span>
  +   <span class="nt">&lt;strong&gt;</span>Email:<span class="nt">&lt;/strong&gt;</span>
  +   <span class="nt">&lt;</span><span class="err">%=</span> <span class="err">@</span><span class="na">user.credential.email</span> <span class="err">%</span><span class="nt">&gt;</span>
  + <span class="nt">&lt;/li&gt;</span>
  <span class="nt">&lt;/ul&gt;</span>
</code></pre></div>
<p>现在如果我们访问users/new 我们会看到email的输入框，如果保存，你会发现email自大un被护士了，没有验证告诉你字段没有被保存。<br />
  我们是哟个Ecto’s belongs_to has_one 关联关系来贯穿起来，为了关联用户输入到数据库，我们需要在changeset中处理，改动Accounts context中的create_user , update_user 函数。</p>

<div class="highlight"><pre class="highlight elixir"><code>  <span class="k">def</span> <span class="n">update_user</span><span class="p">(%</span><span class="no">User</span><span class="p">{}</span> <span class="o">=</span> <span class="n">user</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">user</span>
    <span class="o">|&gt;</span> <span class="no">User</span><span class="o">.</span><span class="n">changeset</span><span class="p">(</span><span class="n">attrs</span><span class="p">)</span>
    <span class="o">|&gt;</span> <span class="no">Ecto</span><span class="o">.</span><span class="no">Changeset</span><span class="o">.</span><span class="n">cast_assoc</span><span class="p">(</span><span class="ss">:credential</span><span class="p">,</span> <span class="ss">with:</span> <span class="o">&amp;</span><span class="no">Credential</span><span class="o">.</span><span class="n">changset</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="o">|&gt;</span> <span class="no">Repo</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">create_user</span><span class="p">(</span><span class="n">attrs</span> <span class="p">\\</span> <span class="p">%{})</span> <span class="k">do</span>
    <span class="p">%</span><span class="no">User</span><span class="p">{}</span>
    <span class="o">|&gt;</span> <span class="no">User</span><span class="o">.</span><span class="n">changset</span><span class="p">(</span><span class="n">attrs</span><span class="p">)</span>
    <span class="o">|&gt;</span> <span class="no">Ecto</span><span class="o">.</span><span class="no">Changeset</span><span class="o">.</span><span class="n">cast_assoc</span><span class="p">(</span><span class="ss">:credential</span><span class="p">,</span> <span class="n">with</span><span class="err">：</span> <span class="o">&amp;</span><span class="no">Credential</span><span class="o">.</span><span class="n">changset</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="o">|&gt;</span> <span class="no">Repo</span><span class="o">.</span><span class="n">insert</span><span class="p">()</span>
  <span class="k">end</span>
</code></pre></div><p>Ecto’s cast_assoc 告诉changset如何转换用户的输入到schema 关系中。我们使用with告诉changset使用Credential.changeset函数来转换用户输入，这样，Credential.changset 中所有的验证会应用到 User中。<br />
  最后，我们可以测试，会见到Email的验证。</p>

<h3 id="adding-account-functions">Adding Account functions</h3>

<p>如你所见， context是一个包粗一组相关函数的module， Phoenix 生成一般的函数， 例如list_users, upate_users, 但是他们只提供一个基础的，为了使用一些真是的功能来扩展我们的Account context， 让我们修复我们应用中的明显的问题， -我们可以创建带有凭证的用户，但是却无法使用凭证登录，建立一个负载的完整的用户验证系统超出了本书的范围，让我们着手建立一个基于email的登录页面来跟踪用户的session， 这会让我们聚焦在Accounts context上， 并且给你一个建立完成的认证系统上一个好的开始。<br />
  首先，开始想名字，为了使用email地址来验证用户，我们需要一个方法来查找用户和验证凭证是否正确，我们只暴露一个函数来完成这件事情。</p>

<div class="highlight"><pre class="highlight elixir"><code>    <span class="o">&gt;</span> <span class="n">user</span> <span class="o">=</span> <span class="no">Accounts</span><span class="o">.</span><span class="n">authenticate_by_email_password</span><span class="p">(</span><span class="n">email</span><span class="p">,</span> <span class="n">password</span><span class="p">)</span>
</code></pre></div>
<p>这看起来很好， 一个描述的名字暴露了我们代码的意图。这一功能使它清楚它充当什么目的，同时允许调用者仍然一无所知的内部细节。 lib/hello/accounts/accounts.ex</p>

<div class="highlight"><pre class="highlight elixir"><code>   <span class="k">def</span> <span class="n">authenticate_by_email_password</span><span class="p">(</span><span class="n">email</span><span class="p">,</span> <span class="n">password</span><span class="p">)</span> <span class="k">do</span>
       <span class="n">query</span> <span class="o">=</span>
           <span class="n">from</span> <span class="n">u</span> <span class="ow">in</span> <span class="no">User</span><span class="p">,</span>
           <span class="n">inner_join</span><span class="err">：</span><span class="n">c</span> <span class="ow">in</span> <span class="n">assoc</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="ss">:credential</span><span class="p">)</span><span class="err">，</span>
           <span class="ss">where:</span> <span class="n">c</span><span class="o">.</span><span class="n">email</span> <span class="o">==</span> <span class="o">^</span><span class="n">email</span>
       <span class="k">case</span> <span class="no">Repo</span><span class="o">.</span><span class="n">one</span><span class="p">(</span><span class="n">query</span><span class="p">)</span> <span class="k">do</span>
           <span class="p">%</span><span class="no">User</span><span class="p">{}</span> <span class="o">=</span> <span class="n">user</span> <span class="o">-&gt;</span> <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">user</span><span class="p">}</span>
           <span class="no">nil</span> <span class="o">-&gt;</span> <span class="p">{</span><span class="ss">:error</span><span class="p">,</span> <span class="ss">:unauthorized</span><span class="p">}</span>
       <span class="k">end</span>
   <span class="k">end</span>
</code></pre></div><p>我们定义的authenticate_by_email_password 函数， 我们忽略掉了password 字段，你可以使用FIX ME 留在以后构建。我们需要的函数是使用验证凭证 来寻找到user， 返回包含%Accounts.User{} and :ok tuple， 或者一个{:error, :unauthorized} 来让调用者知道他们的验证是错误的。<br />
  现在我们使用context来验证用户，我们添加一个login page 在我们的web，首先创建一个新的controller 在 lib/hello_web/controllers/session_controller.ex</p>

<div class="highlight"><pre class="highlight elixir"><code>  <span class="k">defmodule</span> <span class="no">HelloWeb</span><span class="o">.</span><span class="no">SessionController</span> <span class="k">do</span>
      <span class="kn">use</span> <span class="no">HelloWeb</span><span class="p">,</span> <span class="ss">:controller</span>
      <span class="n">alias</span> <span class="no">Hello</span><span class="o">.</span><span class="no">Accounts</span>

      <span class="k">def</span> <span class="n">new</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="k">do</span>
          <span class="n">render</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="s2">"new.html"</span><span class="p">)</span>
      <span class="k">end</span>

      <span class="k">def</span> <span class="n">create</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span><span class="n">k</span> <span class="p">%{</span><span class="s2">"user"</span> <span class="o">=&gt;</span> <span class="p">%{</span><span class="s2">"email"</span> <span class="o">=&gt;</span> <span class="n">email</span><span class="p">,</span> <span class="s2">"password"</span> <span class="o">=&gt;</span> <span class="n">password</span><span class="p">}})</span> <span class="k">do</span>
          <span class="k">case</span> <span class="no">Accounts</span><span class="o">.</span><span class="n">authenticate_by_email_password</span><span class="p">(</span><span class="n">email</span><span class="p">,</span> <span class="n">password</span><span class="p">)</span> <span class="k">do</span>
              <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">user</span><span class="p">}</span> <span class="o">-&gt;</span>
                  <span class="n">conn</span>
                  <span class="o">|&gt;</span> <span class="n">put_flash</span><span class="p">(</span><span class="ss">:info</span><span class="p">,</span> <span class="s2">"welcome back"</span><span class="p">)</span>
                  <span class="o">|&gt;</span> <span class="n">put_session</span><span class="p">(</span><span class="ss">:user_id</span><span class="p">,</span> <span class="n">user</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
                  <span class="o">|&gt;</span> <span class="n">configure_session</span><span class="p">(</span><span class="ss">renew:</span> <span class="no">true</span><span class="p">)</span>
                  <span class="o">|&gt;</span> <span class="n">redirect</span><span class="p">(</span><span class="ss">to:</span> <span class="s2">"/"</span><span class="p">)</span>
              <span class="p">{</span><span class="ss">:error</span><span class="p">,</span> <span class="ss">:unauthorized</span><span class="p">}</span> <span class="o">-&gt;</span>
                  <span class="n">conn</span>
                  <span class="o">|&gt;</span> <span class="n">put_flalsh</span><span class="p">(</span><span class="ss">:error</span><span class="p">,</span> <span class="s2">"bad email/password combination"</span><span class="p">)</span>
                  <span class="o">|&gt;</span> <span class="n">redirect</span><span class="p">(</span><span class="ss">to:</span> <span class="n">session_path</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="ss">:new</span><span class="p">))</span>
          <span class="k">end</span>
      <span class="k">end</span>
  <span class="k">end</span>
</code></pre></div><p>我们定义了一个SessionController来处理用户signing and out，new action 只是简单的渲染 “new session”表单， 表单简单的post 到create action， 我们使用模式匹配然后调用 Accounts.authenticate_by_email_password， 如果成功的话，我们使用Plug.Conn.put_session 来将验证过的用户ID放到 session中， 然后跳转到home page， 我们需要调用 configure_session(conn, renew: true) 在重定向之前，来避免session fixation 个哦高年级， 如果验证错误， 我们添加一个falsh error， 并重定向 四个in-in， 我们添加一个delete action 简单的调用Plug.Conn.configure_session 来删除掉session并重定向到home page<br />
  lib/hello_web/router.ex</p>

<div class="highlight"><pre class="highlight elixir"><code>  <span class="n">scope</span> <span class="s2">"/"</span> <span class="no">HelloWeb</span> <span class="k">do</span>
      <span class="n">pipe_through</span> <span class="ss">:brower</span>

      <span class="n">get</span> <span class="s2">"/"</span> <span class="no">PageController</span><span class="p">,</span> <span class="ss">:index</span>
      <span class="n">resources</span> <span class="s2">"/users"</span><span class="p">,</span> <span class="no">UserController</span>
      <span class="n">resources</span> <span class="s2">"/sessions"</span><span class="p">,</span> <span class="no">SessionController</span><span class="p">,</span> <span class="ss">only:</span> <span class="p">[</span><span class="ss">:new</span><span class="p">,</span> <span class="ss">:create</span><span class="p">,</span> <span class="ss">:delete</span><span class="p">],</span> <span class="ss">singleton:</span> <span class="no">true</span>
  <span class="k">end</span>
</code></pre></div><p>我们使用resources 来生成 一系列的routes 在”/sessions”下，使用:only 来限制我们的route 生成。因为我么只需要支持 :new, :create, :delete action， 我们添加singleton: true 选项，来定义restful routes， 但是不需要一个resource ID 在URL中。 我们不需要一个ID在URL中，因为我们的action 总是知道current_user， 这个ID总是在session中，在我们完成controller之前， 我们添加一个验证的plug 在route中来限制用户访问， lib/hello_web/router.ex</p>

<div class="highlight"><pre class="highlight elixir"><code>  <span class="k">def</span> <span class="n">authenticate_user</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="k">do</span>
      <span class="k">case</span> <span class="n">get_session</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="ss">:user_id</span><span class="p">)</span> <span class="k">do</span>
          <span class="no">nil</span> <span class="o">-&gt;</span>
              <span class="n">conn</span>
              <span class="o">|&gt;</span> <span class="no">Phoenix</span><span class="o">.</span><span class="no">Controller</span><span class="o">.</span><span class="n">put_flash</span><span class="p">(</span><span class="ss">:error</span><span class="p">,</span> <span class="err">”</span><span class="n">login</span> <span class="n">please</span><span class="p">)</span>
              <span class="o">|&gt;</span> <span class="no">Phoenix</span><span class="o">.</span><span class="no">Controller</span><span class="o">.</span><span class="n">redirect</span><span class="p">(</span><span class="ss">to:</span> <span class="s2">"/"</span><span class="p">)</span>
              <span class="o">|&gt;</span> <span class="n">halt</span><span class="p">()</span>
          <span class="n">user_id</span> <span class="o">-&gt;</span>
              <span class="n">assign</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="ss">:current_user</span><span class="p">,</span> <span class="no">Hello</span><span class="o">.</span><span class="no">Accounts</span><span class="o">.</span><span class="n">get_user!</span><span class="p">(</span><span class="n">user_id</span><span class="p">))</span>
      <span class="k">end</span>
  <span class="k">end</span>
</code></pre></div><p>我们定义了authenticate_user plug 在路由中，只是简单的使用get_sessioin 来检查session中的:user_id， 如果我们找到了， 以为着user 已经验证过了，我们就调用Accounts.get_user!，并在当前的connection assigns中赋值:current_user， 如果没有找到，我们就flash 一个错误信息， 重定向到 home page上， 我们使用Halt来组织后面的代码被进一步调用，<br />
  最后，我们需要SessionView来渲染模板， lib/hello_web/views/session_view.ex</p>
<div class="highlight"><pre class="highlight elixir"><code>  <span class="k">defmodule</span> <span class="no">HelloWeb</span><span class="o">.</span><span class="no">SessioinView</span> <span class="k">do</span>
      <span class="kn">use</span> <span class="no">HelloWeb</span><span class="p">,</span> <span class="ss">:view</span>
  <span class="k">end</span>
</code></pre></div>
<h4 id="cross-context-dependencies">cross-context dependencies</h4>

<p>我们已经开始了 用户的 帐号与登录凭证 功能，我们开始开发我们应用的重要功能， 管理页面内容，我们开发一个支持用户创建、编辑 网站页面的cms内容。我们可以拓展用户系统。如果我们回国头来想想应用的独立性，这个并不合适，一个用户系统并不应该关心cms系统，Account context 的职责是管理用户与凭证，不处理任何的页面内容。这时候需要一个独立的context来进行管理。CMS<br />
  我们创建一个CMS context 来处理cms 的职责，在我们写代码之前，可以想想CMS 的功能有这些：</p>
<ol>
  <li>Page 的create、 update</li>
  <li>Page 属于创建的用户</li>
  <li>用户的信息应该展示在页面中<br />
  从描述中，我们清楚的知道需要一个Page resource来存储page， 那author信息怎么办？ 我们拓展现有的Account.User来包含， Role等信息， 这违反了我们定义的context原则，我们定义了User context为什么User context 需要注意到author 的信息呢？<br />
  存在用户的应用中，会自然的成为一个严重的User驱动应用。但是，我们的应用总是为用户使用设计的。与其扩展Account.User结构来追踪平台每个字段的变化，不如，让拥有职责功能的module来负责。在我们的应用中，我们创建CMS.Author 结构来管理Author中管理CMS 的字段信息。</li>
</ol>

<div class="highlight"><pre class="highlight elixir"><code>  <span class="n">mix</span> <span class="n">phx</span><span class="o">.</span><span class="n">gen</span><span class="o">.</span><span class="n">html</span> <span class="no">CMS</span> <span class="no">Page</span> <span class="n">pages</span> <span class="ss">title:</span><span class="n">string</span> <span class="ss">body:</span><span class="n">text</span> <span class="ss">views:</span><span class="n">integer</span> <span class="o">--</span><span class="n">web</span> <span class="no">CMS</span>
  <span class="n">mix</span> <span class="n">ecto</span><span class="o">.</span><span class="n">migrate</span>
</code></pre></div><div class="highlight"><pre class="highlight elixir"><code>  <span class="n">scope</span> <span class="s2">"/cms"</span><span class="p">,</span> <span class="no">HelloWeb</span><span class="o">.</span><span class="no">CMS</span> <span class="ss">as:</span> <span class="ss">:cms</span> <span class="k">do</span>
      <span class="n">pipe_through</span> <span class="p">[</span><span class="ss">:bowser</span><span class="p">,</span> <span class="ss">:authenticate_user</span><span class="p">]</span>
      <span class="n">resources</span> <span class="s2">"/pages"</span><span class="p">,</span> <span class="no">PageController</span>
  <span class="k">end</span>
</code></pre></div><p>我们添加了 authenticate_user 来要求在CMS scope中的路由都需要用户登录。<br />
  创建Author</p>
<div class="highlight"><pre class="highlight elixir"><code>  <span class="n">mix</span> <span class="n">phx</span><span class="o">.</span><span class="n">gen</span><span class="o">.</span><span class="n">context</span> <span class="no">CMS</span> <span class="no">Author</span> <span class="n">authors</span> <span class="ss">bio:</span><span class="n">text</span> <span class="ss">role:</span><span class="n">string</span> <span class="ss">gere:</span><span class="n">string</span> <span class="ss">user_id:reference:users:</span><span class="n">unique</span>
  <span class="n">mix</span> <span class="n">ecto</span><span class="o">.</span><span class="n">migrate</span>
</code></pre></div><p>我们添加了 bio， role，genre， user_id在author中。这样可以保证，CMS API不会因为User context的改动而改动。</p>
<div class="highlight"><pre class="highlight elixir"><code>  <span class="k">def</span> <span class="n">change</span> <span class="k">do</span>
      <span class="n">create</span> <span class="n">table</span><span class="p">(</span><span class="ss">:authors</span><span class="p">)</span> <span class="k">do</span>
          <span class="n">add</span> <span class="ss">:bio</span><span class="p">,</span> <span class="ss">:text</span>
          <span class="n">add</span> <span class="ss">:role</span><span class="p">,</span> <span class="ss">:string</span>
          <span class="n">add</span> <span class="ss">:genre</span><span class="p">,</span> <span class="ss">:string</span>
          <span class="n">add</span> <span class="ss">:user_id</span><span class="p">,</span> <span class="n">references</span><span class="p">(</span><span class="ss">:users</span><span class="p">,</span> <span class="ss">on_delete:</span> <span class="ss">:nothing</span><span class="p">)</span>
          <span class="n">add</span> <span class="ss">:user_id</span><span class="p">,</span> <span class="n">references</span><span class="p">(</span><span class="ss">:users</span><span class="p">,</span> <span class="ss">on_delete:</span> <span class="ss">:delete_all</span><span class="p">),</span> <span class="ss">null:</span> <span class="no">false</span>

          <span class="n">timestamps</span><span class="p">()</span>
      <span class="k">end</span>

      <span class="n">create</span> <span class="n">unique_index</span><span class="p">(</span><span class="ss">:authors</span><span class="p">,</span> <span class="p">[</span><span class="ss">:user_id</span><span class="p">])</span>
  <span class="k">end</span>
</code></pre></div><p>我们添加了delete_all，来限制当用户删除的时候，我们不要依靠应用代码来清理CMS author代码。<br />
  开始之前， 我们需要一个新的数据迁移，我们有一个author表，我们需要关联pages authors， 我们添加个author_id字段到pages，</p>
<div class="highlight"><pre class="highlight elixir"><code>  <span class="n">mix</span> <span class="n">ecto</span><span class="o">.</span><span class="n">gen</span><span class="o">.</span><span class="n">migration</span> <span class="n">add_author_id_to_pages</span>

  <span class="k">def</span> <span class="n">change</span> <span class="k">do</span>
      <span class="n">alter</span> <span class="n">table</span><span class="p">(</span><span class="ss">:pages</span><span class="p">)</span> <span class="k">do</span>
          <span class="n">add</span> <span class="ss">:author_id</span><span class="p">,</span> <span class="n">references</span><span class="p">(</span><span class="ss">:authors</span><span class="p">,</span> <span class="ss">on_delete:</span> <span class="ss">:delete_all</span><span class="p">),</span> <span class="ss">null:</span> <span class="no">false</span>
      <span class="k">end</span>
      <span class="n">create</span> <span class="n">index</span><span class="p">(</span><span class="ss">:pages</span><span class="p">,</span> <span class="p">[</span><span class="ss">:author_id</span><span class="p">])</span>
  <span class="k">end</span>

  <span class="n">mix</span> <span class="n">ecto</span><span class="o">.</span><span class="n">migrate</span>
</code></pre></div><h4 id="cross-context-data">Cross-context data</h4>

<p>依赖在系统中总是不可避免的，但我们进最大的努力来限制他们，当有可能减少以来的时候，我们已经完美的使用context 来区分应用的不同部分，但是我们依然需要处理依赖。<br />
  Author 来负责CMS中的author， CMS context 会对Account context存在一个数据上的依赖。我们有两个选择，1：在Account context中暴露API 来允许我们在CMS中方便的获取User。 2：通过数据库的join操作来获取依赖部分的数据，都是可能的选项，但是join data 对于一个硬的数据依赖，对于大应用来说是很好的，如果你决定拆分context 分散到不同应用，数据中，你依然享受隔离的好处，因为你的开放的接口保持不变。<br />
  /lib/hello/cms/page.ex</p>

<div class="highlight"><pre class="highlight elixir"><code>  <span class="o">-</span> <span class="n">alias</span> <span class="no">Hello</span><span class="o">.</span><span class="no">CMS</span><span class="o">.</span><span class="no">Page</span>
  <span class="o">+</span> <span class="n">alis</span> <span class="no">Hello</span><span class="o">.</span><span class="no">CMS</span><span class="o">.</span><span class="p">{</span><span class="no">Page</span><span class="p">,</span> <span class="no">Author</span><span class="p">}</span>

  <span class="n">schema</span> <span class="s2">"pages"</span> <span class="k">do</span>
      <span class="n">field</span> <span class="ss">:body</span><span class="p">,</span> <span class="ss">:string</span>
      <span class="n">field</span> <span class="ss">:title</span><span class="p">,</span> <span class="ss">:string</span>
      <span class="n">field</span> <span class="ss">:views</span><span class="p">,</span> <span class="ss">:integer</span>
      <span class="n">belongs_to</span> <span class="ss">:author</span><span class="p">,</span> <span class="no">Author</span>
      <span class="n">timestamps</span><span class="p">()</span>
  <span class="k">end</span>
</code></pre></div><p>添加了author page, 之间的关联关系</p>
<div class="highlight"><pre class="highlight elixir"><code>  <span class="o">-</span> <span class="n">alias</span> <span class="no">Hello</span><span class="o">.</span><span class="no">CMS</span><span class="o">.</span><span class="no">Author</span>
  <span class="o">+</span> <span class="n">alias</span> <span class="no">Hello</span><span class="o">.</span><span class="no">CMS</span><span class="o">.</span><span class="p">{</span><span class="no">Author</span><span class="p">,</span> <span class="no">Page</span><span class="p">}</span>

  <span class="n">schema</span> <span class="s2">"authors"</span> <span class="k">do</span>
      <span class="n">field</span> <span class="ss">:bio</span><span class="p">,</span> <span class="ss">:string</span>
      <span class="n">field</span> <span class="ss">:genre</span><span class="p">,</span> <span class="ss">:string</span>
      <span class="n">field</span> <span class="ss">:role</span><span class="p">,</span> <span class="ss">:string</span>
      <span class="n">field</span> <span class="ss">:user_id</span><span class="p">,</span> <span class="ss">:id</span>


      <span class="n">has_many</span> <span class="ss">:pages</span><span class="p">,</span> <span class="no">Page</span>
      <span class="n">belongs_to</span> <span class="ss">:user</span><span class="p">,</span> <span class="no">Hello</span><span class="o">.</span><span class="no">Accounts</span><span class="o">.</span><span class="no">User</span>
      <span class="n">timestamps</span><span class="p">()</span>
  <span class="k">end</span>
</code></pre></div><p>下面我们来改变 CMS context需要一个author当更新、创建page的时候，</p>
<div class="highlight"><pre class="highlight elixir"><code>  <span class="n">alias</span> <span class="no">Hello</span><span class="o">.</span><span class="no">CMS</span><span class="o">.</span><span class="p">{</span><span class="no">Page</span><span class="p">,</span> <span class="no">Author</span><span class="p">}</span>
  <span class="n">alias</span> <span class="no">Hello</span><span class="o">.</span><span class="no">Accounts</span>

  <span class="k">def</span> <span class="n">list_pages</span> <span class="k">do</span>
      <span class="no">Page</span>
      <span class="o">|&gt;</span> <span class="no">Repo</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
      <span class="o">|&gt;</span> <span class="no">Repo</span><span class="o">.</span><span class="n">preload</span><span class="p">(</span><span class="ss">author:</span> <span class="p">[</span><span class="ss">user:</span> <span class="ss">:credential</span><span class="p">])</span>

  <span class="k">end</span>

  <span class="k">def</span> <span class="n">get_page!</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="k">do</span>
       <span class="no">Page</span>
       <span class="o">|&gt;</span> <span class="no">Repo</span><span class="o">.</span><span class="n">get!</span><span class="p">(</span><span class="n">id</span><span class="p">)</span>
       <span class="o">|&gt;</span> <span class="no">Repo</span><span class="o">.</span><span class="n">preload</span><span class="p">(</span><span class="ss">author:</span> <span class="p">[</span><span class="ss">user:</span> <span class="ss">:credential</span><span class="p">])</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">get_author!</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="k">do</span>
      <span class="no">Author</span>
      <span class="o">|&gt;</span> <span class="no">Repo</span><span class="o">.</span><span class="n">get!</span><span class="p">(</span><span class="n">id</span><span class="p">)</span>
      <span class="o">|&gt;</span> <span class="no">Repo</span><span class="o">.</span><span class="n">preload</span><span class="p">(</span><span class="ss">user:</span> <span class="ss">:credential</span><span class="p">)</span>
  <span class="k">end</span>
</code></pre></div>
<p>我们在list_pages, get_page中，preload 关联的author， user，credential 从数据库中，<br />
  我们来处理 数据的存储， 在创建、编辑page的时候，保存author， 编辑文件, lib/hello/cms/cms.ex</p>
<div class="highlight"><pre class="highlight elixir"><code>  <span class="k">def</span> <span class="n">create_page</span><span class="p">(%</span><span class="no">Author</span><span class="p">{}</span> <span class="o">=</span> <span class="n">author</span><span class="p">,</span> <span class="n">attrs</span> <span class="p">\\</span> <span class="p">%{})</span> <span class="k">do</span>
      <span class="p">%</span><span class="no">Page</span><span class="p">{}</span>
      <span class="o">|&gt;</span> <span class="no">Page</span><span class="o">.</span><span class="n">changeset</span><span class="p">(</span><span class="n">attrs</span><span class="p">)</span>
      <span class="o">|&gt;</span> <span class="no">Ecto</span><span class="o">.</span><span class="no">Changeset</span><span class="o">.</span><span class="n">put_change</span><span class="p">(</span><span class="ss">:author_id</span><span class="p">,</span> <span class="n">author</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
      <span class="o">|&gt;</span> <span class="no">Repo</span><span class="o">.</span><span class="n">insert</span><span class="p">()</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">ensure_author_exists</span><span class="p">(%</span><span class="no">Accounts</span><span class="o">.</span><span class="no">User</span><span class="p">{}</span> <span class="o">=</span> <span class="n">user</span><span class="p">)</span> <span class="k">do</span>
     <span class="p">%</span><span class="no">Author</span><span class="p">{</span><span class="ss">user_id:</span> <span class="n">user</span><span class="o">.</span><span class="n">id</span><span class="p">}</span>
     <span class="o">|&gt;</span> <span class="no">Ecto</span><span class="o">.</span><span class="no">Changeset</span><span class="o">.</span><span class="n">change</span><span class="p">()</span>
     <span class="o">|&gt;</span> <span class="no">Ecto</span><span class="o">.</span><span class="no">Changeset</span><span class="o">.</span><span class="n">unique_constraint</span><span class="p">(</span><span class="ss">:user_id</span><span class="p">)</span>
     <span class="o">|&gt;</span> <span class="no">Repo</span><span class="o">.</span><span class="n">insert</span><span class="p">()</span>
     <span class="o">|&gt;</span> <span class="n">handle_existing_author</span><span class="p">()</span>
  <span class="k">end</span>

  <span class="k">defp</span> <span class="n">handle_existing_author</span><span class="p">({</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">author</span><span class="p">}),</span> <span class="k">do</span><span class="p">:</span> <span class="n">author</span>

  <span class="k">defp</span> <span class="n">handle_existing_author</span><span class="p">({</span><span class="ss">:error</span><span class="p">,</span> <span class="n">changeset</span><span class="p">})</span> <span class="k">do</span>
     <span class="no">Repo</span><span class="o">.</span><span class="n">get_by!</span><span class="p">(</span><span class="no">Author</span><span class="p">,</span> <span class="ss">user_id:</span> <span class="n">changeset</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span>
  <span class="k">end</span>
</code></pre></div>
<p>lib/helo_web/controllers/cms/page_controller.ex</p>
<div class="highlight"><pre class="highlight elixir"><code>      <span class="n">plug</span> <span class="ss">:require_existing_author</span>
      <span class="n">plug</span> <span class="ss">:authorize_page</span> <span class="ow">when</span> <span class="n">action</span> <span class="ow">in</span> <span class="p">[</span><span class="ss">:edit</span><span class="p">,</span> <span class="ss">:update</span><span class="p">,</span> <span class="ss">:delete</span><span class="p">]</span>

      <span class="k">def</span> <span class="n">require_existing_author</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="k">do</span>
          <span class="n">author</span> <span class="o">=</span> <span class="no">CMS</span><span class="o">.</span><span class="n">ensure_author_exists</span><span class="p">(</span><span class="n">conn</span><span class="o">.</span><span class="n">assigns</span><span class="o">.</span><span class="n">current_user</span><span class="p">)</span>
          <span class="n">asign</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="ss">:current_author</span><span class="p">,</span> <span class="n">author</span><span class="p">)</span>
      <span class="k">end</span>

      <span class="k">defp</span> <span class="n">authorize_page</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="k">do</span>
          <span class="n">page</span> <span class="o">=</span> <span class="no">CMS</span><span class="o">.</span><span class="n">get_page!</span><span class="p">(</span><span class="n">conn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">"id"</span><span class="p">])</span>

          <span class="k">if</span> <span class="n">conn</span><span class="o">.</span><span class="n">assigns</span><span class="o">.</span><span class="n">current_author</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">page</span><span class="o">.</span><span class="n">author_id</span> <span class="k">do</span>
              <span class="n">assign</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="ss">:page</span><span class="p">,</span> <span class="n">page</span><span class="p">)</span>
          <span class="k">else</span>
              <span class="n">conn</span>
              <span class="o">|&gt;</span> <span class="n">put_flash</span><span class="p">(</span><span class="ss">:error</span><span class="p">,</span> <span class="s2">"you can't modify this page"</span><span class="p">)</span>
              <span class="o">|&gt;</span> <span class="n">redirect</span><span class="p">(</span><span class="ss">to:</span> <span class="n">cms_page_path</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="ss">:index</span><span class="p">))</span>
              <span class="o">|&gt;</span> <span class="n">halt</span><span class="p">()</span>
          <span class="k">end</span>
      <span class="k">end</span>
</code></pre></div><p>我们在 CMS.PageController中添加了 两个Plug, 地一个plug， :require_existing_author, 在每个action都需要执行， 函数 调用CMS.ensure_author_exists 并传递current_user过去，当找到 或者创建author，我们使用Plug.Conn.assign 来将 current_author 传递到下去。<br />
  第二步，我们使用:authorized_page来过滤特定的action， 函数 地一个从connection params获取page，，然后跟current_author 进行验证， 如果current_author 的ID 跟Page的author_id一样，可以通过验证， 如果不一样，我们Plug.Conn.halt 来阻止， action的进一步执行。</p>
<div class="highlight"><pre class="highlight elixir"><code>   <span class="k">def</span> <span class="n">create</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="p">%{</span><span class="s2">"page"</span> <span class="o">=&gt;</span> <span class="n">page_params</span><span class="p">})</span> <span class="k">do</span>
  <span class="o">+</span>   <span class="k">case</span> <span class="no">CMS</span><span class="o">.</span><span class="n">create_page</span><span class="p">(</span><span class="n">conn</span><span class="o">.</span><span class="n">assigns</span><span class="o">.</span><span class="n">current_author</span><span class="p">,</span> <span class="n">page_params</span><span class="p">)</span> <span class="k">do</span>
      <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">page</span><span class="p">}</span> <span class="o">-&gt;</span>
        <span class="n">conn</span>
        <span class="o">|&gt;</span> <span class="n">put_flash</span><span class="p">(</span><span class="ss">:info</span><span class="p">,</span> <span class="s2">"Page created successfully."</span><span class="p">)</span>
        <span class="o">|&gt;</span> <span class="n">redirect</span><span class="p">(</span><span class="ss">to:</span> <span class="n">cms_page_path</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="ss">:show</span><span class="p">,</span> <span class="n">page</span><span class="p">))</span>
      <span class="p">{</span><span class="ss">:error</span><span class="p">,</span> <span class="p">%</span><span class="no">Ecto</span><span class="o">.</span><span class="no">Changeset</span><span class="p">{}</span> <span class="o">=</span> <span class="n">changeset</span><span class="p">}</span> <span class="o">-&gt;</span>
        <span class="n">render</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="s2">"new.html"</span><span class="p">,</span> <span class="ss">changeset:</span> <span class="n">changeset</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">update</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="p">%{</span><span class="s2">"page"</span> <span class="o">=&gt;</span> <span class="n">page_params</span><span class="p">})</span> <span class="k">do</span>
  <span class="o">+</span>   <span class="k">case</span> <span class="no">CMS</span><span class="o">.</span><span class="n">update_page</span><span class="p">(</span><span class="n">conn</span><span class="o">.</span><span class="n">assigns</span><span class="o">.</span><span class="n">page</span><span class="p">,</span> <span class="n">page_params</span><span class="p">)</span> <span class="k">do</span>
      <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">page</span><span class="p">}</span> <span class="o">-&gt;</span>
        <span class="n">conn</span>
        <span class="o">|&gt;</span> <span class="n">put_flash</span><span class="p">(</span><span class="ss">:info</span><span class="p">,</span> <span class="s2">"Page updated successfully."</span><span class="p">)</span>
        <span class="o">|&gt;</span> <span class="n">redirect</span><span class="p">(</span><span class="ss">to:</span> <span class="n">cms_page_path</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="ss">:show</span><span class="p">,</span> <span class="n">page</span><span class="p">))</span>
      <span class="p">{</span><span class="ss">:error</span><span class="p">,</span> <span class="p">%</span><span class="no">Ecto</span><span class="o">.</span><span class="no">Changeset</span><span class="p">{}</span> <span class="o">=</span> <span class="n">changeset</span><span class="p">}</span> <span class="o">-&gt;</span>
        <span class="n">render</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="s2">"edit.html"</span><span class="p">,</span> <span class="ss">changeset:</span> <span class="n">changeset</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">delete</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="k">do</span>
  <span class="o">+</span>   <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">_page</span><span class="p">}</span> <span class="o">=</span> <span class="no">CMS</span><span class="o">.</span><span class="n">delete_page</span><span class="p">(</span><span class="n">conn</span><span class="o">.</span><span class="n">assigns</span><span class="o">.</span><span class="n">page</span><span class="p">)</span>

    <span class="n">conn</span>
    <span class="o">|&gt;</span> <span class="n">put_flash</span><span class="p">(</span><span class="ss">:info</span><span class="p">,</span> <span class="s2">"Page deleted successfully."</span><span class="p">)</span>
    <span class="o">|&gt;</span> <span class="n">redirect</span><span class="p">(</span><span class="ss">to:</span> <span class="n">cms_page_path</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="ss">:index</span><span class="p">))</span>
  <span class="k">end</span>     

</code></pre></div><p>我们改变了create 的写法，从connection assign中获取current_author, authenticate_user 会存放进去， 然后我们传递current_author 到 CMS.create_page 中 来关联到page。<br />
   在web view中展示 author’s name<br />
   lib/hello_web/views/cms/page_view.ex</p>
<div class="highlight"><pre class="highlight elixir"><code>   <span class="k">defmodule</span> <span class="no">HelloWeb</span><span class="o">.</span><span class="no">CMS</span><span class="o">.</span><span class="no">PageView</span> <span class="k">do</span>
       <span class="kn">use</span> <span class="no">HelloWeb</span><span class="p">,</span> <span class="ss">:view</span>
       <span class="n">alias</span> <span class="no">Hello</span><span class="o">.</span><span class="no">CMS</span>

       <span class="k">def</span> <span class="n">author_name</span><span class="p">(%</span><span class="no">CMS</span><span class="o">.</span><span class="no">Page</span><span class="p">{</span><span class="ss">author:</span> <span class="n">author</span><span class="p">})</span> <span class="k">do</span>
        <span class="n">author</span><span class="o">.</span><span class="n">user</span><span class="o">.</span><span class="n">name</span>
       <span class="k">end</span>
   <span class="k">end</span>
</code></pre></div><p>完成！我现在有两个独立的分别负担 user context 和内容管理</p>
<div class="social"></div></article></main><footer><div class="footer-wrapper"><div class="author"><div class="image-wrapper"><a href="/author/"><img alt="author" src="../../../../images/profile-1e71686a.png" /></a></div></div><div class="image-content"><img src="../../../../images/wechat_nasa-0d87c0dd.png" /></div><div class="copyright"><i class="fa fa-copyright"></i> 2021 <a href="/">日常学习</a> - geniousbar</div></div><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?b43ef53b285c49e1af0bd7080994c825";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script></footer></body></html>